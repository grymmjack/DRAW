''
' DRAW - TOOLS/MARQUEE.BM
' =============================================================================
' Marquee selection tool implementation.
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Reset the marquee tool state
' Call this when switching away from the marquee tool
'
SUB MARQUEE_reset ()
    MARQUEE.ACTIVE% = FALSE
    MARQUEE.DRAGGING% = FALSE
    MARQUEE.RESIZING% = FALSE
    MARQUEE.MOVING% = FALSE
    MARQUEE.INITIALIZED% = FALSE
    MARQUEE.USER_CREATED = FALSE
    ' Reset magic wand state (but keep the mode)
    MAGIC_WAND_reset
END SUB


''
' Initialize the marquee tool with default configuration
' 
SUB MARQUEE_init ()
    ' Configure the bounding box for marquee selection
    MARQUEE.CFG.HandleHalfSize       = 1  ' 2px handles (was 3)
    MARQUEE.CFG.HandleFullSize       = MARQUEE.CFG.HandleHalfSize * 2
    MARQUEE.CFG.EdgeHalfSize         = 1
    MARQUEE.CFG.EdgeFullSize         = MARQUEE.CFG.EdgeHalfSize * 2
    MARQUEE.CFG.HandleCornerSize     = MARQUEE.CFG.HandleFullSize
    MARQUEE.CFG.HandleEdgeSize       = MARQUEE.CFG.EdgeFullSize
    MARQUEE.CFG.DragEdgePadding      = 8
    MARQUEE.CFG.MinBoxWidth          = 1  ' 1px minimum (was 8)
    MARQUEE.CFG.MinBoxHeight         = 1  ' 1px minimum (was 8)

    ' Set colors for marquee box - use dotted/dashed appearance
    MARQUEE.CFG.colorIdle            = _RGB32(255, 255, 255)
    MARQUEE.CFG.colorHoverOnly       = _RGB32(255, 255, 0)
    MARQUEE.CFG.colorSelectedOnly    = _RGB32(255, 255, 255)
    MARQUEE.CFG.colorSelectedHover   = _RGB32(255, 255, 0)
    MARQUEE.CFG.colorDragging        = _RGB32(255, 255, 255)
    MARQUEE.CFG.colorResizing        = _RGB32(255, 255, 0)

    MARQUEE.CFG.HandleFillColor      = _RGB32(255, 0, 255)  ' Bright magenta
    MARQUEE.CFG.HandleHoverFillColor = _RGB32(0, 255, 255)  ' Bright cyan
    MARQUEE.CFG.HandleBorderColor    = _RGB32(255, 255, 255)  ' White border

    MARQUEE.CFG.KeyRepeatDelay       = 0.1
    MARQUEE.CFG.KeyRepeatRate        = 0.05

    ' Set initial position (will be set when user starts marquee)
    MARQUEE.CFG.initX = 100
    MARQUEE.CFG.initY = 100
    MARQUEE.CFG.initW = 64
    MARQUEE.CFG.initH = 64

    MARQUEE.ACTIVE% = FALSE
    MARQUEE.INITIALIZED% = FALSE
END SUB


''
' Start a new marquee selection at the given coordinates
' @param x INTEGER Starting x coordinate
' @param y INTEGER Starting y coordinate
'
SUB MARQUEE_start (x AS INTEGER, y AS INTEGER)
    ' Only clear existing marquee in replace mode
    ' For add/subtract modes, we need to preserve the existing selection
    IF MARQUEE.SELECTION_MODE = SEL_MODE_REPLACE THEN
        MARQUEE.ACTIVE% = FALSE
    END IF
    
    MARQUEE.DRAG_START_X% = x
    MARQUEE.DRAG_START_Y% = y
    MARQUEE.DRAG_END_X% = x
    MARQUEE.DRAG_END_Y% = y
    MARQUEE.DRAGGING% = TRUE
    MARQUEE.INITIALIZED% = TRUE
END SUB


''
' Update the marquee tool state
' Call this from the main loop when TOOL_MARQUEE is active
' @param mouseX INTEGER Current mouse X position
' @param mouseY INTEGER Current mouse Y position
'
SUB MARQUEE_update (mouseX AS INTEGER, mouseY AS INTEGER)
    IF NOT MARQUEE.INITIALIZED% THEN MARQUEE_init
    
    IF MARQUEE.DRAGGING% THEN
        ' Update the drag end position
        MARQUEE.DRAG_END_X% = mouseX
        MARQUEE.DRAG_END_Y% = mouseY
    END IF
    ' Note: We no longer sync with GJ_BBX_Update since we handle resize manually
END SUB


''
' Draw the marquee selection
' @param showHUD INTEGER Whether to show handles and HUD elements
'
SUB MARQUEE_draw (showHUD AS INTEGER)
    DIM tempBox AS GJ_BBX_BBOX
    DIM zoomedBox AS GJ_BBX_BBOX
    
    ' Calculate zoom transformation values (canvas dimensions, centered in viewport)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.canvasW& * SCRN.zoom!
    zh& = SCRN.canvasH& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%
    
    ' Explicitly set destination to canvas
    _DEST SCRN.CANVAS&
    
    IF MARQUEE.DRAGGING% THEN
        ' Draw temporary drag preview box
        IF MARQUEE.DRAG_START_X% < MARQUEE.DRAG_END_X% THEN
            tempBox.x = MARQUEE.DRAG_START_X%
        ELSE
            tempBox.x = MARQUEE.DRAG_END_X%
        END IF
        IF MARQUEE.DRAG_START_Y% < MARQUEE.DRAG_END_Y% THEN
            tempBox.y = MARQUEE.DRAG_START_Y%
        ELSE
            tempBox.y = MARQUEE.DRAG_END_Y%
        END IF
        tempBox.w = ABS(MARQUEE.DRAG_END_X% - MARQUEE.DRAG_START_X%)
        tempBox.h = ABS(MARQUEE.DRAG_END_Y% - MARQUEE.DRAG_START_Y%)
        tempBox.state = GJ_BBX_STATE_IDLE
        
        ' Ensure we have at least 1 pixel width/height for visibility
        IF tempBox.w < 1 THEN tempBox.w = 1
        IF tempBox.h < 1 THEN tempBox.h = 1
        
        ' Transform to zoomed canvas coordinates
        zoomedBox.x = dx% + INT(tempBox.x * SCRN.zoom!)
        zoomedBox.y = dy% + INT(tempBox.y * SCRN.zoom!)
        zoomedBox.w = INT(tempBox.w * SCRN.zoom!)
        zoomedBox.h = INT(tempBox.h * SCRN.zoom!)
        zoomedBox.state = tempBox.state
        IF zoomedBox.w < 1 THEN zoomedBox.w = 1
        IF zoomedBox.h < 1 THEN zoomedBox.h = 1
        
        ' Draw the drag preview with dotted lines (in zoomed coordinates)
        MARQUEE_draw_dotted_box zoomedBox, FALSE
    ELSEIF MARQUEE.ACTIVE% THEN
        ' Transform to zoomed canvas coordinates
        zoomedBox.x = dx% + INT(MARQUEE.BOX.x * SCRN.zoom!)
        zoomedBox.y = dy% + INT(MARQUEE.BOX.y * SCRN.zoom!)
        zoomedBox.w = INT(MARQUEE.BOX.w * SCRN.zoom!)
        zoomedBox.h = INT(MARQUEE.BOX.h * SCRN.zoom!)
        zoomedBox.state = MARQUEE.BOX.state
        IF zoomedBox.w < 1 THEN zoomedBox.w = 1
        IF zoomedBox.h < 1 THEN zoomedBox.h = 1
        
        ' Draw the bounding box with dotted line effect (in zoomed coordinates)
        MARQUEE_draw_dotted_box zoomedBox, showHUD%
        
        ' Draw handles directly (in zoomed coordinates)
        IF showHUD% THEN
            DIM hh AS INTEGER, cx AS INTEGER, cy AS INTEGER
            DIM handleColor AS _UNSIGNED LONG
            DIM hoveredHandle AS INTEGER
            
            ' Check which handle the mouse is hovering over (if not actively resizing)
            IF NOT MARQUEE.RESIZING% THEN
                hoveredHandle% = MARQUEE_get_handle_at%(MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%)
            ELSE
                hoveredHandle% = 0
            END IF
            
            ' Scale handle size with zoom (minimum 2px)
            hh% = INT(2 * SCRN.zoom!)
            IF hh% < 2 THEN hh% = 2
            cx% = zoomedBox.x + zoomedBox.w \ 2
            cy% = zoomedBox.y + zoomedBox.h \ 2
            
            ' Draw 8 handles - filled with border, 33% opaque (alpha 85)
            ' Use cyan for active resize handle OR hovered handle, gray for others
            
            ' 1: TL corner
            IF MARQUEE.RESIZE_HANDLE% = 1 OR hoveredHandle% = 1 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
            LINE (zoomedBox.x - hh%, zoomedBox.y - hh%)-(zoomedBox.x + hh%, zoomedBox.y + hh%), handleColor~&, BF
            LINE (zoomedBox.x - hh%, zoomedBox.y - hh%)-(zoomedBox.x + hh%, zoomedBox.y + hh%), _RGBA32(255, 255, 255, 85), B
            
            ' 2: T edge
            IF MARQUEE.RESIZE_HANDLE% = 2 OR hoveredHandle% = 2 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
            LINE (cx% - hh%, zoomedBox.y - hh%)-(cx% + hh%, zoomedBox.y + hh%), handleColor~&, BF
            LINE (cx% - hh%, zoomedBox.y - hh%)-(cx% + hh%, zoomedBox.y + hh%), _RGBA32(255, 255, 255, 85), B
            
            ' 3: TR corner
            IF MARQUEE.RESIZE_HANDLE% = 3 OR hoveredHandle% = 3 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
            LINE (zoomedBox.x + zoomedBox.w - hh%, zoomedBox.y - hh%)-(zoomedBox.x + zoomedBox.w + hh%, zoomedBox.y + hh%), handleColor~&, BF
            LINE (zoomedBox.x + zoomedBox.w - hh%, zoomedBox.y - hh%)-(zoomedBox.x + zoomedBox.w + hh%, zoomedBox.y + hh%), _RGBA32(255, 255, 255, 85), B
            
            ' 4: L edge
            IF MARQUEE.RESIZE_HANDLE% = 4 OR hoveredHandle% = 4 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
            LINE (zoomedBox.x - hh%, cy% - hh%)-(zoomedBox.x + hh%, cy% + hh%), handleColor~&, BF
            LINE (zoomedBox.x - hh%, cy% - hh%)-(zoomedBox.x + hh%, cy% + hh%), _RGBA32(255, 255, 255, 85), B
            
            ' 5: R edge
            IF MARQUEE.RESIZE_HANDLE% = 5 OR hoveredHandle% = 5 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
            LINE (zoomedBox.x + zoomedBox.w - hh%, cy% - hh%)-(zoomedBox.x + zoomedBox.w + hh%, cy% + hh%), handleColor~&, BF
            LINE (zoomedBox.x + zoomedBox.w - hh%, cy% - hh%)-(zoomedBox.x + zoomedBox.w + hh%, cy% + hh%), _RGBA32(255, 255, 255, 85), B
            
            ' 6: BL corner
            IF MARQUEE.RESIZE_HANDLE% = 6 OR hoveredHandle% = 6 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
            LINE (zoomedBox.x - hh%, zoomedBox.y + zoomedBox.h - hh%)-(zoomedBox.x + hh%, zoomedBox.y + zoomedBox.h + hh%), handleColor~&, BF
            LINE (zoomedBox.x - hh%, zoomedBox.y + zoomedBox.h - hh%)-(zoomedBox.x + hh%, zoomedBox.y + zoomedBox.h + hh%), _RGBA32(255, 255, 255, 85), B
            
            ' 7: B edge
            IF MARQUEE.RESIZE_HANDLE% = 7 OR hoveredHandle% = 7 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
            LINE (cx% - hh%, zoomedBox.y + zoomedBox.h - hh%)-(cx% + hh%, zoomedBox.y + zoomedBox.h + hh%), handleColor~&, BF
            LINE (cx% - hh%, zoomedBox.y + zoomedBox.h - hh%)-(cx% + hh%, zoomedBox.y + zoomedBox.h + hh%), _RGBA32(255, 255, 255, 85), B
            
            ' 8: BR corner
            IF MARQUEE.RESIZE_HANDLE% = 8 OR hoveredHandle% = 8 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
            LINE (zoomedBox.x + zoomedBox.w - hh%, zoomedBox.y + zoomedBox.h - hh%)-(zoomedBox.x + zoomedBox.w + hh%, zoomedBox.y + zoomedBox.h + hh%), handleColor~&, BF
            LINE (zoomedBox.x + zoomedBox.w - hh%, zoomedBox.y + zoomedBox.h - hh%)-(zoomedBox.x + zoomedBox.w + hh%, zoomedBox.y + zoomedBox.h + hh%), _RGBA32(255, 255, 255, 85), B
        END IF
    END IF
END SUB


''
' Draw only the drag preview rectangle (for add/subtract mode overlay)
' This is simpler and always draws if DRAGGING is true
'
SUB MARQUEE_draw_drag_preview ()
    IF NOT MARQUEE.DRAGGING% THEN EXIT SUB
    
    DIM tempBox AS GJ_BBX_BBOX
    DIM zoomedBox AS GJ_BBX_BBOX
    
    ' Calculate zoom transformation values (canvas dimensions, centered in viewport)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.canvasW& * SCRN.zoom!
    zh& = SCRN.canvasH& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%
    
    ' Calculate temp box from drag coordinates
    IF MARQUEE.DRAG_START_X% < MARQUEE.DRAG_END_X% THEN
        tempBox.x = MARQUEE.DRAG_START_X%
    ELSE
        tempBox.x = MARQUEE.DRAG_END_X%
    END IF
    IF MARQUEE.DRAG_START_Y% < MARQUEE.DRAG_END_Y% THEN
        tempBox.y = MARQUEE.DRAG_START_Y%
    ELSE
        tempBox.y = MARQUEE.DRAG_END_Y%
    END IF
    tempBox.w = ABS(MARQUEE.DRAG_END_X% - MARQUEE.DRAG_START_X%)
    tempBox.h = ABS(MARQUEE.DRAG_END_Y% - MARQUEE.DRAG_START_Y%)
    
    ' Ensure minimum size for visibility
    IF tempBox.w < 1 THEN tempBox.w = 1
    IF tempBox.h < 1 THEN tempBox.h = 1
    
    ' Transform to zoomed canvas coordinates
    zoomedBox.x = dx% + INT(tempBox.x * SCRN.zoom!)
    zoomedBox.y = dy% + INT(tempBox.y * SCRN.zoom!)
    zoomedBox.w = INT(tempBox.w * SCRN.zoom!)
    zoomedBox.h = INT(tempBox.h * SCRN.zoom!)
    IF zoomedBox.w < 1 THEN zoomedBox.w = 1
    IF zoomedBox.h < 1 THEN zoomedBox.h = 1
    
    ' Draw the preview box
    _DEST SCRN.CANVAS&
    MARQUEE_draw_dotted_box zoomedBox, FALSE
END SUB


''
' Draw ONLY the existing marquee box (not the drag preview)
' Used when dragging in add/subtract mode to show both existing selection AND new drag
' @param showHUD INTEGER Whether to show handles and HUD elements
'
SUB MARQUEE_draw_existing_box (showHUD AS INTEGER)
    IF NOT MARQUEE.ACTIVE% THEN EXIT SUB
    
    DIM zoomedBox AS GJ_BBX_BBOX
    
    ' Calculate zoom transformation values (canvas dimensions, centered in viewport)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.canvasW& * SCRN.zoom!
    zh& = SCRN.canvasH& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%
    
    _DEST SCRN.CANVAS&
    
    ' Transform existing box to zoomed canvas coordinates
    zoomedBox.x = dx% + INT(MARQUEE.BOX.x * SCRN.zoom!)
    zoomedBox.y = dy% + INT(MARQUEE.BOX.y * SCRN.zoom!)
    zoomedBox.w = INT(MARQUEE.BOX.w * SCRN.zoom!)
    zoomedBox.h = INT(MARQUEE.BOX.h * SCRN.zoom!)
    zoomedBox.state = MARQUEE.BOX.state
    IF zoomedBox.w < 1 THEN zoomedBox.w = 1
    IF zoomedBox.h < 1 THEN zoomedBox.h = 1
    
    ' Draw the bounding box with dotted line effect (in zoomed coordinates)
    MARQUEE_draw_dotted_box zoomedBox, showHUD%
    
    ' Draw handles if showHUD requested
    IF showHUD% THEN
        DIM hh AS INTEGER, cx AS INTEGER, cy AS INTEGER
        DIM handleColor AS _UNSIGNED LONG
        DIM hoveredHandle AS INTEGER
        
        ' Check which handle the mouse is hovering over (if not actively resizing)
        IF NOT MARQUEE.RESIZING% THEN
            hoveredHandle% = MARQUEE_get_handle_at%(MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%)
        ELSE
            hoveredHandle% = 0
        END IF
        
        ' Scale handle size with zoom (minimum 1px)
        hh% = INT(1 * SCRN.zoom!)
        IF hh% < 1 THEN hh% = 1
        cx% = zoomedBox.x + zoomedBox.w \ 2
        cy% = zoomedBox.y + zoomedBox.h \ 2
        
        ' Draw 8 handles - filled with border, 33% opaque (alpha 85)
        ' Use cyan for hovered handle, gray for others
        
        ' 1: TL corner
        IF hoveredHandle% = 1 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
        LINE (zoomedBox.x - hh%, zoomedBox.y - hh%)-(zoomedBox.x + hh%, zoomedBox.y + hh%), handleColor~&, BF
        LINE (zoomedBox.x - hh%, zoomedBox.y - hh%)-(zoomedBox.x + hh%, zoomedBox.y + hh%), _RGBA32(255, 255, 255, 85), B
        
        ' 2: T edge
        IF hoveredHandle% = 2 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
        LINE (cx% - hh%, zoomedBox.y - hh%)-(cx% + hh%, zoomedBox.y + hh%), handleColor~&, BF
        LINE (cx% - hh%, zoomedBox.y - hh%)-(cx% + hh%, zoomedBox.y + hh%), _RGBA32(255, 255, 255, 85), B
        
        ' 3: TR corner
        IF hoveredHandle% = 3 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
        LINE (zoomedBox.x + zoomedBox.w - hh%, zoomedBox.y - hh%)-(zoomedBox.x + zoomedBox.w + hh%, zoomedBox.y + hh%), handleColor~&, BF
        LINE (zoomedBox.x + zoomedBox.w - hh%, zoomedBox.y - hh%)-(zoomedBox.x + zoomedBox.w + hh%, zoomedBox.y + hh%), _RGBA32(255, 255, 255, 85), B
        
        ' 4: L edge
        IF hoveredHandle% = 4 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
        LINE (zoomedBox.x - hh%, cy% - hh%)-(zoomedBox.x + hh%, cy% + hh%), handleColor~&, BF
        LINE (zoomedBox.x - hh%, cy% - hh%)-(zoomedBox.x + hh%, cy% + hh%), _RGBA32(255, 255, 255, 85), B
        
        ' 5: R edge
        IF hoveredHandle% = 5 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
        LINE (zoomedBox.x + zoomedBox.w - hh%, cy% - hh%)-(zoomedBox.x + zoomedBox.w + hh%, cy% + hh%), handleColor~&, BF
        LINE (zoomedBox.x + zoomedBox.w - hh%, cy% - hh%)-(zoomedBox.x + zoomedBox.w + hh%, cy% + hh%), _RGBA32(255, 255, 255, 85), B
        
        ' 6: BL corner
        IF hoveredHandle% = 6 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
        LINE (zoomedBox.x - hh%, zoomedBox.y + zoomedBox.h - hh%)-(zoomedBox.x + hh%, zoomedBox.y + zoomedBox.h + hh%), handleColor~&, BF
        LINE (zoomedBox.x - hh%, zoomedBox.y + zoomedBox.h - hh%)-(zoomedBox.x + hh%, zoomedBox.y + zoomedBox.h + hh%), _RGBA32(255, 255, 255, 85), B
        
        ' 7: B edge
        IF hoveredHandle% = 7 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
        LINE (cx% - hh%, zoomedBox.y + zoomedBox.h - hh%)-(cx% + hh%, zoomedBox.y + zoomedBox.h + hh%), handleColor~&, BF
        LINE (cx% - hh%, zoomedBox.y + zoomedBox.h - hh%)-(cx% + hh%, zoomedBox.y + zoomedBox.h + hh%), _RGBA32(255, 255, 255, 85), B
        
        ' 8: BR corner
        IF hoveredHandle% = 8 THEN handleColor~& = _RGBA32(0, 255, 255, 85) ELSE handleColor~& = _RGBA32(160, 160, 160, 85)
        LINE (zoomedBox.x + zoomedBox.w - hh%, zoomedBox.y + zoomedBox.h - hh%)-(zoomedBox.x + zoomedBox.w + hh%, zoomedBox.y + zoomedBox.h + hh%), handleColor~&, BF
        LINE (zoomedBox.x + zoomedBox.w - hh%, zoomedBox.y + zoomedBox.h - hh%)-(zoomedBox.x + zoomedBox.w + hh%, zoomedBox.y + zoomedBox.h + hh%), _RGBA32(255, 255, 255, 85), B
    END IF
END SUB


''
' Draw a dotted/dashed box outline
' @param b GJ_BBX_BBOX The bounding box to draw (already in canvas/screen coordinates)
' @param showHUD INTEGER Whether to show the HUD
'
SUB MARQUEE_draw_dotted_box (b AS GJ_BBX_BBOX, showHUD AS INTEGER)
    DIM i AS INTEGER
    DIM dotSize AS INTEGER
    DIM gapSize AS INTEGER
    DIM x AS INTEGER, y AS INTEGER
    DIM lineColor AS _UNSIGNED LONG
    DIM outlineColor AS _UNSIGNED LONG
    DIM prevBlend AS LONG
    
    ' Save and set blend mode
    prevBlend& = _BLEND
    _DONTBLEND
    
    ' Fixed dot and gap size in screen pixels (consistent at any zoom)
    dotSize% = 3
    gapSize% = 3
    
    ' Animate marching ants with time-based offset
    DIM antOffset AS INTEGER
    antOffset% = INT(TIMER * 8) MOD (dotSize% + gapSize%)
    
    ' Use white and black for marching ants contrast
    DIM whiteColor AS _UNSIGNED LONG
    DIM blackColor AS _UNSIGNED LONG
    whiteColor~& = _RGB32(255, 255, 255)
    blackColor~& = _RGB32(0, 0, 0)
    
    ' Draw marching ants for top and bottom edges
    FOR i% = 0 TO b.w - 1
        x% = b.x + i%
        IF x% <= b.x + b.w - 1 THEN
            ' Calculate pattern position with animation offset
            DIM pattern AS INTEGER
            pattern% = (i% + antOffset%) MOD (dotSize% + gapSize%)
            
            IF pattern% < dotSize% THEN
                lineColor~& = whiteColor~&
            ELSE
                lineColor~& = blackColor~&
            END IF
            
            ' Top edge (1px thin)
            PSET (x%, b.y), lineColor~&
            
            ' Bottom edge (1px thin)
            PSET (x%, b.y + b.h - 1), lineColor~&
        END IF
    NEXT i%
    
    ' Draw marching ants for left and right edges
    FOR i% = 0 TO b.h - 1
        y% = b.y + i%
        IF y% <= b.y + b.h - 1 THEN
            ' Calculate pattern position with animation offset
            DIM patternV AS INTEGER
            patternV% = (i% + antOffset%) MOD (dotSize% + gapSize%)
            
            IF patternV% < dotSize% THEN
                lineColor~& = whiteColor~&
            ELSE
                lineColor~& = blackColor~&
            END IF
            
            ' Left edge (1px thin)
            PSET (b.x, y%), lineColor~&
            
            ' Right edge (1px thin)
            PSET (b.x + b.w - 1, y%), lineColor~&
        END IF
    NEXT i%
    
    ' Restore blend mode
    IF prevBlend& THEN _BLEND
END SUB


''
' Finish the drag operation and create the final BBOX
'
SUB MARQUEE_finish_drag ()
    IF NOT MARQUEE.DRAGGING% THEN EXIT SUB
    
    ' Calculate final box dimensions
    DIM finalX AS INTEGER, finalY AS INTEGER
    DIM finalW AS INTEGER, finalH AS INTEGER
    
    IF MARQUEE.DRAG_START_X% < MARQUEE.DRAG_END_X% THEN
        finalX% = MARQUEE.DRAG_START_X%
    ELSE
        finalX% = MARQUEE.DRAG_END_X%
    END IF
    IF MARQUEE.DRAG_START_Y% < MARQUEE.DRAG_END_Y% THEN
        finalY% = MARQUEE.DRAG_START_Y%
    ELSE
        finalY% = MARQUEE.DRAG_END_Y%
    END IF
    finalW% = ABS(MARQUEE.DRAG_END_X% - MARQUEE.DRAG_START_X%)
    finalH% = ABS(MARQUEE.DRAG_END_Y% - MARQUEE.DRAG_START_Y%)
    
    ' Check if this was just a click (no significant drag movement)
    IF finalW% < 4 AND finalH% < 4 THEN
        ' Just a click - clear selection only in replace mode
        IF MARQUEE.SELECTION_MODE = SEL_MODE_REPLACE THEN
            MARQUEE.ACTIVE% = FALSE
        END IF
        MARQUEE.DRAGGING% = FALSE
        EXIT SUB
    END IF
    
    ' Only create box if drag has some size
    IF finalW% >= MARQUEE.CFG.MinBoxWidth AND finalH% >= MARQUEE.CFG.MinBoxHeight THEN
        ' Handle add/subtract modes by converting to/from mask
        ' For add mode without existing selection, treat as replace (creates new selection)
        DIM useAddSubtractMode AS INTEGER
        useAddSubtractMode% = (MARQUEE.SELECTION_MODE <> SEL_MODE_REPLACE) AND (MARQUEE.ACTIVE% OR MARQUEE.WAND_HAS_SELECTION)
        
        IF useAddSubtractMode% THEN
            DIM w AS INTEGER, h AS INTEGER
            DIM px AS INTEGER, py AS INTEGER
            DIM mask_color AS _UNSIGNED LONG
            mask_color~& = _RGB32(255, 255, 255)
            w% = SCRN.canvasW&
            h% = SCRN.canvasH&
            
            ' Create mask from existing box selection if we don't have one
            IF MARQUEE.SELECTION_MASK >= -1 OR NOT MARQUEE.WAND_HAS_SELECTION THEN
                ' Convert existing box to mask
                IF MARQUEE.SELECTION_MASK < -1 THEN _FREEIMAGE MARQUEE.SELECTION_MASK
                MARQUEE.SELECTION_MASK = _NEWIMAGE(w%, h%, 32)
                IF MARQUEE.SELECTION_MASK < -1 THEN
                    _DEST MARQUEE.SELECTION_MASK
                    CLS , _RGBA32(0, 0, 0, 0)
                    _DONTBLEND MARQUEE.SELECTION_MASK
                    ' Fill existing box area
                    IF MARQUEE.ACTIVE% THEN
                        LINE (MARQUEE.BOX.x, MARQUEE.BOX.y)-(MARQUEE.BOX.x + MARQUEE.BOX.w - 1, MARQUEE.BOX.y + MARQUEE.BOX.h - 1), mask_color~&, BF
                    END IF
                    _BLEND MARQUEE.SELECTION_MASK
                END IF
            END IF
            
            ' Apply the new rectangle to the mask
            IF MARQUEE.SELECTION_MASK < -1 THEN
                _DEST MARQUEE.SELECTION_MASK
                _DONTBLEND MARQUEE.SELECTION_MASK
                IF MARQUEE.SELECTION_MODE = SEL_MODE_ADD THEN
                    ' Add: fill the new rectangle
                    LINE (finalX%, finalY%)-(finalX% + finalW% - 1, finalY% + finalH% - 1), mask_color~&, BF
                ELSEIF MARQUEE.SELECTION_MODE = SEL_MODE_SUBTRACT THEN
                    ' Subtract: clear the new rectangle (transparent)
                    LINE (finalX%, finalY%)-(finalX% + finalW% - 1, finalY% + finalH% - 1), _RGBA32(0, 0, 0, 0), BF
                END IF
                _BLEND MARQUEE.SELECTION_MASK
                
                ' Recalculate bounding box from mask
                DIM minX AS INTEGER, minY AS INTEGER, maxX AS INTEGER, maxY AS INTEGER
                minX% = w%: minY% = h%: maxX% = 0: maxY% = 0
                _SOURCE MARQUEE.SELECTION_MASK
                FOR py% = 0 TO h% - 1
                    FOR px% = 0 TO w% - 1
                        IF _ALPHA32(POINT(px%, py%)) > 0 THEN
                            IF px% < minX% THEN minX% = px%
                            IF px% > maxX% THEN maxX% = px%
                            IF py% < minY% THEN minY% = py%
                            IF py% > maxY% THEN maxY% = py%
                        END IF
                    NEXT px%
                NEXT py%
                
                ' Check if selection is empty
                IF minX% > maxX% THEN
                    ' Empty selection after subtract
                    MARQUEE_clear
                    MAGIC_WAND_reset
                ELSE
                    ' Update bounding box and wand bounds
                    MARQUEE.WAND_MIN_X = minX%
                    MARQUEE.WAND_MIN_Y = minY%
                    MARQUEE.WAND_MAX_X = maxX%
                    MARQUEE.WAND_MAX_Y = maxY%
                    MARQUEE.BOX.x = minX%
                    MARQUEE.BOX.y = minY%
                    MARQUEE.BOX.w = maxX% - minX% + 1
                    MARQUEE.BOX.h = maxY% - minY% + 1
                    MARQUEE.ACTIVE% = TRUE
                    MARQUEE.WAND_HAS_SELECTION = TRUE
                    MARQUEE.USER_CREATED = TRUE
                END IF
            END IF
        ELSE
            ' Replace mode - simple box creation
            MARQUEE.CFG.initX = finalX%
            MARQUEE.CFG.initY = finalY%
            MARQUEE.CFG.initW = finalW%
            MARQUEE.CFG.initH = finalH%
            
            ' Initialize the bounding box with our config
            GJ_BBX_InitWithConfig MARQUEE.CFG
            
            MARQUEE.BOX = GJ_BBX_box
            MARQUEE.ACTIVE% = TRUE
            MARQUEE.USER_CREATED = TRUE  ' User manually created this selection
            
            ' Clear any wand selection mask for clean replace
            IF MARQUEE.SELECTION_MASK < -1 THEN
                _FREEIMAGE MARQUEE.SELECTION_MASK
                MARQUEE.SELECTION_MASK = 0
            END IF
            MARQUEE.WAND_HAS_SELECTION = FALSE
        END IF
    END IF
    
    MARQUEE.DRAGGING% = FALSE
    MARQUEE.SELECTION_MODE = SEL_MODE_REPLACE  ' Reset mode
END SUB


''
' Check if a point is inside the active marquee box
' @param x INTEGER X coordinate to check
' @param y INTEGER Y coordinate to check
' @return INTEGER TRUE if point is inside, FALSE otherwise
'
FUNCTION MARQUEE_is_point_inside% (x AS INTEGER, y AS INTEGER)
    IF NOT MARQUEE.ACTIVE% THEN
        MARQUEE_is_point_inside% = FALSE
        EXIT FUNCTION
    END IF
    
    IF x >= MARQUEE.BOX.x AND x <= (MARQUEE.BOX.x + MARQUEE.BOX.w) THEN
        IF y >= MARQUEE.BOX.y AND y <= (MARQUEE.BOX.y + MARQUEE.BOX.h) THEN
            MARQUEE_is_point_inside% = TRUE
            EXIT FUNCTION
        END IF
    END IF
    
    MARQUEE_is_point_inside% = FALSE
END FUNCTION


''  
'
SUB MARQUEE_clear ()
    MARQUEE.ACTIVE% = FALSE
    MARQUEE.DRAGGING% = FALSE
    MARQUEE.RESIZING% = FALSE
    MARQUEE.RESIZE_HANDLE% = 0
    MARQUEE.MOVING% = FALSE
    MARQUEE.USER_CREATED = FALSE
    MARQUEE.INITIALIZED% = FALSE
END SUB


''
' Get which handle (if any) is at the given coordinates
' @param x INTEGER X coordinate to check
' @param y INTEGER Y coordinate to check  
' @return INTEGER Handle number (0=none, 1=TL, 2=T, 3=TR, 4=L, 5=R, 6=BL, 7=B, 8=BR)
'
FUNCTION MARQUEE_get_handle_at% (x AS INTEGER, y AS INTEGER)
    IF NOT MARQUEE.ACTIVE% THEN
        MARQUEE_get_handle_at% = 0
        EXIT FUNCTION
    END IF
    
    DIM hh AS INTEGER, cx AS INTEGER, cy AS INTEGER
    hh% = 3  ' Handle half size (6px total hit area)
    cx% = MARQUEE.BOX.x + MARQUEE.BOX.w \ 2
    cy% = MARQUEE.BOX.y + MARQUEE.BOX.h \ 2
    
    ' Check each handle (TL, T, TR, L, R, BL, B, BR)
    ' 1: TL corner
    IF x >= MARQUEE.BOX.x - hh% AND x <= MARQUEE.BOX.x + hh% THEN
        IF y >= MARQUEE.BOX.y - hh% AND y <= MARQUEE.BOX.y + hh% THEN
            MARQUEE_get_handle_at% = 1
            EXIT FUNCTION
        END IF
    END IF
    
    ' 2: T edge
    IF x >= cx% - hh% AND x <= cx% + hh% THEN
        IF y >= MARQUEE.BOX.y - hh% AND y <= MARQUEE.BOX.y + hh% THEN
            MARQUEE_get_handle_at% = 2
            EXIT FUNCTION
        END IF
    END IF
    
    ' 3: TR corner
    IF x >= MARQUEE.BOX.x + MARQUEE.BOX.w - hh% AND x <= MARQUEE.BOX.x + MARQUEE.BOX.w + hh% THEN
        IF y >= MARQUEE.BOX.y - hh% AND y <= MARQUEE.BOX.y + hh% THEN
            MARQUEE_get_handle_at% = 3
            EXIT FUNCTION
        END IF
    END IF
    
    ' 4: L edge
    IF x >= MARQUEE.BOX.x - hh% AND x <= MARQUEE.BOX.x + hh% THEN
        IF y >= cy% - hh% AND y <= cy% + hh% THEN
            MARQUEE_get_handle_at% = 4
            EXIT FUNCTION
        END IF
    END IF
    
    ' 5: R edge
    IF x >= MARQUEE.BOX.x + MARQUEE.BOX.w - hh% AND x <= MARQUEE.BOX.x + MARQUEE.BOX.w + hh% THEN
        IF y >= cy% - hh% AND y <= cy% + hh% THEN
            MARQUEE_get_handle_at% = 5
            EXIT FUNCTION
        END IF
    END IF
    
    ' 6: BL corner
    IF x >= MARQUEE.BOX.x - hh% AND x <= MARQUEE.BOX.x + hh% THEN
        IF y >= MARQUEE.BOX.y + MARQUEE.BOX.h - hh% AND y <= MARQUEE.BOX.y + MARQUEE.BOX.h + hh% THEN
            MARQUEE_get_handle_at% = 6
            EXIT FUNCTION
        END IF
    END IF
    
    ' 7: B edge
    IF x >= cx% - hh% AND x <= cx% + hh% THEN
        IF y >= MARQUEE.BOX.y + MARQUEE.BOX.h - hh% AND y <= MARQUEE.BOX.y + MARQUEE.BOX.h + hh% THEN
            MARQUEE_get_handle_at% = 7
            EXIT FUNCTION
        END IF
    END IF
    
    ' 8: BR corner
    IF x >= MARQUEE.BOX.x + MARQUEE.BOX.w - hh% AND x <= MARQUEE.BOX.x + MARQUEE.BOX.w + hh% THEN
        IF y >= MARQUEE.BOX.y + MARQUEE.BOX.h - hh% AND y <= MARQUEE.BOX.y + MARQUEE.BOX.h + hh% THEN
            MARQUEE_get_handle_at% = 8
            EXIT FUNCTION
        END IF
    END IF
    
    MARQUEE_get_handle_at% = 0
END FUNCTION


''
' Start resizing from a handle
' @param handle INTEGER Which handle is being resized
' @param x INTEGER Starting X coordinate
' @param y INTEGER Starting Y coordinate
'
SUB MARQUEE_start_resize (handle AS INTEGER, x AS INTEGER, y AS INTEGER)
    MARQUEE.RESIZING% = TRUE
    MARQUEE.RESIZE_HANDLE% = handle
    MARQUEE.RESIZE_START_X% = x
    MARQUEE.RESIZE_START_Y% = y
    MARQUEE.RESIZE_ORIG_X% = MARQUEE.BOX.x
    MARQUEE.RESIZE_ORIG_Y% = MARQUEE.BOX.y
    MARQUEE.RESIZE_ORIG_W% = MARQUEE.BOX.w
    MARQUEE.RESIZE_ORIG_H% = MARQUEE.BOX.h
END SUB


''
' Update resize based on current mouse position
' @param x INTEGER Current X coordinate
' @param y INTEGER Current Y coordinate
'
SUB MARQUEE_update_resize (x AS INTEGER, y AS INTEGER)
    IF NOT MARQUEE.RESIZING% THEN EXIT SUB
    
    DIM dx AS INTEGER, dy AS INTEGER
    dx% = x - MARQUEE.RESIZE_START_X%
    dy% = y - MARQUEE.RESIZE_START_Y%
    
    SELECT CASE MARQUEE.RESIZE_HANDLE%
        CASE 1  ' TL corner - move top-left, adjust width/height
            MARQUEE.BOX.w = MARQUEE.RESIZE_ORIG_W% - dx%
            MARQUEE.BOX.h = MARQUEE.RESIZE_ORIG_H% - dy%
            ' Enforce minimum size
            IF MARQUEE.BOX.w < MARQUEE.CFG.MinBoxWidth THEN MARQUEE.BOX.w = MARQUEE.CFG.MinBoxWidth
            IF MARQUEE.BOX.h < MARQUEE.CFG.MinBoxHeight THEN MARQUEE.BOX.h = MARQUEE.CFG.MinBoxHeight
            ' Adjust position to keep BR corner anchored
            MARQUEE.BOX.x = MARQUEE.RESIZE_ORIG_X% + MARQUEE.RESIZE_ORIG_W% - MARQUEE.BOX.w
            MARQUEE.BOX.y = MARQUEE.RESIZE_ORIG_Y% + MARQUEE.RESIZE_ORIG_H% - MARQUEE.BOX.h
            
        CASE 2  ' T edge - move top, adjust height
            MARQUEE.BOX.h = MARQUEE.RESIZE_ORIG_H% - dy%
            ' Enforce minimum size
            IF MARQUEE.BOX.h < MARQUEE.CFG.MinBoxHeight THEN MARQUEE.BOX.h = MARQUEE.CFG.MinBoxHeight
            ' Adjust position to keep bottom edge anchored
            MARQUEE.BOX.y = MARQUEE.RESIZE_ORIG_Y% + MARQUEE.RESIZE_ORIG_H% - MARQUEE.BOX.h
            
        CASE 3  ' TR corner - adjust width, move top, adjust height
            MARQUEE.BOX.w = MARQUEE.RESIZE_ORIG_W% + dx%
            MARQUEE.BOX.h = MARQUEE.RESIZE_ORIG_H% - dy%
            ' Enforce minimum size
            IF MARQUEE.BOX.w < MARQUEE.CFG.MinBoxWidth THEN MARQUEE.BOX.w = MARQUEE.CFG.MinBoxWidth
            IF MARQUEE.BOX.h < MARQUEE.CFG.MinBoxHeight THEN MARQUEE.BOX.h = MARQUEE.CFG.MinBoxHeight
            ' Adjust Y position to keep bottom edge anchored
            MARQUEE.BOX.y = MARQUEE.RESIZE_ORIG_Y% + MARQUEE.RESIZE_ORIG_H% - MARQUEE.BOX.h
            
        CASE 4  ' L edge - move left, adjust width
            MARQUEE.BOX.w = MARQUEE.RESIZE_ORIG_W% - dx%
            ' Enforce minimum size
            IF MARQUEE.BOX.w < MARQUEE.CFG.MinBoxWidth THEN MARQUEE.BOX.w = MARQUEE.CFG.MinBoxWidth
            ' Adjust position to keep right edge anchored
            MARQUEE.BOX.x = MARQUEE.RESIZE_ORIG_X% + MARQUEE.RESIZE_ORIG_W% - MARQUEE.BOX.w
            
        CASE 5  ' R edge - adjust width only
            MARQUEE.BOX.w = MARQUEE.RESIZE_ORIG_W% + dx%
            IF MARQUEE.BOX.w < MARQUEE.CFG.MinBoxWidth THEN MARQUEE.BOX.w = MARQUEE.CFG.MinBoxWidth
            
        CASE 6  ' BL corner - move left, adjust width and height
            MARQUEE.BOX.w = MARQUEE.RESIZE_ORIG_W% - dx%
            MARQUEE.BOX.h = MARQUEE.RESIZE_ORIG_H% + dy%
            ' Enforce minimum size
            IF MARQUEE.BOX.w < MARQUEE.CFG.MinBoxWidth THEN MARQUEE.BOX.w = MARQUEE.CFG.MinBoxWidth
            IF MARQUEE.BOX.h < MARQUEE.CFG.MinBoxHeight THEN MARQUEE.BOX.h = MARQUEE.CFG.MinBoxHeight
            ' Adjust X position to keep right edge anchored
            MARQUEE.BOX.x = MARQUEE.RESIZE_ORIG_X% + MARQUEE.RESIZE_ORIG_W% - MARQUEE.BOX.w
            
        CASE 7  ' B edge - adjust height only
            MARQUEE.BOX.h = MARQUEE.RESIZE_ORIG_H% + dy%
            IF MARQUEE.BOX.h < MARQUEE.CFG.MinBoxHeight THEN MARQUEE.BOX.h = MARQUEE.CFG.MinBoxHeight
            
        CASE 8  ' BR corner - adjust width and height
            MARQUEE.BOX.w = MARQUEE.RESIZE_ORIG_W% + dx%
            MARQUEE.BOX.h = MARQUEE.RESIZE_ORIG_H% + dy%
            IF MARQUEE.BOX.w < MARQUEE.CFG.MinBoxWidth THEN MARQUEE.BOX.w = MARQUEE.CFG.MinBoxWidth
            IF MARQUEE.BOX.h < MARQUEE.CFG.MinBoxHeight THEN MARQUEE.BOX.h = MARQUEE.CFG.MinBoxHeight
    END SELECT
    
    ' Apply screen bounds (keep at least 1 pixel visible)
    IF MARQUEE.BOX.x > SCRN.w - 1 THEN MARQUEE.BOX.x = SCRN.w - 1
    IF MARQUEE.BOX.x < 1 - MARQUEE.BOX.w THEN MARQUEE.BOX.x = 1 - MARQUEE.BOX.w
    IF MARQUEE.BOX.y > SCRN.h - 1 THEN MARQUEE.BOX.y = SCRN.h - 1
    IF MARQUEE.BOX.y < 1 - MARQUEE.BOX.h THEN MARQUEE.BOX.y = 1 - MARQUEE.BOX.h
    ' Also ensure the box doesn't extend too far
    IF MARQUEE.BOX.x + MARQUEE.BOX.w > SCRN.w THEN MARQUEE.BOX.w = SCRN.w - MARQUEE.BOX.x
    IF MARQUEE.BOX.y + MARQUEE.BOX.h > SCRN.h THEN MARQUEE.BOX.h = SCRN.h - MARQUEE.BOX.y
    ' And enforce minimum again after bounds checking
    IF MARQUEE.BOX.w < 1 THEN MARQUEE.BOX.w = 1
    IF MARQUEE.BOX.h < 1 THEN MARQUEE.BOX.h = 1
END SUB


''
' Finish resizing operation
'
SUB MARQUEE_finish_resize ()
    MARQUEE.RESIZING% = FALSE
    MARQUEE.RESIZE_HANDLE% = 0
END SUB


''
' Start moving the box from inside
' @param x INTEGER Starting X coordinate
' @param y INTEGER Starting Y coordinate
'
SUB MARQUEE_start_move (x AS INTEGER, y AS INTEGER)
    MARQUEE.MOVING% = TRUE
    MARQUEE.MOVE_START_X% = x
    MARQUEE.MOVE_START_Y% = y
    MARQUEE.MOVE_ORIG_X% = MARQUEE.BOX.x
    MARQUEE.MOVE_ORIG_Y% = MARQUEE.BOX.y
END SUB


''
' Update move based on current mouse position
' @param x INTEGER Current X coordinate
' @param y INTEGER Current Y coordinate
'
SUB MARQUEE_update_move (x AS INTEGER, y AS INTEGER)
    IF NOT MARQUEE.MOVING% THEN EXIT SUB
    
    DIM dx AS INTEGER, dy AS INTEGER
    dx% = x - MARQUEE.MOVE_START_X%
    dy% = y - MARQUEE.MOVE_START_Y%
    
    MARQUEE.BOX.x = MARQUEE.MOVE_ORIG_X% + dx%
    MARQUEE.BOX.y = MARQUEE.MOVE_ORIG_Y% + dy%
    
    ' Keep box within screen bounds (at least 1 pixel visible)
    ' Left edge can go as far right as SCRN.w - 1
    IF MARQUEE.BOX.x > SCRN.w - 1 THEN MARQUEE.BOX.x = SCRN.w - 1
    ' Right edge must be at least at x=0, so x >= -(w-1) or x >= 1-w
    IF MARQUEE.BOX.x < 1 - MARQUEE.BOX.w THEN MARQUEE.BOX.x = 1 - MARQUEE.BOX.w
    ' Top edge can go as far down as SCRN.h - 1
    IF MARQUEE.BOX.y > SCRN.h - 1 THEN MARQUEE.BOX.y = SCRN.h - 1
    ' Bottom edge must be at least at y=0
    IF MARQUEE.BOX.y < 1 - MARQUEE.BOX.h THEN MARQUEE.BOX.y = 1 - MARQUEE.BOX.h
END SUB


''
' Finish moving operation
'
SUB MARQUEE_finish_move ()
    MARQUEE.MOVING% = FALSE
END SUB


' ============================================================================
' MAGIC WAND SELECTION FUNCTIONS
' ============================================================================

''
' Reset magic wand selection state (but keep mode)
'
SUB MAGIC_WAND_reset ()
    ' Free existing mask if valid
    IF MARQUEE.SELECTION_MASK < -1 THEN
        _FREEIMAGE MARQUEE.SELECTION_MASK
    END IF
    MARQUEE.SELECTION_MASK = 0
    MARQUEE.WAND_HAS_SELECTION = FALSE
    MARQUEE.WAND_MIN_X = 0
    MARQUEE.WAND_MIN_Y = 0
    MARQUEE.WAND_MAX_X = 0
    MARQUEE.WAND_MAX_Y = 0
END SUB


''
' Check if magic wand has an active selection
' @return INTEGER TRUE if wand has selection, FALSE otherwise
'
FUNCTION MAGIC_WAND_has_selection% ()
    MAGIC_WAND_has_selection% = MARQUEE.WAND_HAS_SELECTION
END FUNCTION


''
' Select contiguous pixels of the same color (wrapper for backward compatibility)
' @param x INTEGER X coordinate to start selection
' @param y INTEGER Y coordinate to start selection
'
SUB MAGIC_WAND_select (x AS INTEGER, y AS INTEGER)
    MAGIC_WAND_select_with_mode x%, y%, SEL_MODE_REPLACE
END SUB


''
' Select contiguous pixels of the same color using scanline flood fill algorithm
' @param x INTEGER X coordinate to start selection  
' @param y INTEGER Y coordinate to start selection
' @param mode INTEGER Selection mode: SEL_MODE_REPLACE, SEL_MODE_ADD, or SEL_MODE_SUBTRACT
'
SUB MAGIC_WAND_select_with_mode (x AS INTEGER, y AS INTEGER, mode AS INTEGER)
    DIM old_dest AS LONG
    DIM old_source AS LONG
    DIM target_color AS _UNSIGNED LONG
    DIM w AS INTEGER, h AS INTEGER
    DIM targetImg AS LONG
    DIM existing_mask AS LONG
    DIM has_existing AS INTEGER
    
    ' Get the current layer image
    targetImg& = LAYER_current_image&
    old_dest& = _DEST
    old_source& = _SOURCE
    
    _SOURCE targetImg&
    
    w% = _WIDTH(targetImg&)
    h% = _HEIGHT(targetImg&)
    
    ' Bounds check
    IF x% < 0 OR x% >= w% OR y% < 0 OR y% >= h% THEN
        _SOURCE old_source&
        EXIT SUB
    END IF
    
    ' Get target color at click position
    target_color~& = POINT(x%, y%)
    
    ' For add/subtract modes, preserve existing mask
    existing_mask& = 0
    has_existing% = FALSE
    IF mode% <> SEL_MODE_REPLACE AND MARQUEE.WAND_HAS_SELECTION AND MARQUEE.SELECTION_MASK < -1 THEN
        existing_mask& = MARQUEE.SELECTION_MASK
        has_existing% = TRUE
        MARQUEE.SELECTION_MASK = 0  ' Don't free it yet
    ELSE
        ' Reset any existing selection for replace mode
        MAGIC_WAND_reset
    END IF
    
    ' Create selection mask (white = selected, transparent = not selected)
    MARQUEE.SELECTION_MASK = _NEWIMAGE(w%, h%, 32)
    IF MARQUEE.SELECTION_MASK >= -1 THEN
        _SOURCE old_source&
        EXIT SUB ' Failed to create mask
    END IF
    
    ' Clear mask to transparent
    _DEST MARQUEE.SELECTION_MASK
    CLS , _RGBA32(0, 0, 0, 0)
    _DONTBLEND MARQUEE.SELECTION_MASK
    
    ' Initialize bounding box tracking
    MARQUEE.WAND_MIN_X = w%
    MARQUEE.WAND_MIN_Y = h%
    MARQUEE.WAND_MAX_X = 0
    MARQUEE.WAND_MAX_Y = 0
    
    ' Stack for scanline seeds - starts minimal, grows dynamically as needed
    DIM stack_capacity AS LONG
    stack_capacity& = 128
    REDIM stack_x(1 TO 128) AS INTEGER
    REDIM stack_y(1 TO 128) AS INTEGER
    DIM stack_ptr AS LONG
    
    DIM py AS INTEGER, x1 AS INTEGER, x2 AS INTEGER
    DIM sx AS INTEGER, dy AS INTEGER, ny AS INTEGER
    DIM in_span AS INTEGER
    DIM mask_color AS _UNSIGNED LONG
    
    ' Mask color is white (fully opaque) for selected pixels
    mask_color~& = _RGB32(255, 255, 255)
    
    ' Initialize with starting point
    stack_ptr& = 1
    stack_x(stack_ptr&) = x%
    stack_y(stack_ptr&) = y%
    
    WHILE stack_ptr& > 0
        ' Pop seed point from stack
        x% = stack_x(stack_ptr&)
        py% = stack_y(stack_ptr&)
        stack_ptr& = stack_ptr& - 1
        
        ' Skip if out of bounds
        IF py% < 0 OR py% >= h% OR x% < 0 OR x% >= w% THEN GOTO wand_next_seed
        
        ' Skip if already selected (check mask)
        _SOURCE MARQUEE.SELECTION_MASK
        IF POINT(x%, py%) = mask_color~& THEN GOTO wand_next_seed
        
        ' Skip if color doesn't match target
        _SOURCE targetImg&
        IF POINT(x%, py%) <> target_color~& THEN GOTO wand_next_seed
        
        ' Find left edge of scanline
        x1% = x%
        WHILE x1% > 0
            _SOURCE targetImg&
            IF POINT(x1% - 1, py%) <> target_color~& THEN EXIT WHILE
            _SOURCE MARQUEE.SELECTION_MASK
            IF POINT(x1% - 1, py%) = mask_color~& THEN EXIT WHILE
            x1% = x1% - 1
        WEND
        
        ' Find right edge of scanline
        x2% = x%
        WHILE x2% < w% - 1
            _SOURCE targetImg&
            IF POINT(x2% + 1, py%) <> target_color~& THEN EXIT WHILE
            _SOURCE MARQUEE.SELECTION_MASK
            IF POINT(x2% + 1, py%) = mask_color~& THEN EXIT WHILE
            x2% = x2% + 1
        WEND
        
        ' Mark the entire horizontal scanline as selected in mask
        _DEST MARQUEE.SELECTION_MASK
        LINE (x1%, py%)-(x2%, py%), mask_color~&
        
        ' Update bounding box
        IF x1% < MARQUEE.WAND_MIN_X THEN MARQUEE.WAND_MIN_X = x1%
        IF x2% > MARQUEE.WAND_MAX_X THEN MARQUEE.WAND_MAX_X = x2%
        IF py% < MARQUEE.WAND_MIN_Y THEN MARQUEE.WAND_MIN_Y = py%
        IF py% > MARQUEE.WAND_MAX_Y THEN MARQUEE.WAND_MAX_Y = py%
        
        ' Check scanlines above and below for new spans to fill
        FOR dy% = -1 TO 1 STEP 2
            ny% = py% + dy%
            IF ny% >= 0 AND ny% < h% THEN
                in_span% = FALSE
                ' Scan the filled span for matching pixels
                FOR sx% = x1% TO x2%
                    _SOURCE targetImg&
                    DIM pxColor AS _UNSIGNED LONG
                    pxColor~& = POINT(sx%, ny%)
                    IF pxColor~& = target_color~& THEN
                        ' Check if not already selected
                        _SOURCE MARQUEE.SELECTION_MASK
                        IF POINT(sx%, ny%) <> mask_color~& THEN
                            IF NOT in_span% THEN
                                ' Found start of new span - add seed point
                                ' Grow stack if needed
                                IF stack_ptr& >= stack_capacity& THEN
                                    stack_capacity& = stack_capacity& * 2
                                    REDIM _PRESERVE stack_x(1 TO stack_capacity&) AS INTEGER
                                    REDIM _PRESERVE stack_y(1 TO stack_capacity&) AS INTEGER
                                END IF
                                stack_ptr& = stack_ptr& + 1
                                stack_x(stack_ptr&) = sx%
                                stack_y(stack_ptr&) = ny%
                                in_span% = TRUE
                            END IF
                        ELSE
                            in_span% = FALSE
                        END IF
                    ELSE
                        ' No longer in matching span
                        in_span% = FALSE
                    END IF
                NEXT sx%
            END IF
        NEXT dy%
        
        wand_next_seed:
    WEND
    
    ' Explicitly free stack memory
    ERASE stack_x, stack_y
    
    ' Merge with existing selection if in add/subtract mode
    IF has_existing% AND existing_mask& < -1 THEN
        DIM px AS INTEGER, py2 AS INTEGER
        DIM new_pixel AS _UNSIGNED LONG, old_pixel AS _UNSIGNED LONG
        DIM final_mask AS LONG
        
        ' Create final merged mask
        final_mask& = _NEWIMAGE(w%, h%, 32)
        IF final_mask& < -1 THEN
            _DEST final_mask&
            CLS , _RGBA32(0, 0, 0, 0)
            _DONTBLEND final_mask&
            
            ' Merge based on mode
            FOR py2% = 0 TO h% - 1
                FOR px% = 0 TO w% - 1
                    _SOURCE existing_mask&
                    old_pixel~& = POINT(px%, py2%)
                    _SOURCE MARQUEE.SELECTION_MASK
                    new_pixel~& = POINT(px%, py2%)
                    
                    _DEST final_mask&
                    IF mode% = SEL_MODE_ADD THEN
                        ' Add: OR operation - selected if either mask has it
                        IF _ALPHA32(old_pixel~&) > 0 OR _ALPHA32(new_pixel~&) > 0 THEN
                            PSET (px%, py2%), mask_color~&
                            ' Update bounding box
                            IF px% < MARQUEE.WAND_MIN_X THEN MARQUEE.WAND_MIN_X = px%
                            IF px% > MARQUEE.WAND_MAX_X THEN MARQUEE.WAND_MAX_X = px%
                            IF py2% < MARQUEE.WAND_MIN_Y THEN MARQUEE.WAND_MIN_Y = py2%
                            IF py2% > MARQUEE.WAND_MAX_Y THEN MARQUEE.WAND_MAX_Y = py2%
                        END IF
                    ELSEIF mode% = SEL_MODE_SUBTRACT THEN
                        ' Subtract: AND NOT - selected if old has it but new doesn't
                        IF _ALPHA32(old_pixel~&) > 0 AND _ALPHA32(new_pixel~&) = 0 THEN
                            PSET (px%, py2%), mask_color~&
                            ' Update bounding box
                            IF px% < MARQUEE.WAND_MIN_X THEN MARQUEE.WAND_MIN_X = px%
                            IF px% > MARQUEE.WAND_MAX_X THEN MARQUEE.WAND_MAX_X = px%
                            IF py2% < MARQUEE.WAND_MIN_Y THEN MARQUEE.WAND_MIN_Y = py2%
                            IF py2% > MARQUEE.WAND_MAX_Y THEN MARQUEE.WAND_MAX_Y = py2%
                        END IF
                    END IF
                NEXT px%
            NEXT py2%
            
            _BLEND final_mask&
            
            ' Replace the new mask with merged result
            _FREEIMAGE MARQUEE.SELECTION_MASK
            MARQUEE.SELECTION_MASK = final_mask&
        END IF
        
        ' Free the old existing mask
        _FREEIMAGE existing_mask&
        
        ' Check if selection is empty after subtract
        IF mode% = SEL_MODE_SUBTRACT AND MARQUEE.WAND_MIN_X > MARQUEE.WAND_MAX_X THEN
            MAGIC_WAND_reset
            _SOURCE old_source&
            _DEST old_dest&
            EXIT SUB
        END IF
    END IF
    
    ' Mark selection as valid
    MARQUEE.WAND_HAS_SELECTION = TRUE
    
    ' Also set regular marquee box to bounding box of selection
    ' This allows resize handles to work if desired in future
    MARQUEE.BOX.x = MARQUEE.WAND_MIN_X
    MARQUEE.BOX.y = MARQUEE.WAND_MIN_Y
    MARQUEE.BOX.w = MARQUEE.WAND_MAX_X - MARQUEE.WAND_MIN_X + 1
    MARQUEE.BOX.h = MARQUEE.WAND_MAX_Y - MARQUEE.WAND_MIN_Y + 1
    MARQUEE.ACTIVE% = TRUE
    MARQUEE.INITIALIZED% = TRUE
    MARQUEE.USER_CREATED = TRUE  ' User selected with magic wand
    
    _BLEND MARQUEE.SELECTION_MASK
    _SOURCE old_source&
    _DEST old_dest&
END SUB


''
' Draw marching ants outline around selected pixels in magic wand mask
'
SUB MAGIC_WAND_draw_outline ()
    IF NOT MARQUEE.WAND_HAS_SELECTION THEN EXIT SUB
    IF MARQUEE.SELECTION_MASK >= -1 THEN EXIT SUB
    
    DIM old_dest AS LONG
    DIM old_source AS LONG
    DIM x AS INTEGER, y AS INTEGER
    DIM w AS INTEGER, h AS INTEGER
    DIM mask_color AS _UNSIGNED LONG
    DIM lineColor AS _UNSIGNED LONG
    
    old_dest& = _DEST
    old_source& = _SOURCE
    
    _SOURCE MARQUEE.SELECTION_MASK
    _DEST SCRN.CANVAS&
    
    w% = _WIDTH(MARQUEE.SELECTION_MASK)
    h% = _HEIGHT(MARQUEE.SELECTION_MASK)
    
    mask_color~& = _RGB32(255, 255, 255)
    lineColor~& = _RGB32(255, 255, 255)  ' White outline
    
    ' Calculate zoom transformation values (canvas dimensions, centered in viewport)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.canvasW& * SCRN.zoom!
    zh& = SCRN.canvasH& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%
    
    ' Animate the marching ants with time-based offset
    DIM antOffset AS INTEGER
    DIM dotSize AS INTEGER, gapSize AS INTEGER
    
    ' Fixed dot and gap size in canvas pixels (consistent pattern at any zoom)
    dotSize% = 2
    gapSize% = 2
    
    ' Use TIMER for animation (shift pattern over time)
    antOffset% = INT(TIMER * 8) MOD (dotSize% + gapSize%)
    
    ' Only scan within bounding box for performance
    FOR y% = MARQUEE.WAND_MIN_Y TO MARQUEE.WAND_MAX_Y
        FOR x% = MARQUEE.WAND_MIN_X TO MARQUEE.WAND_MAX_X
            _SOURCE MARQUEE.SELECTION_MASK
            IF POINT(x%, y%) = mask_color~& THEN
                ' This pixel is selected - check if it's on an edge
                DIM isEdge AS INTEGER
                isEdge% = FALSE
                
                ' Check 4-connected neighbors
                IF x% = 0 OR POINT(x% - 1, y%) <> mask_color~& THEN isEdge% = TRUE  ' Left edge
                IF NOT isEdge% AND (x% = w% - 1 OR POINT(x% + 1, y%) <> mask_color~&) THEN isEdge% = TRUE  ' Right edge
                IF NOT isEdge% AND (y% = 0 OR POINT(x%, y% - 1) <> mask_color~&) THEN isEdge% = TRUE  ' Top edge
                IF NOT isEdge% AND (y% = h% - 1 OR POINT(x%, y% + 1) <> mask_color~&) THEN isEdge% = TRUE  ' Bottom edge
                
                IF isEdge% THEN
                    ' Draw edge pixel with marching ants effect
                    DIM screenX AS INTEGER, screenY AS INTEGER
                    screenX% = dx% + INT(x% * SCRN.zoom!)
                    screenY% = dy% + INT(y% * SCRN.zoom!)
                    
                    ' Marching ants pattern: alternate based on position + time offset
                    DIM pattern AS INTEGER
                    pattern% = ((x% + y% + antOffset%) MOD (dotSize% + gapSize%))
                    
                    _DEST SCRN.CANVAS&
                    IF pattern% < dotSize% THEN
                        ' Draw white pixel
                        IF SCRN.zoom! >= 1 THEN
                            LINE (screenX%, screenY%)-(screenX% + INT(SCRN.zoom!) - 1, screenY% + INT(SCRN.zoom!) - 1), _RGB32(255, 255, 255), BF
                        ELSE
                            PSET (screenX%, screenY%), _RGB32(255, 255, 255)
                        END IF
                    ELSE
                        ' Draw black pixel for contrast
                        IF SCRN.zoom! >= 1 THEN
                            LINE (screenX%, screenY%)-(screenX% + INT(SCRN.zoom!) - 1, screenY% + INT(SCRN.zoom!) - 1), _RGB32(0, 0, 0), BF
                        ELSE
                            PSET (screenX%, screenY%), _RGB32(0, 0, 0)
                        END IF
                    END IF
                END IF
            END IF
        NEXT x%
    NEXT y%
    
    _SOURCE old_source&
    _DEST old_dest&
END SUB


''
' Clear selected pixels by making them transparent
' Used when DEL or CTRL+E is pressed with magic wand selection active
'
SUB MAGIC_WAND_clear_selected_transparent ()
    IF NOT MARQUEE.WAND_HAS_SELECTION THEN EXIT SUB
    IF MARQUEE.SELECTION_MASK >= -1 THEN EXIT SUB
    
    DIM old_dest AS LONG
    DIM old_source AS LONG
    DIM x AS INTEGER, y AS INTEGER
    DIM mask_color AS _UNSIGNED LONG
    DIM targetImg AS LONG
    
    old_dest& = _DEST
    old_source& = _SOURCE
    
    targetImg& = LAYER_current_image&
    
    _SOURCE MARQUEE.SELECTION_MASK
    _DEST targetImg&
    _DONTBLEND targetImg&
    
    mask_color~& = _RGB32(255, 255, 255)
    
    ' Iterate through bounding box and clear selected pixels
    FOR y% = MARQUEE.WAND_MIN_Y TO MARQUEE.WAND_MAX_Y
        FOR x% = MARQUEE.WAND_MIN_X TO MARQUEE.WAND_MAX_X
            _SOURCE MARQUEE.SELECTION_MASK
            IF POINT(x%, y%) = mask_color~& THEN
                ' Set pixel to fully transparent
                _DEST targetImg&
                PSET (x%, y%), _RGBA32(0, 0, 0, 0)
            END IF
        NEXT x%
    NEXT y%
    
    _BLEND targetImg&
    _SOURCE old_source&
    _DEST old_dest&
    
    ' Save undo state AFTER modifying so the post-delete canvas is captured
    IF NOT UNDO_saved_this_frame% THEN
        UNDO_save_state
        UNDO_saved_this_frame% = TRUE
    END IF
    
    CANVAS_DIRTY% = TRUE
END SUB

''
' Check if there's any active selection (marquee or magic wand)
' Returns TRUE if drawing should be clipped to selection
'
FUNCTION SELECTION_has_active% ()
    ' Check for mask-based selection (magic wand or combined marquee)
    IF MARQUEE.WAND_HAS_SELECTION AND MARQUEE.SELECTION_MASK < -1 THEN
        SELECTION_has_active% = TRUE
        EXIT FUNCTION
    END IF
    
    ' Check for regular marquee selection (only if user-created)
    IF MARQUEE.ACTIVE AND MARQUEE.USER_CREATED AND MARQUEE.INITIALIZED THEN
        SELECTION_has_active% = TRUE
        EXIT FUNCTION
    END IF
    
    SELECTION_has_active% = FALSE
END FUNCTION


''
' Get the canvas-coordinate bounding box of the active selection overlay.
' Returns the rectangle that the marching ants / handles occupy on SCRN.CANVAS&.
' Used by the dirty-rect fast path in SCREEN_render to know which area needs
' restoring from the scene cache each frame.
'
SUB SELECTION_get_screen_bbox (sx1 AS INTEGER, sy1 AS INTEGER, sx2 AS INTEGER, sy2 AS INTEGER)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.canvasW& * SCRN.zoom!
    zh& = SCRN.canvasH& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%

    IF MARQUEE.WAND_HAS_SELECTION AND MARQUEE.SELECTION_MASK < -1 THEN
        ' Magic wand: use stored bounding box
        sx1% = dx% + INT(MARQUEE.WAND_MIN_X * SCRN.zoom!) - 1
        sy1% = dy% + INT(MARQUEE.WAND_MIN_Y * SCRN.zoom!) - 1
        sx2% = dx% + INT((MARQUEE.WAND_MAX_X + 1) * SCRN.zoom!)
        sy2% = dy% + INT((MARQUEE.WAND_MAX_Y + 1) * SCRN.zoom!)
    ELSEIF MARQUEE.ACTIVE% AND MARQUEE.USER_CREATED THEN
        ' Marquee box: transform box coords + handle padding
        DIM hh AS INTEGER
        hh% = INT(2 * SCRN.zoom!)
        IF hh% < 2 THEN hh% = 2
        sx1% = dx% + INT(MARQUEE.BOX.x * SCRN.zoom!) - hh% - 1
        sy1% = dy% + INT(MARQUEE.BOX.y * SCRN.zoom!) - hh% - 1
        sx2% = dx% + INT((MARQUEE.BOX.x + MARQUEE.BOX.w) * SCRN.zoom!) + hh% + 1
        sy2% = dy% + INT((MARQUEE.BOX.y + MARQUEE.BOX.h) * SCRN.zoom!) + hh% + 1
    ELSE
        ' No selection  return zero-area box
        sx1% = 0: sy1% = 0: sx2% = 0: sy2% = 0
    END IF
END SUB


''
' Check if a point is inside the active selection
' Used for clipping drawing operations to selection mask
' Returns TRUE if point is inside selection (or no selection is active)
' Returns FALSE if point is outside active selection
'
FUNCTION SELECTION_is_point_inside% (x AS INTEGER, y AS INTEGER)
    ' If no active selection, all points are valid
    IF NOT SELECTION_has_active% THEN
        SELECTION_is_point_inside% = TRUE
        EXIT FUNCTION
    END IF
    
    ' Check if we have a mask-based selection (magic wand OR combined marquee)
    ' A mask exists and is valid when WAND_HAS_SELECTION is true
    IF MARQUEE.WAND_HAS_SELECTION AND MARQUEE.SELECTION_MASK < -1 THEN
        ' Quick bounds check first
        IF x% < MARQUEE.WAND_MIN_X OR x% > MARQUEE.WAND_MAX_X THEN
            SELECTION_is_point_inside% = FALSE
            EXIT FUNCTION
        END IF
        IF y% < MARQUEE.WAND_MIN_Y OR y% > MARQUEE.WAND_MAX_Y THEN
            SELECTION_is_point_inside% = FALSE
            EXIT FUNCTION
        END IF
        
        ' Check the mask pixel
        DIM old_source AS LONG
        DIM mask_color AS _UNSIGNED LONG
        old_source& = _SOURCE
        _SOURCE MARQUEE.SELECTION_MASK
        mask_color~& = POINT(x%, y%)
        _SOURCE old_source&
        
        SELECTION_is_point_inside% = (mask_color~& = _RGB32(255, 255, 255))
        EXIT FUNCTION
    END IF
    
    ' Check regular marquee bounding box (simple rectangular selection)
    IF MARQUEE.ACTIVE AND MARQUEE.USER_CREATED AND MARQUEE.INITIALIZED THEN
        IF x% >= MARQUEE.BOX.x AND x% < MARQUEE.BOX.x + MARQUEE.BOX.w THEN
            IF y% >= MARQUEE.BOX.y AND y% < MARQUEE.BOX.y + MARQUEE.BOX.h THEN
                SELECTION_is_point_inside% = TRUE
                EXIT FUNCTION
            END IF
        END IF
        SELECTION_is_point_inside% = FALSE
        EXIT FUNCTION
    END IF
    
    ' No selection, allow all
    SELECTION_is_point_inside% = TRUE
END FUNCTION


''
' Select all - creates a full-canvas selection
'
SUB SELECTION_select_all ()
    DIM w AS INTEGER, h AS INTEGER
    w% = SCRN.canvasW&
    h% = SCRN.canvasH&
    
    ' Clear any existing wand selection
    IF MARQUEE.SELECTION_MASK < -1 THEN
        _FREEIMAGE MARQUEE.SELECTION_MASK
    END IF
    MARQUEE.SELECTION_MASK = 0
    MARQUEE.WAND_HAS_SELECTION = FALSE
    
    ' Set marquee box to full canvas
    MARQUEE.BOX.x = 0
    MARQUEE.BOX.y = 0
    MARQUEE.BOX.w = w%
    MARQUEE.BOX.h = h%
    MARQUEE.ACTIVE% = TRUE
    MARQUEE.INITIALIZED% = TRUE
    MARQUEE.USER_CREATED = TRUE
    
    ' Update config
    MARQUEE.CFG.initX = 0
    MARQUEE.CFG.initY = 0
    MARQUEE.CFG.initW = w%
    MARQUEE.CFG.initH = h%
    GJ_BBX_InitWithConfig MARQUEE.CFG
    MARQUEE.BOX = GJ_BBX_box
    
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Invert selection - selects everything that's not currently selected
'
SUB SELECTION_invert ()
    DIM w AS INTEGER, h AS INTEGER
    DIM px AS INTEGER, py AS INTEGER
    DIM old_dest AS LONG, old_source AS LONG
    DIM mask_color AS _UNSIGNED LONG
    DIM has_selection AS INTEGER
    
    w% = SCRN.canvasW&
    h% = SCRN.canvasH&
    mask_color~& = _RGB32(255, 255, 255)
    
    has_selection% = SELECTION_has_active%
    
    ' If no selection, invert means select all (everything was "not selected")
    IF NOT has_selection% THEN
        SELECTION_select_all
        EXIT SUB
    END IF
    
    old_dest& = _DEST
    old_source& = _SOURCE
    
    ' Check if we have a mask-based selection (magic wand or combined marquee)
    IF MARQUEE.WAND_HAS_SELECTION AND MARQUEE.SELECTION_MASK < -1 THEN
        ' Invert the existing mask
        _DEST MARQUEE.SELECTION_MASK
        _DONTBLEND MARQUEE.SELECTION_MASK
        
        ' XOR-like inversion: toggle each pixel
        FOR py% = 0 TO h% - 1
            FOR px% = 0 TO w% - 1
                _SOURCE MARQUEE.SELECTION_MASK
                IF _ALPHA32(POINT(px%, py%)) > 0 THEN
                    ' Was selected, make unselected (transparent)
                    PSET (px%, py%), _RGBA32(0, 0, 0, 0)
                ELSE
                    ' Was not selected, make selected (white)
                    PSET (px%, py%), mask_color~&
                END IF
            NEXT px%
        NEXT py%
        
        _BLEND MARQUEE.SELECTION_MASK
        
        ' Recalculate bounding box
        DIM minX AS INTEGER, minY AS INTEGER, maxX AS INTEGER, maxY AS INTEGER
        minX% = w%: minY% = h%: maxX% = 0: maxY% = 0
        _SOURCE MARQUEE.SELECTION_MASK
        FOR py% = 0 TO h% - 1
            FOR px% = 0 TO w% - 1
                IF _ALPHA32(POINT(px%, py%)) > 0 THEN
                    IF px% < minX% THEN minX% = px%
                    IF px% > maxX% THEN maxX% = px%
                    IF py% < minY% THEN minY% = py%
                    IF py% > maxY% THEN maxY% = py%
                END IF
            NEXT px%
        NEXT py%
        
        IF minX% > maxX% THEN
            ' Empty selection after invert (shouldn't happen normally)
            MARQUEE_clear
            MAGIC_WAND_reset
        ELSE
            MARQUEE.WAND_MIN_X = minX%
            MARQUEE.WAND_MIN_Y = minY%
            MARQUEE.WAND_MAX_X = maxX%
            MARQUEE.WAND_MAX_Y = maxY%
            MARQUEE.BOX.x = minX%
            MARQUEE.BOX.y = minY%
            MARQUEE.BOX.w = maxX% - minX% + 1
            MARQUEE.BOX.h = maxY% - minY% + 1
        END IF
    ELSEIF MARQUEE.ACTIVE% AND MARQUEE.USER_CREATED THEN
        ' Convert rectangular marquee to mask and invert
        DIM new_mask AS LONG
        new_mask& = _NEWIMAGE(w%, h%, 32)
        IF new_mask& < -1 THEN
            _DEST new_mask&
            CLS , _RGBA32(0, 0, 0, 0)
            _DONTBLEND new_mask&
            
            ' Fill everything EXCEPT the current box
            ' Top region (above the box)
            IF MARQUEE.BOX.y > 0 THEN
                LINE (0, 0)-(w% - 1, MARQUEE.BOX.y - 1), mask_color~&, BF
            END IF
            ' Bottom region (below the box)
            IF MARQUEE.BOX.y + MARQUEE.BOX.h < h% THEN
                LINE (0, MARQUEE.BOX.y + MARQUEE.BOX.h)-(w% - 1, h% - 1), mask_color~&, BF
            END IF
            ' Left region (left of the box, between top and bottom)
            IF MARQUEE.BOX.x > 0 THEN
                LINE (0, MARQUEE.BOX.y)-(MARQUEE.BOX.x - 1, MARQUEE.BOX.y + MARQUEE.BOX.h - 1), mask_color~&, BF
            END IF
            ' Right region (right of the box, between top and bottom)
            IF MARQUEE.BOX.x + MARQUEE.BOX.w < w% THEN
                LINE (MARQUEE.BOX.x + MARQUEE.BOX.w, MARQUEE.BOX.y)-(w% - 1, MARQUEE.BOX.y + MARQUEE.BOX.h - 1), mask_color~&, BF
            END IF
            
            _BLEND new_mask&
            
            ' Replace selection with inverted mask
            IF MARQUEE.SELECTION_MASK < -1 THEN _FREEIMAGE MARQUEE.SELECTION_MASK
            MARQUEE.SELECTION_MASK = new_mask&
            MARQUEE.WAND_HAS_SELECTION = TRUE
            
            ' Update bounding box to full canvas (inverted selection spans entire canvas minus original box)
            MARQUEE.WAND_MIN_X = 0
            MARQUEE.WAND_MIN_Y = 0
            MARQUEE.WAND_MAX_X = w% - 1
            MARQUEE.WAND_MAX_Y = h% - 1
            MARQUEE.BOX.x = 0
            MARQUEE.BOX.y = 0
            MARQUEE.BOX.w = w%
            MARQUEE.BOX.h = h%
            MARQUEE.ACTIVE% = TRUE
            MARQUEE.INITIALIZED% = TRUE
            MARQUEE.USER_CREATED = TRUE
        END IF
    END IF
    
    _SOURCE old_source&
    _DEST old_dest&
    GUI_NEEDS_REDRAW% = TRUE
END SUB