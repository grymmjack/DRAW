''
' DRAW - TOOLS/UNDO.BM
' =============================================================================
' Undo/Redo system implementation
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initialize undo system
'
SUB UNDO_init ()
    UNDO.current% = 0
    UNDO.count% = 0
    UNDO.max_states% = 100
    
    ' Free any existing undo states
    DIM i AS INTEGER
    FOR i% = 0 TO UNDO.max_states%
        IF UNDO_STATES(i%).img& < -1 THEN
            _FREEIMAGE UNDO_STATES(i%).img&
            UNDO_STATES(i%).img& = 0
        END IF
        UNDO_STATES(i%).layer_index% = 0
    NEXT i%
    
    ' Save initial blank canvas as state 0 (use current layer image)
    UNDO_STATES(0).img& = _COPYIMAGE(LAYER_current_image&, 32)
    UNDO_STATES(0).layer_index% = CURRENT_LAYER%
    UNDO.count% = 1
    UNDO.current% = 0
END SUB


''
' Save current canvas state to undo history
' @param none
' @return none
' Call this BEFORE making changes to the canvas
'
SUB UNDO_save_state ()
    DIM i AS INTEGER
    
    _LOGINFO "UNDO_save_state called: saving layer " + STR$(CURRENT_LAYER%) + " count was " + STR$(UNDO.count%)
    
    ' If we're not at the end of the undo stack, clear everything after current position
    ' (because we're creating a new branch)
    IF UNDO.current% < UNDO.count% - 1 THEN
        FOR i% = UNDO.current% + 1 TO UNDO.count% - 1
            IF UNDO_STATES(i%).img& < -1 THEN
                _FREEIMAGE UNDO_STATES(i%).img&
                UNDO_STATES(i%).img& = 0
            END IF
            UNDO_STATES(i%).layer_index% = 0
        NEXT i%
        UNDO.count% = UNDO.current% + 1
    END IF
    
    ' If we're at max capacity, remove oldest state
    IF UNDO.count% >= UNDO.max_states% THEN
        IF UNDO_STATES(0).img& < -1 THEN
            _FREEIMAGE UNDO_STATES(0).img&
        END IF
        
        ' Shift all states down
        FOR i% = 0 TO UNDO.count% - 2
            UNDO_STATES(i%).img& = UNDO_STATES(i% + 1).img&
            UNDO_STATES(i%).layer_index% = UNDO_STATES(i% + 1).layer_index%
        NEXT i%
        UNDO_STATES(UNDO.count% - 1).img& = 0
        UNDO_STATES(UNDO.count% - 1).layer_index% = 0
        UNDO.count% = UNDO.count% - 1
        UNDO.current% = UNDO.current% - 1
    END IF
    
    ' Save current layer image as new undo state, tracking which layer
    UNDO_STATES(UNDO.count%).img& = _COPYIMAGE(LAYER_current_image&, 32)
    UNDO_STATES(UNDO.count%).layer_index% = CURRENT_LAYER%
    UNDO_STATES(UNDO.count%).timestamp# = TIMER
    UNDO.count% = UNDO.count% + 1
    UNDO.current% = UNDO.count% - 1
    
    ' Update the global pixel undo timestamp for intelligent undo comparison
    PIXEL_UNDO_LAST_TIMESTAMP# = UNDO_STATES(UNDO.current%).timestamp#
    
    ' Mark canvas as dirty (has unsaved changes)
    CANVAS_DIRTY% = TRUE
END SUB


''
' Check if a layer image is empty (all transparent)
'
FUNCTION LAYER_is_empty% (layerImg AS LONG)
    DIM x AS INTEGER, y AS INTEGER
    DIM w AS INTEGER, h AS INTEGER
    DIM c AS _UNSIGNED LONG
    DIM oldSrc AS LONG
    
    IF layerImg& >= -1 THEN
        LAYER_is_empty% = TRUE
        EXIT FUNCTION
    END IF
    
    w% = _WIDTH(layerImg&)
    h% = _HEIGHT(layerImg&)
    
    oldSrc& = _SOURCE
    _SOURCE layerImg&
    
    ' Sample a few points instead of checking every pixel (for performance)
    FOR y% = 0 TO h% - 1 STEP 8
        FOR x% = 0 TO w% - 1 STEP 8
            c~& = POINT(x%, y%)
            IF _ALPHA32(c~&) > 0 THEN
                _SOURCE oldSrc&
                LAYER_is_empty% = FALSE
                EXIT FUNCTION
            END IF
        NEXT x%
    NEXT y%
    
    _SOURCE oldSrc&
    LAYER_is_empty% = TRUE
END FUNCTION


''
' Undo - restore previous state
' Works by finding the previous state for the layer that was modified in the current state
'
SUB UNDO_undo ()
    DIM targetImg AS LONG
    DIM oldDest AS LONG
    DIM currentLayer AS INTEGER
    DIM restoreIdx AS INTEGER
    DIM i AS INTEGER
    DIM skipState AS INTEGER
    
    _LOGINFO "UNDO_undo called: current=" + STR$(UNDO.current%) + " count=" + STR$(UNDO.count%)
    IF UNDO.current% > 0 THEN
        ' Get the layer that the current state modified
        currentLayer% = UNDO_STATES(UNDO.current%).layer_index%
        
        ' Find the previous state for this SAME layer (or go to beginning)
        restoreIdx% = -1
        FOR i% = UNDO.current% - 1 TO 0 STEP -1
            IF UNDO_STATES(i%).layer_index% = currentLayer% THEN
                restoreIdx% = i%
                EXIT FOR
            END IF
        NEXT i%
        
        skipState% = FALSE
        
        ' If no previous state found for this layer, clear to transparent
        IF restoreIdx% < 0 THEN
            ' Check if layer is already empty - if so, skip this state
            IF currentLayer% >= 1 AND currentLayer% <= LAYER_COUNT% THEN
                IF LAYERS(currentLayer%).imgHandle& < -1 THEN
                    targetImg& = LAYERS(currentLayer%).imgHandle&
                    IF LAYER_is_empty%(targetImg&) THEN
                        ' Layer is already empty, skip this undo step
                        _LOGINFO "UNDO: Layer " + STR$(currentLayer%) + " already empty, skipping"
                        skipState% = TRUE
                    ELSE
                        ' Clear the layer to transparent (initial state)
                        oldDest& = _DEST
                        _DEST targetImg&
                        CLS , _RGBA32(0, 0, 0, 0)
                        _DEST oldDest&
                        _LOGINFO "UNDO: Cleared layer " + STR$(currentLayer%) + " to transparent (no previous state)"
                    END IF
                END IF
            END IF
        ELSE
            ' Restore from the found state
            IF UNDO_STATES(restoreIdx%).img& < -1 THEN
                ' Get the target layer's image handle
                IF currentLayer% >= 1 AND currentLayer% <= LAYER_COUNT% THEN
                    IF LAYERS(currentLayer%).imgHandle& < -1 THEN
                        targetImg& = LAYERS(currentLayer%).imgHandle&
                    ELSE
                        targetImg& = SCRN.PAINTING&
                    END IF
                ELSE
                    targetImg& = SCRN.PAINTING&
                END IF
                
                ' Copy the undo state into the target layer image
                oldDest& = _DEST
                _DEST targetImg&
                CLS , _RGBA32(0, 0, 0, 0) ' Clear with transparent
                _PUTIMAGE (0, 0), UNDO_STATES(restoreIdx%).img&, targetImg&
                _DEST oldDest&
                
                _LOGINFO "UNDO: Restored state " + STR$(restoreIdx%) + " to layer " + STR$(currentLayer%) + " image " + STR$(targetImg&)
            ELSE
                _LOGWARN "UNDO: State " + STR$(restoreIdx%) + " has invalid image handle"
            END IF
        END IF
        
        ' Move back one state in the history
        UNDO.current% = UNDO.current% - 1
        
        ' If we skipped this state, automatically continue to the next undo
        IF skipState% AND UNDO.current% > 0 THEN
            UNDO_undo
        END IF
    ELSE
        _LOGINFO "UNDO: Nothing to undo (current=0)"
    END IF
END SUB


''
' Redo - restore next state
'
SUB UNDO_redo ()
    DIM targetImg AS LONG
    DIM oldDest AS LONG
    DIM targetLayer AS INTEGER
    
    _LOGINFO "UNDO_redo called: current=" + STR$(UNDO.current%) + " count=" + STR$(UNDO.count%)
    IF UNDO.current% < UNDO.count% - 1 THEN
        ' Move forward one state
        UNDO.current% = UNDO.current% + 1
        
        ' Restore the state
        IF UNDO_STATES(UNDO.current%).img& < -1 THEN
            ' Get the layer index this state belongs to
            targetLayer% = UNDO_STATES(UNDO.current%).layer_index%
            
            ' Get the target layer's image handle
            IF targetLayer% >= 1 AND targetLayer% <= LAYER_COUNT% THEN
                IF LAYERS(targetLayer%).imgHandle& < -1 THEN
                    targetImg& = LAYERS(targetLayer%).imgHandle&
                ELSE
                    targetImg& = SCRN.PAINTING&
                END IF
            ELSE
                targetImg& = SCRN.PAINTING&
            END IF
            
            ' Copy the undo state into the target layer image
            oldDest& = _DEST
            _DEST targetImg&
            CLS , _RGBA32(0, 0, 0, 0) ' Clear with transparent
            _PUTIMAGE (0, 0), UNDO_STATES(UNDO.current%).img&, targetImg&
            _DEST oldDest&
            
            _LOGINFO "REDO: Restored state " + STR$(UNDO.current%) + " to layer " + STR$(targetLayer%) + " image " + STR$(targetImg&)
        ELSE
            _LOGWARN "REDO: State " + STR$(UNDO.current%) + " has invalid image handle: " + STR$(UNDO_STATES(UNDO.current%).img&)
        END IF
    ELSE
        _LOGINFO "REDO: Nothing to redo (current=" + STR$(UNDO.current%) + " count=" + STR$(UNDO.count%) + ")"
    END IF
END SUB


''
' Clear undo history (useful for new document)
'
SUB UNDO_clear ()
    DIM i AS INTEGER
    FOR i% = 0 TO UNDO.max_states%
        IF UNDO_STATES(i%).img& < -1 THEN
            _FREEIMAGE UNDO_STATES(i%).img&
            UNDO_STATES(i%).img& = 0
        END IF
    NEXT i%
    UNDO.current% = 0
    UNDO.count% = 0
END SUB

''
' Get the timestamp of the current pixel undo state
' Used for intelligent undo comparison with workspace undo
' @return DOUBLE - TIMER value when current state was saved, or 0 if none
'
FUNCTION UNDO_get_last_timestamp# ()
    IF UNDO.current% >= 0 AND UNDO.current% < UNDO.count% THEN
        UNDO_get_last_timestamp# = UNDO_STATES(UNDO.current%).timestamp#
    ELSE
        UNDO_get_last_timestamp# = 0
    END IF
END FUNCTION
