''
' DRAW - TOOLS/UNDO.BM
' =============================================================================
' Undo/Redo system implementation
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initialize undo system
'
SUB UNDO_init ()
    UNDO.current% = 0
    UNDO.count% = 0
    UNDO.max_states% = 100
    UNDO_SEQ = 0  ' Reset monotonic sequence counter on file load / new file
    
    ' Free any existing undo states
    DIM i AS INTEGER
    FOR i% = 0 TO UNDO_STATES_MAX%
        IF UNDO_STATES(i%).img& < -1 THEN
            _FREEIMAGE UNDO_STATES(i%).img&
            UNDO_STATES(i%).img& = 0
        END IF
        UNDO_STATES(i%).layer_index% = 0
        UNDO_STATES(i%).timestamp# = 0
    NEXT i%
    
    ' Cap max_states to safe limit (leave room for post-increment overshoot)
    IF UNDO.max_states% > UNDO_STATES_MAX% - 1 THEN
        UNDO.max_states% = UNDO_STATES_MAX% - 1
    END IF
    IF UNDO.max_states% < 1 THEN UNDO.max_states% = 100
    
    ' Save initial state for ALL active layers (not just current layer).
    ' This ensures every layer has a pixel undo baseline for operations like move
    ' that need a prior state to restore when undone.
    FOR i% = 1 TO 64
        IF UNDO.count% >= UNDO.max_states% THEN EXIT FOR ' Don't exceed capacity
        IF LAYERS(i%).imgHandle& < -1 THEN
            UNDO_STATES(UNDO.count%).img& = _COPYIMAGE(LAYERS(i%).imgHandle&, 32)
            UNDO_STATES(UNDO.count%).layer_index% = i%
            UNDO_SEQ = UNDO_SEQ + 1
            UNDO_STATES(UNDO.count%).timestamp# = UNDO_SEQ
            UNDO.count% = UNDO.count% + 1
        END IF
    NEXT i%
    IF UNDO.count% > 0 THEN
        UNDO.current% = UNDO.count% - 1
    ELSE
        UNDO.current% = 0
    END IF
END SUB


''
' Save current canvas state to undo history
' @param none
' @return none
' Call this BEFORE making changes to the canvas
'
SUB UNDO_save_state ()
    DIM i AS INTEGER
    DIM ubnd AS INTEGER
    DIM srcImg AS LONG
    ubnd% = UNDO_STATES_MAX%
    
    _LOGINFO "UNDO_save_state called: saving layer " + STR$(CURRENT_LAYER%) + " count was " + STR$(UNDO.count%) + " current=" + STR$(UNDO.current%)
    
    ' Sanitize state — clamp count and current to valid range
    IF UNDO.count% < 0 THEN
        _LOGWARN "UNDO_save_state: count was negative (" + STR$(UNDO.count%) + "), clamping to 0"
        UNDO.count% = 0
    END IF
    IF UNDO.count% > ubnd% THEN
        _LOGWARN "UNDO_save_state: count exceeded array bounds (" + STR$(UNDO.count%) + "), clamping to " + STR$(ubnd%)
        UNDO.count% = ubnd%
    END IF
    IF UNDO.current% < 0 THEN UNDO.current% = 0
    IF UNDO.current% > ubnd% THEN UNDO.current% = ubnd%
    
    ' Ensure max_states is valid
    IF UNDO.max_states% < 1 THEN UNDO.max_states% = 100
    IF UNDO.max_states% > ubnd% THEN UNDO.max_states% = ubnd%
    
    ' If we're not at the end of the undo stack, clear everything after current position
    ' (because we're creating a new branch)
    IF UNDO.current% < UNDO.count% - 1 THEN
        FOR i% = UNDO.current% + 1 TO UNDO.count% - 1
            IF i% < 0 OR i% > ubnd% THEN EXIT FOR ' Bounds safety
            IF UNDO_STATES(i%).img& < -1 THEN
                _FREEIMAGE UNDO_STATES(i%).img&
                UNDO_STATES(i%).img& = 0
            END IF
            UNDO_STATES(i%).layer_index% = 0
        NEXT i%
        UNDO.count% = UNDO.current% + 1
    END IF
    
    ' If we're at max capacity, remove oldest state
    IF UNDO.count% >= UNDO.max_states% THEN
        IF UNDO_STATES(0).img& < -1 THEN
            _FREEIMAGE UNDO_STATES(0).img&
        END IF
        
        ' Shift all states down (must copy ALL fields including timestamp)
        DIM shiftEnd AS INTEGER
        shiftEnd% = UNDO.count% - 2
        IF shiftEnd% > ubnd% - 1 THEN shiftEnd% = ubnd% - 1 ' Ensure i+1 stays in bounds
        FOR i% = 0 TO shiftEnd%
            UNDO_STATES(i%).img& = UNDO_STATES(i% + 1).img&
            UNDO_STATES(i%).layer_index% = UNDO_STATES(i% + 1).layer_index%
            UNDO_STATES(i%).timestamp# = UNDO_STATES(i% + 1).timestamp#
        NEXT i%
        IF UNDO.count% - 1 >= 0 AND UNDO.count% - 1 <= ubnd% THEN
            UNDO_STATES(UNDO.count% - 1).img& = 0
            UNDO_STATES(UNDO.count% - 1).layer_index% = 0
            UNDO_STATES(UNDO.count% - 1).timestamp# = 0
        END IF
        UNDO.count% = UNDO.count% - 1
        UNDO.current% = UNDO.current% - 1
        IF UNDO.count% < 0 THEN UNDO.count% = 0
        IF UNDO.current% < 0 THEN UNDO.current% = 0
    END IF
    
    ' Final bounds check before saving new state
    IF UNDO.count% < 0 OR UNDO.count% > ubnd% THEN
        _LOGERROR "UNDO_save_state: count out of range after capacity check (" + STR$(UNDO.count%) + "), aborting save"
        EXIT SUB
    END IF
    
    ' Save current layer image as new undo state, tracking which layer
    srcImg& = LAYER_current_image&
    IF srcImg& >= -1 THEN
        _LOGWARN "UNDO_save_state: invalid source image handle from LAYER_current_image: " + STR$(srcImg&) + " (expected < -1)"
        EXIT SUB
    END IF
    UNDO_STATES(UNDO.count%).img& = _COPYIMAGE(srcImg&, 32)
    UNDO_STATES(UNDO.count%).layer_index% = CURRENT_LAYER%
    UNDO_SEQ = UNDO_SEQ + 1
    UNDO_STATES(UNDO.count%).timestamp# = UNDO_SEQ
    UNDO.count% = UNDO.count% + 1
    ' Clamp count immediately — never leave it beyond array bounds
    IF UNDO.count% > UNDO_STATES_MAX% THEN UNDO.count% = UNDO_STATES_MAX%
    UNDO.current% = UNDO.count% - 1
    IF UNDO.current% < 0 THEN UNDO.current% = 0
    
    ' Update the global pixel undo timestamp for intelligent undo comparison
    IF UNDO.current% >= 0 AND UNDO.current% <= UNDO_STATES_MAX% THEN
        PIXEL_UNDO_LAST_TIMESTAMP# = UNDO_STATES(UNDO.current%).timestamp#
    END IF
    
    ' Mark canvas as dirty (has unsaved changes)
    CANVAS_DIRTY% = TRUE
END SUB


''
' Save a SPECIFIC layer's state to undo history.
' Use this instead of UNDO_save_state when the target layer differs from CURRENT_LAYER%
' (e.g., MOVE_apply_transform operates on CAPTURED_LAYER which may != CURRENT_LAYER%).
'
SUB UNDO_save_layer_state (layerIndex AS INTEGER)
    DIM i AS INTEGER
    DIM ubnd AS INTEGER
    ubnd% = UNDO_STATES_MAX%

    ' Validate layer index
    IF layerIndex < 1 OR layerIndex > 64 THEN EXIT SUB
    IF LAYERS(layerIndex).imgHandle& >= -1 THEN
        _LOGWARN "UNDO_save_layer_state: invalid image handle for layer " + STR$(layerIndex) + ": " + STR$(LAYERS(layerIndex).imgHandle&) + " (expected < -1)"
        EXIT SUB
    END IF

    _LOGINFO "UNDO_save_layer_state called: saving layer " + STR$(layerIndex) + " count was " + STR$(UNDO.count%) + " current=" + STR$(UNDO.current%)

    ' Sanitize state — clamp count and current to valid range
    IF UNDO.count% < 0 THEN
        _LOGWARN "UNDO_save_layer_state: count was negative (" + STR$(UNDO.count%) + "), clamping to 0"
        UNDO.count% = 0
    END IF
    IF UNDO.count% > ubnd% THEN
        _LOGWARN "UNDO_save_layer_state: count exceeded array bounds (" + STR$(UNDO.count%) + "), clamping to " + STR$(ubnd%)
        UNDO.count% = ubnd%
    END IF
    IF UNDO.current% < 0 THEN UNDO.current% = 0
    IF UNDO.current% > ubnd% THEN UNDO.current% = ubnd%

    ' Ensure max_states is valid
    IF UNDO.max_states% < 1 THEN UNDO.max_states% = 100
    IF UNDO.max_states% > ubnd% THEN UNDO.max_states% = ubnd%

    ' If we're not at the end of the undo stack, clear everything after current position
    IF UNDO.current% < UNDO.count% - 1 THEN
        FOR i% = UNDO.current% + 1 TO UNDO.count% - 1
            IF i% < 0 OR i% > ubnd% THEN EXIT FOR ' Bounds safety
            IF UNDO_STATES(i%).img& < -1 THEN
                _FREEIMAGE UNDO_STATES(i%).img&
                UNDO_STATES(i%).img& = 0
            END IF
            UNDO_STATES(i%).layer_index% = 0
        NEXT i%
        UNDO.count% = UNDO.current% + 1
    END IF

    ' If we're at max capacity, remove oldest state
    IF UNDO.count% >= UNDO.max_states% THEN
        IF UNDO_STATES(0).img& < -1 THEN
            _FREEIMAGE UNDO_STATES(0).img&
        END IF
        DIM shiftEnd AS INTEGER
        shiftEnd% = UNDO.count% - 2
        IF shiftEnd% > ubnd% - 1 THEN shiftEnd% = ubnd% - 1 ' Ensure i+1 stays in bounds
        FOR i% = 0 TO shiftEnd%
            UNDO_STATES(i%).img& = UNDO_STATES(i% + 1).img&
            UNDO_STATES(i%).layer_index% = UNDO_STATES(i% + 1).layer_index%
            UNDO_STATES(i%).timestamp# = UNDO_STATES(i% + 1).timestamp#
        NEXT i%
        IF UNDO.count% - 1 >= 0 AND UNDO.count% - 1 <= ubnd% THEN
            UNDO_STATES(UNDO.count% - 1).img& = 0
            UNDO_STATES(UNDO.count% - 1).layer_index% = 0
            UNDO_STATES(UNDO.count% - 1).timestamp# = 0
        END IF
        UNDO.count% = UNDO.count% - 1
        UNDO.current% = UNDO.current% - 1
        IF UNDO.count% < 0 THEN UNDO.count% = 0
        IF UNDO.current% < 0 THEN UNDO.current% = 0
    END IF

    ' Final bounds check before saving new state
    IF UNDO.count% < 0 OR UNDO.count% > ubnd% THEN
        _LOGERROR "UNDO_save_layer_state: count out of range after capacity check (" + STR$(UNDO.count%) + "), aborting save"
        EXIT SUB
    END IF

    ' Save the specified layer's image
    UNDO_STATES(UNDO.count%).img& = _COPYIMAGE(LAYERS(layerIndex).imgHandle&, 32)
    UNDO_STATES(UNDO.count%).layer_index% = layerIndex
    UNDO_SEQ = UNDO_SEQ + 1
    UNDO_STATES(UNDO.count%).timestamp# = UNDO_SEQ
    UNDO.count% = UNDO.count% + 1
    ' Clamp count immediately — never leave it beyond array bounds
    IF UNDO.count% > UNDO_STATES_MAX% THEN UNDO.count% = UNDO_STATES_MAX%
    UNDO.current% = UNDO.count% - 1
    IF UNDO.current% < 0 THEN UNDO.current% = 0

    IF UNDO.current% >= 0 AND UNDO.current% <= UNDO_STATES_MAX% THEN
        PIXEL_UNDO_LAST_TIMESTAMP# = UNDO_STATES(UNDO.current%).timestamp#
    END IF
    CANVAS_DIRTY% = TRUE
END SUB


''
' Check if a layer image is empty (all transparent)
'
FUNCTION LAYER_is_empty% (layerImg AS LONG)
    DIM x AS INTEGER, y AS INTEGER
    DIM w AS INTEGER, h AS INTEGER
    DIM c AS _UNSIGNED LONG
    DIM oldSrc AS LONG
    
    IF layerImg& >= -1 THEN
        LAYER_is_empty% = TRUE
        EXIT FUNCTION
    END IF
    
    w% = _WIDTH(layerImg&)
    h% = _HEIGHT(layerImg&)
    
    oldSrc& = _SOURCE
    _SOURCE layerImg&
    
    ' Sample a few points instead of checking every pixel (for performance)
    FOR y% = 0 TO h% - 1 STEP 8
        FOR x% = 0 TO w% - 1 STEP 8
            c~& = POINT(x%, y%)
            IF _ALPHA32(c~&) > 0 THEN
                _SOURCE oldSrc&
                LAYER_is_empty% = FALSE
                EXIT FUNCTION
            END IF
        NEXT x%
    NEXT y%
    
    _SOURCE oldSrc&
    LAYER_is_empty% = TRUE
END FUNCTION


''
' Undo - restore previous state
' Works by finding the previous state for the layer that was modified in the current state
'
SUB UNDO_undo ()
    DIM targetImg AS LONG
    DIM oldDest AS LONG
    DIM currentLayer AS INTEGER
    DIM restoreIdx AS INTEGER
    DIM i AS INTEGER
    DIM ubnd AS INTEGER
    ubnd% = UNDO_STATES_MAX%
    
    ' Sanitize state before any array access
    IF UNDO.current% < 0 THEN UNDO.current% = 0
    IF UNDO.current% > ubnd% THEN UNDO.current% = ubnd%
    IF UNDO.count% < 0 THEN UNDO.count% = 0
    IF UNDO.count% > ubnd% THEN UNDO.count% = ubnd%
    
    _LOGINFO "UNDO_undo called: current=" + STR$(UNDO.current%) + " count=" + STR$(UNDO.count%)
    IF UNDO.current% > 0 THEN
        ' Get the layer that the current state modified
        currentLayer% = UNDO_STATES(UNDO.current%).layer_index%
        
        ' Find the previous state for this SAME layer (or go to beginning)
        restoreIdx% = -1
        FOR i% = UNDO.current% - 1 TO 0 STEP -1
            IF UNDO_STATES(i%).layer_index% = currentLayer% THEN
                restoreIdx% = i%
                EXIT FOR
            END IF
        NEXT i%
        
        ' If no previous state found for this layer, clear to transparent
        IF restoreIdx% < 0 THEN
            IF currentLayer% >= 1 AND currentLayer% <= LAYER_COUNT% THEN
                IF LAYERS(currentLayer%).imgHandle& < -1 THEN
                    targetImg& = LAYERS(currentLayer%).imgHandle&
                    IF LAYER_is_empty%(targetImg&) THEN
                        ' Layer is already empty — nothing to undo visually
                        _LOGINFO "UNDO: Layer " + STR$(currentLayer%) + " already empty, nothing to clear"
                    ELSE
                        ' Clear the layer to transparent (initial state)
                        oldDest& = _DEST
                        _DEST targetImg&
                        CLS , _RGBA32(0, 0, 0, 0)
                        _DEST oldDest&
                        _LOGINFO "UNDO: Cleared layer " + STR$(currentLayer%) + " to transparent (no previous state)"
                    END IF
                END IF
            END IF
        ELSE
            ' Restore from the found state
            IF UNDO_STATES(restoreIdx%).img& < -1 THEN
                ' Get the target layer's image handle
                IF currentLayer% >= 1 AND currentLayer% <= LAYER_COUNT% THEN
                    IF LAYERS(currentLayer%).imgHandle& < -1 THEN
                        targetImg& = LAYERS(currentLayer%).imgHandle&
                    ELSE
                        targetImg& = SCRN.PAINTING&
                    END IF
                ELSE
                    targetImg& = SCRN.PAINTING&
                END IF
                
                ' Copy the undo state into the target layer image
                oldDest& = _DEST
                _DEST targetImg&
                CLS , _RGBA32(0, 0, 0, 0) ' Clear with transparent
                _PUTIMAGE (0, 0), UNDO_STATES(restoreIdx%).img&, targetImg&
                _DEST oldDest&
                
                _LOGINFO "UNDO: Restored state " + STR$(restoreIdx%) + " to layer " + STR$(currentLayer%) + " image " + STR$(targetImg&)
            ELSE
                _LOGWARN "UNDO: State " + STR$(restoreIdx%) + " has invalid image handle"
            END IF
        END IF
        
        ' Move back one state in the history
        UNDO.current% = UNDO.current% - 1
        
        ' Mark layer as having changed content (for opacity cache invalidation)
        IF currentLayer% >= 1 AND currentLayer% <= LAYER_COUNT% THEN
            LAYERS(currentLayer%).contentDirty% = TRUE
        END IF
        BLEND_invalidate_cache
    ELSE
        _LOGINFO "UNDO: Nothing to undo (current=0)"
    END IF
END SUB


''
' Redo - restore next state
'
SUB UNDO_redo ()
    DIM targetImg AS LONG
    DIM oldDest AS LONG
    DIM targetLayer AS INTEGER
    DIM ubnd AS INTEGER
    ubnd% = UNDO_STATES_MAX%
    
    ' Sanitize state before any array access
    IF UNDO.current% < 0 THEN UNDO.current% = 0
    IF UNDO.current% > ubnd% THEN UNDO.current% = ubnd%
    IF UNDO.count% < 0 THEN UNDO.count% = 0
    IF UNDO.count% > ubnd% THEN UNDO.count% = ubnd%
    
    _LOGINFO "UNDO_redo called: current=" + STR$(UNDO.current%) + " count=" + STR$(UNDO.count%)
    IF UNDO.current% < UNDO.count% - 1 THEN
        ' Move forward one state
        UNDO.current% = UNDO.current% + 1
        
        ' Bounds check after increment
        IF UNDO.current% > ubnd% THEN
            UNDO.current% = ubnd%
            EXIT SUB
        END IF
        
        ' Restore the state
        IF UNDO_STATES(UNDO.current%).img& < -1 THEN
            ' Get the layer index this state belongs to
            targetLayer% = UNDO_STATES(UNDO.current%).layer_index%
            
            ' Get the target layer's image handle
            IF targetLayer% >= 1 AND targetLayer% <= LAYER_COUNT% THEN
                IF LAYERS(targetLayer%).imgHandle& < -1 THEN
                    targetImg& = LAYERS(targetLayer%).imgHandle&
                ELSE
                    targetImg& = SCRN.PAINTING&
                END IF
            ELSE
                targetImg& = SCRN.PAINTING&
            END IF
            
            ' Copy the undo state into the target layer image
            oldDest& = _DEST
            _DEST targetImg&
            CLS , _RGBA32(0, 0, 0, 0) ' Clear with transparent
            _PUTIMAGE (0, 0), UNDO_STATES(UNDO.current%).img&, targetImg&
            _DEST oldDest&
            
            _LOGINFO "REDO: Restored state " + STR$(UNDO.current%) + " to layer " + STR$(targetLayer%) + " image " + STR$(targetImg&)
        ELSE
            _LOGWARN "REDO: State " + STR$(UNDO.current%) + " has invalid image handle: " + STR$(UNDO_STATES(UNDO.current%).img&)
        END IF
        
        ' Mark layer as having changed content (for opacity cache invalidation)
        IF targetLayer% >= 1 AND targetLayer% <= LAYER_COUNT% THEN
            LAYERS(targetLayer%).contentDirty% = TRUE
        END IF
        BLEND_invalidate_cache
    ELSE
        _LOGINFO "REDO: Nothing to redo (current=" + STR$(UNDO.current%) + " count=" + STR$(UNDO.count%) + ")"
    END IF
END SUB


''
' Clear undo history (useful for new document)
'
SUB UNDO_clear ()
    DIM i AS INTEGER
    FOR i% = 0 TO UNDO_STATES_MAX%
        IF UNDO_STATES(i%).img& < -1 THEN
            _FREEIMAGE UNDO_STATES(i%).img&
            UNDO_STATES(i%).img& = 0
        END IF
    NEXT i%
    UNDO.current% = 0
    UNDO.count% = 0
END SUB

''
' Get the timestamp of the current pixel undo state
' Used for intelligent undo comparison with workspace undo
' @return DOUBLE - TIMER value when current state was saved, or 0 if none
'
FUNCTION UNDO_get_last_timestamp# ()
    IF UNDO.current% >= 0 AND UNDO.current% < UNDO.count% AND UNDO.current% <= UNDO_STATES_MAX% THEN
        UNDO_get_last_timestamp# = UNDO_STATES(UNDO.current%).timestamp#
    ELSE
        UNDO_get_last_timestamp# = 0
    END IF
END FUNCTION


''
' Discard the most recent undo state (pop from stack).
' Used when cancelling a move — the pre-capture state saved by MOVE_capture_selection
' is redundant since the layer was restored to its original state by the cancel.
' Without popping, the dead state wastes a CTRL+Z press (no visible change).
'
SUB UNDO_pop_last ()
    IF UNDO.count% <= 0 THEN EXIT SUB
    IF UNDO.current% <= 0 THEN EXIT SUB
    ' Only pop if we're at the top of the stack (not in middle of a redo branch)
    IF UNDO.current% <> UNDO.count% - 1 THEN EXIT SUB

    DIM popIdx AS INTEGER
    popIdx% = UNDO.count% - 1

    ' Bounds check before array access
    IF popIdx% < 0 OR popIdx% > UNDO_STATES_MAX% THEN EXIT SUB

    ' Free the image handle
    IF UNDO_STATES(popIdx%).img& < -1 THEN
        _FREEIMAGE UNDO_STATES(popIdx%).img&
        UNDO_STATES(popIdx%).img& = 0
    END IF
    UNDO_STATES(popIdx%).layer_index% = 0

    ' Shrink the stack
    UNDO.count% = UNDO.count% - 1
    UNDO.current% = UNDO.current% - 1
    IF UNDO.count% < 0 THEN UNDO.count% = 0
    IF UNDO.current% < 0 THEN UNDO.current% = 0

    ' Update the global pixel undo timestamp
    IF UNDO.current% >= 0 AND UNDO.current% < UNDO.count% AND UNDO.current% <= UNDO_STATES_MAX% THEN
        PIXEL_UNDO_LAST_TIMESTAMP# = UNDO_STATES(UNDO.current%).timestamp#
    ELSE
        PIXEL_UNDO_LAST_TIMESTAMP# = 0
    END IF
    _LOGINFO "UNDO_pop_last: discarded state, current=" + STR$(UNDO.current%) + " count=" + STR$(UNDO.count%)
END SUB
