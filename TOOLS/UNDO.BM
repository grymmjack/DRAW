''
' DRAW - TOOLS/UNDO.BM
' =============================================================================
' Undo/Redo system implementation
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initialize undo system
'
SUB UNDO_init ()
    UNDO.current% = 0
    UNDO.count% = 0
    UNDO.max_states% = 100
    
    ' Free any existing undo states
    DIM i AS INTEGER
    FOR i% = 0 TO UNDO.max_states%
        IF UNDO_STATES(i%).img& <> 0 THEN
            _FREEIMAGE UNDO_STATES(i%).img&
            UNDO_STATES(i%).img& = 0
        END IF
    NEXT i%
    
    ' Save initial blank canvas as state 0
    UNDO_STATES(0).img& = _COPYIMAGE(SCRN.PAINTING&, 32)
    UNDO.count% = 1
    UNDO.current% = 0
END SUB


''
' Save current canvas state to undo history
' @param none
' @return none
' Call this BEFORE making changes to the canvas
'
SUB UNDO_save_state ()
    DIM i AS INTEGER
    _LOGINFO "UNDO_save_state: START count=" + _TRIM$(STR$(UNDO.count%)) + " current=" + _TRIM$(STR$(UNDO.current%))
    
    ' If we're not at the end of the undo stack, clear everything after current position
    ' (because we're creating a new branch)
    IF UNDO.current% < UNDO.count% - 1 THEN
        FOR i% = UNDO.current% + 1 TO UNDO.count% - 1
            IF UNDO_STATES(i%).img& <> 0 THEN
                _FREEIMAGE UNDO_STATES(i%).img&
                UNDO_STATES(i%).img& = 0
            END IF
        NEXT i%
        UNDO.count% = UNDO.current% + 1
    END IF
    
    ' If we're at max capacity, remove oldest state
    IF UNDO.count% >= UNDO.max_states% THEN
        IF UNDO_STATES(0).img& <> 0 THEN
            _FREEIMAGE UNDO_STATES(0).img&
        END IF
        
        ' Shift all states down
        FOR i% = 0 TO UNDO.count% - 2
            UNDO_STATES(i%).img& = UNDO_STATES(i% + 1).img&
        NEXT i%
        UNDO_STATES(UNDO.count% - 1).img& = 0
        UNDO.count% = UNDO.count% - 1
        UNDO.current% = UNDO.current% - 1
    END IF
    
    ' Save current painting layer as new undo state
    UNDO_STATES(UNDO.count%).img& = _COPYIMAGE(SCRN.PAINTING&, 32)
    UNDO.count% = UNDO.count% + 1
    UNDO.current% = UNDO.count% - 1
    
    _LOGINFO "UNDO_save_state: END count=" + STR$(UNDO.count%) + " current=" + STR$(UNDO.current%)
    
    ' Mark canvas as dirty (has unsaved changes)
    CANVAS_DIRTY% = TRUE
END SUB


''
' Undo - restore previous state
'
SUB UNDO_undo ()
    _LOGINFO "UNDO_undo: CALLED count=" + _TRIM$(STR$(UNDO.count%)) + " current=" + _TRIM$(STR$(UNDO.current%))
    IF UNDO.current% > 0 THEN
        _LOGINFO "UNDO_undo: Restoring state " + _TRIM$(STR$(UNDO.current% - 1))
        ' Restore the previous state (current - 1)
        IF UNDO_STATES(UNDO.current% - 1).img& <> 0 THEN
            _FREEIMAGE SCRN.PAINTING&
            SCRN.PAINTING& = _COPYIMAGE(UNDO_STATES(UNDO.current% - 1).img&, 32)
        END IF
        
        ' Move back one state
        UNDO.current% = UNDO.current% - 1
        _LOGINFO "UNDO_undo: DONE new current=" + _TRIM$(STR$(UNDO.current%))
    ELSE
        _LOGINFO "UNDO_undo: Cannot undo - already at first state"
    END IF
END SUB


''
' Redo - restore next state
'
SUB UNDO_redo ()
    IF UNDO.current% < UNDO.count% - 1 THEN
        ' Move forward one state
        UNDO.current% = UNDO.current% + 1
        
        ' Restore the state
        IF UNDO_STATES(UNDO.current%).img& <> 0 THEN
            _FREEIMAGE SCRN.PAINTING&
            SCRN.PAINTING& = _COPYIMAGE(UNDO_STATES(UNDO.current%).img&, 32)
        END IF
    END IF
END SUB


''
' Clear undo history (useful for new document)
'
SUB UNDO_clear ()
    DIM i AS INTEGER
    FOR i% = 0 TO UNDO.max_states%
        IF UNDO_STATES(i%).img& <> 0 THEN
            _FREEIMAGE UNDO_STATES(i%).img&
            UNDO_STATES(i%).img& = 0
        END IF
    NEXT i%
    UNDO.current% = 0
    UNDO.count% = 0
END SUB
