''
' DRAW - TOOLS/ELLIPSE.BM
' =============================================================================
' Ellipse (CIRCLE) tool subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Resets ellipse tool state
'
SUB ELLIPSE_reset ()
    ELLIPSE_TOOL.DRAGGING = FALSE
    ELLIPSE_TOOL.START_X = 0
    ELLIPSE_TOOL.START_Y = 0
    ELLIPSE_TOOL.END_X = 0
    ELLIPSE_TOOL.END_Y = 0
    ELLIPSE_TOOL.FILLED = FALSE
END SUB

''
' Draws a thick brush-stamped ellipse outline using midpoint algorithm.
' Stamps the current brush shape at each pixel along the ellipse path.
' Symmetry, selection clipping, and opacity lock are handled by PAINT_stamp_brush.
'
SUB ELLIPSE_draw_brushed (cx AS INTEGER, cy AS INTEGER, rx AS SINGLE, ry AS SINGLE, col AS _UNSIGNED LONG)
    IF rx! <= 0 OR ry! <= 0 THEN EXIT SUB

    DIM AS INTEGER x, y
    DIM AS SINGLE rxSq, rySq, twoRxSq, twoRySq
    DIM AS SINGLE p

    rxSq! = rx! * rx!
    rySq! = ry! * ry!
    twoRxSq! = 2 * rxSq!
    twoRySq! = 2 * rySq!

    ' Region 1
    x% = 0
    y% = INT(ry! + 0.5)

    DIM AS SINGLE px, py
    px! = 0
    py! = twoRxSq! * y%

    ' Draw initial points in 4 quadrants
    PAINT_stamp_brush cx% + x%, cy% + y%, col~&
    PAINT_stamp_brush cx% - x%, cy% + y%, col~&
    PAINT_stamp_brush cx% + x%, cy% - y%, col~&
    PAINT_stamp_brush cx% - x%, cy% - y%, col~&

    p! = rySq! - (rxSq! * ry!) + (0.25 * rxSq!)

    WHILE px! < py!
        x% = x% + 1
        px! = px! + twoRySq!
        IF p! < 0 THEN
            p! = p! + rySq! + px!
        ELSE
            y% = y% - 1
            py! = py! - twoRxSq!
            p! = p! + rySq! + px! - py!
        END IF
        PAINT_stamp_brush cx% + x%, cy% + y%, col~&
        PAINT_stamp_brush cx% - x%, cy% + y%, col~&
        PAINT_stamp_brush cx% + x%, cy% - y%, col~&
        PAINT_stamp_brush cx% - x%, cy% - y%, col~&
    WEND

    ' Region 2
    p! = rySq! * (x% + 0.5) * (x% + 0.5) + rxSq! * (y% - 1) * (y% - 1) - rxSq! * rySq!
    WHILE y% >= 0
        y% = y% - 1
        py! = py! - twoRxSq!
        IF p! > 0 THEN
            p! = p! + rxSq! - py!
        ELSE
            x% = x% + 1
            px! = px! + twoRySq!
            p! = p! + rxSq! - py! + px!
        END IF
        PAINT_stamp_brush cx% + x%, cy% + y%, col~&
        PAINT_stamp_brush cx% - x%, cy% + y%, col~&
        PAINT_stamp_brush cx% + x%, cy% - y%, col~&
        PAINT_stamp_brush cx% - x%, cy% - y%, col~&
    WEND
END SUB

''
' Draws an ellipse outline with selection clipping using midpoint algorithm
'
SUB ELLIPSE_draw_clipped_outline (cx AS INTEGER, cy AS INTEGER, rx AS SINGLE, ry AS SINGLE, col AS _UNSIGNED LONG)
    IF rx! <= 0 OR ry! <= 0 THEN EXIT SUB
    
    DIM AS INTEGER x, y
    DIM AS SINGLE rxSq, rySq, twoRxSq, twoRySq
    DIM AS SINGLE p
    
    rxSq! = rx! * rx!
    rySq! = ry! * ry!
    twoRxSq! = 2 * rxSq!
    twoRySq! = 2 * rySq!
    
    ' Region 1
    x% = 0
    y% = INT(ry! + 0.5)
    
    DIM AS SINGLE px, py
    px! = 0
    py! = twoRxSq! * y%
    
    ' Draw initial points in 4 quadrants
    IF SELECTION_is_point_inside%(cx% + x%, cy% + y%) AND OPACITY_LOCK_allows_draw%(cx% + x%, cy% + y%) THEN PSET (cx% + x%, cy% + y%), col~&
    IF SELECTION_is_point_inside%(cx% - x%, cy% + y%) AND OPACITY_LOCK_allows_draw%(cx% - x%, cy% + y%) THEN PSET (cx% - x%, cy% + y%), col~&
    IF SELECTION_is_point_inside%(cx% + x%, cy% - y%) AND OPACITY_LOCK_allows_draw%(cx% + x%, cy% - y%) THEN PSET (cx% + x%, cy% - y%), col~&
    IF SELECTION_is_point_inside%(cx% - x%, cy% - y%) AND OPACITY_LOCK_allows_draw%(cx% - x%, cy% - y%) THEN PSET (cx% - x%, cy% - y%), col~&
    
    p! = rySq! - (rxSq! * ry!) + (0.25 * rxSq!)
    
    WHILE px! < py!
        x% = x% + 1
        px! = px! + twoRySq!
        IF p! < 0 THEN
            p! = p! + rySq! + px!
        ELSE
            y% = y% - 1
            py! = py! - twoRxSq!
            p! = p! + rySq! + px! - py!
        END IF
        IF SELECTION_is_point_inside%(cx% + x%, cy% + y%) AND OPACITY_LOCK_allows_draw%(cx% + x%, cy% + y%) THEN PSET (cx% + x%, cy% + y%), col~&
        IF SELECTION_is_point_inside%(cx% - x%, cy% + y%) AND OPACITY_LOCK_allows_draw%(cx% - x%, cy% + y%) THEN PSET (cx% - x%, cy% + y%), col~&
        IF SELECTION_is_point_inside%(cx% + x%, cy% - y%) AND OPACITY_LOCK_allows_draw%(cx% + x%, cy% - y%) THEN PSET (cx% + x%, cy% - y%), col~&
        IF SELECTION_is_point_inside%(cx% - x%, cy% - y%) AND OPACITY_LOCK_allows_draw%(cx% - x%, cy% - y%) THEN PSET (cx% - x%, cy% - y%), col~&
    WEND
    
    ' Region 2
    p! = rySq! * (x% + 0.5) * (x% + 0.5) + rxSq! * (y% - 1) * (y% - 1) - rxSq! * rySq!
    WHILE y% >= 0
        y% = y% - 1
        py! = py! - twoRxSq!
        IF p! > 0 THEN
            p! = p! + rxSq! - py!
        ELSE
            x% = x% + 1
            px! = px! + twoRySq!
            p! = p! + rxSq! - py! + px!
        END IF
        IF SELECTION_is_point_inside%(cx% + x%, cy% + y%) AND OPACITY_LOCK_allows_draw%(cx% + x%, cy% + y%) THEN PSET (cx% + x%, cy% + y%), col~&
        IF SELECTION_is_point_inside%(cx% - x%, cy% + y%) AND OPACITY_LOCK_allows_draw%(cx% - x%, cy% + y%) THEN PSET (cx% - x%, cy% + y%), col~&
        IF SELECTION_is_point_inside%(cx% + x%, cy% - y%) AND OPACITY_LOCK_allows_draw%(cx% + x%, cy% - y%) THEN PSET (cx% + x%, cy% - y%), col~&
        IF SELECTION_is_point_inside%(cx% - x%, cy% - y%) AND OPACITY_LOCK_allows_draw%(cx% - x%, cy% - y%) THEN PSET (cx% - x%, cy% - y%), col~&
    WEND
END SUB

''
' Fills an ellipse using scanline algorithm (more reliable than PAINT)
' cx, cy = center, rx, ry = radii
'
SUB ELLIPSE_fill_scanline (cx AS INTEGER, cy AS INTEGER, rx AS SINGLE, ry AS SINGLE, fill_color AS _UNSIGNED LONG, dest_image AS LONG)
    IF rx! <= 0 OR ry! <= 0 THEN EXIT SUB
    
    DIM AS INTEGER y, x_left, x_right, scan_x
    DIM AS SINGLE dx
    DIM AS INTEGER y_start, y_end
    DIM oldDest AS LONG
    DIM has_selection AS INTEGER
    
    oldDest& = _DEST
    _DEST dest_image&
    
    ' Check if there's an active selection for clipping
    has_selection% = SELECTION_has_active%
    
    ' Calculate y range with proper rounding to avoid missing scanlines
    y_start% = cy% - INT(ry! + 0.5)
    y_end% = cy% + INT(ry! + 0.5)
    
    ' Ensure at least one scanline for very thin ellipses
    IF y_start% = y_end% THEN y_end% = y_start% + 1
    
    ' For each scanline from top to bottom of ellipse
    FOR y% = y_start% TO y_end%
        ' Calculate x extent at this y using ellipse equation: (x/rx)^2 + (y/ry)^2 = 1
        ' Solving for x: x = rx * sqrt(1 - (y/ry)^2)
        DIM dy AS SINGLE
        dy! = (y% - cy%) / ry!
        
        IF ABS(dy!) <= 1.0001 THEN ' Small tolerance for rounding errors
            dx! = rx! * SQR(1 - dy! * dy!)
            ' Use proper rounding instead of truncation
            x_left% = cx% - INT(dx! + 0.5)
            x_right% = cx% + INT(dx! + 0.5)
            
            ' Ensure at least one pixel for very thin ellipses
            IF x_left% > x_right% THEN x_left% = x_right%
            
            ' Draw horizontal line for this scanline
            IF x_left% <= x_right% THEN
                IF has_selection% THEN
                    ' Clipped solid fill
                    FOR scan_x% = x_left% TO x_right%
                        IF SELECTION_is_point_inside%(scan_x%, y%) AND OPACITY_LOCK_allows_draw%(scan_x%, y%) THEN
                            PSET (scan_x%, y%), fill_color~&
                        END IF
                    NEXT scan_x%
                ELSE
                    ' Solid fill - check opacity lock per pixel if enabled
                    IF LAYERS(CURRENT_LAYER%).opacityLock% THEN
                        FOR scan_x% = x_left% TO x_right%
                            IF OPACITY_LOCK_allows_draw%(scan_x%, y%) THEN
                                PSET (scan_x%, y%), fill_color~&
                            END IF
                        NEXT scan_x%
                    ELSE
                        ' Fast path - no selection or opacity lock
                        LINE (x_left%, y%)-(x_right%, y%), fill_color~&
                    END IF
                END IF
            END IF
        END IF
    NEXT y%
    
    _DEST oldDest&
END SUB
