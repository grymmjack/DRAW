''
' DRAW - TOOLS/ELLIPSE.BM
' =============================================================================
' Ellipse (CIRCLE) tool subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Resets ellipse tool state
'
SUB ELLIPSE_reset ()
    ELLIPSE_TOOL.DRAGGING = FALSE
    ELLIPSE_TOOL.START_X = 0
    ELLIPSE_TOOL.START_Y = 0
    ELLIPSE_TOOL.END_X = 0
    ELLIPSE_TOOL.END_Y = 0
    ELLIPSE_TOOL.FILLED = FALSE
END SUB

''
' Fills an ellipse using scanline algorithm (more reliable than PAINT)
' cx, cy = center, rx, ry = radii
'
SUB ELLIPSE_fill_scanline (cx AS INTEGER, cy AS INTEGER, rx AS SINGLE, ry AS SINGLE, fill_color AS _UNSIGNED LONG, dest_image AS LONG)
    IF rx! <= 0 OR ry! <= 0 THEN EXIT SUB
    
    DIM AS INTEGER y, x_left, x_right, scan_x
    DIM AS SINGLE dx
    DIM AS INTEGER y_start, y_end
    DIM oldDest AS LONG
    
    oldDest& = _DEST
    _DEST dest_image&
    
    ' Calculate y range with proper rounding to avoid missing scanlines
    y_start% = cy% - INT(ry! + 0.5)
    y_end% = cy% + INT(ry! + 0.5)
    
    ' Ensure at least one scanline for very thin ellipses
    IF y_start% = y_end% THEN y_end% = y_start% + 1
    
    ' For each scanline from top to bottom of ellipse
    FOR y% = y_start% TO y_end%
        ' Calculate x extent at this y using ellipse equation: (x/rx)^2 + (y/ry)^2 = 1
        ' Solving for x: x = rx * sqrt(1 - (y/ry)^2)
        DIM dy AS SINGLE
        dy! = (y% - cy%) / ry!
        
        IF ABS(dy!) <= 1.0001 THEN ' Small tolerance for rounding errors
            dx! = rx! * SQR(1 - dy! * dy!)
            ' Use proper rounding instead of truncation
            x_left% = cx% - INT(dx! + 0.5)
            x_right% = cx% + INT(dx! + 0.5)
            
            ' Ensure at least one pixel for very thin ellipses
            IF x_left% > x_right% THEN x_left% = x_right%
            
            ' Draw horizontal line for this scanline
            IF x_left% <= x_right% THEN
                ' Check if NumLock is OFF and dither pattern is active
                IF NOT _NUMLOCK AND BRUSH_DITHER_ACTIVE > 0 THEN
                    ' Use dither pattern fill
                    FOR scan_x% = x_left% TO x_right%
                        IF BRUSH_DITHERS_should_draw%(scan_x%, y%) THEN
                            PSET (scan_x%, y%), fill_color~&
                        END IF
                    NEXT scan_x%
                ELSE
                    ' Solid fill
                    FOR scan_x% = x_left% TO x_right%
                        PSET (scan_x%, y%), fill_color~&
                    NEXT scan_x%
                END IF
            END IF
        END IF
    NEXT y%
    
    _DEST oldDest&
END SUB
