''
' DRAW - TOOLS/BRUSH.BM
' =============================================================================
' Brush tool subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Check if opacity lock allows drawing at the given position
' Returns TRUE if drawing is allowed, FALSE if blocked (transparent pixel with opacity lock)
' @param INTEGER x - X coordinate
' @param INTEGER y - Y coordinate
' @return INTEGER - TRUE if drawing allowed, FALSE if blocked
'
FUNCTION OPACITY_LOCK_allows_draw% (x AS INTEGER, y AS INTEGER)
    ' If opacity lock is not enabled, always allow drawing
    IF NOT LAYERS(CURRENT_LAYER%).opacityLock% THEN
        OPACITY_LOCK_allows_draw% = TRUE
        EXIT FUNCTION
    END IF
    
    ' Check if the target pixel has any alpha (non-transparent)
    DIM oldSrc AS LONG
    DIM pixelAlpha AS INTEGER
    oldSrc& = _SOURCE
    _SOURCE LAYER_current_image&
    pixelAlpha% = _ALPHA32(POINT(x%, y%))
    _SOURCE oldSrc&
    
    ' Allow drawing only on non-transparent pixels (alpha > 0)
    OPACITY_LOCK_allows_draw% = (pixelAlpha% > 0)
END FUNCTION


''
' Draw a pixel with symmetry support
' @param INTEGER x - X coordinate
' @param INTEGER y - Y coordinate
' @param _UNSIGNED LONG col - Color to draw
' @param INTEGER apply_symmetry - TRUE to apply symmetry, FALSE for master stroke only
'
SUB PAINT_pset_with_symmetry (x AS INTEGER, y AS INTEGER, col AS _UNSIGNED LONG, apply_symmetry AS INTEGER)
    DIM mx(0 TO 7) AS INTEGER
    DIM my(0 TO 7) AS INTEGER
    DIM count AS INTEGER
    DIM i AS INTEGER
    DIM oldDest AS LONG
    DIM targetImg AS LONG
    DIM is_transparent AS INTEGER
    
    targetImg& = LAYER_current_image&
    oldDest& = _DEST
    _DEST targetImg&
    
    ' Check if drawing with transparent color (eraser mode)
    is_transparent% = (_ALPHA32(col~&) = 0)
    
    ' For transparent drawing, we need to disable blending
    IF is_transparent% THEN _DONTBLEND targetImg&
    
    ' Check selection clipping AND opacity lock for master stroke
    IF SELECTION_is_point_inside%(x%, y%) AND OPACITY_LOCK_allows_draw%(x%, y%) THEN
        ' Draw master stroke at full opacity
        PSET (x%, y%), col~&
    END IF
    
    ' Apply symmetry if enabled and requested
    IF apply_symmetry% AND SYMMETRY.MODE > 0 THEN
        ' Get mirrored points
        SYMMETRY_get_mirrored_points x%, y%, mx%(), my%(), count%
        
        ' Draw mirrored strokes (check selection clipping and opacity lock for each)
        FOR i% = 0 TO count% - 1
            IF SELECTION_is_point_inside%(mx%(i%), my%(i%)) AND OPACITY_LOCK_allows_draw%(mx%(i%), my%(i%)) THEN
                PSET (mx%(i%), my%(i%)), col~&
            END IF
        NEXT i%
    END IF
    
    ' Restore blending if we disabled it
    IF is_transparent% THEN _BLEND targetImg&
    
    _DEST oldDest&
END SUB


''
' Turns painting on
' Draws circular brush strokes with interpolation for smooth lines
' 
SUB PAINT_on ()
    ' If custom brush is active, use it instead of normal brush
    IF CUSTOM_BRUSH_is_active% THEN
        BRUSH_draw_custom
        EXIT SUB
    END IF
    
    DIM radius AS INTEGER
    DIM dx AS INTEGER, dy AS INTEGER
    DIM steps AS INTEGER
    DIM t AS SINGLE
    DIM cx AS INTEGER, cy AS INTEGER
    DIM i AS INTEGER
    DIM start_x AS INTEGER, start_y AS INTEGER
    DIM end_x AS INTEGER, end_y AS INTEGER
    
    ' Pixel perfect variables
    DIM temp_pixels(0 TO 10000) AS PIXEL_PERFECT_STROKE_TYPE
    DIM temp_count AS INTEGER
    DIM is_dup AS INTEGER
    DIM j AS INTEGER
    DIM should_draw AS INTEGER
    DIM prev_x2 AS INTEGER, prev_y2 AS INTEGER
    DIM curr_x2 AS INTEGER, curr_y2 AS INTEGER  
    DIM next_x2 AS INTEGER, next_y2 AS INTEGER
    DIM prev_aligned2 AS INTEGER, next_aligned2 AS INTEGER, ends_not_aligned2 AS INTEGER
    DIM sx AS INTEGER, sy AS INTEGER
    DIM berr AS INTEGER, e2 AS INTEGER
    DIM chk_prev_x AS INTEGER, chk_prev_y AS INTEGER
    DIM chk_curr_x AS INTEGER, chk_curr_y AS INTEGER
    DIM chk_next_x AS INTEGER, chk_next_y AS INTEGER
    DIM chk_prev_aligned AS INTEGER, chk_next_aligned AS INTEGER, chk_ends_not_aligned AS INTEGER
    DIM c AS INTEGER
    DIM px AS INTEGER, py AS INTEGER
    DIM targetImg AS LONG
    
    targetImg& = LAYER_current_image&
    _DEST targetImg&
    
    ' Determine start and end points based on constraint mode
    IF CONSTRAIN_X% THEN
        start_x% = MOUSE.CON_X%
        start_y% = MOUSE.OLD_Y%
        end_x% = MOUSE.CON_X%
        end_y% = MOUSE.Y%
    ELSEIF CONSTRAIN_Y% THEN
        start_x% = MOUSE.OLD_X%
        start_y% = MOUSE.CON_Y%
        end_x% = MOUSE.X%
        end_y% = MOUSE.CON_Y%
    ELSE
        start_x% = MOUSE.OLD_X%
        start_y% = MOUSE.OLD_Y%
        end_x% = MOUSE.X%
        end_y% = MOUSE.Y%
    END IF
    
    ' For DOT tool, track last position for SHIFT+RightClick lines
    ' Only update when LEFT button is used (not right-click)
    IF CURRENT_TOOL% = TOOL_DOT AND MOUSE.B1% THEN
        DOT.LAST_X = end_x%
        DOT.LAST_Y = end_y%
        DOT.HAS_LAST = TRUE
    END IF
    
    DIM pixel_size AS INTEGER
    pixel_size% = BRUSH_SIZE_pixels%
    
    ' Pixel perfect mode only applies to single pixel (size 1) DOT/BRUSH tools
    DIM use_pixel_perfect AS INTEGER
    use_pixel_perfect% = FALSE
    IF pixel_size% = 1 AND BRUSH_SIZE.PIXEL_PERFECT AND (CURRENT_TOOL% = TOOL_DOT OR CURRENT_TOOL% = TOOL_BRUSH) THEN
        use_pixel_perfect% = TRUE
    END IF
    
    IF pixel_size% = 1 THEN
        ' Single pixel - draw with pixel perfect mode if enabled
        IF use_pixel_perfect% THEN
            ' Pixel-perfect mode: just draw and collect, post-processing on mouse up
            dx% = ABS(end_x% - start_x%)
            dy% = ABS(end_y% - start_y%)
            
            IF start_x% < end_x% THEN sx% = 1 ELSE sx% = -1
            IF start_y% < end_y% THEN sy% = 1 ELSE sy% = -1
            
            berr% = dx% - dy%
            
            cx% = start_x%
            cy% = start_y%
            
            ' Collect AND draw unfiltered (so user can see)
            DO
                ' Check dither pattern before drawing/collecting
                IF BRUSH_DITHERS_should_draw(cx%, cy%) THEN
                    ' Check if pixel was already drawn (not just last pixel)
                    _SOURCE targetImg&
                    DIM existing_color AS _UNSIGNED LONG
                    existing_color~& = POINT(cx%, cy%)
                    
                    ' Only add if this pixel hasn't been drawn yet this stroke
                    IF existing_color~& <> DRAW_COLOR~& AND PP_STROKE_COUNT% < 10000 THEN
                        PP_STROKE(PP_STROKE_COUNT%).ORIGINAL_COLOR = existing_color~&
                        PP_STROKE(PP_STROKE_COUNT%).X = cx%
                        PP_STROKE(PP_STROKE_COUNT%).Y = cy%
                        PP_STROKE_COUNT% = PP_STROKE_COUNT% + 1
                        ' Now draw so user can see (with symmetry)
                        PAINT_pset_with_symmetry cx%, cy%, DRAW_COLOR~&, TRUE
                    END IF
                END IF
                
                IF cx% = end_x% AND cy% = end_y% THEN EXIT DO
                
                ' Bresenham step
                e2% = 2 * berr%
                IF e2% > -dy% THEN
                    berr% = berr% - dy%
                    cx% = cx% + sx%
                END IF
                IF e2% < dx% THEN
                    berr% = berr% + dx%
                    cy% = cy% + sy%
                END IF
            LOOP
            ' On mouse UP, erase and redraw filtered in PAINT_draw_pixel_perfect
        ELSE
            ' Standard line drawing without pixel perfect - draw with dither check
            dx% = ABS(end_x% - start_x%)
            dy% = ABS(end_y% - start_y%)
            
            IF start_x% < end_x% THEN sx% = 1 ELSE sx% = -1
            IF start_y% < end_y% THEN sy% = 1 ELSE sy% = -1
            
            berr% = dx% - dy%
            
            cx% = start_x%
            cy% = start_y%
            
            DO
                IF BRUSH_DITHERS_should_draw%(cx%, cy%) THEN
                    PAINT_pset_with_symmetry cx%, cy%, DRAW_COLOR~&, TRUE
                END IF
                
                IF cx% = end_x% AND cy% = end_y% THEN EXIT DO
                
                ' Bresenham step
                e2% = 2 * berr%
                IF e2% > -dy% THEN
                    berr% = berr% - dy%
                    cx% = cx% + sx%
                END IF
                IF e2% < dx% THEN
                    berr% = berr% + dx%
                    cy% = cy% + sy%
                END IF
            LOOP
        END IF
    ELSEIF pixel_size% = 3 AND BRUSH_SIZE.SHAPE = 0 THEN
        ' Plus sign for size 3 circle only - with dither check
        dx% = end_x% - start_x%
        dy% = end_y% - start_y%
        
        steps% = INT(SQR(dx% * dx% + dy% * dy%)) + 1
        IF steps% < 1 THEN steps% = 1
        
        FOR i% = 0 TO steps%
            t! = i% / steps%
            cx% = start_x% + INT(dx% * t!)
            cy% = start_y% + INT(dy% * t!)
            ' Draw vertical line of plus
            FOR py% = cy% - 1 TO cy% + 1
                IF BRUSH_DITHERS_should_draw%(cx%, py%) THEN
                    PAINT_pset_with_symmetry cx%, py%, DRAW_COLOR~&, TRUE
                END IF
            NEXT
            ' Draw horizontal line of plus
            FOR px% = cx% - 1 TO cx% + 1
                IF BRUSH_DITHERS_should_draw%(px%, cy%) THEN
                    PAINT_pset_with_symmetry px%, cy%, DRAW_COLOR~&, TRUE
                END IF
            NEXT
        NEXT i%
    ELSE
        ' Brush - draw filled shapes along the path
        radius% = pixel_size% \ 2
        
        dx% = end_x% - start_x%
        dy% = end_y% - start_y%
        
        ' Calculate steps based on distance to ensure smooth line
        steps% = INT(SQR(dx% * dx% + dy% * dy%)) + 1
        IF steps% < 1 THEN steps% = 1
        
        ' Draw shapes along the path
        FOR i% = 0 TO steps%
            t! = i% / steps%
            cx% = start_x% + INT(dx% * t!)
            cy% = start_y% + INT(dy% * t!)
            IF BRUSH_SIZE.SHAPE = 0 THEN
                PAINT_draw_filled_circle cx%, cy%, radius%, DRAW_COLOR~&
            ELSE
                PAINT_draw_filled_square cx%, cy%, pixel_size%, DRAW_COLOR~&
            END IF
        NEXT i%
    END IF
    
    _DEST SCRN.CANVAS&
END SUB


''
' Draws a filled circle
' @param INTEGER x Center X coordinate
' @param INTEGER y Center Y coordinate
' @param INTEGER radius Circle radius
' @param _UNSIGNED LONG col Color to fill with
'
SUB PAINT_draw_filled_circle (x AS INTEGER, y AS INTEGER, radius AS INTEGER, col AS _UNSIGNED LONG)
    DIM cx AS INTEGER, cy AS INTEGER
    DIM d AS INTEGER
    DIM dist_sq AS SINGLE, r_sq AS SINGLE
    
    r_sq! = (radius% - 0.5) * (radius% - 0.5)
    
    ' Scan the bounding box and fill pixels inside the circle
    FOR cy% = y% - radius% TO y% + radius%
        FOR cx% = x% - radius% TO x% + radius%
            dist_sq! = (cx% - x%) * (cx% - x%) + (cy% - y%) * (cy% - y%)
            IF dist_sq! <= r_sq! THEN
                ' Check dither pattern before drawing
                IF BRUSH_DITHERS_should_draw(cx%, cy%) THEN
                    PAINT_pset_with_symmetry cx%, cy%, col~&, TRUE
                END IF
            END IF
        NEXT cx%
    NEXT cy%
END SUB

''
' Draws a filled square
' @param INTEGER x Center X coordinate
' @param INTEGER y Center Y coordinate
' @param INTEGER size Square size
' @param _UNSIGNED LONG col Color to fill with
'
SUB PAINT_draw_filled_square (x AS INTEGER, y AS INTEGER, size AS INTEGER, col AS _UNSIGNED LONG)
    DIM half AS INTEGER
    DIM px AS INTEGER, py AS INTEGER
    half% = size% \ 2
    
    ' Draw with dither pattern check
    FOR py = y% - half% TO y% + half%
        FOR px = x% - half% TO x% + half%
            IF BRUSH_DITHERS_should_draw(px, py) THEN
                PAINT_pset_with_symmetry px, py, col~&, TRUE
            END IF
        NEXT
    NEXT
END SUB


''
' Clears the canvas
' Background layer (index 1) clears to PAINT_BG_COLOR, other layers clear to transparent
' 
SUB PAINT_clear ()
    DIM targetImg AS LONG
    DIM x AS INTEGER, y AS INTEGER
    targetImg& = LAYER_current_image&
    
    ' Must disable blending to write transparent pixels
    _DONTBLEND targetImg&
    _DEST targetImg&
    
    ' Fill entire image with fully transparent pixels
    FOR y% = 0 TO _HEIGHT(targetImg&) - 1
        FOR x% = 0 TO _WIDTH(targetImg&) - 1
            PSET (x%, y%), _RGBA32(0, 0, 0, 0)
        NEXT x%
    NEXT y%
    
    ' Re-enable blending
    _BLEND targetImg&
    _DEST SCRN.CANVAS&
END SUB


''
' Clears the canvas with confirmation prompt
' Used for DELETE key
'
SUB PAINT_clear_with_prompt ()
    DIM result AS LONG
    POINTER_hide_for_dialog
    result& = _MESSAGEBOX("Clear Canvas", "Are you sure you want to clear the canvas?", "yesno", "question", 0)
    POINTER_show_after_dialog
    
    ' Clear input buffers
    DO WHILE _MOUSEINPUT : LOOP
    _MOUSEMOVE _WIDTH \ 2, _HEIGHT \ 2
    MOUSE_force_buttons_up
    
    IF result& = 1 THEN ' User clicked Yes
        PAINT_clear
        CANVAS_DIRTY% = TRUE
    END IF
END SUB


''
' Clears the canvas without confirmation
' Used for BACKSPACE key
'
SUB PAINT_clear_no_prompt ()
    PAINT_clear
    CANVAS_DIRTY% = TRUE
END SUB

''
' Draws collected pixel-perfect stroke, skipping L-corners
' Called on mouse UP after complete path is collected
'
SUB PAINT_draw_pixel_perfect ()
    IF PP_STROKE_COUNT% < 1 THEN EXIT SUB
    
    DIM targetImg AS LONG
    targetImg& = LAYER_current_image&
    _DEST targetImg&
    
    ' STEP 1: Restore ALL original pixels (erase the unfiltered stroke)
    ' MUST disable blending or transparent pixels won't overwrite!
    DIM i AS INTEGER
    _DONTBLEND targetImg&
    FOR i% = 0 TO PP_STROKE_COUNT% - 1
        PSET (PP_STROKE(i%).X, PP_STROKE(i%).Y), PP_STROKE(i%).ORIGINAL_COLOR
    NEXT i%
    _BLEND targetImg&
    
    ' STEP 2: Draw path with L-corner filtering (reference algorithm)
    DIM c AS INTEGER
    DIM skipped AS INTEGER
    DIM chk_prev_x AS INTEGER, chk_prev_y AS INTEGER
    DIM chk_curr_x AS INTEGER, chk_curr_y AS INTEGER
    DIM chk_next_x AS INTEGER, chk_next_y AS INTEGER
    DIM chk_prev_aligned AS INTEGER, chk_next_aligned AS INTEGER, chk_ends_not_aligned AS INTEGER
    DIM is_corner AS INTEGER
    
    skipped% = 0
    c% = 0
    WHILE c% < PP_STROKE_COUNT%
        is_corner% = FALSE
        
        ' Check if current pixel is an L-corner
        IF c% > 0 AND c% + 1 < PP_STROKE_COUNT% THEN
            chk_prev_x% = PP_STROKE(c% - 1).X
            chk_prev_y% = PP_STROKE(c% - 1).Y
            chk_curr_x% = PP_STROKE(c%).X
            chk_curr_y% = PP_STROKE(c%).Y
            chk_next_x% = PP_STROKE(c% + 1).X
            chk_next_y% = PP_STROKE(c% + 1).Y
            
            chk_prev_aligned% = (chk_prev_x% = chk_curr_x%) OR (chk_prev_y% = chk_curr_y%)
            chk_next_aligned% = (chk_next_x% = chk_curr_x%) OR (chk_next_y% = chk_curr_y%)
            chk_ends_not_aligned% = (chk_prev_x% <> chk_next_x%) AND (chk_prev_y% <> chk_next_y%)
            
            ' Only remove corner if prev and next are EXACTLY diagonal (distance = 1 on both axes)
            DIM prev_next_diagonal AS INTEGER
            prev_next_diagonal% = (ABS(chk_prev_x% - chk_next_x%) = 1) AND (ABS(chk_prev_y% - chk_next_y%) = 1)
            
            IF chk_prev_aligned% AND chk_next_aligned% AND chk_ends_not_aligned% AND prev_next_diagonal% THEN
                ' SKIP this corner - increment to move past it
                skipped% = skipped% + 1
                c% = c% + 1
                ' Now draw the NEXT pixel without checking if it's a corner
                IF c% < PP_STROKE_COUNT% THEN
                    PSET (PP_STROKE(c%).X, PP_STROKE(c%).Y), DRAW_COLOR~&
                END IF
                c% = c% + 1
                ' Continue to next iteration (skip the normal draw below)
                GOTO pp_continue
            END IF
        END IF
        
        ' Draw non-corner pixels
        PSET (PP_STROKE(c%).X, PP_STROKE(c%).Y), DRAW_COLOR~&
        c% = c% + 1
        pp_continue:
    WEND
END SUB


''
' Draw with custom brush - stamps brush along stroke path
'
SUB BRUSH_draw_custom ()
    IF NOT CUSTOM_BRUSH_is_active% THEN EXIT SUB
    
    DIM start_x AS INTEGER, start_y AS INTEGER
    DIM end_x AS INTEGER, end_y AS INTEGER
    DIM dx AS INTEGER, dy AS INTEGER
    DIM steps AS INTEGER, i AS INTEGER
    DIM t AS SINGLE
    DIM stamp_x AS INTEGER, stamp_y AS INTEGER
    
    ' Determine start and end points based on constraint mode
    IF CONSTRAIN_X% THEN
        start_x% = MOUSE.CON_X%
        start_y% = MOUSE.OLD_Y%
        end_x% = MOUSE.CON_X%
        end_y% = MOUSE.Y%
    ELSEIF CONSTRAIN_Y% THEN
        start_x% = MOUSE.OLD_X%
        start_y% = MOUSE.CON_Y%
        end_x% = MOUSE.X%
        end_y% = MOUSE.CON_Y%
    ELSE
        start_x% = MOUSE.OLD_X%
        start_y% = MOUSE.OLD_Y%
        end_x% = MOUSE.X%
        end_y% = MOUSE.Y%
    END IF
    
    ' Calculate distance and interpolation steps
    dx% = end_x% - start_x%
    dy% = end_y% - start_y%
    steps% = INT(SQR(dx% * dx% + dy% * dy%))
    
    IF steps% = 0 THEN
        ' Single stamp at current position
        stamp_x% = end_x% - CUSTOM_BRUSH.WIDTH% \ 2
        stamp_y% = end_y% - CUSTOM_BRUSH.HEIGHT% \ 2
        CUSTOM_BRUSH_stamp stamp_x%, stamp_y%
    ELSE
        ' Interpolate and stamp along the path
        ' Space stamps based on brush size to avoid excessive overlap
        DIM stamp_spacing AS INTEGER
        stamp_spacing% = (CUSTOM_BRUSH.WIDTH% + CUSTOM_BRUSH.HEIGHT%) \ 4
        IF stamp_spacing% < 1 THEN stamp_spacing% = 1
        
        FOR i% = 0 TO steps% STEP stamp_spacing%
            t! = i% / steps%
            stamp_x% = start_x% + dx% * t! - CUSTOM_BRUSH.WIDTH% \ 2
            stamp_y% = start_y% + dy% * t! - CUSTOM_BRUSH.HEIGHT% \ 2
            CUSTOM_BRUSH_stamp stamp_x%, stamp_y%
        NEXT i%
        
        ' Always stamp at the end point
        stamp_x% = end_x% - CUSTOM_BRUSH.WIDTH% \ 2
        stamp_y% = end_y% - CUSTOM_BRUSH.HEIGHT% \ 2
        CUSTOM_BRUSH_stamp stamp_x%, stamp_y%
    END IF
END SUB

''
' Stamps custom brush along a line from (x1,y1) to (x2,y2)
' Used by LINE, RECTANGLE, ELLIPSE, POLYGON tools
'
SUB CUSTOM_BRUSH_stamp_line (x1 AS INTEGER, y1 AS INTEGER, x2 AS INTEGER, y2 AS INTEGER)
    IF NOT CUSTOM_BRUSH_is_active% THEN EXIT SUB
    
    DIM dx AS INTEGER, dy AS INTEGER
    DIM steps AS INTEGER
    DIM t AS SINGLE
    DIM i AS INTEGER
    DIM stamp_x AS INTEGER, stamp_y AS INTEGER
    DIM stamp_spacing AS INTEGER
    
    dx% = x2% - x1%
    dy% = y2% - y1%
    steps% = INT(SQR(dx% * dx% + dy% * dy%))
    
    IF steps% = 0 THEN
        ' Single stamp at start position
        stamp_x% = x1% - CUSTOM_BRUSH.WIDTH% \ 2
        stamp_y% = y1% - CUSTOM_BRUSH.HEIGHT% \ 2
        CUSTOM_BRUSH_stamp stamp_x%, stamp_y%
    ELSE
        ' Space stamps based on brush size to avoid excessive overlap
        stamp_spacing% = (CUSTOM_BRUSH.WIDTH% + CUSTOM_BRUSH.HEIGHT%) \ 4
        IF stamp_spacing% < 1 THEN stamp_spacing% = 1
        
        FOR i% = 0 TO steps% STEP stamp_spacing%
            t! = i% / steps%
            stamp_x% = x1% + dx% * t! - CUSTOM_BRUSH.WIDTH% \ 2
            stamp_y% = y1% + dy% * t! - CUSTOM_BRUSH.HEIGHT% \ 2
            CUSTOM_BRUSH_stamp stamp_x%, stamp_y%
        NEXT i%
        
        ' Always stamp at end point
        stamp_x% = x2% - CUSTOM_BRUSH.WIDTH% \ 2
        stamp_y% = y2% - CUSTOM_BRUSH.HEIGHT% \ 2
        CUSTOM_BRUSH_stamp stamp_x%, stamp_y%
    END IF
END SUB

''
' Stamps custom brush along an ellipse outline
' cx, cy = center, rx, ry = radii
'
SUB CUSTOM_BRUSH_stamp_ellipse (cx AS INTEGER, cy AS INTEGER, rx AS SINGLE, ry AS SINGLE)
    IF NOT CUSTOM_BRUSH_is_active% THEN EXIT SUB
    IF rx! <= 0 OR ry! <= 0 THEN EXIT SUB
    
    DIM angle AS SINGLE
    DIM x AS INTEGER, y AS INTEGER
    DIM prev_x AS INTEGER, prev_y AS INTEGER
    DIM first_loop AS INTEGER
    DIM stamp_x AS INTEGER, stamp_y AS INTEGER
    DIM step_angle AS SINGLE
    
    ' Calculate step size based on ellipse perimeter approximation
    DIM perimeter AS SINGLE
    perimeter! = 3.14159 * (rx! + ry!) * 2
    step_angle! = 6.28318 / perimeter! * ((CUSTOM_BRUSH.WIDTH% + CUSTOM_BRUSH.HEIGHT%) \ 4)
    IF step_angle! < 0.05 THEN step_angle! = 0.05
    
    first_loop% = TRUE
    angle! = 0
    
    DO WHILE angle! < 6.28318
        x% = cx% + INT(rx! * COS(angle!))
        y% = cy% + INT(ry! * SIN(angle!))
        
        IF NOT first_loop% THEN
            ' Stamp between previous and current point
            CUSTOM_BRUSH_stamp_line prev_x%, prev_y%, x%, y%
        ELSE
            ' Just stamp at first point
            stamp_x% = x% - CUSTOM_BRUSH.WIDTH% \ 2
            stamp_y% = y% - CUSTOM_BRUSH.HEIGHT% \ 2
            CUSTOM_BRUSH_stamp stamp_x%, stamp_y%
            first_loop% = FALSE
        END IF
        
        prev_x% = x%
        prev_y% = y%
        angle! = angle! + step_angle!
    LOOP
END SUB
