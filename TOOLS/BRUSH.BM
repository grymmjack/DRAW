''
' DRAW - TOOLS/BRUSH.BM
' =============================================================================
' Brush tool subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Turns painting on
' Draws circular brush strokes with interpolation for smooth lines
' 
SUB PAINT_on ()
    DIM radius AS INTEGER
    DIM dx AS INTEGER, dy AS INTEGER
    DIM steps AS INTEGER
    DIM t AS SINGLE
    DIM cx AS INTEGER, cy AS INTEGER
    DIM i AS INTEGER
    DIM start_x AS INTEGER, start_y AS INTEGER
    DIM end_x AS INTEGER, end_y AS INTEGER
    
    _DEST SCRN.PAINTING&
    
    ' Determine start and end points based on constraint mode
    IF CONSTRAIN_X% THEN
        start_x% = MOUSE.CON_X%
        start_y% = MOUSE.OLD_Y%
        end_x% = MOUSE.CON_X%
        end_y% = MOUSE.Y%
    ELSEIF CONSTRAIN_Y% THEN
        start_x% = MOUSE.OLD_X%
        start_y% = MOUSE.CON_Y%
        end_x% = MOUSE.X%
        end_y% = MOUSE.CON_Y%
    ELSE
        start_x% = MOUSE.OLD_X%
        start_y% = MOUSE.OLD_Y%
        end_x% = MOUSE.X%
        end_y% = MOUSE.Y%
    END IF
    
    ' For DOT tool, track last position for SHIFT+RightClick lines
    IF CURRENT_TOOL% = TOOL_DOT THEN
        DOT.LAST_X = end_x%
        DOT.LAST_Y = end_y%
        DOT.HAS_LAST = TRUE
    END IF
    
    DIM pixel_size AS INTEGER
    pixel_size% = BRUSH_SIZE_pixels%
    
    IF pixel_size% = 1 THEN
        ' Single pixel - use LINE for efficiency
        LINE (start_x%, start_y%)-(end_x%, end_y%), PAINT_COLOR~&
    ELSEIF pixel_size% = 3 AND BRUSH_SIZE.SHAPE = 0 THEN
        ' Plus sign for size 3 circle only
        dx% = end_x% - start_x%
        dy% = end_y% - start_y%
        
        steps% = INT(SQR(dx% * dx% + dy% * dy%)) + 1
        IF steps% < 1 THEN steps% = 1
        
        FOR i% = 0 TO steps%
            t! = i% / steps%
            cx% = start_x% + INT(dx% * t!)
            cy% = start_y% + INT(dy% * t!)
            LINE (cx%, cy% - 1)-(cx%, cy% + 1), PAINT_COLOR~&
            LINE (cx% - 1, cy%)-(cx% + 1, cy%), PAINT_COLOR~&
        NEXT i%
    ELSE
        ' Brush - draw filled shapes along the path
        radius% = pixel_size% \ 2
        
        dx% = end_x% - start_x%
        dy% = end_y% - start_y%
        
        ' Calculate steps based on distance to ensure smooth line
        steps% = INT(SQR(dx% * dx% + dy% * dy%)) + 1
        IF steps% < 1 THEN steps% = 1
        
        ' Draw shapes along the path
        FOR i% = 0 TO steps%
            t! = i% / steps%
            cx% = start_x% + INT(dx% * t!)
            cy% = start_y% + INT(dy% * t!)
            IF BRUSH_SIZE.SHAPE = 0 THEN
                PAINT_draw_filled_circle cx%, cy%, radius%, PAINT_COLOR~&
            ELSE
                PAINT_draw_filled_square cx%, cy%, pixel_size%, PAINT_COLOR~&
            END IF
        NEXT i%
    END IF
    
    _DEST SCRN.CANVAS&
END SUB


''
' Draws a filled circle
' @param INTEGER x Center X coordinate
' @param INTEGER y Center Y coordinate
' @param INTEGER radius Circle radius
' @param _UNSIGNED LONG col Color to fill with
'
SUB PAINT_draw_filled_circle (x AS INTEGER, y AS INTEGER, radius AS INTEGER, col AS _UNSIGNED LONG)
    DIM cx AS INTEGER, cy AS INTEGER
    DIM d AS INTEGER
    DIM dist_sq AS SINGLE, r_sq AS SINGLE
    
    r_sq! = (radius% - 0.5) * (radius% - 0.5)
    
    ' Scan the bounding box and fill pixels inside the circle
    FOR cy% = y% - radius% TO y% + radius%
        FOR cx% = x% - radius% TO x% + radius%
            dist_sq! = (cx% - x%) * (cx% - x%) + (cy% - y%) * (cy% - y%)
            IF dist_sq! <= r_sq! THEN
                PSET (cx%, cy%), col~&
            END IF
        NEXT cx%
    NEXT cy%
END SUB

''
' Draws a filled square
' @param INTEGER x Center X coordinate
' @param INTEGER y Center Y coordinate
' @param INTEGER size Square size
' @param _UNSIGNED LONG col Color to fill with
'
SUB PAINT_draw_filled_square (x AS INTEGER, y AS INTEGER, size AS INTEGER, col AS _UNSIGNED LONG)
    DIM half AS INTEGER
    half% = size% \ 2
    LINE (x% - half%, y% - half%)-(x% + half%, y% + half%), col~&, BF
END SUB


''
' Clears the canvas
' @todo
' 
SUB PAINT_clear ()
    _DEST SCRN.PAINTING&
    CLS
    _DEST SCRN.CANVAS&
END SUB
