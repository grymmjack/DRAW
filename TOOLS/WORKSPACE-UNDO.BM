''
' DRAW - TOOLS/WORKSPACE-UNDO.BM
' =============================================================================
' Workspace undo system implementation
' Handles undo/redo for layer operations with timestamp support
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

' ============================================================================
' WORKSPACE_UNDO_init - Initialize workspace undo system
' ============================================================================
SUB WORKSPACE_UNDO_init
    WORKSPACE_UNDO.current% = 0
    WORKSPACE_UNDO.count% = 0
    WORKSPACE_UNDO.max_states% = CFG.WORKSPACE_UNDO_MAX_STATES%
    IF WORKSPACE_UNDO.max_states% < 1 THEN WORKSPACE_UNDO.max_states% = 20
    IF WORKSPACE_UNDO.max_states% > 100 THEN WORKSPACE_UNDO.max_states% = 100
    REDIM WORKSPACE_UNDO_STATES(1 TO WORKSPACE_UNDO.max_states%) AS WORKSPACE_UNDO_STATE
    PIXEL_UNDO_LAST_TIMESTAMP# = 0
    WORKSPACE_UNDO_READY% = TRUE  ' Mark system as ready for use
END SUB

' ============================================================================
' WORKSPACE_UNDO_clear - Clear all workspace undo states and free images
' ============================================================================
SUB WORKSPACE_UNDO_clear
    DIM i AS INTEGER
    FOR i% = 1 TO WORKSPACE_UNDO.count%
        ' Free any stored images
        IF WORKSPACE_UNDO_STATES(i%).img& < -1 THEN
            _FREEIMAGE WORKSPACE_UNDO_STATES(i%).img&
        END IF
        IF WORKSPACE_UNDO_STATES(i%).img2& < -1 THEN
            _FREEIMAGE WORKSPACE_UNDO_STATES(i%).img2&
        END IF
        WORKSPACE_UNDO_STATES(i%).img& = 0
        WORKSPACE_UNDO_STATES(i%).img2& = 0
        ' Free merge-visible source layer images if applicable
        IF WORKSPACE_UNDO_STATES(i%).action_type% = WUNDO_TYPE_LAYER_MERGE_VISIBLE THEN
            MERGE_VIS_free_state_images i%
        END IF
    NEXT i%
    WORKSPACE_UNDO.current% = 0
    WORKSPACE_UNDO.count% = 0
END SUB

' ============================================================================
' WUNDO_shift_states_down - Internal: shift states to make room at the end
' ============================================================================
SUB WUNDO_shift_states_down
    DIM i AS INTEGER
    ' Free the oldest state's images
    IF WORKSPACE_UNDO_STATES(1).img& < -1 THEN
        _FREEIMAGE WORKSPACE_UNDO_STATES(1).img&
    END IF
    IF WORKSPACE_UNDO_STATES(1).img2& < -1 THEN
        _FREEIMAGE WORKSPACE_UNDO_STATES(1).img2&
    END IF
    ' Free merge-visible data for state 1 (being shifted out)
    IF WORKSPACE_UNDO_STATES(1).action_type% = WUNDO_TYPE_LAYER_MERGE_VISIBLE THEN
        MERGE_VIS_free_state_images 1
    END IF
    ' Shift all states down
    FOR i% = 1 TO WORKSPACE_UNDO.max_states% - 1
        WORKSPACE_UNDO_STATES(i%) = WORKSPACE_UNDO_STATES(i% + 1)
        ' Also shift merge-visible data
        MERGE_VIS_COUNT(i%) = MERGE_VIS_COUNT(i% + 1)
        DIM mvShiftJ AS INTEGER
        FOR mvShiftJ% = 1 TO 64
            MERGE_VIS_DATA(i%, mvShiftJ%) = MERGE_VIS_DATA(i% + 1, mvShiftJ%)
        NEXT mvShiftJ%
    NEXT i%
    ' Clear the last slot
    WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.max_states%).img& = 0
    WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.max_states%).img2& = 0
    MERGE_VIS_COUNT(WORKSPACE_UNDO.max_states%) = 0
END SUB

' ============================================================================
' WUNDO_prepare_new_state - Internal: prepare for adding a new state
' Returns the index where the new state should be stored
' ============================================================================
FUNCTION WUNDO_prepare_new_state%
    DIM i AS INTEGER
    DIM newIndex AS INTEGER
    
    ' If we're not at the end, truncate future redo states
    IF WORKSPACE_UNDO.current% < WORKSPACE_UNDO.count% THEN
        FOR i% = WORKSPACE_UNDO.current% + 1 TO WORKSPACE_UNDO.count%
            IF WORKSPACE_UNDO_STATES(i%).img& < -1 THEN
                _FREEIMAGE WORKSPACE_UNDO_STATES(i%).img&
            END IF
            IF WORKSPACE_UNDO_STATES(i%).img2& < -1 THEN
                _FREEIMAGE WORKSPACE_UNDO_STATES(i%).img2&
            END IF
            WORKSPACE_UNDO_STATES(i%).img& = 0
            WORKSPACE_UNDO_STATES(i%).img2& = 0
            ' Free merge-visible source layer images if applicable
            IF WORKSPACE_UNDO_STATES(i%).action_type% = WUNDO_TYPE_LAYER_MERGE_VISIBLE THEN
                MERGE_VIS_free_state_images i%
            END IF
        NEXT i%
        WORKSPACE_UNDO.count% = WORKSPACE_UNDO.current%
    END IF
    
    ' Check if we need to shift states
    IF WORKSPACE_UNDO.count% >= WORKSPACE_UNDO.max_states% THEN
        WUNDO_shift_states_down
        newIndex% = WORKSPACE_UNDO.max_states%
        WORKSPACE_UNDO.count% = WORKSPACE_UNDO.max_states%
        WORKSPACE_UNDO.current% = WORKSPACE_UNDO.max_states%
    ELSE
        WORKSPACE_UNDO.count% = WORKSPACE_UNDO.count% + 1
        WORKSPACE_UNDO.current% = WORKSPACE_UNDO.count%
        newIndex% = WORKSPACE_UNDO.count%
    END IF
    
    WUNDO_prepare_new_state% = newIndex%
END FUNCTION

' ============================================================================
' WORKSPACE_UNDO_save_layer_add - Save state before adding a new layer
' Called BEFORE the layer is actually added
' ============================================================================
SUB WORKSPACE_UNDO_save_layer_add (layerIndex AS INTEGER)
    ' Skip if workspace undo not ready (during initialization) or in progress (during undo/redo)
    IF NOT WORKSPACE_UNDO_READY% THEN EXIT SUB
    IF WORKSPACE_UNDO_IN_PROGRESS% THEN EXIT SUB
    
    DIM idx AS INTEGER
    idx% = WUNDO_prepare_new_state%
    
    WORKSPACE_UNDO_STATES(idx%).action_type% = WUNDO_TYPE_LAYER_ADD
    UNDO_SEQ = UNDO_SEQ + 1
    WORKSPACE_UNDO_STATES(idx%).timestamp# = UNDO_SEQ
    WORKSPACE_UNDO_STATES(idx%).layer_index% = layerIndex%
    WORKSPACE_UNDO_STATES(idx%).old_layer_count% = LAYER_COUNT%
    WORKSPACE_UNDO_STATES(idx%).img2& = 0
    
    ' Save the added layer's full state so redo can restore it faithfully
    ' (Important for duplicate layers which have custom names, content, etc.)
    WORKSPACE_UNDO_STATES(idx%).old_name$ = LAYERS(layerIndex%).name$
    WORKSPACE_UNDO_STATES(idx%).old_zIndex% = LAYERS(layerIndex%).zIndex%
    WORKSPACE_UNDO_STATES(idx%).old_opacity% = LAYERS(layerIndex%).opacity%
    WORKSPACE_UNDO_STATES(idx%).old_visible% = LAYERS(layerIndex%).visible%
    WORKSPACE_UNDO_STATES(idx%).old_opacityLock% = LAYERS(layerIndex%).opacityLock%
    WORKSPACE_UNDO_STATES(idx%).old_blendMode% = LAYERS(layerIndex%).blendMode%
    IF LAYERS(layerIndex%).imgHandle& < -1 THEN
        WORKSPACE_UNDO_STATES(idx%).img& = _COPYIMAGE(LAYERS(layerIndex%).imgHandle&)
    ELSE
        WORKSPACE_UNDO_STATES(idx%).img& = 0
    END IF
END SUB

' ============================================================================
' WORKSPACE_UNDO_save_layer_delete - Save state before deleting a layer
' Called BEFORE the layer is actually deleted
' ============================================================================
SUB WORKSPACE_UNDO_save_layer_delete (layerIndex AS INTEGER)
    ' Skip if workspace undo not ready (during initialization) or in progress (during undo/redo)
    IF NOT WORKSPACE_UNDO_READY% THEN EXIT SUB
    IF WORKSPACE_UNDO_IN_PROGRESS% THEN EXIT SUB
    
    DIM idx AS INTEGER
    idx% = WUNDO_prepare_new_state%
    
    WORKSPACE_UNDO_STATES(idx%).action_type% = WUNDO_TYPE_LAYER_DELETE
    UNDO_SEQ = UNDO_SEQ + 1
    WORKSPACE_UNDO_STATES(idx%).timestamp# = UNDO_SEQ
    WORKSPACE_UNDO_STATES(idx%).layer_index% = layerIndex%
    WORKSPACE_UNDO_STATES(idx%).old_layer_count% = LAYER_COUNT%
    
    ' Save copy of layer content before it's deleted
    IF LAYERS(layerIndex%).imgHandle& < -1 THEN
        WORKSPACE_UNDO_STATES(idx%).img& = _COPYIMAGE(LAYERS(layerIndex%).imgHandle&)
    ELSE
        WORKSPACE_UNDO_STATES(idx%).img& = 0
    END IF
    WORKSPACE_UNDO_STATES(idx%).img2& = 0
    
    ' Save layer properties
    WORKSPACE_UNDO_STATES(idx%).old_name$ = LAYERS(layerIndex%).name$
    WORKSPACE_UNDO_STATES(idx%).old_zIndex% = LAYERS(layerIndex%).zIndex%
    WORKSPACE_UNDO_STATES(idx%).old_opacity% = LAYERS(layerIndex%).opacity%
    WORKSPACE_UNDO_STATES(idx%).old_visible% = LAYERS(layerIndex%).visible%
    WORKSPACE_UNDO_STATES(idx%).old_opacityLock% = LAYERS(layerIndex%).opacityLock%
    WORKSPACE_UNDO_STATES(idx%).old_blendMode% = LAYERS(layerIndex%).blendMode%
END SUB
' WORKSPACE_UNDO_save_layer_rename - Save state before renaming a layer
' ============================================================================
SUB WORKSPACE_UNDO_save_layer_rename (layerIndex AS INTEGER, oldName AS STRING, newName AS STRING)
    ' Skip if workspace undo not ready (during initialization) or in progress (during undo/redo)
    IF NOT WORKSPACE_UNDO_READY% THEN EXIT SUB
    IF WORKSPACE_UNDO_IN_PROGRESS% THEN EXIT SUB
    
    DIM idx AS INTEGER
    idx% = WUNDO_prepare_new_state%
    
    WORKSPACE_UNDO_STATES(idx%).action_type% = WUNDO_TYPE_LAYER_RENAME
    UNDO_SEQ = UNDO_SEQ + 1
    WORKSPACE_UNDO_STATES(idx%).timestamp# = UNDO_SEQ
    WORKSPACE_UNDO_STATES(idx%).layer_index% = layerIndex%
    WORKSPACE_UNDO_STATES(idx%).old_name$ = oldName$
    WORKSPACE_UNDO_STATES(idx%).new_name$ = newName$
    WORKSPACE_UNDO_STATES(idx%).img& = 0
    WORKSPACE_UNDO_STATES(idx%).img2& = 0
END SUB

' ============================================================================
' WORKSPACE_UNDO_save_layer_reorder - Save state before reordering a layer
' ============================================================================
SUB WORKSPACE_UNDO_save_layer_reorder (layerIndex AS INTEGER, oldZIndex AS INTEGER, newZIndex AS INTEGER)
    ' Skip if workspace undo not ready (during initialization) or in progress (during undo/redo)
    IF NOT WORKSPACE_UNDO_READY% THEN EXIT SUB
    IF WORKSPACE_UNDO_IN_PROGRESS% THEN EXIT SUB
    
    DIM idx AS INTEGER
    idx% = WUNDO_prepare_new_state%
    
    WORKSPACE_UNDO_STATES(idx%).action_type% = WUNDO_TYPE_LAYER_REORDER
    UNDO_SEQ = UNDO_SEQ + 1
    WORKSPACE_UNDO_STATES(idx%).timestamp# = UNDO_SEQ
    WORKSPACE_UNDO_STATES(idx%).layer_index% = layerIndex%
    WORKSPACE_UNDO_STATES(idx%).old_zIndex% = oldZIndex%
    WORKSPACE_UNDO_STATES(idx%).new_zIndex% = newZIndex%
    WORKSPACE_UNDO_STATES(idx%).img& = 0
    WORKSPACE_UNDO_STATES(idx%).img2& = 0
END SUB

' ============================================================================
' WORKSPACE_UNDO_save_layer_merge - Save state before merging layers
' ============================================================================
SUB WORKSPACE_UNDO_save_layer_merge (topIndex AS INTEGER, bottomIndex AS INTEGER)
    ' Skip if workspace undo not ready (during initialization) or in progress (during undo/redo)
    IF NOT WORKSPACE_UNDO_READY% THEN EXIT SUB
    IF WORKSPACE_UNDO_IN_PROGRESS% THEN EXIT SUB
    
    DIM idx AS INTEGER
    idx% = WUNDO_prepare_new_state%
    
    WORKSPACE_UNDO_STATES(idx%).action_type% = WUNDO_TYPE_LAYER_MERGE
    UNDO_SEQ = UNDO_SEQ + 1
    WORKSPACE_UNDO_STATES(idx%).timestamp# = UNDO_SEQ
    WORKSPACE_UNDO_STATES(idx%).layer_index% = topIndex%
    WORKSPACE_UNDO_STATES(idx%).merge_top_index% = topIndex%
    WORKSPACE_UNDO_STATES(idx%).merge_bottom_index% = bottomIndex%
    WORKSPACE_UNDO_STATES(idx%).old_layer_count% = LAYER_COUNT%
    
    ' Save copies of both layer contents before merge
    IF LAYERS(topIndex%).imgHandle& < -1 THEN
        WORKSPACE_UNDO_STATES(idx%).img& = _COPYIMAGE(LAYERS(topIndex%).imgHandle&)
    ELSE
        WORKSPACE_UNDO_STATES(idx%).img& = 0
    END IF
    
    IF LAYERS(bottomIndex%).imgHandle& < -1 THEN
        WORKSPACE_UNDO_STATES(idx%).img2& = _COPYIMAGE(LAYERS(bottomIndex%).imgHandle&)
    ELSE
        WORKSPACE_UNDO_STATES(idx%).img2& = 0
    END IF
    
    ' Save top layer properties (the one that will be deleted)
    WORKSPACE_UNDO_STATES(idx%).old_name$ = LAYERS(topIndex%).name$
    WORKSPACE_UNDO_STATES(idx%).old_zIndex% = LAYERS(topIndex%).zIndex%
    WORKSPACE_UNDO_STATES(idx%).old_opacity% = LAYERS(topIndex%).opacity%
    WORKSPACE_UNDO_STATES(idx%).old_visible% = LAYERS(topIndex%).visible%
    WORKSPACE_UNDO_STATES(idx%).old_opacityLock% = LAYERS(topIndex%).opacityLock%
    WORKSPACE_UNDO_STATES(idx%).old_blendMode% = LAYERS(topIndex%).blendMode%
END SUB

' ============================================================================
' MERGE_VIS_free_state_images - Free all stored images for a merge-visible state
' ============================================================================
SUB MERGE_VIS_free_state_images (stateIdx AS INTEGER)
    IF stateIdx% < 1 OR stateIdx% > 100 THEN EXIT SUB
    DIM mvfi AS INTEGER
    FOR mvfi% = 1 TO MERGE_VIS_COUNT(stateIdx%)
        IF MERGE_VIS_DATA(stateIdx%, mvfi%).img& < -1 THEN
            _FREEIMAGE MERGE_VIS_DATA(stateIdx%, mvfi%).img&
            MERGE_VIS_DATA(stateIdx%, mvfi%).img& = 0
        END IF
    NEXT mvfi%
    MERGE_VIS_COUNT(stateIdx%) = 0
END SUB

' ============================================================================
' WORKSPACE_UNDO_save_merge_visible - Save state before merging all visible layers
' sortedLayers(): array of visible layer slot indices, sorted by zIndex bottom-to-top
' sortCount: number of entries in sortedLayers()
' ============================================================================
SUB WORKSPACE_UNDO_save_merge_visible (sortedLayers() AS INTEGER, sortCount AS INTEGER)
    ' Skip if workspace undo not ready (during initialization) or in progress (during undo/redo)
    IF NOT WORKSPACE_UNDO_READY% THEN EXIT SUB
    IF WORKSPACE_UNDO_IN_PROGRESS% THEN EXIT SUB

    DIM idx AS INTEGER
    idx% = WUNDO_prepare_new_state%

    WORKSPACE_UNDO_STATES(idx%).action_type% = WUNDO_TYPE_LAYER_MERGE_VISIBLE
    UNDO_SEQ = UNDO_SEQ + 1
    WORKSPACE_UNDO_STATES(idx%).timestamp# = UNDO_SEQ
    WORKSPACE_UNDO_STATES(idx%).old_layer_count% = LAYER_COUNT%
    WORKSPACE_UNDO_STATES(idx%).layer_index% = sortCount%  ' Store count of source layers
    WORKSPACE_UNDO_STATES(idx%).merge_bottom_index% = CURRENT_LAYER%  ' Store selected layer for undo restore
    WORKSPACE_UNDO_STATES(idx%).img& = 0
    WORKSPACE_UNDO_STATES(idx%).img2& = 0

    ' Save each source layer's data into MERGE_VIS_DATA
    DIM mvsI AS INTEGER
    DIM mvsSrcIdx AS INTEGER
    MERGE_VIS_COUNT(idx%) = sortCount%
    FOR mvsI% = 1 TO sortCount%
        mvsSrcIdx% = sortedLayers%(mvsI%)
        MERGE_VIS_DATA(idx%, mvsI%).slotIndex% = mvsSrcIdx%
        MERGE_VIS_DATA(idx%, mvsI%).name$ = LAYERS(mvsSrcIdx%).name$
        MERGE_VIS_DATA(idx%, mvsI%).zIndex% = LAYERS(mvsSrcIdx%).zIndex%
        MERGE_VIS_DATA(idx%, mvsI%).opacity% = LAYERS(mvsSrcIdx%).opacity%
        MERGE_VIS_DATA(idx%, mvsI%).visible% = LAYERS(mvsSrcIdx%).visible%
        MERGE_VIS_DATA(idx%, mvsI%).opacityLock% = LAYERS(mvsSrcIdx%).opacityLock%
        MERGE_VIS_DATA(idx%, mvsI%).blendMode% = LAYERS(mvsSrcIdx%).blendMode%
        IF LAYERS(mvsSrcIdx%).imgHandle& < -1 THEN
            MERGE_VIS_DATA(idx%, mvsI%).img& = _COPYIMAGE(LAYERS(mvsSrcIdx%).imgHandle&, 32)
        ELSE
            MERGE_VIS_DATA(idx%, mvsI%).img& = 0
        END IF
    NEXT mvsI%
END SUB

' ============================================================================
' WORKSPACE_UNDO_undo - Undo the last workspace operation
' ============================================================================
SUB WORKSPACE_UNDO_undo
    IF NOT WORKSPACE_UNDO_can_undo% THEN EXIT SUB
    
    ' Prevent nested undo states from being created
    WORKSPACE_UNDO_IN_PROGRESS% = TRUE
    
    DIM state AS WORKSPACE_UNDO_STATE
    state = WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%)
    
    SELECT CASE state.action_type%
        CASE WUNDO_TYPE_LAYER_ADD
            ' Undo layer add = delete the layer
            ' First, snapshot the layer's current state back into the undo record
            ' so redo can faithfully restore it (layer may have been modified since add)
            IF state.layer_index% >= 1 AND state.layer_index% <= 64 THEN
                IF LAYERS(state.layer_index%).imgHandle& <> 0 THEN
                    WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%).old_name$ = LAYERS(state.layer_index%).name$
                    WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%).old_zIndex% = LAYERS(state.layer_index%).zIndex%
                    WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%).old_opacity% = LAYERS(state.layer_index%).opacity%
                    WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%).old_visible% = LAYERS(state.layer_index%).visible%
                    WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%).old_opacityLock% = LAYERS(state.layer_index%).opacityLock%
                    WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%).old_blendMode% = LAYERS(state.layer_index%).blendMode%
                    IF WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%).img& < -1 THEN
                        _FREEIMAGE WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%).img&
                    END IF
                    IF LAYERS(state.layer_index%).imgHandle& < -1 THEN
                        WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%).img& = _COPYIMAGE(LAYERS(state.layer_index%).imgHandle&)
                    ELSE
                        WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%).img& = 0
                    END IF
                END IF
            END IF
            IF state.layer_index% >= 1 AND state.layer_index% <= 64 AND LAYERS(state.layer_index%).imgHandle& < -1 THEN
                LAYERS_delete state.layer_index%
            END IF
            
        CASE WUNDO_TYPE_LAYER_DELETE
            ' Undo layer delete = recreate the layer
            DIM newIdx AS INTEGER
            newIdx% = LAYERS_new%
            IF newIdx% = 0 THEN
                WORKSPACE_UNDO_IN_PROGRESS% = FALSE
                EXIT SUB ' Failed to create layer
            END IF
            
            ' Restore layer properties
            LAYERS(newIdx%).name$ = state.old_name$
            LAYERS(newIdx%).zIndex% = state.old_zIndex%
            LAYERS(newIdx%).opacity% = state.old_opacity%
            LAYERS(newIdx%).visible% = state.old_visible%
            LAYERS(newIdx%).opacityLock% = state.old_opacityLock%
            LAYERS(newIdx%).blendMode% = state.old_blendMode%
            
            ' Restore layer content
            IF state.img& < -1 THEN
                IF LAYERS(newIdx%).imgHandle& < -1 THEN
                    _FREEIMAGE LAYERS(newIdx%).imgHandle&
                END IF
                LAYERS(newIdx%).imgHandle& = _COPYIMAGE(state.img&)
            END IF
            
            ' Move to correct position if needed
            WHILE LAYERS(newIdx%).zIndex% < state.old_zIndex% AND newIdx% < LAYER_COUNT%
                LAYERS_move_down newIdx%
                newIdx% = newIdx% + 1
            WEND
            WHILE LAYERS(newIdx%).zIndex% > state.old_zIndex% AND newIdx% > 1
                LAYERS_move_up newIdx%
                newIdx% = newIdx% - 1
            WEND
            
        CASE WUNDO_TYPE_LAYER_RENAME
            ' Undo rename = restore old name
            IF state.layer_index% >= 1 AND state.layer_index% <= 64 AND LAYERS(state.layer_index%).imgHandle& < -1 THEN
                LAYERS(state.layer_index%).name$ = state.old_name$
            END IF
            
        CASE WUNDO_TYPE_LAYER_REORDER
            ' Undo reorder = move back to old position
            IF state.layer_index% >= 1 AND state.layer_index% <= 64 AND LAYERS(state.layer_index%).imgHandle& < -1 THEN
                IF state.new_zIndex% > state.old_zIndex% THEN
                    ' Layer was moved up, move it back down
                    LAYERS_move_down state.layer_index%
                ELSE
                    ' Layer was moved down, move it back up
                    LAYERS_move_up state.layer_index%
                END IF
            END IF
            
        CASE WUNDO_TYPE_LAYER_MERGE
            ' Undo merge = recreate top layer and restore both contents
            ' First, restore the bottom layer's original content
            IF state.img2& < -1 AND state.merge_bottom_index% <= LAYER_COUNT% THEN
                IF LAYERS(state.merge_bottom_index%).imgHandle& < -1 THEN
                    _FREEIMAGE LAYERS(state.merge_bottom_index%).imgHandle&
                END IF
                LAYERS(state.merge_bottom_index%).imgHandle& = _COPYIMAGE(state.img2&)
            END IF
            
            ' Recreate the top layer manually (don't use LAYERS_new% - it has side effects)
            ' Find first empty slot to recreate the layer
            DIM topIdx AS INTEGER
            DIM slotIdx AS INTEGER
            topIdx% = 0
            FOR slotIdx% = 1 TO 64
                IF LAYERS(slotIdx%).imgHandle& = 0 THEN
                    topIdx% = slotIdx%
                    EXIT FOR
                END IF
            NEXT slotIdx%
            
            IF topIdx% = 0 THEN
                WORKSPACE_UNDO_IN_PROGRESS% = FALSE
                EXIT SUB ' No empty slot available
            END IF
            
            ' Create the layer image buffer manually
            LAYERS(topIdx%).imgWidth% = SCRN.canvasW&
            LAYERS(topIdx%).imgHeight% = SCRN.canvasH&
            LAYERS(topIdx%).imgHandle& = _NEWIMAGE(SCRN.canvasW&, SCRN.canvasH&, 32)
            
            ' Restore top layer properties - use saved values, not LAYERS_new% defaults
            LAYERS(topIdx%).name$ = state.old_name$
            LAYERS(topIdx%).zIndex% = state.old_zIndex%
            LAYERS(topIdx%).opacity% = state.old_opacity%
            LAYERS(topIdx%).visible% = state.old_visible%
            LAYERS(topIdx%).opacityLock% = state.old_opacityLock%
            LAYERS(topIdx%).blendMode% = state.old_blendMode%
            LAYERS(topIdx%).isSelected% = FALSE
            LAYERS(topIdx%).lastSelected% = FALSE
            
            ' Restore top layer content
            IF state.img& < -1 THEN
                IF LAYERS(topIdx%).imgHandle& < -1 THEN
                    _FREEIMAGE LAYERS(topIdx%).imgHandle&
                END IF
                LAYERS(topIdx%).imgHandle& = _COPYIMAGE(state.img&)
            END IF
            
            ' Restore layer count
            LAYER_COUNT% = state.old_layer_count%
            
            ' Select the restored top layer
            LAYERS_select topIdx%

        CASE WUNDO_TYPE_LAYER_MERGE_VISIBLE
            ' Undo merge visible = delete merged layer, recreate all source layers
            DIM mvUndoIdx AS INTEGER
            mvUndoIdx% = WORKSPACE_UNDO.current%

            ' Delete the merged result layer
            IF state.merge_top_index% >= 1 AND state.merge_top_index% <= 64 THEN
                IF LAYERS(state.merge_top_index%).imgHandle& < -1 THEN
                    ' Free the image and clear the slot directly (not via LAYERS_delete
                    ' which has side effects like adjusting zIndices of other layers)
                    IF LAYERS(state.merge_top_index%).opacityCacheImg& < -1 THEN
                        _FREEIMAGE LAYERS(state.merge_top_index%).opacityCacheImg&
                    END IF
                    _FREEIMAGE LAYERS(state.merge_top_index%).imgHandle&
                    LAYERS(state.merge_top_index%).imgHandle& = 0
                    LAYERS(state.merge_top_index%).imgWidth% = 0
                    LAYERS(state.merge_top_index%).imgHeight% = 0
                    LAYERS(state.merge_top_index%).zIndex% = 0
                    LAYERS(state.merge_top_index%).visible% = FALSE
                    LAYERS(state.merge_top_index%).isSelected% = FALSE
                    LAYERS(state.merge_top_index%).name$ = ""
                    LAYERS(state.merge_top_index%).opacity% = 255
                    LAYERS(state.merge_top_index%).opacityLock% = FALSE
                    LAYERS(state.merge_top_index%).opacityCacheImg& = 0
                    LAYERS(state.merge_top_index%).opacityCacheVal% = 0
                    LAYERS(state.merge_top_index%).contentDirty% = FALSE
                END IF
            END IF

            ' Recreate all source layers from backup
            DIM mvRestoreI AS INTEGER
            DIM mvRestoreSlot AS INTEGER
            FOR mvRestoreI% = 1 TO MERGE_VIS_COUNT(mvUndoIdx%)
                mvRestoreSlot% = MERGE_VIS_DATA(mvUndoIdx%, mvRestoreI%).slotIndex%

                ' Verify slot is available (it should be after source layers were deleted
                ' during merge and the merged layer was just cleared above)
                IF mvRestoreSlot% >= 1 AND mvRestoreSlot% <= 64 THEN
                    IF LAYERS(mvRestoreSlot%).imgHandle& <> 0 THEN
                        ' Slot occupied â€” find first empty slot as fallback
                        DIM mvFallback AS INTEGER
                        mvRestoreSlot% = 0
                        FOR mvFallback% = 1 TO 64
                            IF LAYERS(mvFallback%).imgHandle& = 0 THEN
                                mvRestoreSlot% = mvFallback%
                                EXIT FOR
                            END IF
                        NEXT mvFallback%
                    END IF
                END IF

                IF mvRestoreSlot% >= 1 AND mvRestoreSlot% <= 64 THEN
                    ' Create layer manually (not via LAYERS_new% to avoid side effects)
                    LAYERS(mvRestoreSlot%).imgHandle& = _NEWIMAGE(SCRN.canvasW&, SCRN.canvasH&, 32)
                    LAYERS(mvRestoreSlot%).imgWidth% = SCRN.canvasW&
                    LAYERS(mvRestoreSlot%).imgHeight% = SCRN.canvasH&
                    LAYERS(mvRestoreSlot%).name$ = MERGE_VIS_DATA(mvUndoIdx%, mvRestoreI%).name$
                    LAYERS(mvRestoreSlot%).zIndex% = MERGE_VIS_DATA(mvUndoIdx%, mvRestoreI%).zIndex%
                    LAYERS(mvRestoreSlot%).opacity% = MERGE_VIS_DATA(mvUndoIdx%, mvRestoreI%).opacity%
                    LAYERS(mvRestoreSlot%).visible% = MERGE_VIS_DATA(mvUndoIdx%, mvRestoreI%).visible%
                    LAYERS(mvRestoreSlot%).opacityLock% = MERGE_VIS_DATA(mvUndoIdx%, mvRestoreI%).opacityLock%
                    LAYERS(mvRestoreSlot%).blendMode% = MERGE_VIS_DATA(mvUndoIdx%, mvRestoreI%).blendMode%
                    LAYERS(mvRestoreSlot%).isSelected% = FALSE
                    LAYERS(mvRestoreSlot%).lastSelected% = FALSE
                    LAYERS(mvRestoreSlot%).contentDirty% = TRUE

                    ' Restore pixel content
                    IF MERGE_VIS_DATA(mvUndoIdx%, mvRestoreI%).img& < -1 THEN
                        IF LAYERS(mvRestoreSlot%).imgHandle& < -1 THEN
                            _FREEIMAGE LAYERS(mvRestoreSlot%).imgHandle&
                        END IF
                        LAYERS(mvRestoreSlot%).imgHandle& = _COPYIMAGE(MERGE_VIS_DATA(mvUndoIdx%, mvRestoreI%).img&, 32)
                    END IF
                END IF
            NEXT mvRestoreI%

            ' Restore layer count from saved value
            LAYER_COUNT% = state.old_layer_count%

            ' Select the layer that was selected before the merge
            IF state.merge_bottom_index% >= 1 AND state.merge_bottom_index% <= 64 THEN
                IF LAYERS(state.merge_bottom_index%).imgHandle& < -1 THEN
                    LAYERS_select state.merge_bottom_index%
                ELSE
                    ' Fallback: select first valid layer
                    DIM mvSelFb AS INTEGER
                    FOR mvSelFb% = 1 TO 64
                        IF LAYERS(mvSelFb%).imgHandle& <> 0 THEN
                            LAYERS_select mvSelFb%
                            EXIT FOR
                        END IF
                    NEXT mvSelFb%
                END IF
            END IF
    END SELECT
    
    WORKSPACE_UNDO.current% = WORKSPACE_UNDO.current% - 1
    WORKSPACE_UNDO_IN_PROGRESS% = FALSE  ' Allow undo saves again
    ' Safety net: recount layers to ensure LAYER_COUNT% is accurate
    LAYER_COUNT% = LAYERS_recount%
    ' Mark all layers contentDirty since undo may have restored layer content
    DIM wui AS INTEGER
    FOR wui% = 1 TO 64
        IF LAYERS(wui%).imgHandle& <> 0 THEN LAYERS(wui%).contentDirty% = TRUE
    NEXT wui%
    BLEND_invalidate_cache
    GUI_NEEDS_REDRAW% = TRUE
    SCENE_DIRTY% = TRUE
    FRAME_IDLE% = FALSE
END SUB

' ============================================================================
' WORKSPACE_UNDO_redo - Redo the last undone workspace operation
' ============================================================================
SUB WORKSPACE_UNDO_redo
    IF NOT WORKSPACE_UNDO_can_redo% THEN EXIT SUB
    
    ' Prevent nested undo states from being created
    WORKSPACE_UNDO_IN_PROGRESS% = TRUE
    
    WORKSPACE_UNDO.current% = WORKSPACE_UNDO.current% + 1
    
    DIM state AS WORKSPACE_UNDO_STATE
    state = WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%)
    
    SELECT CASE state.action_type%
        CASE WUNDO_TYPE_LAYER_ADD
            ' Redo layer add = recreate the layer with its saved properties and content
            DIM redoNewIdx AS INTEGER
            redoNewIdx% = LAYERS_new%
            IF redoNewIdx% > 0 THEN
                ' Restore layer properties from the saved state
                LAYERS(redoNewIdx%).name$ = state.old_name$
                LAYERS(redoNewIdx%).zIndex% = state.old_zIndex%
                LAYERS(redoNewIdx%).opacity% = state.old_opacity%
                LAYERS(redoNewIdx%).visible% = state.old_visible%
                LAYERS(redoNewIdx%).opacityLock% = state.old_opacityLock%
                LAYERS(redoNewIdx%).blendMode% = state.old_blendMode%
                LAYERS(redoNewIdx%).contentDirty% = TRUE
                ' Restore layer pixel content
                IF state.img& < -1 THEN
                    IF LAYERS(redoNewIdx%).imgHandle& < -1 THEN
                        _FREEIMAGE LAYERS(redoNewIdx%).imgHandle&
                    END IF
                    LAYERS(redoNewIdx%).imgHandle& = _COPYIMAGE(state.img&)
                END IF
            END IF
            
        CASE WUNDO_TYPE_LAYER_DELETE
            ' Redo layer delete = delete the layer again
            IF state.layer_index% >= 1 AND state.layer_index% <= 64 AND LAYERS(state.layer_index%).imgHandle& < -1 THEN
                LAYERS_delete state.layer_index%
            END IF
            
        CASE WUNDO_TYPE_LAYER_RENAME
            ' Redo rename = apply new name
            IF state.layer_index% >= 1 AND state.layer_index% <= 64 AND LAYERS(state.layer_index%).imgHandle& < -1 THEN
                LAYERS(state.layer_index%).name$ = state.new_name$
            END IF
            
        CASE WUNDO_TYPE_LAYER_REORDER
            ' Redo reorder = move to new position
            IF state.layer_index% >= 1 AND state.layer_index% <= 64 AND LAYERS(state.layer_index%).imgHandle& < -1 THEN
                IF state.new_zIndex% > state.old_zIndex% THEN
                    LAYERS_move_up state.layer_index%
                ELSE
                    LAYERS_move_down state.layer_index%
                END IF
            END IF
            
        CASE WUNDO_TYPE_LAYER_MERGE
            ' Redo merge = merge the layers again
            LAYERS_merge_down state.merge_top_index%

        CASE WUNDO_TYPE_LAYER_MERGE_VISIBLE
            ' Redo merge visible = merge the visible layers again
            ' WORKSPACE_UNDO_IN_PROGRESS% is already TRUE (set by redo wrapper),
            ' so LAYERS_merge_visible's internal save call and LAYERS_new%/delete
            ' auto-saves will all be suppressed.
            LAYERS_merge_visible
    END SELECT
    
    WORKSPACE_UNDO_IN_PROGRESS% = FALSE  ' Allow undo saves again
    ' Safety net: recount layers to ensure LAYER_COUNT% is accurate
    LAYER_COUNT% = LAYERS_recount%
    ' Mark all layers contentDirty since redo may have restored layer content
    DIM wuri AS INTEGER
    FOR wuri% = 1 TO 64
        IF LAYERS(wuri%).imgHandle& <> 0 THEN LAYERS(wuri%).contentDirty% = TRUE
    NEXT wuri%
    BLEND_invalidate_cache
    GUI_NEEDS_REDRAW% = TRUE
    SCENE_DIRTY% = TRUE
    FRAME_IDLE% = FALSE
END SUB

' ============================================================================
' WORKSPACE_UNDO_can_undo - Check if undo is available
' ============================================================================
FUNCTION WORKSPACE_UNDO_can_undo%
    WORKSPACE_UNDO_can_undo% = (WORKSPACE_UNDO.current% > 0)
END FUNCTION

' ============================================================================
' WORKSPACE_UNDO_can_redo - Check if redo is available
' ============================================================================
FUNCTION WORKSPACE_UNDO_can_redo%
    WORKSPACE_UNDO_can_redo% = (WORKSPACE_UNDO.current% < WORKSPACE_UNDO.count%)
END FUNCTION

' ============================================================================
' WORKSPACE_UNDO_get_last_timestamp - Get timestamp of most recent undo state
' Returns 0 if no states exist
' ============================================================================
FUNCTION WORKSPACE_UNDO_get_last_timestamp#
    IF WORKSPACE_UNDO.current% > 0 THEN
        WORKSPACE_UNDO_get_last_timestamp# = WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current%).timestamp#
    ELSE
        WORKSPACE_UNDO_get_last_timestamp# = 0
    END IF
END FUNCTION
