''
' DRAW - TOOLS/CUSTOM-BRUSH.BM
' =============================================================================
' Custom brush tool implementation.
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initialize the custom brush system
'
SUB CUSTOM_BRUSH_init ()
    CUSTOM_BRUSH.ACTIVE% = FALSE
    CUSTOM_BRUSH.WIDTH% = 0
    CUSTOM_BRUSH.HEIGHT% = 0
    CUSTOM_BRUSH.ORIG_WIDTH% = 0
    CUSTOM_BRUSH.ORIG_HEIGHT% = 0
    CUSTOM_BRUSH.IMAGE& = 0
    CUSTOM_BRUSH.FLIP_H% = FALSE
    CUSTOM_BRUSH.FLIP_V% = FALSE
    CUSTOM_BRUSH.HAS_TRANSPARENCY% = FALSE
    CUSTOM_BRUSH.BG_COLOR~& = 0
    CUSTOM_BRUSH.SCALE! = 1.0
    CUSTOM_BRUSH.RECOLOR_MODE% = FALSE
    CUSTOM_BRUSH.SHOW_OUTLINE% = TRUE
END SUB


''
' Reset/clear the custom brush
' Frees the image handle and resets all state
'
SUB CUSTOM_BRUSH_reset ()
    ' Free the image if it exists
    IF CUSTOM_BRUSH.IMAGE& <> 0 THEN
        _FREEIMAGE CUSTOM_BRUSH.IMAGE&
        CUSTOM_BRUSH.IMAGE& = 0
    END IF
    
    CUSTOM_BRUSH.ACTIVE% = FALSE
    CUSTOM_BRUSH.WIDTH% = 0
    CUSTOM_BRUSH.HEIGHT% = 0
    CUSTOM_BRUSH.ORIG_WIDTH% = 0
    CUSTOM_BRUSH.ORIG_HEIGHT% = 0
    CUSTOM_BRUSH.FLIP_H% = FALSE
    CUSTOM_BRUSH.FLIP_V% = FALSE
    CUSTOM_BRUSH.HAS_TRANSPARENCY% = FALSE
    CUSTOM_BRUSH.BG_COLOR~& = 0
    CUSTOM_BRUSH.SCALE! = 1.0
    CUSTOM_BRUSH.RECOLOR_MODE% = FALSE
    CUSTOM_BRUSH.SHOW_OUTLINE% = TRUE
END SUB


''
' Check if a custom brush is currently active
' @return INTEGER -1 if active, 0 if not
'
FUNCTION CUSTOM_BRUSH_is_active% ()
    CUSTOM_BRUSH_is_active% = CUSTOM_BRUSH.ACTIVE%
END FUNCTION


''
' Capture the current marquee selection as a custom brush
' Uses smart transparency: if background color matches pixels, make transparent
'
SUB CUSTOM_BRUSH_capture_from_marquee ()
    ' Check if marquee is active and has a valid selection
    IF NOT MARQUEE.ACTIVE% THEN EXIT SUB
    IF MARQUEE.BOX.w <= 0 OR MARQUEE.BOX.h <= 0 THEN EXIT SUB
    
    ' Clear any existing brush
    CUSTOM_BRUSH_reset
    
    ' Get the marquee bounds
    DIM sel_x AS INTEGER, sel_y AS INTEGER
    DIM sel_w AS INTEGER, sel_h AS INTEGER
    sel_x% = MARQUEE.BOX.x
    sel_y% = MARQUEE.BOX.y
    sel_w% = MARQUEE.BOX.w
    sel_h% = MARQUEE.BOX.h
    
    ' Store brush dimensions
    CUSTOM_BRUSH.WIDTH% = sel_w%
    CUSTOM_BRUSH.HEIGHT% = sel_h%
    CUSTOM_BRUSH.ORIG_WIDTH% = sel_w%
    CUSTOM_BRUSH.ORIG_HEIGHT% = sel_h%
    
    ' Create a new image for the brush
    CUSTOM_BRUSH.IMAGE& = _NEWIMAGE(sel_w%, sel_h%, 32)
    
    ' Copy the selected area from the painting surface
    DIM old_dest AS LONG
    DIM old_source AS LONG
    old_dest& = _DEST
    old_source& = _SOURCE
    
    _SOURCE SCRN.PAINTING&
    _DEST CUSTOM_BRUSH.IMAGE&
    
    ' Clear brush image with full transparency first
    CLS , _RGBA32(0, 0, 0, 0)
    
    ' Store background color for transparency (strip alpha for comparison)
    DIM bg_r AS INTEGER, bg_g AS INTEGER, bg_b AS INTEGER
    bg_r% = _RED32(PAINT_BG_COLOR~&)
    bg_g% = _GREEN32(PAINT_BG_COLOR~&)
    bg_b% = _BLUE32(PAINT_BG_COLOR~&)
    
    ' Copy pixels - make BG color pixels transparent, others opaque
    DIM px AS INTEGER, py AS INTEGER
    DIM pixel_color AS _UNSIGNED LONG
    DIM pixel_r AS INTEGER, pixel_g AS INTEGER, pixel_b AS INTEGER
    
    FOR py% = 0 TO sel_h% - 1
        FOR px% = 0 TO sel_w% - 1
            pixel_color~& = POINT(sel_x% + px%, sel_y% + py%)
            
            ' Extract RGB components (ignore alpha from source)
            pixel_r% = _RED32(pixel_color~&)
            pixel_g% = _GREEN32(pixel_color~&)
            pixel_b% = _BLUE32(pixel_color~&)
            
            ' Check if this pixel matches the current background color
            IF pixel_r% = bg_r% AND pixel_g% = bg_g% AND pixel_b% = bg_b% THEN
                ' Leave transparent (already cleared to transparent)
            ELSE
                ' Copy as opaque pixel
                PSET (px%, py%), _RGB32(pixel_r%, pixel_g%, pixel_b%)
            END IF
        NEXT px%
    NEXT py%
    
    ' Always enable transparency since we're using BG color matching
    CUSTOM_BRUSH.HAS_TRANSPARENCY% = TRUE
    CUSTOM_BRUSH.BG_COLOR~& = PAINT_BG_COLOR~&
    
    _SOURCE old_source&
    _DEST old_dest&
    
    ' Activate the brush
    CUSTOM_BRUSH.ACTIVE% = TRUE
    CUSTOM_BRUSH.FLIP_H% = FALSE
    CUSTOM_BRUSH.FLIP_V% = FALSE
    CUSTOM_BRUSH.SCALE! = 1.0
    
    ' Clear the marquee selection
    MARQUEE_reset
END SUB


''
' Render the custom brush at the given position
' @param x INTEGER X position (top-left corner)
' @param y INTEGER Y position (top-left corner)
' @param dest LONG Destination image handle
'
SUB CUSTOM_BRUSH_render (x AS INTEGER, y AS INTEGER, dest AS LONG)
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    IF CUSTOM_BRUSH.IMAGE& = 0 THEN EXIT SUB
    
    DIM old_dest AS LONG
    DIM old_source AS LONG
    old_dest& = _DEST
    old_source& = _SOURCE
    
    ' Enable blending on destination for proper alpha transparency
    _BLEND dest&
    _DEST dest&
    
    ' Calculate source coordinates based on flip flags
    DIM src_x1 AS INTEGER, src_y1 AS INTEGER
    DIM src_x2 AS INTEGER, src_y2 AS INTEGER
    
    IF CUSTOM_BRUSH.FLIP_H% THEN
        src_x1% = CUSTOM_BRUSH.ORIG_WIDTH% - 1
        src_x2% = 0
    ELSE
        src_x1% = 0
        src_x2% = CUSTOM_BRUSH.ORIG_WIDTH% - 1
    END IF
    
    IF CUSTOM_BRUSH.FLIP_V% THEN
        src_y1% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1
        src_y2% = 0
    ELSE
        src_y1% = 0
        src_y2% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1
    END IF
    
    ' Calculate scaled destination size
    DIM dest_w AS INTEGER, dest_h AS INTEGER
    dest_w% = CUSTOM_BRUSH.WIDTH%
    dest_h% = CUSTOM_BRUSH.HEIGHT%
    
    ' If recolor mode is active, render pixel by pixel with color replacement
    IF CUSTOM_BRUSH.RECOLOR_MODE% THEN
        _LOGINFO "Rendering with RECOLOR mode - FG color: " + STR$(_RED32(PAINT_COLOR~&)) + "," + STR$(_GREEN32(PAINT_COLOR~&)) + "," + STR$(_BLUE32(PAINT_COLOR~&))
        DIM px AS INTEGER, py AS INTEGER
        DIM src_px AS INTEGER, src_py AS INTEGER
        DIM pixel_color AS _UNSIGNED LONG
        DIM alpha_value AS INTEGER
        
        _SOURCE CUSTOM_BRUSH.IMAGE&
        FOR py% = 0 TO dest_h% - 1
            FOR px% = 0 TO dest_w% - 1
                ' Map destination coordinates to source coordinates
                IF CUSTOM_BRUSH.FLIP_H% THEN
                    src_px% = CUSTOM_BRUSH.ORIG_WIDTH% - 1 - px%
                ELSE
                    src_px% = px%
                END IF
                
                IF CUSTOM_BRUSH.FLIP_V% THEN
                    src_py% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1 - py%
                ELSE
                    src_py% = py%
                END IF
                
                ' Get pixel from source
                pixel_color~& = POINT(src_px%, src_py%)
                alpha_value% = _ALPHA32(pixel_color~&)
                
                ' Only draw non-transparent pixels, using FG color
                IF alpha_value% > 0 THEN
                    ' Use FG color with full opacity (255) for solid recolor
                    PSET (x% + px%, y% + py%), _RGB32(_RED32(PAINT_COLOR~&), _GREEN32(PAINT_COLOR~&), _BLUE32(PAINT_COLOR~&))
                END IF
            NEXT px%
        NEXT py%
    ELSE
        ' Use _PUTIMAGE to render with transparency support and scaling
        _PUTIMAGE (x%, y%)-(x% + dest_w% - 1, y% + dest_h% - 1), CUSTOM_BRUSH.IMAGE&, dest&, (src_x1%, src_y1%)-(src_x2%, src_y2%)
    END IF
    
    _SOURCE old_source&
    _DEST old_dest&
END SUB


''
' Stamp the custom brush onto the painting surface at the given position
' @param x INTEGER X position (top-left corner)
' @param y INTEGER Y position (top-left corner)
'
SUB CUSTOM_BRUSH_stamp (x AS INTEGER, y AS INTEGER)
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH_render x%, y%, SCRN.PAINTING&
END SUB


''
' Toggle horizontal flip
'
SUB CUSTOM_BRUSH_toggle_flip_h ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH.FLIP_H% = NOT CUSTOM_BRUSH.FLIP_H%
END SUB


''
' Toggle vertical flip
'
SUB CUSTOM_BRUSH_toggle_flip_v ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH.FLIP_V% = NOT CUSTOM_BRUSH.FLIP_V%
END SUB


''
' Render the custom brush with zoom scaling for cursor display
' @param x INTEGER X position (top-left corner)
' @param y INTEGER Y position (top-left corner)
' @param dest LONG Destination image handle
' @param zoom SINGLE Zoom ratio for scaling
'
SUB CUSTOM_BRUSH_render_scaled (x AS INTEGER, y AS INTEGER, dest AS LONG, zoom AS SINGLE)
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    IF CUSTOM_BRUSH.IMAGE& = 0 THEN EXIT SUB
    
    DIM old_dest AS LONG
    DIM old_source AS LONG
    old_dest& = _DEST
    old_source& = _SOURCE
    
    ' Enable blending on destination for proper alpha transparency
    _BLEND dest&
    _DEST dest&
    
    ' Calculate scaled dimensions
    DIM scaled_w AS INTEGER, scaled_h AS INTEGER
    scaled_w% = CUSTOM_BRUSH.WIDTH% * CUSTOM_BRUSH.SCALE! * zoom!
    scaled_h% = CUSTOM_BRUSH.HEIGHT% * CUSTOM_BRUSH.SCALE! * zoom!
    
    ' Calculate source coordinates based on flip flags
    DIM src_x1 AS INTEGER, src_y1 AS INTEGER
    DIM src_x2 AS INTEGER, src_y2 AS INTEGER
    
    IF CUSTOM_BRUSH.FLIP_H% THEN
        src_x1% = CUSTOM_BRUSH.ORIG_WIDTH% - 1
        src_x2% = 0
    ELSE
        src_x1% = 0
        src_x2% = CUSTOM_BRUSH.ORIG_WIDTH% - 1
    END IF
    
    IF CUSTOM_BRUSH.FLIP_V% THEN
        src_y1% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1
        src_y2% = 0
    ELSE
        src_y1% = 0
        src_y2% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1
    END IF
    
    ' If recolor mode is active, create temporary recolored brush
    IF CUSTOM_BRUSH.RECOLOR_MODE% THEN
        DIM temp_brush AS LONG
        temp_brush& = _NEWIMAGE(CUSTOM_BRUSH.ORIG_WIDTH%, CUSTOM_BRUSH.ORIG_HEIGHT%, 32)
        
        DIM old_dest2 AS LONG
        old_dest2& = _DEST
        _DEST temp_brush&
        CLS , _RGBA32(0, 0, 0, 0) ' Clear with full transparency
        
        ' Render recolored brush to temp image
        DIM px AS INTEGER, py AS INTEGER
        DIM pixel_color AS _UNSIGNED LONG
        DIM alpha_value AS INTEGER
        
        _SOURCE CUSTOM_BRUSH.IMAGE&
        FOR py% = 0 TO CUSTOM_BRUSH.ORIG_HEIGHT% - 1
            FOR px% = 0 TO CUSTOM_BRUSH.ORIG_WIDTH% - 1
                pixel_color~& = POINT(px%, py%)
                alpha_value% = _ALPHA32(pixel_color~&)
                
                ' Only draw non-transparent pixels, using FG color with full opacity
                IF alpha_value% > 0 THEN
                    PSET (px%, py%), _RGB32(_RED32(PAINT_COLOR~&), _GREEN32(PAINT_COLOR~&), _BLUE32(PAINT_COLOR~&))
                END IF
            NEXT px%
        NEXT py%
        
        _DEST old_dest2&
        
        ' Now use _PUTIMAGE with the recolored temp brush
        _PUTIMAGE (x%, y%)-(x% + scaled_w% - 1, y% + scaled_h% - 1), temp_brush&, dest&, (src_x1%, src_y1%)-(src_x2%, src_y2%)
        
        _FREEIMAGE temp_brush&
    ELSE
        ' Use _PUTIMAGE to render with transparency support and scaling
        _PUTIMAGE (x%, y%)-(x% + scaled_w% - 1, y% + scaled_h% - 1), CUSTOM_BRUSH.IMAGE&, dest&, (src_x1%, src_y1%)-(src_x2%, src_y2%)
    END IF
    
    _SOURCE old_source&
    _DEST old_dest&
END SUB


''
' Scale custom brush up by 100% (double size)
'
SUB CUSTOM_BRUSH_scale_up ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH.SCALE! = CUSTOM_BRUSH.SCALE! * 2.0
    CUSTOM_BRUSH.WIDTH% = CUSTOM_BRUSH.ORIG_WIDTH% * CUSTOM_BRUSH.SCALE!
    CUSTOM_BRUSH.HEIGHT% = CUSTOM_BRUSH.ORIG_HEIGHT% * CUSTOM_BRUSH.SCALE!
END SUB


''
' Scale custom brush down by 100% (half size)
'
SUB CUSTOM_BRUSH_scale_down ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    IF CUSTOM_BRUSH.SCALE! <= 0.125 THEN EXIT SUB ' Minimum scale of 12.5%
    CUSTOM_BRUSH.SCALE! = CUSTOM_BRUSH.SCALE! / 2.0
    CUSTOM_BRUSH.WIDTH% = CUSTOM_BRUSH.ORIG_WIDTH% * CUSTOM_BRUSH.SCALE!
    CUSTOM_BRUSH.HEIGHT% = CUSTOM_BRUSH.ORIG_HEIGHT% * CUSTOM_BRUSH.SCALE!
END SUB


''
' Reset custom brush scale to original size
'
SUB CUSTOM_BRUSH_scale_reset ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH.SCALE! = 1.0
    CUSTOM_BRUSH.WIDTH% = CUSTOM_BRUSH.ORIG_WIDTH%
    CUSTOM_BRUSH.HEIGHT% = CUSTOM_BRUSH.ORIG_HEIGHT%
END SUB


''
' Toggle recolor mode for custom brush
' When active, replaces all non-transparent pixels with the current FG color
'
SUB CUSTOM_BRUSH_toggle_recolor ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH.RECOLOR_MODE% = NOT CUSTOM_BRUSH.RECOLOR_MODE%
    IF CUSTOM_BRUSH.RECOLOR_MODE% THEN
        _LOGINFO "RECOLOR MODE: ON"
    ELSE
        _LOGINFO "RECOLOR MODE: OFF"
    END IF
END SUB


''
' Toggle outline visibility for custom brush cursor preview
'
SUB CUSTOM_BRUSH_toggle_outline ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH.SHOW_OUTLINE% = NOT CUSTOM_BRUSH.SHOW_OUTLINE%
END SUB


''
' Export custom brush as PNG file
' @param filepath STRING Full path for the PNG file
'
SUB CUSTOM_BRUSH_export_png (filepath AS STRING)
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN
        _LOGERROR "Export failed: No custom brush active"
        EXIT SUB
    END IF
    IF CUSTOM_BRUSH.IMAGE& = 0 THEN
        _LOGERROR "Export failed: No brush image"
        EXIT SUB
    END IF
    
    _LOGINFO "Exporting custom brush to: " + filepath$
    _LOGINFO "Brush dimensions: " + _TRIM$(STR$(CUSTOM_BRUSH.ORIG_WIDTH%)) + "x" + _TRIM$(STR$(CUSTOM_BRUSH.ORIG_HEIGHT%))
    
    ' Create a temporary image at the original brush size
    DIM temp_img AS LONG
    temp_img& = _NEWIMAGE(CUSTOM_BRUSH.ORIG_WIDTH%, CUSTOM_BRUSH.ORIG_HEIGHT%, 32)
    
    IF temp_img& = 0 THEN
        _LOGERROR "Export failed: Could not create temporary image"
        EXIT SUB
    END IF
    
    DIM old_dest AS LONG
    old_dest& = _DEST
    
    _DEST temp_img&
    CLS , _RGBA32(0, 0, 0, 0) ' Clear with transparency
    
    ' Copy brush to temp image (respecting flips)
    DIM src_x1 AS INTEGER, src_y1 AS INTEGER
    DIM src_x2 AS INTEGER, src_y2 AS INTEGER
    
    IF CUSTOM_BRUSH.FLIP_H% THEN
        src_x1% = CUSTOM_BRUSH.ORIG_WIDTH% - 1
        src_x2% = 0
    ELSE
        src_x1% = 0
        src_x2% = CUSTOM_BRUSH.ORIG_WIDTH% - 1
    END IF
    
    IF CUSTOM_BRUSH.FLIP_V% THEN
        src_y1% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1
        src_y2% = 0
    ELSE
        src_y1% = 0
        src_y2% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1
    END IF
    
    _PUTIMAGE (0, 0)-(CUSTOM_BRUSH.ORIG_WIDTH% - 1, CUSTOM_BRUSH.ORIG_HEIGHT% - 1), CUSTOM_BRUSH.IMAGE&, temp_img&, (src_x1%, src_y1%)-(src_x2%, src_y2%)
    
    ' Save as PNG
    _DEST old_dest&
    _SAVEIMAGE filepath$, temp_img&
    
    _LOGINFO "Brush successfully exported to: " + filepath$
    
    ' Clean up
    _FREEIMAGE temp_img&
END SUB
