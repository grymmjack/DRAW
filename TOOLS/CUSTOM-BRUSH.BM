''
' DRAW - TOOLS/CUSTOM-BRUSH.BM
' =============================================================================
' Custom brush tool implementation.
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initialize the custom brush system
'
SUB CUSTOM_BRUSH_init ()
    CUSTOM_BRUSH.ACTIVE% = FALSE
    CUSTOM_BRUSH.WIDTH% = 0
    CUSTOM_BRUSH.HEIGHT% = 0
    CUSTOM_BRUSH.ORIG_WIDTH% = 0
    CUSTOM_BRUSH.ORIG_HEIGHT% = 0
    CUSTOM_BRUSH.IMAGE& = 0
    CUSTOM_BRUSH.FLIP_H% = FALSE
    CUSTOM_BRUSH.FLIP_V% = FALSE
    CUSTOM_BRUSH.HAS_TRANSPARENCY% = FALSE
    CUSTOM_BRUSH.BG_COLOR~& = 0
    CUSTOM_BRUSH.SCALE! = 1.0
    CUSTOM_BRUSH.RECOLOR_MODE% = FALSE
    CUSTOM_BRUSH.SHOW_OUTLINE% = TRUE
END SUB


''
' Reset/clear the custom brush
' Frees the image handle and resets all state
'
SUB CUSTOM_BRUSH_reset ()
    ' Free the image if it exists
    IF CUSTOM_BRUSH.IMAGE& < -1 THEN
        _FREEIMAGE CUSTOM_BRUSH.IMAGE&
        CUSTOM_BRUSH.IMAGE& = 0
    END IF
    
    CUSTOM_BRUSH.ACTIVE% = FALSE
    CUSTOM_BRUSH.WIDTH% = 0
    CUSTOM_BRUSH.HEIGHT% = 0
    CUSTOM_BRUSH.ORIG_WIDTH% = 0
    CUSTOM_BRUSH.ORIG_HEIGHT% = 0
    CUSTOM_BRUSH.FLIP_H% = FALSE
    CUSTOM_BRUSH.FLIP_V% = FALSE
    CUSTOM_BRUSH.HAS_TRANSPARENCY% = FALSE
    CUSTOM_BRUSH.BG_COLOR~& = 0
    CUSTOM_BRUSH.SCALE! = 1.0
    CUSTOM_BRUSH.RECOLOR_MODE% = FALSE
    CUSTOM_BRUSH.SHOW_OUTLINE% = TRUE
END SUB


''
' Check if a custom brush is currently active
' @return INTEGER -1 if active, 0 if not
'
FUNCTION CUSTOM_BRUSH_is_active% ()
    CUSTOM_BRUSH_is_active% = CUSTOM_BRUSH.ACTIVE%
END FUNCTION


''
' Capture the current marquee selection as a custom brush
' Uses smart transparency: if background color matches pixels, make transparent
'
SUB CUSTOM_BRUSH_capture_from_marquee ()
    ' Check if marquee is active and has a valid selection
    IF NOT MARQUEE.ACTIVE% THEN EXIT SUB
    IF MARQUEE.BOX.w <= 0 OR MARQUEE.BOX.h <= 0 THEN EXIT SUB
    
    ' Clear any existing brush
    CUSTOM_BRUSH_reset
    
    ' Get the marquee bounds
    DIM sel_x AS INTEGER, sel_y AS INTEGER
    DIM sel_w AS INTEGER, sel_h AS INTEGER
    sel_x% = MARQUEE.BOX.x
    sel_y% = MARQUEE.BOX.y
    sel_w% = MARQUEE.BOX.w
    sel_h% = MARQUEE.BOX.h
    
    ' Store brush dimensions
    CUSTOM_BRUSH.WIDTH% = sel_w%
    CUSTOM_BRUSH.HEIGHT% = sel_h%
    CUSTOM_BRUSH.ORIG_WIDTH% = sel_w%
    CUSTOM_BRUSH.ORIG_HEIGHT% = sel_h%
    
    ' Create a new image for the brush
    CUSTOM_BRUSH.IMAGE& = _NEWIMAGE(sel_w%, sel_h%, 32)
    
    ' Copy the selected area from the painting surface
    DIM old_dest AS LONG
    DIM old_source AS LONG
    old_dest& = _DEST
    old_source& = _SOURCE
    
    _SOURCE LAYER_current_image& ' Use current layer, not SCRN.PAINTING
    _DEST CUSTOM_BRUSH.IMAGE&
    
    ' Clear brush image with full transparency first
    CLS , _RGBA32(0, 0, 0, 0)
    
    ' Store background color for transparency (strip alpha for comparison)
    DIM bg_r AS INTEGER, bg_g AS INTEGER, bg_b AS INTEGER
    bg_r% = _RED32(PAINT_BG_COLOR~&)
    bg_g% = _GREEN32(PAINT_BG_COLOR~&)
    bg_b% = _BLUE32(PAINT_BG_COLOR~&)
    
    ' Copy pixels - preserve source alpha, make BG color pixels transparent
    DIM px AS INTEGER, py AS INTEGER
    DIM pixel_color AS _UNSIGNED LONG
    DIM pixel_r AS INTEGER, pixel_g AS INTEGER, pixel_b AS INTEGER
    DIM pixel_alpha AS INTEGER
    
    FOR py% = 0 TO sel_h% - 1
        FOR px% = 0 TO sel_w% - 1
            pixel_color~& = POINT(sel_x% + px%, sel_y% + py%)
            
            ' Extract RGBA components
            pixel_r% = _RED32(pixel_color~&)
            pixel_g% = _GREEN32(pixel_color~&)
            pixel_b% = _BLUE32(pixel_color~&)
            pixel_alpha% = _ALPHA32(pixel_color~&)
            
            ' If source pixel is already transparent, keep it transparent
            IF pixel_alpha% = 0 THEN
                ' Leave transparent (already cleared to transparent)
            ' Check if this pixel matches the current background color
            ELSEIF pixel_r% = bg_r% AND pixel_g% = bg_g% AND pixel_b% = bg_b% THEN
                ' Make BG color transparent
            ELSE
                ' Copy as opaque pixel, preserving source alpha
                PSET (px%, py%), _RGBA32(pixel_r%, pixel_g%, pixel_b%, pixel_alpha%)
            END IF
        NEXT px%
    NEXT py%
    
    ' Always enable transparency since we're using BG color matching
    CUSTOM_BRUSH.HAS_TRANSPARENCY% = TRUE
    CUSTOM_BRUSH.BG_COLOR~& = PAINT_BG_COLOR~&
    
    _SOURCE old_source&
    _DEST old_dest&
    
    ' Activate the brush
    CUSTOM_BRUSH.ACTIVE% = TRUE
    CUSTOM_BRUSH.FLIP_H% = FALSE
    CUSTOM_BRUSH.FLIP_V% = FALSE
    CUSTOM_BRUSH.SCALE! = 1.0
    
    ' Clear the marquee selection
    MARQUEE_reset
END SUB


''
' Render the custom brush at the given position
' @param x INTEGER X position (top-left corner)
' @param y INTEGER Y position (top-left corner)
' @param dest LONG Destination image handle
'
SUB CUSTOM_BRUSH_render (x AS INTEGER, y AS INTEGER, dest AS LONG)
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    IF CUSTOM_BRUSH.IMAGE& = 0 THEN EXIT SUB
    
    DIM old_dest AS LONG
    DIM old_source AS LONG
    old_dest& = _DEST
    old_source& = _SOURCE
    
    ' Enable blending on destination for proper alpha transparency
    _BLEND dest&
    _DEST dest&
    
    ' Calculate source coordinates based on flip flags
    DIM src_x1 AS INTEGER, src_y1 AS INTEGER
    DIM src_x2 AS INTEGER, src_y2 AS INTEGER
    
    IF CUSTOM_BRUSH.FLIP_H% THEN
        src_x1% = CUSTOM_BRUSH.ORIG_WIDTH% - 1
        src_x2% = 0
    ELSE
        src_x1% = 0
        src_x2% = CUSTOM_BRUSH.ORIG_WIDTH% - 1
    END IF
    
    IF CUSTOM_BRUSH.FLIP_V% THEN
        src_y1% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1
        src_y2% = 0
    ELSE
        src_y1% = 0
        src_y2% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1
    END IF
    
    ' Calculate scaled destination size
    DIM dest_w AS INTEGER, dest_h AS INTEGER
    dest_w% = CUSTOM_BRUSH.WIDTH%
    dest_h% = CUSTOM_BRUSH.HEIGHT%
    
    ' If recolor mode is active, render pixel by pixel with color replacement
    IF CUSTOM_BRUSH.RECOLOR_MODE% THEN
        _LOGINFO "Rendering with RECOLOR mode - FG color: " + STR$(_RED32(PAINT_COLOR~&)) + "," + STR$(_GREEN32(PAINT_COLOR~&)) + "," + STR$(_BLUE32(PAINT_COLOR~&))
        DIM px AS INTEGER, py AS INTEGER
        DIM src_px AS INTEGER, src_py AS INTEGER
        DIM pixel_color AS _UNSIGNED LONG
        DIM alpha_value AS INTEGER
        
        _SOURCE CUSTOM_BRUSH.IMAGE&
        FOR py% = 0 TO dest_h% - 1
            FOR px% = 0 TO dest_w% - 1
                ' Map destination coordinates to source coordinates
                IF CUSTOM_BRUSH.FLIP_H% THEN
                    src_px% = CUSTOM_BRUSH.ORIG_WIDTH% - 1 - px%
                ELSE
                    src_px% = px%
                END IF
                
                IF CUSTOM_BRUSH.FLIP_V% THEN
                    src_py% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1 - py%
                ELSE
                    src_py% = py%
                END IF
                
                ' Get pixel from source
                pixel_color~& = POINT(src_px%, src_py%)
                alpha_value% = _ALPHA32(pixel_color~&)
                
                ' Only draw non-transparent pixels, using FG color
                IF alpha_value% > 0 THEN
                    PSET (x% + px%, y% + py%), _RGBA32(_RED32(PAINT_COLOR~&), _GREEN32(PAINT_COLOR~&), _BLUE32(PAINT_COLOR~&), 255)
                END IF
            NEXT px%
        NEXT py%
    ELSE
        ' Use _PUTIMAGE to render with transparency support and scaling
        _PUTIMAGE (x%, y%)-(x% + dest_w% - 1, y% + dest_h% - 1), CUSTOM_BRUSH.IMAGE&, dest&, (src_x1%, src_y1%)-(src_x2%, src_y2%)
    END IF
    
    _SOURCE old_source&
    _DEST old_dest&
END SUB


''
' Stamp the custom brush onto the painting surface at the given position
' @param x INTEGER X position (top-left corner)
' @param y INTEGER Y position (top-left corner)
'
SUB CUSTOM_BRUSH_stamp (x AS INTEGER, y AS INTEGER)
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    
    ' Stamp at the master position
    CUSTOM_BRUSH_render x%, y%, LAYER_current_image&
    
    ' Apply symmetry if enabled - mirror the stamp around symmetry center
    IF SYMMETRY.MODE% > 0 THEN
        DIM mx(0 TO 7) AS INTEGER
        DIM my(0 TO 7) AS INTEGER
        DIM sym_count AS INTEGER
        DIM sym_i AS INTEGER
        DIM brush_cx AS INTEGER, brush_cy AS INTEGER
        DIM mir_x AS INTEGER, mir_y AS INTEGER
        
        ' Calculate the center of the brush stamp (symmetry mirrors around center, not corner)
        brush_cx% = x% + CUSTOM_BRUSH.WIDTH% \ 2
        brush_cy% = y% + CUSTOM_BRUSH.HEIGHT% \ 2
        
        ' Get mirrored center points
        SYMMETRY_get_mirrored_points brush_cx%, brush_cy%, mx%(), my%(), sym_count%
        
        ' Stamp at each mirrored position (convert back from center to top-left corner)
        FOR sym_i% = 0 TO sym_count% - 1
            mir_x% = mx%(sym_i%) - CUSTOM_BRUSH.WIDTH% \ 2
            mir_y% = my%(sym_i%) - CUSTOM_BRUSH.HEIGHT% \ 2
            CUSTOM_BRUSH_render mir_x%, mir_y%, LAYER_current_image&
        NEXT sym_i%
    END IF
END SUB


''
' Toggle horizontal flip
'
SUB CUSTOM_BRUSH_toggle_flip_h ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH.FLIP_H% = NOT CUSTOM_BRUSH.FLIP_H%
    SCENE_DIRTY% = TRUE
    GUI_NEEDS_REDRAW% = TRUE
    FRAME_IDLE% = FALSE
END SUB


''
' Toggle vertical flip
'
SUB CUSTOM_BRUSH_toggle_flip_v ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH.FLIP_V% = NOT CUSTOM_BRUSH.FLIP_V%
    SCENE_DIRTY% = TRUE
    GUI_NEEDS_REDRAW% = TRUE
    FRAME_IDLE% = FALSE
END SUB


''
' Rotate custom brush 90 degrees clockwise
' Physically rotates the pixel data in CUSTOM_BRUSH.IMAGE&
' and swaps width/height dimensions.
'
SUB CUSTOM_BRUSH_rotate_cw ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    IF CUSTOM_BRUSH.IMAGE& = 0 THEN EXIT SUB
    
    DIM old_w AS INTEGER, old_h AS INTEGER
    DIM new_img AS LONG
    DIM old_source AS LONG, old_dest AS LONG
    DIM px AS INTEGER, py AS INTEGER
    DIM pixel_color AS _UNSIGNED LONG
    
    old_w% = CUSTOM_BRUSH.ORIG_WIDTH%
    old_h% = CUSTOM_BRUSH.ORIG_HEIGHT%
    
    ' Create new image with swapped dimensions (W becomes H, H becomes W)
    new_img& = _NEWIMAGE(old_h%, old_w%, 32)
    
    old_source& = _SOURCE
    old_dest& = _DEST
    
    ' Clear new image with transparency
    _DEST new_img&
    CLS , _RGBA32(0, 0, 0, 0)
    
    ' Rotate: dst(y, w-1-x) <- src(x, y)  for CW 90
    ' Equivalently: dst(old_h-1-sy, sx) <- src(sx, sy)
    _SOURCE CUSTOM_BRUSH.IMAGE&
    _DONTBLEND new_img&
    FOR py% = 0 TO old_h% - 1
        FOR px% = 0 TO old_w% - 1
            pixel_color~& = POINT(px%, py%)
            PSET (old_h% - 1 - py%, px%), pixel_color~&
        NEXT px%
    NEXT py%
    _BLEND new_img&
    
    _SOURCE old_source&
    _DEST old_dest&
    
    ' Free old image and assign new
    IF CUSTOM_BRUSH.IMAGE& < -1 THEN _FREEIMAGE CUSTOM_BRUSH.IMAGE&
    CUSTOM_BRUSH.IMAGE& = new_img&
    
    ' Swap original dimensions
    CUSTOM_BRUSH.ORIG_WIDTH% = old_h%
    CUSTOM_BRUSH.ORIG_HEIGHT% = old_w%
    
    ' Update scaled dimensions
    CUSTOM_BRUSH.WIDTH% = CUSTOM_BRUSH.ORIG_WIDTH% * CUSTOM_BRUSH.SCALE!
    CUSTOM_BRUSH.HEIGHT% = CUSTOM_BRUSH.ORIG_HEIGHT% * CUSTOM_BRUSH.SCALE!
    
    ' Reset flip flags since the image data itself rotated
    CUSTOM_BRUSH.FLIP_H% = FALSE
    CUSTOM_BRUSH.FLIP_V% = FALSE
    
    SCENE_DIRTY% = TRUE
    GUI_NEEDS_REDRAW% = TRUE
    FRAME_IDLE% = FALSE
    
    _LOGINFO "CUSTOM_BRUSH: Rotated 90 CW -> " + ns$(CUSTOM_BRUSH.ORIG_WIDTH%) + "x" + ns$(CUSTOM_BRUSH.ORIG_HEIGHT%)
END SUB


''
' Rotate custom brush 90 degrees counter-clockwise
' Physically rotates the pixel data in CUSTOM_BRUSH.IMAGE&
' and swaps width/height dimensions.
'
SUB CUSTOM_BRUSH_rotate_ccw ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    IF CUSTOM_BRUSH.IMAGE& = 0 THEN EXIT SUB
    
    DIM old_w AS INTEGER, old_h AS INTEGER
    DIM new_img AS LONG
    DIM old_source AS LONG, old_dest AS LONG
    DIM px AS INTEGER, py AS INTEGER
    DIM pixel_color AS _UNSIGNED LONG
    
    old_w% = CUSTOM_BRUSH.ORIG_WIDTH%
    old_h% = CUSTOM_BRUSH.ORIG_HEIGHT%
    
    ' Create new image with swapped dimensions (W becomes H, H becomes W)
    new_img& = _NEWIMAGE(old_h%, old_w%, 32)
    
    old_source& = _SOURCE
    old_dest& = _DEST
    
    ' Clear new image with transparency
    _DEST new_img&
    CLS , _RGBA32(0, 0, 0, 0)
    
    ' Rotate: dst(sy, old_w-1-sx) <- src(sx, sy)  for CCW 90
    _SOURCE CUSTOM_BRUSH.IMAGE&
    _DONTBLEND new_img&
    FOR py% = 0 TO old_h% - 1
        FOR px% = 0 TO old_w% - 1
            pixel_color~& = POINT(px%, py%)
            PSET (py%, old_w% - 1 - px%), pixel_color~&
        NEXT px%
    NEXT py%
    _BLEND new_img&
    
    _SOURCE old_source&
    _DEST old_dest&
    
    ' Free old image and assign new
    IF CUSTOM_BRUSH.IMAGE& < -1 THEN _FREEIMAGE CUSTOM_BRUSH.IMAGE&
    CUSTOM_BRUSH.IMAGE& = new_img&
    
    ' Swap original dimensions
    CUSTOM_BRUSH.ORIG_WIDTH% = old_h%
    CUSTOM_BRUSH.ORIG_HEIGHT% = old_w%
    
    ' Update scaled dimensions
    CUSTOM_BRUSH.WIDTH% = CUSTOM_BRUSH.ORIG_WIDTH% * CUSTOM_BRUSH.SCALE!
    CUSTOM_BRUSH.HEIGHT% = CUSTOM_BRUSH.ORIG_HEIGHT% * CUSTOM_BRUSH.SCALE!
    
    ' Reset flip flags since the image data itself rotated
    CUSTOM_BRUSH.FLIP_H% = FALSE
    CUSTOM_BRUSH.FLIP_V% = FALSE
    
    SCENE_DIRTY% = TRUE
    GUI_NEEDS_REDRAW% = TRUE
    FRAME_IDLE% = FALSE
    
    _LOGINFO "CUSTOM_BRUSH: Rotated 90 CCW -> " + ns$(CUSTOM_BRUSH.ORIG_WIDTH%) + "x" + ns$(CUSTOM_BRUSH.ORIG_HEIGHT%)
END SUB


''
' Render the custom brush with zoom scaling for cursor display
' @param x INTEGER X position (top-left corner)
' @param y INTEGER Y position (top-left corner)
' @param dest LONG Destination image handle
' @param zoom SINGLE Zoom ratio for scaling
'
SUB CUSTOM_BRUSH_render_scaled (x AS INTEGER, y AS INTEGER, dest AS LONG, zoom AS SINGLE)
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    IF CUSTOM_BRUSH.IMAGE& = 0 THEN EXIT SUB
    
    DIM old_dest AS LONG
    DIM old_source AS LONG
    old_dest& = _DEST
    old_source& = _SOURCE
    
    ' Enable blending on destination for proper alpha transparency
    _BLEND dest&
    _DEST dest&
    
    ' Calculate scaled dimensions (WIDTH/HEIGHT already include SCALE factor)
    DIM scaled_w AS INTEGER, scaled_h AS INTEGER
    scaled_w% = CUSTOM_BRUSH.WIDTH% * zoom!
    scaled_h% = CUSTOM_BRUSH.HEIGHT% * zoom!
    
    ' Calculate source coordinates based on flip flags
    DIM src_x1 AS INTEGER, src_y1 AS INTEGER
    DIM src_x2 AS INTEGER, src_y2 AS INTEGER
    
    IF CUSTOM_BRUSH.FLIP_H% THEN
        src_x1% = CUSTOM_BRUSH.ORIG_WIDTH% - 1
        src_x2% = 0
    ELSE
        src_x1% = 0
        src_x2% = CUSTOM_BRUSH.ORIG_WIDTH% - 1
    END IF
    
    IF CUSTOM_BRUSH.FLIP_V% THEN
        src_y1% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1
        src_y2% = 0
    ELSE
        src_y1% = 0
        src_y2% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1
    END IF
    
    ' If recolor mode is active, create temporary recolored brush
    IF CUSTOM_BRUSH.RECOLOR_MODE% THEN
        DIM temp_brush AS LONG
        temp_brush& = _NEWIMAGE(CUSTOM_BRUSH.ORIG_WIDTH%, CUSTOM_BRUSH.ORIG_HEIGHT%, 32)
        
        DIM old_dest2 AS LONG
        old_dest2& = _DEST
        _DEST temp_brush&
        CLS , _RGBA32(0, 0, 0, 0) ' Clear with full transparency
        
        ' Render recolored brush to temp image
        DIM px AS INTEGER, py AS INTEGER
        DIM pixel_color AS _UNSIGNED LONG
        DIM alpha_value AS INTEGER
        
        _SOURCE CUSTOM_BRUSH.IMAGE&
        FOR py% = 0 TO CUSTOM_BRUSH.ORIG_HEIGHT% - 1
            FOR px% = 0 TO CUSTOM_BRUSH.ORIG_WIDTH% - 1
                pixel_color~& = POINT(px%, py%)
                alpha_value% = _ALPHA32(pixel_color~&)
                
                ' Only draw non-transparent pixels, using FG color with full opacity
                IF alpha_value% > 0 THEN
                    PSET (px%, py%), _RGBA32(_RED32(PAINT_COLOR~&), _GREEN32(PAINT_COLOR~&), _BLUE32(PAINT_COLOR~&), 255)
                END IF
            NEXT px%
        NEXT py%
        
        _DEST old_dest2&
        
        ' Now use _PUTIMAGE with the recolored temp brush
        _PUTIMAGE (x%, y%)-(x% + scaled_w% - 1, y% + scaled_h% - 1), temp_brush&, dest&, (src_x1%, src_y1%)-(src_x2%, src_y2%)
        
        IF temp_brush& < -1 THEN _FREEIMAGE temp_brush&
    ELSE
        ' Use _PUTIMAGE to render with transparency support and scaling
        _PUTIMAGE (x%, y%)-(x% + scaled_w% - 1, y% + scaled_h% - 1), CUSTOM_BRUSH.IMAGE&, dest&, (src_x1%, src_y1%)-(src_x2%, src_y2%)
    END IF
    
    _SOURCE old_source&
    _DEST old_dest&
END SUB


''
' Scale custom brush up by 100% (double size)
'
SUB CUSTOM_BRUSH_scale_up ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH.SCALE! = CUSTOM_BRUSH.SCALE! * 2.0
    CUSTOM_BRUSH.WIDTH% = CUSTOM_BRUSH.ORIG_WIDTH% * CUSTOM_BRUSH.SCALE!
    CUSTOM_BRUSH.HEIGHT% = CUSTOM_BRUSH.ORIG_HEIGHT% * CUSTOM_BRUSH.SCALE!
    SCENE_DIRTY% = TRUE
    GUI_NEEDS_REDRAW% = TRUE
    FRAME_IDLE% = FALSE
END SUB


''
' Scale custom brush down by 100% (half size)
'
SUB CUSTOM_BRUSH_scale_down ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    IF CUSTOM_BRUSH.SCALE! <= 0.125 THEN EXIT SUB ' Minimum scale of 12.5%
    CUSTOM_BRUSH.SCALE! = CUSTOM_BRUSH.SCALE! / 2.0
    CUSTOM_BRUSH.WIDTH% = CUSTOM_BRUSH.ORIG_WIDTH% * CUSTOM_BRUSH.SCALE!
    CUSTOM_BRUSH.HEIGHT% = CUSTOM_BRUSH.ORIG_HEIGHT% * CUSTOM_BRUSH.SCALE!
    SCENE_DIRTY% = TRUE
    GUI_NEEDS_REDRAW% = TRUE
    FRAME_IDLE% = FALSE
END SUB


''
' Reset custom brush scale to original size
'
SUB CUSTOM_BRUSH_scale_reset ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH.SCALE! = 1.0
    CUSTOM_BRUSH.WIDTH% = CUSTOM_BRUSH.ORIG_WIDTH%
    CUSTOM_BRUSH.HEIGHT% = CUSTOM_BRUSH.ORIG_HEIGHT%
    SCENE_DIRTY% = TRUE
    GUI_NEEDS_REDRAW% = TRUE
    FRAME_IDLE% = FALSE
END SUB


''
' Toggle recolor mode for custom brush
' When active, replaces all non-transparent pixels with the current FG color
'
SUB CUSTOM_BRUSH_toggle_recolor ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH.RECOLOR_MODE% = NOT CUSTOM_BRUSH.RECOLOR_MODE%
    IF CUSTOM_BRUSH.RECOLOR_MODE% THEN
        _LOGINFO "RECOLOR MODE: ON"
    ELSE
        _LOGINFO "RECOLOR MODE: OFF"
    END IF
END SUB


''
' Toggle outline visibility for custom brush cursor preview
'
SUB CUSTOM_BRUSH_toggle_outline ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    CUSTOM_BRUSH.SHOW_OUTLINE% = NOT CUSTOM_BRUSH.SHOW_OUTLINE%
END SUB


''
' Apply a 1px outline around non-transparent pixels using the current BG color
' This permanently modifies the brush image and expands the canvas to prevent clipping
'
SUB CUSTOM_BRUSH_apply_outline ()
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN EXIT SUB
    IF CUSTOM_BRUSH.IMAGE& = 0 THEN EXIT SUB
    
    DIM old_dest AS LONG, old_source AS LONG
    old_dest& = _DEST
    old_source& = _SOURCE
    
    DIM w AS INTEGER, h AS INTEGER
    w% = CUSTOM_BRUSH.ORIG_WIDTH%
    h% = CUSTOM_BRUSH.ORIG_HEIGHT%
    
    ' Create expanded canvas (2px wider, 2px taller) to accommodate outline without clipping
    DIM new_w AS INTEGER, new_h AS INTEGER
    new_w% = w% + 2
    new_h% = h% + 2
    
    DIM expanded_img AS LONG
    expanded_img& = _NEWIMAGE(new_w%, new_h%, 32)
    IF expanded_img& = 0 THEN
        _DEST old_dest&
        _SOURCE old_source&
        _LOGERROR "Failed to create expanded image for outline"
        EXIT SUB
    END IF
    
    ' Copy original brush into center of expanded canvas (offset by 1,1)
    _DEST expanded_img&
    CLS , _RGBA32(0, 0, 0, 0)
    _PUTIMAGE (1, 1), CUSTOM_BRUSH.IMAGE&
    
    ' Now apply outline algorithm to the expanded canvas
    ' Create arrays to mark outline pixels
    REDIM outline_x(new_w% * new_h%) AS INTEGER
    REDIM outline_y(new_w% * new_h%) AS INTEGER
    DIM outline_count AS INTEGER
    outline_count% = 0
    
    _SOURCE expanded_img&
    
    ' First pass: find all transparent pixels adjacent to non-transparent pixels
    DIM x AS INTEGER, y AS INTEGER
    DIM nx AS INTEGER, ny AS INTEGER
    DIM pixel_alpha AS INTEGER, neighbor_alpha AS INTEGER
    DIM found_neighbor AS INTEGER
    
    FOR y% = 0 TO new_h% - 1
        FOR x% = 0 TO new_w% - 1
            pixel_alpha% = _ALPHA32(POINT(x%, y%))
            
            ' Only process transparent pixels
            IF pixel_alpha% = 0 THEN
                found_neighbor% = FALSE
                
                ' Check 8 neighbors (including diagonals)
                FOR ny% = y% - 1 TO y% + 1
                    FOR nx% = x% - 1 TO x% + 1
                        ' Skip self
                        IF nx% = x% AND ny% = y% THEN _CONTINUE
                        
                        ' Check bounds
                        IF nx% >= 0 AND nx% < new_w% AND ny% >= 0 AND ny% < new_h% THEN
                            neighbor_alpha% = _ALPHA32(POINT(nx%, ny%))
                            IF neighbor_alpha% > 0 THEN
                                found_neighbor% = TRUE
                                EXIT FOR
                            END IF
                        END IF
                    NEXT nx%
                    IF found_neighbor% THEN EXIT FOR
                NEXT ny%
                
                ' Mark this pixel for outline
                IF found_neighbor% THEN
                    outline_x(outline_count%) = x%
                    outline_y(outline_count%) = y%
                    outline_count% = outline_count% + 1
                END IF
            END IF
        NEXT x%
    NEXT y%
    
    ' Second pass: draw outline pixels with BG color (fully opaque)
    _DEST expanded_img&
    
    DIM i AS INTEGER
    DIM outline_color AS _UNSIGNED LONG
    outline_color~& = _RGB32(_RED32(PAINT_BG_COLOR~&), _GREEN32(PAINT_BG_COLOR~&), _BLUE32(PAINT_BG_COLOR~&))
    
    FOR i% = 0 TO outline_count% - 1
        PSET (outline_x(i%), outline_y(i%)), outline_color~&
    NEXT i%
    
    ' Replace old brush image with expanded version
    IF CUSTOM_BRUSH.IMAGE& < -1 THEN _FREEIMAGE CUSTOM_BRUSH.IMAGE&
    CUSTOM_BRUSH.IMAGE& = expanded_img&
    
    ' Update dimensions
    CUSTOM_BRUSH.ORIG_WIDTH% = new_w%
    CUSTOM_BRUSH.ORIG_HEIGHT% = new_h%
    CUSTOM_BRUSH.WIDTH% = new_w%
    CUSTOM_BRUSH.HEIGHT% = new_h%
    
    _SOURCE old_source&
    _DEST old_dest&
    
    ' Turn off recolor mode so the outline keeps its color when stamping
    IF CUSTOM_BRUSH.RECOLOR_MODE% THEN
        CUSTOM_BRUSH.RECOLOR_MODE% = FALSE
        _LOGINFO "RECOLOR MODE: OFF (disabled by outline)"
    END IF
    
    _LOGINFO "Applied outline to custom brush with " + STR$(outline_count%) + " pixels"
    _LOGINFO "Expanded brush dimensions to " + _TRIM$(STR$(new_w%)) + "x" + _TRIM$(STR$(new_h%))
END SUB


''
' Export custom brush as PNG file
' @param filepath STRING Full path for the PNG file
'
SUB CUSTOM_BRUSH_export_png (filepath AS STRING)
    IF NOT CUSTOM_BRUSH.ACTIVE% THEN
        _LOGERROR "Export failed: No custom brush active"
        EXIT SUB
    END IF
    IF CUSTOM_BRUSH.IMAGE& = 0 THEN
        _LOGERROR "Export failed: No brush image"
        EXIT SUB
    END IF
    
    _LOGINFO "Exporting custom brush to: " + filepath$
    _LOGINFO "Brush dimensions: " + _TRIM$(STR$(CUSTOM_BRUSH.ORIG_WIDTH%)) + "x" + _TRIM$(STR$(CUSTOM_BRUSH.ORIG_HEIGHT%))
    
    ' Create a temporary image at the original brush size
    DIM temp_img AS LONG
    temp_img& = _NEWIMAGE(CUSTOM_BRUSH.ORIG_WIDTH%, CUSTOM_BRUSH.ORIG_HEIGHT%, 32)
    
    IF temp_img& = 0 THEN
        _LOGERROR "Export failed: Could not create temporary image"
        EXIT SUB
    END IF
    
    DIM old_dest AS LONG
    old_dest& = _DEST
    
    _DEST temp_img&
    CLS , _RGBA32(0, 0, 0, 0) ' Clear with transparency
    
    ' Copy brush to temp image (respecting flips)
    DIM src_x1 AS INTEGER, src_y1 AS INTEGER
    DIM src_x2 AS INTEGER, src_y2 AS INTEGER
    
    IF CUSTOM_BRUSH.FLIP_H% THEN
        src_x1% = CUSTOM_BRUSH.ORIG_WIDTH% - 1
        src_x2% = 0
    ELSE
        src_x1% = 0
        src_x2% = CUSTOM_BRUSH.ORIG_WIDTH% - 1
    END IF
    
    IF CUSTOM_BRUSH.FLIP_V% THEN
        src_y1% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1
        src_y2% = 0
    ELSE
        src_y1% = 0
        src_y2% = CUSTOM_BRUSH.ORIG_HEIGHT% - 1
    END IF
    
    _PUTIMAGE (0, 0)-(CUSTOM_BRUSH.ORIG_WIDTH% - 1, CUSTOM_BRUSH.ORIG_HEIGHT% - 1), CUSTOM_BRUSH.IMAGE&, temp_img&, (src_x1%, src_y1%)-(src_x2%, src_y2%)
    
    ' Save as PNG
    _DEST old_dest&
    _SAVEIMAGE filepath$, temp_img&
    
    _LOGINFO "Brush successfully exported to: " + filepath$
    
    ' Clean up
    IF temp_img& < -1 THEN _FREEIMAGE temp_img&
END SUB
