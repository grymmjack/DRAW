''
' DRAW - TOOLS/MOVE.BM
' =============================================================================
' Move and transform tool implementation.
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

' Initialize the move tool
SUB MOVE_init ()
    MOVE.ACTIVE = FALSE
    MOVE.TRANSFORMING = FALSE
    MOVE.TRANSFORM_TYPE = 0
    MOVE.SELECTION_IMAGE = 0
    MOVE.PREVIEW_BUFFER = 0
    MOVE.SELECTION_X = 0
    MOVE.SELECTION_Y = 0
    MOVE.SELECTION_W = 0
    MOVE.SELECTION_H = 0
    MOVE.HANDLE = 0
    MOVE.CLONING = FALSE
    MOVE.CONSTRAIN = FALSE
END SUB

' Reset the move tool (automatically applies any pending transformation)
SUB MOVE_reset ()
    ' Apply any active transformation before resetting
    IF MOVE.ACTIVE AND MOVE.SELECTION_IMAGE < -1 THEN
        MOVE_apply_transform
    END IF
    IF MOVE.SELECTION_IMAGE < -1 THEN _FREEIMAGE MOVE.SELECTION_IMAGE
    IF MOVE.PREVIEW_BUFFER < -1 THEN _FREEIMAGE MOVE.PREVIEW_BUFFER
    MOVE_init
END SUB

' Capture the selected pixels from the marquee, or entire layer if no marquee
SUB MOVE_capture_selection ()
    ' If no marquee is active, capture the entire layer
    DIM captureWholeLayer AS INTEGER
    captureWholeLayer% = NOT MARQUEE.ACTIVE OR NOT MARQUEE.INITIALIZED
    
    ' Free old image if exists
    IF MOVE.SELECTION_IMAGE < -1 THEN _FREEIMAGE MOVE.SELECTION_IMAGE
    IF MOVE.PREVIEW_BUFFER < -1 THEN _FREEIMAGE MOVE.PREVIEW_BUFFER
    
    IF captureWholeLayer% THEN
        ' No marquee: capture entire layer
        MOVE.SELECTION_X = 0
        MOVE.SELECTION_Y = 0
        MOVE.SELECTION_W = _WIDTH(LAYER_current_image&)
        MOVE.SELECTION_H = _HEIGHT(LAYER_current_image&)
        
        ' Set up marquee bounds to match full layer (so handles render correctly)
        MARQUEE.BOX.x = 0
        MARQUEE.BOX.y = 0
        MARQUEE.BOX.w = MOVE.SELECTION_W
        MARQUEE.BOX.h = MOVE.SELECTION_H
        MARQUEE.INITIALIZED = TRUE
        MARQUEE.ACTIVE = TRUE
        MARQUEE.USER_CREATED = FALSE  ' Auto-created for full-layer move, not user selection
    ELSE
        ' Get marquee dimensions
        MOVE.SELECTION_X = MARQUEE.BOX.x
        MOVE.SELECTION_Y = MARQUEE.BOX.y
        MOVE.SELECTION_W = MARQUEE.BOX.w
        MOVE.SELECTION_H = MARQUEE.BOX.h
    END IF
    
    ' Store original position for ESC cancel
    MOVE.ORIGINAL_X = MOVE.SELECTION_X
    MOVE.ORIGINAL_Y = MOVE.SELECTION_Y
    MOVE.ORIGINAL_W = MOVE.SELECTION_W
    MOVE.ORIGINAL_H = MOVE.SELECTION_H
    
    ' Create image buffer and copy selected region from CURRENT LAYER
    MOVE.SELECTION_IMAGE = _NEWIMAGE(MOVE.SELECTION_W, MOVE.SELECTION_H, 32)
    _DEST MOVE.SELECTION_IMAGE
    _PUTIMAGE (0, 0), LAYER_current_image&, MOVE.SELECTION_IMAGE, (MOVE.SELECTION_X, MOVE.SELECTION_Y)-(MOVE.SELECTION_X + MOVE.SELECTION_W - 1, MOVE.SELECTION_Y + MOVE.SELECTION_H - 1)
    
    ' Create preview buffer (same size as current layer)
    MOVE.PREVIEW_BUFFER = _NEWIMAGE(_WIDTH(LAYER_current_image&), _HEIGHT(LAYER_current_image&), 32)
    
    ' Initialize current transform to original selection
    MOVE.CURRENT_X = MOVE.SELECTION_X
    MOVE.CURRENT_Y = MOVE.SELECTION_Y
    MOVE.CURRENT_W = MOVE.SELECTION_W
    MOVE.CURRENT_H = MOVE.SELECTION_H
    
    ' Make sure marquee box is synced with the selection
    MARQUEE.BOX.x = MOVE.SELECTION_X
    MARQUEE.BOX.y = MOVE.SELECTION_Y
    MARQUEE.BOX.w = MOVE.SELECTION_W
    MARQUEE.BOX.h = MOVE.SELECTION_H
    
    ' Update the preview buffer initially
    MOVE_update_preview_buffer
    
    MOVE.ACTIVE = TRUE
END SUB

' Start a transform operation
SUB MOVE_start_transform (handle AS INTEGER, x AS INTEGER, y AS INTEGER)
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    
    MOVE.TRANSFORMING = TRUE
    MOVE.HANDLE = handle
    MOVE.START_X = x
    MOVE.START_Y = y
    
    ' Determine transform type based on handle
    IF handle = 0 THEN
        MOVE.TRANSFORM_TYPE = 0 ' Move
    ELSEIF handle = 1 OR handle = 2 OR handle = 3 OR handle = 4 THEN
        MOVE.TRANSFORM_TYPE = 1 ' Scale (corner handles)
    ELSE
        MOVE.TRANSFORM_TYPE = 2 ' Stretch (side handles)
    END IF
END SUB

' Update transform based on current mouse position
SUB MOVE_update_transform (x AS INTEGER, y AS INTEGER)
    IF NOT MOVE.TRANSFORMING THEN EXIT SUB
    
    DIM dx AS INTEGER, dy AS INTEGER, new_w AS INTEGER, new_h AS INTEGER
    DIM aspect_ratio AS SINGLE
    
    dx = x - MOVE.START_X
    dy = y - MOVE.START_Y
    
    ' Check for ALT (clone) and SHIFT (constrain) modifiers
    MOVE.CLONING = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
    MOVE.CONSTRAIN = (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&))
    
    ' Store old values to detect changes
    DIM old_x AS INTEGER, old_y AS INTEGER, old_w AS INTEGER, old_h AS INTEGER
    old_x = MOVE.CURRENT_X
    old_y = MOVE.CURRENT_Y
    old_w = MOVE.CURRENT_W
    old_h = MOVE.CURRENT_H
    
    SELECT CASE MOVE.TRANSFORM_TYPE
        CASE 0 ' Move
            MOVE.CURRENT_X = MOVE.SELECTION_X + dx
            MOVE.CURRENT_Y = MOVE.SELECTION_Y + dy
            
        CASE 1 ' Scale (corner handles)
            aspect_ratio = MOVE.SELECTION_W / MOVE.SELECTION_H
            
            SELECT CASE MOVE.HANDLE
                CASE 1 ' Top-left
                    new_w = MOVE.SELECTION_W - dx
                    new_h = MOVE.SELECTION_H - dy
                    IF MOVE.CONSTRAIN THEN
                        IF ABS(dx) > ABS(dy) THEN
                            new_h = INT(new_w / aspect_ratio)
                        ELSE
                            new_w = INT(new_h * aspect_ratio)
                        END IF
                    END IF
                    IF new_w > 1 AND new_h > 1 THEN
                        MOVE.CURRENT_X = MOVE.SELECTION_X + MOVE.SELECTION_W - new_w
                        MOVE.CURRENT_Y = MOVE.SELECTION_Y + MOVE.SELECTION_H - new_h
                        MOVE.CURRENT_W = new_w
                        MOVE.CURRENT_H = new_h
                    END IF
                    
                CASE 2 ' Top-right
                    new_w = MOVE.SELECTION_W + dx
                    new_h = MOVE.SELECTION_H - dy
                    IF MOVE.CONSTRAIN THEN
                        IF ABS(dx) > ABS(dy) THEN
                            new_h = INT(new_w / aspect_ratio)
                        ELSE
                            new_w = INT(new_h * aspect_ratio)
                        END IF
                    END IF
                    IF new_w > 1 AND new_h > 1 THEN
                        MOVE.CURRENT_Y = MOVE.SELECTION_Y + MOVE.SELECTION_H - new_h
                        MOVE.CURRENT_W = new_w
                        MOVE.CURRENT_H = new_h
                    END IF
                    
                CASE 3 ' Bottom-right
                    new_w = MOVE.SELECTION_W + dx
                    new_h = MOVE.SELECTION_H + dy
                    IF MOVE.CONSTRAIN THEN
                        IF ABS(dx) > ABS(dy) THEN
                            new_h = INT(new_w / aspect_ratio)
                        ELSE
                            new_w = INT(new_h * aspect_ratio)
                        END IF
                    END IF
                    IF new_w > 1 AND new_h > 1 THEN
                        MOVE.CURRENT_W = new_w
                        MOVE.CURRENT_H = new_h
                    END IF
                    
                CASE 4 ' Bottom-left
                    new_w = MOVE.SELECTION_W - dx
                    new_h = MOVE.SELECTION_H + dy
                    IF MOVE.CONSTRAIN THEN
                        IF ABS(dx) > ABS(dy) THEN
                            new_h = INT(new_w / aspect_ratio)
                        ELSE
                            new_w = INT(new_h * aspect_ratio)
                        END IF
                    END IF
                    IF new_w > 1 AND new_h > 1 THEN
                        MOVE.CURRENT_X = MOVE.SELECTION_X + MOVE.SELECTION_W - new_w
                        MOVE.CURRENT_W = new_w
                        MOVE.CURRENT_H = new_h
                    END IF
            END SELECT
            
        CASE 2 ' Stretch (side handles)
            SELECT CASE MOVE.HANDLE
                CASE 5 ' Top
                    new_h = MOVE.SELECTION_H - dy
                    IF new_h > 1 THEN
                        MOVE.CURRENT_Y = MOVE.SELECTION_Y + MOVE.SELECTION_H - new_h
                        MOVE.CURRENT_H = new_h
                    END IF
                    
                CASE 6 ' Right
                    new_w = MOVE.SELECTION_W + dx
                    IF new_w > 1 THEN
                        MOVE.CURRENT_W = new_w
                    END IF
                    
                CASE 7 ' Bottom
                    new_h = MOVE.SELECTION_H + dy
                    IF new_h > 1 THEN
                        MOVE.CURRENT_H = new_h
                    END IF
                    
                CASE 8 ' Left
                    new_w = MOVE.SELECTION_W - dx
                    IF new_w > 1 THEN
                        MOVE.CURRENT_X = MOVE.SELECTION_X + MOVE.SELECTION_W - new_w
                        MOVE.CURRENT_W = new_w
                    END IF
            END SELECT
    END SELECT
    
    ' Update marquee box to follow the transform in real-time
    IF MOVE.CURRENT_X <> old_x OR MOVE.CURRENT_Y <> old_y OR MOVE.CURRENT_W <> old_w OR MOVE.CURRENT_H <> old_h THEN
        MARQUEE.BOX.x = MOVE.CURRENT_X
        MARQUEE.BOX.y = MOVE.CURRENT_Y
        MARQUEE.BOX.w = MOVE.CURRENT_W
        MARQUEE.BOX.h = MOVE.CURRENT_H
        ' Update preview buffer when transform changes
        MOVE_update_preview_buffer
    END IF
END SUB

' Apply the transform to the canvas
SUB MOVE_apply_transform ()
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    ' Check ALT key at apply time to determine clone mode
    MOVE.CLONING = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
    
    ' Save undo state BEFORE making changes
    UNDO_save_state
    
    _DEST LAYER_current_image&
    
    ' If not cloning, clear the ORIGINAL area
    ' Use transparency for layers > 1, BG color only for Background layer
    IF NOT MOVE.CLONING THEN
        DIM clearColor AS _UNSIGNED LONG
        IF CURRENT_LAYER% > 1 THEN
            clearColor~& = _RGBA32(0, 0, 0, 0) ' Transparent for non-background layers
            _DONTBLEND LAYER_current_image&
        ELSE
            clearColor~& = PAINT_BG_COLOR~& ' BG color for background layer
        END IF
        LINE (MOVE.ORIGINAL_X, MOVE.ORIGINAL_Y)-(MOVE.ORIGINAL_X + MOVE.ORIGINAL_W - 1, MOVE.ORIGINAL_Y + MOVE.ORIGINAL_H - 1), clearColor~&, BF
        IF CURRENT_LAYER% > 1 THEN _BLEND LAYER_current_image&
    END IF
    
    ' Draw the transformed selection
    IF MOVE.SELECTION_IMAGE < -1 THEN
        _PUTIMAGE (MOVE.CURRENT_X, MOVE.CURRENT_Y)-(MOVE.CURRENT_X + MOVE.CURRENT_W - 1, MOVE.CURRENT_Y + MOVE.CURRENT_H - 1), MOVE.SELECTION_IMAGE, LAYER_current_image&
    END IF
    
    _DEST SCRN.CANVAS&
    
    ' Update marquee to new position/size
    MARQUEE.BOX.x = MOVE.CURRENT_X
    MARQUEE.BOX.y = MOVE.CURRENT_Y
    MARQUEE.BOX.w = MOVE.CURRENT_W
    MARQUEE.BOX.h = MOVE.CURRENT_H
    
    CANVAS_DIRTY% = TRUE
    
    ' Reset transforming flag
    MOVE.TRANSFORMING = FALSE
END SUB


''
' Stamp a copy of the selection at the current position (for clone mode)
' Unlike apply_transform, this keeps the move tool active for more stamps
SUB MOVE_stamp ()
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    ' Save undo state BEFORE making changes
    IF NOT UNDO_saved_this_frame% THEN
        UNDO_save_state
        UNDO_saved_this_frame% = TRUE
    END IF
    
    _DEST LAYER_current_image&
    
    ' Draw a copy of the selection at current position (DON'T clear original - that's the point of stamp)
    IF MOVE.SELECTION_IMAGE < -1 THEN
        _PUTIMAGE (MOVE.CURRENT_X, MOVE.CURRENT_Y)-(MOVE.CURRENT_X + MOVE.CURRENT_W - 1, MOVE.CURRENT_Y + MOVE.CURRENT_H - 1), MOVE.SELECTION_IMAGE, LAYER_current_image&
    END IF
    
    _DEST SCRN.CANVAS&
    
    ' Update the selection base to current position for next drag
    MOVE.SELECTION_X = MOVE.CURRENT_X
    MOVE.SELECTION_Y = MOVE.CURRENT_Y
    
    ' Update marquee to stamped position
    MARQUEE.BOX.x = MOVE.CURRENT_X
    MARQUEE.BOX.y = MOVE.CURRENT_Y
    MARQUEE.BOX.w = MOVE.CURRENT_W
    MARQUEE.BOX.h = MOVE.CURRENT_H
    
    CANVAS_DIRTY% = TRUE
    
    ' Keep move tool active for more stamps - don't reset MOVE.TRANSFORMING
END SUB


' Cancel the current transform
SUB MOVE_cancel_transform ()
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    
    ' Reset to original position/size from when tool was activated
    MOVE.CURRENT_X = MOVE.ORIGINAL_X
    MOVE.CURRENT_Y = MOVE.ORIGINAL_Y
    MOVE.CURRENT_W = MOVE.ORIGINAL_W
    MOVE.CURRENT_H = MOVE.ORIGINAL_H
    
    ' Also reset selection base
    MOVE.SELECTION_X = MOVE.ORIGINAL_X
    MOVE.SELECTION_Y = MOVE.ORIGINAL_Y
    MOVE.SELECTION_W = MOVE.ORIGINAL_W
    MOVE.SELECTION_H = MOVE.ORIGINAL_H
    
    ' Update marquee to original position
    MARQUEE.BOX.x = MOVE.ORIGINAL_X
    MARQUEE.BOX.y = MOVE.ORIGINAL_Y
    MARQUEE.BOX.w = MOVE.ORIGINAL_W
    MARQUEE.BOX.h = MOVE.ORIGINAL_H
    
    MOVE.TRANSFORMING = FALSE
END SUB

' Render preview of the transform with realtime visualization
' Note: dest should be the canvas, but we need zoom info from SCRN for coordinate conversion
SUB MOVE_render_preview (dest AS LONG)
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    ' The preview buffer already contains the painting layer with move applied
    ' This is just for drawing additional visual feedback (border, handles, etc.)
    ' The actual preview rendering happens in SCREEN_render using MOVE_get_preview_buffer
    
    ' Calculate zoomed coordinates for canvas overlay
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    DIM zx AS INTEGER, zy AS INTEGER, zx2 AS INTEGER, zy2 AS INTEGER
    zw& = SCRN.w& * SCRN.zoom!
    zh& = SCRN.h& * SCRN.zoom!
    dx% = (_WIDTH(dest) - zw&) \ 2 + SCRN.offsetX%
    dy% = (_HEIGHT(dest) - zh&) \ 2 + SCRN.offsetY%

    ' Offset for layer panel when visible
    IF LAYER_PANEL.visible% THEN dx% = dx% + CFG.LAYER_PANEL_WIDTH%
    
    ' Convert painting coordinates to canvas (screen) coordinates
    zx% = dx% + INT(MOVE.CURRENT_X * SCRN.zoom!)
    zy% = dy% + INT(MOVE.CURRENT_Y * SCRN.zoom!)
    zx2% = dx% + INT((MOVE.CURRENT_X + MOVE.CURRENT_W) * SCRN.zoom!) - 1
    zy2% = dy% + INT((MOVE.CURRENT_Y + MOVE.CURRENT_H) * SCRN.zoom!) - 1
    
    _DEST dest
    
    ' Draw visual feedback during active transform (white outline)
    IF MOVE.TRANSFORMING THEN
        DIM c~& : c~& = _RGB32(255, 255, 255)
        ' White outline for active transform feedback in canvas coordinates
        LINE (zx%, zy%)-(zx2%, zy2%), c~&, B
    END IF
END SUB


''
' Render the status tip bar for the move tool (called AFTER GUI layer)
' @param dest LONG Destination image handle
SUB MOVE_render_status (dest AS LONG)
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    DIM prevDest AS LONG
    prevDest& = _DEST
    
    ' Check current ALT state for status display
    MOVE.CLONING = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
    
    ' Calculate zoomed coordinates for canvas overlay
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.w& * SCRN.zoom!
    zh& = SCRN.h& * SCRN.zoom!
    dx% = (_WIDTH(dest) - zw&) \ 2 + SCRN.offsetX%
    dy% = (_HEIGHT(dest) - zh&) \ 2 + SCRN.offsetY%

    ' Offset for layer panel when visible
    IF LAYER_PANEL.visible% THEN dx% = dx% + CFG.LAYER_PANEL_WIDTH%

    ' Draw status tip bar at bottom of canvas
    DIM status_text AS STRING
    
    ' Build status text based on current state
    IF MOVE.CLONING THEN
        ' Clone mode active - show stamp instructions
        status_text$ = "[CLONE] DRAG+Release: Stamp copy | Keep ALT held for more stamps | Release ALT: Done"
    ELSE
        ' Normal move mode
        status_text$ = "DRAG: Move | ARROWS: Nudge | H/V: Flip | Hold ALT+DRAG: Stamp copies | ENTER: Apply | ESC: Cancel"
    END IF
    
    ' Load Tiny5 font
    DIM tiny_font AS LONG
    DIM old_font AS LONG
    DIM text_h AS INTEGER
    DIM bar_y AS INTEGER
    
    tiny_font& = _LOADFONT("ASSETS/FONTS/Tiny5-Regular.ttf", 8)
    IF tiny_font& > 0 THEN
        old_font& = _FONT(dest)
        _FONT tiny_font&, dest
        text_h% = _FONTHEIGHT(tiny_font&)
    ELSE
        old_font& = 0
        text_h% = 8
    END IF
    
    ' Position status bar at the very bottom of the screen, covering everything
    bar_y% = _HEIGHT(dest) - text_h% - 4
    
    _DEST dest
    
    ' Draw solid background bar across full width at bottom
    LINE (0, bar_y%)-((_WIDTH(dest) - 1), _HEIGHT(dest) - 1), _RGB32(32, 32, 32), BF
    ' Top border line
    LINE (0, bar_y%)-((_WIDTH(dest) - 1), bar_y%), _RGB32(80, 80, 80)
    
    ' Draw status text (flush left)
    COLOR _RGB32(255, 255, 255), _RGB32(32, 32, 32)
    _PRINTSTRING (4, bar_y% + 2), status_text$
    
    ' Restore original font and free loaded font
    IF tiny_font& > 0 THEN
        _FONT old_font&, dest
        _FREEFONT tiny_font&
    END IF
    
    _DEST prevDest&
END SUB

' Update the preview buffer with current transform state
' This creates a "virtual" view of the painting layer with the move/transform applied
SUB MOVE_update_preview_buffer ()
    IF MOVE.PREVIEW_BUFFER = 0 THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    ' Clear preview buffer first to prevent ghosts
    _DEST MOVE.PREVIEW_BUFFER
    CLS , _RGBA32(0, 0, 0, 0) ' Clear with transparency for layers
    
    ' Copy entire current layer to preview buffer
    _PUTIMAGE , LAYER_current_image&, MOVE.PREVIEW_BUFFER
    
    ' If NOT cloning, clear the ORIGINAL area
    ' Use transparency for layers > 1, BG color only for Background layer
    IF NOT MOVE.CLONING THEN
        DIM previewClearColor AS _UNSIGNED LONG
        IF CURRENT_LAYER% > 1 THEN
            previewClearColor~& = _RGBA32(0, 0, 0, 0) ' Transparent for non-background layers
            _DONTBLEND MOVE.PREVIEW_BUFFER
        ELSE
            previewClearColor~& = PAINT_BG_COLOR~& ' BG color for background layer
        END IF
        LINE (MOVE.ORIGINAL_X, MOVE.ORIGINAL_Y)-(MOVE.ORIGINAL_X + MOVE.ORIGINAL_W - 1, MOVE.ORIGINAL_Y + MOVE.ORIGINAL_H - 1), previewClearColor~&, BF
        IF CURRENT_LAYER% > 1 THEN _BLEND MOVE.PREVIEW_BUFFER
    END IF
    
    ' Draw the transformed selection at its current position/size
    _PUTIMAGE (MOVE.CURRENT_X, MOVE.CURRENT_Y)-(MOVE.CURRENT_X + MOVE.CURRENT_W - 1, MOVE.CURRENT_Y + MOVE.CURRENT_H - 1), MOVE.SELECTION_IMAGE, MOVE.PREVIEW_BUFFER
END SUB

' Get the preview buffer for rendering
' Returns the preview buffer if move is active, 0 otherwise
FUNCTION MOVE_get_preview_buffer& ()
    IF MOVE.ACTIVE AND MOVE.PREVIEW_BUFFER < -1 THEN
        MOVE_get_preview_buffer& = MOVE.PREVIEW_BUFFER
    ELSE
        MOVE_get_preview_buffer& = 0
    END IF
END FUNCTION

' Flip the selection image horizontally
SUB MOVE_flip_horizontal ()
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    DIM w AS INTEGER, h AS INTEGER
    DIM flipped AS LONG
    
    w% = _WIDTH(MOVE.SELECTION_IMAGE)
    h% = _HEIGHT(MOVE.SELECTION_IMAGE)
    
    ' Create a new image for the flipped version
    flipped& = _NEWIMAGE(w%, h%, 32)
    
    ' Copy pixels flipped horizontally using _PUTIMAGE with negative width
    _PUTIMAGE (w% - 1, 0)-(0, h% - 1), MOVE.SELECTION_IMAGE, flipped&
    
    ' Free the old image and replace with flipped
    IF MOVE.SELECTION_IMAGE < -1 THEN _FREEIMAGE MOVE.SELECTION_IMAGE
    MOVE.SELECTION_IMAGE = flipped&
    
    ' Update preview buffer
    MOVE_update_preview_buffer
END SUB

' Flip the selection image vertically
SUB MOVE_flip_vertical ()
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    DIM w AS INTEGER, h AS INTEGER
    DIM flipped AS LONG
    
    w% = _WIDTH(MOVE.SELECTION_IMAGE)
    h% = _HEIGHT(MOVE.SELECTION_IMAGE)
    
    ' Create a new image for the flipped version
    flipped& = _NEWIMAGE(w%, h%, 32)
    
    ' Copy pixels flipped vertically using _PUTIMAGE with negative height
    _PUTIMAGE (0, h% - 1)-(w% - 1, 0), MOVE.SELECTION_IMAGE, flipped&
    
    ' Free the old image and replace with flipped
    IF MOVE.SELECTION_IMAGE < -1 THEN _FREEIMAGE MOVE.SELECTION_IMAGE
    MOVE.SELECTION_IMAGE = flipped&
    
    ' Update preview buffer
    MOVE_update_preview_buffer
END SUB

' Nudge the selection by dx, dy pixels
SUB MOVE_nudge (dx AS INTEGER, dy AS INTEGER)
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    
    ' Update current position
    MOVE.CURRENT_X = MOVE.CURRENT_X + dx%
    MOVE.CURRENT_Y = MOVE.CURRENT_Y + dy%
    
    ' Also update base selection position for subsequent transforms
    MOVE.SELECTION_X = MOVE.CURRENT_X
    MOVE.SELECTION_Y = MOVE.CURRENT_Y
    
    ' Update marquee box to follow
    MARQUEE.BOX.x = MOVE.CURRENT_X
    MARQUEE.BOX.y = MOVE.CURRENT_Y
    
    ' Update preview buffer
    MOVE_update_preview_buffer
END SUB

' Resize the selection by dw, dh pixels (scaling the image)
SUB MOVE_resize (dw AS INTEGER, dh AS INTEGER)
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    
    ' Calculate new dimensions
    DIM new_w AS INTEGER, new_h AS INTEGER
    new_w% = MOVE.CURRENT_W + dw%
    new_h% = MOVE.CURRENT_H + dh%
    
    ' Enforce minimum size
    IF new_w% < 1 THEN new_w% = 1
    IF new_h% < 1 THEN new_h% = 1
    
    ' Update current dimensions
    MOVE.CURRENT_W = new_w%
    MOVE.CURRENT_H = new_h%
    
    ' Also update base selection size for subsequent transforms
    MOVE.SELECTION_W = new_w%
    MOVE.SELECTION_H = new_h%
    
    ' Update marquee box to follow
    MARQUEE.BOX.w = MOVE.CURRENT_W
    MARQUEE.BOX.h = MOVE.CURRENT_H
    
    ' Update preview buffer
    MOVE_update_preview_buffer
END SUB
