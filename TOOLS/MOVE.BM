''
' DRAW - TOOLS/MOVE.BM
' =============================================================================
' Move and transform tool implementation.
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

' Initialize the move tool
SUB MOVE_init ()
    MOVE.ACTIVE = FALSE
    MOVE.TRANSFORMING = FALSE
    MOVE.TRANSFORM_TYPE = 0
    IF MOVE.ORIGINAL_IMAGE < -1 THEN _FREEIMAGE MOVE.ORIGINAL_IMAGE
    MOVE.ORIGINAL_IMAGE = 0
    MOVE.ORIGINAL_IMG_W = 0
    MOVE.ORIGINAL_IMG_H = 0
    MOVE.SCALE_FACTOR = 1.0
    MOVE.SELECTION_IMAGE = 0
    MOVE.PREVIEW_BUFFER = 0
    MOVE.SELECTION_X = 0
    MOVE.SELECTION_Y = 0
    MOVE.SELECTION_W = 0
    MOVE.SELECTION_H = 0
    MOVE.HANDLE = 0
    MOVE.CLONING = FALSE
    MOVE.CLONE_STAMPED = FALSE
    MOVE.CONSTRAIN = FALSE
    MOVE.CAPTURED_LAYER = 0
    ' Also clear layer-level scale original
    IF SCALE_ORIGINAL_IMAGE < -1 THEN _FREEIMAGE SCALE_ORIGINAL_IMAGE
    SCALE_ORIGINAL_IMAGE = 0
    SCALE_ORIGINAL_LAYER = 0
    SCALE_FACTOR_LAYER = 1.0
END SUB

' Reset the move tool (automatically applies any pending transformation)
SUB MOVE_reset ()
    ' Apply any active transformation before resetting
    IF MOVE.ACTIVE AND MOVE.SELECTION_IMAGE < -1 THEN
        MOVE_apply_transform
    END IF
    ' Clean up auto-created marquee from full-layer move (preserve user-created selections)
    ' Without this, the stale MARQUEE causes subsequent MOVE_capture_selection to capture
    ' only the old MARQUEE.BOX region instead of the full layer ("only part moves" bug)
    IF MARQUEE.ACTIVE% AND NOT MARQUEE.USER_CREATED THEN
        MARQUEE_reset
    END IF
    IF MOVE.SELECTION_IMAGE < -1 THEN _FREEIMAGE MOVE.SELECTION_IMAGE
    IF MOVE.PREVIEW_BUFFER < -1 THEN _FREEIMAGE MOVE.PREVIEW_BUFFER
    MOVE_init
END SUB

' Capture the selected pixels from the marquee, or entire layer if no marquee
SUB MOVE_capture_selection ()
    ' If no marquee is active, capture the entire layer
    DIM captureWholeLayer AS INTEGER
    captureWholeLayer% = NOT MARQUEE.ACTIVE OR NOT MARQUEE.INITIALIZED
    
    ' Free old image if exists
    IF MOVE.SELECTION_IMAGE < -1 THEN _FREEIMAGE MOVE.SELECTION_IMAGE
    IF MOVE.PREVIEW_BUFFER < -1 THEN _FREEIMAGE MOVE.PREVIEW_BUFFER
    
    IF captureWholeLayer% THEN
        ' No marquee: capture entire layer
        MOVE.SELECTION_X = 0
        MOVE.SELECTION_Y = 0
        MOVE.SELECTION_W = _WIDTH(LAYER_current_image&)
        MOVE.SELECTION_H = _HEIGHT(LAYER_current_image&)
        
        ' Set up marquee bounds to match full layer (so handles render correctly)
        MARQUEE.BOX.x = 0
        MARQUEE.BOX.y = 0
        MARQUEE.BOX.w = MOVE.SELECTION_W
        MARQUEE.BOX.h = MOVE.SELECTION_H
        MARQUEE.INITIALIZED = TRUE
        MARQUEE.ACTIVE = TRUE
        MARQUEE.USER_CREATED = FALSE  ' Auto-created for full-layer move, not user selection
    ELSE
        ' Get marquee dimensions
        MOVE.SELECTION_X = MARQUEE.BOX.x
        MOVE.SELECTION_Y = MARQUEE.BOX.y
        MOVE.SELECTION_W = MARQUEE.BOX.w
        MOVE.SELECTION_H = MARQUEE.BOX.h
    END IF
    
    ' Store original position for ESC cancel
    MOVE.ORIGINAL_X = MOVE.SELECTION_X
    MOVE.ORIGINAL_Y = MOVE.SELECTION_Y
    MOVE.ORIGINAL_W = MOVE.SELECTION_W
    MOVE.ORIGINAL_H = MOVE.SELECTION_H

    ' Track which layer we captured from (ensures apply targets the correct layer
    ' even if the user switches layers before committing)
    MOVE.CAPTURED_LAYER = CURRENT_LAYER%

    ' NOTE: No undo save here. The post-move state is saved in MOVE_apply_transform.
    ' The pre-move baseline comes from UNDO_init (file load), LAYERS_new, or
    ' LAYERS_duplicate, ensuring every layer has a prior state for undo to restore.
    ' Saving here AND in apply_transform created duplicate states when consecutive
    ' moves happened (post-apply of move N = pre-capture of move N+1), causing
    ' one undo press to "do nothing" visually.

    ' Create image buffer and copy selected region from CURRENT LAYER
    MOVE.SELECTION_IMAGE = _NEWIMAGE(MOVE.SELECTION_W, MOVE.SELECTION_H, 32)
    _DEST MOVE.SELECTION_IMAGE
    _PUTIMAGE (0, 0), LAYER_current_image&, MOVE.SELECTION_IMAGE, (MOVE.SELECTION_X, MOVE.SELECTION_Y)-(MOVE.SELECTION_X + MOVE.SELECTION_W - 1, MOVE.SELECTION_Y + MOVE.SELECTION_H - 1)
    
    ' Save original image for lossless re-scaling
    IF MOVE.ORIGINAL_IMAGE < -1 THEN _FREEIMAGE MOVE.ORIGINAL_IMAGE
    MOVE.ORIGINAL_IMAGE = _COPYIMAGE(MOVE.SELECTION_IMAGE)
    MOVE.ORIGINAL_IMG_W = MOVE.SELECTION_W
    MOVE.ORIGINAL_IMG_H = MOVE.SELECTION_H
    MOVE.SCALE_FACTOR = 1.0
    
    ' Create preview buffer (same size as current layer)
    MOVE.PREVIEW_BUFFER = _NEWIMAGE(_WIDTH(LAYER_current_image&), _HEIGHT(LAYER_current_image&), 32)
    
    ' Initialize current transform to original selection
    MOVE.CURRENT_X = MOVE.SELECTION_X
    MOVE.CURRENT_Y = MOVE.SELECTION_Y
    MOVE.CURRENT_W = MOVE.SELECTION_W
    MOVE.CURRENT_H = MOVE.SELECTION_H
    
    ' Make sure marquee box is synced with the selection
    MARQUEE.BOX.x = MOVE.SELECTION_X
    MARQUEE.BOX.y = MOVE.SELECTION_Y
    MARQUEE.BOX.w = MOVE.SELECTION_W
    MARQUEE.BOX.h = MOVE.SELECTION_H
    
    ' Update the preview buffer initially
    MOVE_update_preview_buffer
    
    MOVE.ACTIVE = TRUE
END SUB

' Start a transform operation
SUB MOVE_start_transform (handle AS INTEGER, x AS INTEGER, y AS INTEGER)
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    
    MOVE.TRANSFORMING = TRUE
    MOVE.HANDLE = handle
    MOVE.START_X = x
    MOVE.START_Y = y
    
    ' Determine transform type based on handle
    IF handle = 0 THEN
        MOVE.TRANSFORM_TYPE = 0 ' Move
    ELSEIF handle = 1 OR handle = 2 OR handle = 3 OR handle = 4 THEN
        MOVE.TRANSFORM_TYPE = 1 ' Scale (corner handles)
    ELSE
        MOVE.TRANSFORM_TYPE = 2 ' Stretch (side handles)
    END IF
END SUB

' Update transform based on current mouse position
SUB MOVE_update_transform (x AS INTEGER, y AS INTEGER)
    IF NOT MOVE.TRANSFORMING THEN EXIT SUB
    
    DIM dx AS INTEGER, dy AS INTEGER, new_w AS INTEGER, new_h AS INTEGER
    DIM aspect_ratio AS SINGLE
    
    dx = x - MOVE.START_X
    dy = y - MOVE.START_Y
    
    ' Check for ALT (clone) and SHIFT (constrain) modifiers
    $IF MAC THEN
        MOVE.CLONING = MAC_ALT_HELD%
    $ELSE
        MOVE.CLONING = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
    $END IF
    MOVE.CONSTRAIN = (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&))
    
    ' Store old values to detect changes
    DIM old_x AS INTEGER, old_y AS INTEGER, old_w AS INTEGER, old_h AS INTEGER
    old_x = MOVE.CURRENT_X
    old_y = MOVE.CURRENT_Y
    old_w = MOVE.CURRENT_W
    old_h = MOVE.CURRENT_H
    
    SELECT CASE MOVE.TRANSFORM_TYPE
        CASE 0 ' Move
            MOVE.CURRENT_X = MOVE.SELECTION_X + dx
            MOVE.CURRENT_Y = MOVE.SELECTION_Y + dy
            
        CASE 1 ' Scale (corner handles)
            aspect_ratio = MOVE.SELECTION_W / MOVE.SELECTION_H
            
            SELECT CASE MOVE.HANDLE
                CASE 1 ' Top-left
                    new_w = MOVE.SELECTION_W - dx
                    new_h = MOVE.SELECTION_H - dy
                    IF MOVE.CONSTRAIN THEN
                        IF ABS(dx) > ABS(dy) THEN
                            new_h = INT(new_w / aspect_ratio)
                        ELSE
                            new_w = INT(new_h * aspect_ratio)
                        END IF
                    END IF
                    IF new_w > 1 AND new_h > 1 THEN
                        MOVE.CURRENT_X = MOVE.SELECTION_X + MOVE.SELECTION_W - new_w
                        MOVE.CURRENT_Y = MOVE.SELECTION_Y + MOVE.SELECTION_H - new_h
                        MOVE.CURRENT_W = new_w
                        MOVE.CURRENT_H = new_h
                    END IF
                    
                CASE 2 ' Top-right
                    new_w = MOVE.SELECTION_W + dx
                    new_h = MOVE.SELECTION_H - dy
                    IF MOVE.CONSTRAIN THEN
                        IF ABS(dx) > ABS(dy) THEN
                            new_h = INT(new_w / aspect_ratio)
                        ELSE
                            new_w = INT(new_h * aspect_ratio)
                        END IF
                    END IF
                    IF new_w > 1 AND new_h > 1 THEN
                        MOVE.CURRENT_Y = MOVE.SELECTION_Y + MOVE.SELECTION_H - new_h
                        MOVE.CURRENT_W = new_w
                        MOVE.CURRENT_H = new_h
                    END IF
                    
                CASE 3 ' Bottom-right
                    new_w = MOVE.SELECTION_W + dx
                    new_h = MOVE.SELECTION_H + dy
                    IF MOVE.CONSTRAIN THEN
                        IF ABS(dx) > ABS(dy) THEN
                            new_h = INT(new_w / aspect_ratio)
                        ELSE
                            new_w = INT(new_h * aspect_ratio)
                        END IF
                    END IF
                    IF new_w > 1 AND new_h > 1 THEN
                        MOVE.CURRENT_W = new_w
                        MOVE.CURRENT_H = new_h
                    END IF
                    
                CASE 4 ' Bottom-left
                    new_w = MOVE.SELECTION_W - dx
                    new_h = MOVE.SELECTION_H + dy
                    IF MOVE.CONSTRAIN THEN
                        IF ABS(dx) > ABS(dy) THEN
                            new_h = INT(new_w / aspect_ratio)
                        ELSE
                            new_w = INT(new_h * aspect_ratio)
                        END IF
                    END IF
                    IF new_w > 1 AND new_h > 1 THEN
                        MOVE.CURRENT_X = MOVE.SELECTION_X + MOVE.SELECTION_W - new_w
                        MOVE.CURRENT_W = new_w
                        MOVE.CURRENT_H = new_h
                    END IF
            END SELECT
            
        CASE 2 ' Stretch (side handles)
            SELECT CASE MOVE.HANDLE
                CASE 5 ' Top
                    new_h = MOVE.SELECTION_H - dy
                    IF new_h > 1 THEN
                        MOVE.CURRENT_Y = MOVE.SELECTION_Y + MOVE.SELECTION_H - new_h
                        MOVE.CURRENT_H = new_h
                    END IF
                    
                CASE 6 ' Right
                    new_w = MOVE.SELECTION_W + dx
                    IF new_w > 1 THEN
                        MOVE.CURRENT_W = new_w
                    END IF
                    
                CASE 7 ' Bottom
                    new_h = MOVE.SELECTION_H + dy
                    IF new_h > 1 THEN
                        MOVE.CURRENT_H = new_h
                    END IF
                    
                CASE 8 ' Left
                    new_w = MOVE.SELECTION_W - dx
                    IF new_w > 1 THEN
                        MOVE.CURRENT_X = MOVE.SELECTION_X + MOVE.SELECTION_W - new_w
                        MOVE.CURRENT_W = new_w
                    END IF
            END SELECT
    END SELECT
    
    ' Update marquee box to follow the transform in real-time
    IF MOVE.CURRENT_X <> old_x OR MOVE.CURRENT_Y <> old_y OR MOVE.CURRENT_W <> old_w OR MOVE.CURRENT_H <> old_h THEN
        MARQUEE.BOX.x = MOVE.CURRENT_X
        MARQUEE.BOX.y = MOVE.CURRENT_Y
        MARQUEE.BOX.w = MOVE.CURRENT_W
        MARQUEE.BOX.h = MOVE.CURRENT_H
        ' Update preview buffer when transform changes
        MOVE_update_preview_buffer
    END IF
END SUB

' Apply the transform to the canvas
SUB MOVE_apply_transform ()
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    ' Check ALT key at apply time to determine clone mode
    $IF MAC THEN
        MOVE.CLONING = MAC_ALT_HELD%
    $ELSE
        MOVE.CLONING = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
    $END IF
    
    ' Use the captured layer (not necessarily current layer, which may have changed)
    DIM targetLayer AS INTEGER
    targetLayer% = MOVE.CAPTURED_LAYER
    IF targetLayer% < 1 OR targetLayer% > 64 OR LAYERS(targetLayer%).imgHandle& = 0 THEN
        targetLayer% = CURRENT_LAYER%  ' Fallback to current layer
    END IF
    DIM targetImg AS LONG
    targetImg& = LAYERS(targetLayer%).imgHandle&
    
    _DEST targetImg&
    
    ' If not cloning (and no stamps were placed), clear the ORIGINAL area to transparent
    ' Must use _DONTBLEND so alpha=0 pixels actually overwrite existing content
    IF NOT MOVE.CLONING AND NOT MOVE.CLONE_STAMPED THEN
        _DONTBLEND targetImg&
        LINE (MOVE.ORIGINAL_X, MOVE.ORIGINAL_Y)-(MOVE.ORIGINAL_X + MOVE.ORIGINAL_W - 1, MOVE.ORIGINAL_Y + MOVE.ORIGINAL_H - 1), _RGBA32(0, 0, 0, 0), BF
        _BLEND targetImg&
    END IF
    
    ' Draw the transformed selection
    IF MOVE.SELECTION_IMAGE < -1 THEN
        _PUTIMAGE (MOVE.CURRENT_X, MOVE.CURRENT_Y)-(MOVE.CURRENT_X + MOVE.CURRENT_W - 1, MOVE.CURRENT_Y + MOVE.CURRENT_H - 1), MOVE.SELECTION_IMAGE, targetImg&
    END IF
    
    _DEST SCRN.CANVAS&
    
    ' Update marquee to new position/size
    MARQUEE.BOX.x = MOVE.CURRENT_X
    MARQUEE.BOX.y = MOVE.CURRENT_Y
    MARQUEE.BOX.w = MOVE.CURRENT_W
    MARQUEE.BOX.h = MOVE.CURRENT_H
    
    CANVAS_DIRTY% = TRUE
    LAYERS(targetLayer%).contentDirty% = TRUE
    BLEND_invalidate_cache
    
    ' Save undo state AFTER transform is committed so the post-move result
    ' is captured. Pre-move state was saved in MOVE_capture_selection.
    ' Use UNDO_save_layer_state with the target layer (CAPTURED_LAYER) so undo
    ' captures the correct layer, not whichever layer happens to be selected now.
    IF NOT UNDO_saved_this_frame% THEN
        UNDO_save_layer_state targetLayer%
        UNDO_saved_this_frame% = TRUE
    END IF
    
    ' Reset transforming flag
    MOVE.TRANSFORMING = FALSE
END SUB


''
' Stamp a copy of the selection at the current position (for clone mode)
' Unlike apply_transform, this keeps the move tool active for more stamps
SUB MOVE_stamp ()
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    ' Use the captured layer (not necessarily current layer)
    DIM stampTarget AS INTEGER
    stampTarget% = MOVE.CAPTURED_LAYER
    IF stampTarget% < 1 OR stampTarget% > 64 OR LAYERS(stampTarget%).imgHandle& = 0 THEN
        stampTarget% = CURRENT_LAYER%
    END IF
    DIM stampImg AS LONG
    stampImg& = LAYERS(stampTarget%).imgHandle&
    
    _DEST stampImg&
    
    ' Draw a copy of the selection at current position (DON'T clear original - that's the point of stamp)
    IF MOVE.SELECTION_IMAGE < -1 THEN
        _PUTIMAGE (MOVE.CURRENT_X, MOVE.CURRENT_Y)-(MOVE.CURRENT_X + MOVE.CURRENT_W - 1, MOVE.CURRENT_Y + MOVE.CURRENT_H - 1), MOVE.SELECTION_IMAGE, stampImg&
    END IF
    
    _DEST SCRN.CANVAS&
    
    ' Save undo state AFTER stamp so the post-stamp result is captured.
    ' This matches the "save after modification" pattern used by brush, line, etc.
    ' Each stamp gets its own undo state, so consecutive stamps can be undone individually.
    IF NOT UNDO_saved_this_frame% THEN
        UNDO_save_layer_state stampTarget%
        UNDO_saved_this_frame% = TRUE
    END IF
    
    ' Latch clone mode - once stamped, don't clear original area on commit
    MOVE.CLONE_STAMPED = TRUE
    
    ' Update the selection base to current position for next drag
    MOVE.SELECTION_X = MOVE.CURRENT_X
    MOVE.SELECTION_Y = MOVE.CURRENT_Y
    
    ' Update marquee to stamped position
    MARQUEE.BOX.x = MOVE.CURRENT_X
    MARQUEE.BOX.y = MOVE.CURRENT_Y
    MARQUEE.BOX.w = MOVE.CURRENT_W
    MARQUEE.BOX.h = MOVE.CURRENT_H
    
    CANVAS_DIRTY% = TRUE
    LAYERS(stampTarget%).contentDirty% = TRUE
    BLEND_invalidate_cache
    
    ' Suppress marching ants around stamped clones
    MARQUEE.USER_CREATED = FALSE
    
    ' Keep move tool active for more stamps - don't reset MOVE.TRANSFORMING
END SUB


' Cancel the current transform
SUB MOVE_cancel_transform ()
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    
    ' Reset to original position/size from when tool was activated
    MOVE.CURRENT_X = MOVE.ORIGINAL_X
    MOVE.CURRENT_Y = MOVE.ORIGINAL_Y
    MOVE.CURRENT_W = MOVE.ORIGINAL_W
    MOVE.CURRENT_H = MOVE.ORIGINAL_H
    
    ' Also reset selection base
    MOVE.SELECTION_X = MOVE.ORIGINAL_X
    MOVE.SELECTION_Y = MOVE.ORIGINAL_Y
    MOVE.SELECTION_W = MOVE.ORIGINAL_W
    MOVE.SELECTION_H = MOVE.ORIGINAL_H
    
    ' Update marquee to original position
    MARQUEE.BOX.x = MOVE.ORIGINAL_X
    MARQUEE.BOX.y = MOVE.ORIGINAL_Y
    MARQUEE.BOX.w = MOVE.ORIGINAL_W
    MARQUEE.BOX.h = MOVE.ORIGINAL_H
    
    MOVE.TRANSFORMING = FALSE
END SUB

' Render preview of the transform with realtime visualization
' Note: dest should be the canvas, but we need zoom info from SCRN for coordinate conversion
SUB MOVE_render_preview (dest AS LONG)
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    ' The preview buffer already contains the painting layer with move applied
    ' This is just for drawing additional visual feedback (border, handles, etc.)
    ' The actual preview rendering happens in SCREEN_render using MOVE_get_preview_buffer
    
    ' Calculate zoomed coordinates for canvas overlay (canvas dimensions, centered in viewport)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    DIM zx AS INTEGER, zy AS INTEGER, zx2 AS INTEGER, zy2 AS INTEGER
    zw& = SCRN.canvasW& * SCRN.zoom!
    zh& = SCRN.canvasH& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%

    ' Convert painting coordinates to canvas (screen) coordinates
    zx% = dx% + INT(MOVE.CURRENT_X * SCRN.zoom!)
    zy% = dy% + INT(MOVE.CURRENT_Y * SCRN.zoom!)
    zx2% = dx% + INT((MOVE.CURRENT_X + MOVE.CURRENT_W) * SCRN.zoom!) - 1
    zy2% = dy% + INT((MOVE.CURRENT_Y + MOVE.CURRENT_H) * SCRN.zoom!) - 1
    
    _DEST dest
    
    ' Draw visual feedback during active transform (white outline)
    ' Only show outline for user-created selections, not full-layer auto-selections
    IF MOVE.TRANSFORMING AND MARQUEE.USER_CREATED THEN
        DIM c~& : c~& = _RGB32(255, 255, 255)
        ' White outline for active transform feedback in canvas coordinates
        LINE (zx%, zy%)-(zx2%, zy2%), c~&, B
    END IF
END SUB


''
' Render the status tip bar for the move tool (called AFTER GUI layer)
' @param dest LONG Destination image handle
SUB MOVE_render_status (dest AS LONG)
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    DIM prevDest AS LONG
    prevDest& = _DEST
    
    ' Check current ALT state for status display
    $IF MAC THEN
        MOVE.CLONING = MAC_ALT_HELD%
    $ELSE
        MOVE.CLONING = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
    $END IF
    
    ' Calculate zoomed coordinates for canvas overlay (canvas dimensions, centered in viewport)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.canvasW& * SCRN.zoom!
    zh& = SCRN.canvasH& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%

    ' Draw status tip bar at bottom of canvas
    DIM status_text AS STRING
    
    ' Build status text based on current state
    IF MOVE.CLONING THEN
        ' Clone mode active - show stamp instructions
        status_text$ = "[CLONE] DRAG+Release: Stamp copy | Keep ALT held for more stamps | Release ALT: Done"
    ELSE
        ' Normal move mode
        status_text$ = "DRAG: Move | ARROWS: Nudge | H/V: Flip | Hold ALT+DRAG: Stamp copies | ENTER: Apply | ESC: Cancel"
    END IF
    
    ' Use shared STATUS_FONT (loaded once at init, not per-frame)
    DIM old_font AS LONG
    DIM text_h AS INTEGER
    DIM bar_y AS INTEGER
    
    IF STATUS_FONT > 0 THEN
        old_font& = _FONT(dest)
        _FONT STATUS_FONT, dest
        text_h% = _FONTHEIGHT(STATUS_FONT)
    ELSE
        old_font& = 0
        text_h% = 8
    END IF
    
    ' Position status bar at the very bottom of the screen, covering everything
    bar_y% = _HEIGHT(dest) - text_h% - 4
    
    _DEST dest
    
    ' Draw solid background bar across full width at bottom
    LINE (0, bar_y%)-((_WIDTH(dest) - 1), _HEIGHT(dest) - 1), _RGB32(32, 32, 32), BF
    ' Top border line
    LINE (0, bar_y%)-((_WIDTH(dest) - 1), bar_y%), _RGB32(80, 80, 80)
    
    ' Draw status text (flush left)
    COLOR _RGB32(255, 255, 255), _RGB32(32, 32, 32)
    _PRINTSTRING (4, bar_y% + 2), status_text$
    
    ' Restore original font
    IF old_font& > 0 THEN
        _FONT old_font&, dest
    END IF
    
    _DEST prevDest&
END SUB

' Update the preview buffer with current transform state
' This creates a "virtual" view of the painting layer with the move/transform applied
SUB MOVE_update_preview_buffer ()
    IF MOVE.PREVIEW_BUFFER = 0 THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    ' Use the captured layer (not necessarily current layer)
    DIM previewLayer AS INTEGER
    previewLayer% = MOVE.CAPTURED_LAYER
    IF previewLayer% < 1 OR previewLayer% > 64 OR LAYERS(previewLayer%).imgHandle& = 0 THEN
        previewLayer% = CURRENT_LAYER%
    END IF
    DIM previewSrc AS LONG
    previewSrc& = LAYERS(previewLayer%).imgHandle&
    
    ' Clear preview buffer first to prevent ghosts
    _DEST MOVE.PREVIEW_BUFFER
    CLS , _RGBA32(0, 0, 0, 0) ' Clear with transparency for layers
    
    ' Copy entire captured layer to preview buffer
    _PUTIMAGE , previewSrc&, MOVE.PREVIEW_BUFFER
    
    ' If NOT cloning (and no stamps were placed), clear the ORIGINAL area to transparent
    ' Must use _DONTBLEND so alpha=0 pixels actually overwrite existing content
    IF NOT MOVE.CLONING AND NOT MOVE.CLONE_STAMPED THEN
        _DONTBLEND MOVE.PREVIEW_BUFFER
        LINE (MOVE.ORIGINAL_X, MOVE.ORIGINAL_Y)-(MOVE.ORIGINAL_X + MOVE.ORIGINAL_W - 1, MOVE.ORIGINAL_Y + MOVE.ORIGINAL_H - 1), _RGBA32(0, 0, 0, 0), BF
        _BLEND MOVE.PREVIEW_BUFFER
    END IF
    
    ' Draw the transformed selection at its current position/size
    _PUTIMAGE (MOVE.CURRENT_X, MOVE.CURRENT_Y)-(MOVE.CURRENT_X + MOVE.CURRENT_W - 1, MOVE.CURRENT_Y + MOVE.CURRENT_H - 1), MOVE.SELECTION_IMAGE, MOVE.PREVIEW_BUFFER
END SUB

' Get the preview buffer for rendering
' Returns the preview buffer if move is active, 0 otherwise
FUNCTION MOVE_get_preview_buffer& ()
    IF MOVE.ACTIVE AND MOVE.PREVIEW_BUFFER < -1 THEN
        MOVE_get_preview_buffer& = MOVE.PREVIEW_BUFFER
    ELSE
        MOVE_get_preview_buffer& = 0
    END IF
END FUNCTION

' Flip the selection image horizontally
SUB MOVE_flip_horizontal ()
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    DIM w AS INTEGER, h AS INTEGER
    DIM flipped AS LONG
    
    w% = _WIDTH(MOVE.SELECTION_IMAGE)
    h% = _HEIGHT(MOVE.SELECTION_IMAGE)
    
    ' Create a new image for the flipped version
    flipped& = _NEWIMAGE(w%, h%, 32)
    
    ' Copy pixels flipped horizontally using _PUTIMAGE with negative width
    _PUTIMAGE (w% - 1, 0)-(0, h% - 1), MOVE.SELECTION_IMAGE, flipped&
    
    ' Free the old image and replace with flipped
    IF MOVE.SELECTION_IMAGE < -1 THEN _FREEIMAGE MOVE.SELECTION_IMAGE
    MOVE.SELECTION_IMAGE = flipped&
    
    ' Update preview buffer
    MOVE_update_preview_buffer
END SUB

' Flip the selection image vertically
SUB MOVE_flip_vertical ()
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE = 0 THEN EXIT SUB
    
    DIM w AS INTEGER, h AS INTEGER
    DIM flipped AS LONG
    
    w% = _WIDTH(MOVE.SELECTION_IMAGE)
    h% = _HEIGHT(MOVE.SELECTION_IMAGE)
    
    ' Create a new image for the flipped version
    flipped& = _NEWIMAGE(w%, h%, 32)
    
    ' Copy pixels flipped vertically using _PUTIMAGE with negative height
    _PUTIMAGE (0, h% - 1)-(w% - 1, 0), MOVE.SELECTION_IMAGE, flipped&
    
    ' Free the old image and replace with flipped
    IF MOVE.SELECTION_IMAGE < -1 THEN _FREEIMAGE MOVE.SELECTION_IMAGE
    MOVE.SELECTION_IMAGE = flipped&
    
    ' Update preview buffer
    MOVE_update_preview_buffer
END SUB

' Nudge the selection by dx, dy pixels
SUB MOVE_nudge (dx AS INTEGER, dy AS INTEGER)
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    
    ' Update current position
    MOVE.CURRENT_X = MOVE.CURRENT_X + dx%
    MOVE.CURRENT_Y = MOVE.CURRENT_Y + dy%
    
    ' Also update base selection position for subsequent transforms
    MOVE.SELECTION_X = MOVE.CURRENT_X
    MOVE.SELECTION_Y = MOVE.CURRENT_Y
    
    ' Update marquee box to follow
    MARQUEE.BOX.x = MOVE.CURRENT_X
    MARQUEE.BOX.y = MOVE.CURRENT_Y
    
    ' Update preview buffer
    MOVE_update_preview_buffer
END SUB

' Resize the selection by dw, dh pixels (scaling the image)
SUB MOVE_resize (dw AS INTEGER, dh AS INTEGER)
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    
    ' Calculate new dimensions
    DIM new_w AS INTEGER, new_h AS INTEGER
    new_w% = MOVE.CURRENT_W + dw%
    new_h% = MOVE.CURRENT_H + dh%
    
    ' Enforce minimum size
    IF new_w% < 1 THEN new_w% = 1
    IF new_h% < 1 THEN new_h% = 1
    
    ' Update current dimensions
    MOVE.CURRENT_W = new_w%
    MOVE.CURRENT_H = new_h%
    
    ' Also update base selection size for subsequent transforms
    MOVE.SELECTION_W = new_w%
    MOVE.SELECTION_H = new_h%
    
    ' Update marquee box to follow
    MARQUEE.BOX.w = MOVE.CURRENT_W
    MARQUEE.BOX.h = MOVE.CURRENT_H
    
    ' Update preview buffer
    MOVE_update_preview_buffer
END SUB
