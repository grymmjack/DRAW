''
' DRAW - OUTPUT/SCREEN.BM
' =============================================================================
' Screen output files subs and functions.
'
' @todo
' @depends ./SCREEN.BI
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Helper for console output in graphics mode
'
SUB ECHO_LOG (msg AS STRING)
    DIM d AS LONG
    d& = _DEST
    _DEST _CONSOLE
    PRINT msg
    _DEST d&
END SUB

''
' Mark GUI as needing redraw
' Call this when: tool switches, palette changes, window resizes, toolbar/status toggles
'
SUB GUI_mark_dirty ()
    GUI_NEEDS_REDRAW% = TRUE
END SUB

''
' Detects the resolution of the desktop and sets the width and height to It
' 
SUB SCREEN_detect_desktop_resolution()
    DO: _LIMIT CFG.FPS_LIMIT% : LOOP UNTIL _SCREENEXISTS
    SCRN.w& = _DESKTOPWIDTH : SCRN.h& = _DESKTOPHEIGHT
END SUB


''
' Detects optimal display scale based on desktop resolution
' Returns scale clamped to CFG.DISPLAY_SCALE_MAX%
' 
FUNCTION SCREEN_detect_display_scale% ()
    DIM desktopH AS INTEGER
    DIM scale AS INTEGER
    DIM maxFitW AS INTEGER, maxFitH AS INTEGER
    
    ' Wait for screen to exist and get valid desktop dimensions
    DO: _LIMIT CFG.FPS_LIMIT% : LOOP UNTIL _SCREENEXISTS
    DO
        desktopH% = _DESKTOPHEIGHT
        IF desktopH% <= 0 THEN _DELAY 0.01
    LOOP UNTIL desktopH% > 0
    
    ' Calculate scale based on desktop height
    ' 4K (2160+) = 4x, 1440p (1440+) = 3x, 1080p (1080+) = 2x, else 1x
    IF desktopH% >= 2160 THEN
        scale% = 4
    ELSEIF desktopH% >= 1440 THEN
        scale% = 3
    ELSEIF desktopH% >= 1080 THEN
        scale% = 2
    ELSE
        scale% = 1
    END IF
    
    ' Clamp to configured maximum
    IF scale% > CFG.DISPLAY_SCALE_MAX% THEN scale% = CFG.DISPLAY_SCALE_MAX%
    
    ' Also ensure window fits on desktop (leave some margin for taskbar/dock)
    ' Calculate max scale that fits
    IF SCRN.w& > 0 AND SCRN.h& > 0 THEN
        maxFitW% = (_DESKTOPWIDTH - 100) \ SCRN.w&
        maxFitH% = (_DESKTOPHEIGHT - 100) \ SCRN.h&
        IF maxFitW% < scale% THEN scale% = maxFitW%
        IF maxFitH% < scale% THEN scale% = maxFitH%
    END IF
    
    ' Minimum scale is 1
    IF scale% < 1 THEN scale% = 1
    
    SCREEN_detect_display_scale% = scale%
END FUNCTION


''
' Set display scale at runtime (for hotkey scaling)
' newScale: desired new scale (will be clamped to valid range)
' 
SUB SCREEN_set_display_scale (newScale AS INTEGER)
    DIM winW AS LONG, winH AS LONG
    DIM maxFitW AS INTEGER, maxFitH AS INTEGER
    DIM clampedScale AS INTEGER
    
    ' Don't allow scale changes in fullscreen mode
    IF CFG.FULLSCREEN% THEN EXIT SUB
    
    clampedScale% = newScale%
    
    ' Clamp to minimum of 1
    IF clampedScale% < 1 THEN clampedScale% = 1
    
    ' Clamp to configured maximum
    IF clampedScale% > CFG.DISPLAY_SCALE_MAX% THEN
        clampedScale% = CFG.DISPLAY_SCALE_MAX%
    END IF
    
    ' Clamp to fit on desktop (leave margin for taskbar/dock)
    maxFitW% = (_DESKTOPWIDTH - 100) \ SCRN.w&
    maxFitH% = (_DESKTOPHEIGHT - 100) \ SCRN.h&
    IF clampedScale% > maxFitW% THEN clampedScale% = maxFitW%
    IF clampedScale% > maxFitH% THEN clampedScale% = maxFitH%
    
    ' No change needed
    IF clampedScale% = SCRN.displayScale% THEN EXIT SUB
    
    ' Update display scale
    SCRN.displayScale% = clampedScale%
    
    ' Calculate new window size
    winW& = SCRN.w& * SCRN.displayScale%
    winH& = SCRN.h& * SCRN.displayScale%
    
    ' Create new window image FIRST (before freeing old one)
    DIM oldWindow AS LONG
    oldWindow& = SCRN.WINDOW_IMG&
    SCRN.WINDOW_IMG& = _NEWIMAGE(winW&, winH&, 32)
    
    ' Switch to new window
    SCREEN SCRN.WINDOW_IMG&
    _DEST SCRN.CANVAS&
    
    ' NOW free the old window image (after we're no longer using it as SCREEN)
    IF oldWindow& < -1 THEN _FREEIMAGE oldWindow&
    
    ' Reset input state after screen change
    DO WHILE _MOUSEINPUT: LOOP  ' Drain mouse buffer
    MOUSE_force_buttons_up       ' Reset button state
    _MOUSEHIDE                   ' Ensure system cursor stays hidden
    
    ' Mark GUI as needing redraw
    GUI_NEEDS_REDRAW% = TRUE
    
    ' Mark config as changed
    CFG.DISPLAY_SCALE_CHANGED% = TRUE
END SUB


''
' Initialize the screen and various images we will use
' 
SUB SCREEN_init ()
    DIM winW AS LONG, winH AS LONG
    
    ' Load configuration from disk
    CONFIG_load
    
    SCRN.w&   = 0
    SCRN.h&   = 0
    SCRN.bpp% = 0
    
    ' Get screen dimensions from config or auto-detect
    IF CFG.SCREEN_WIDTH% > 0 AND CFG.SCREEN_HEIGHT% > 0 THEN
        ' Use configured dimensions
        SCRN.w& = CFG.SCREEN_WIDTH%
        SCRN.h& = CFG.SCREEN_HEIGHT%
    ELSE
        ' Auto-detect desktop resolution
        SCREEN_detect_desktop_resolution
    END IF
    
    ' Determine display scale
    IF CFG.DISPLAY_SCALE% > 0 THEN
        ' Use explicit scale from config
        SCRN.displayScale% = CFG.DISPLAY_SCALE%
        ' Clamp to max
        IF SCRN.displayScale% > CFG.DISPLAY_SCALE_MAX% THEN
            SCRN.displayScale% = CFG.DISPLAY_SCALE_MAX%
        END IF
    ELSE
        ' Auto-detect optimal scale
        SCRN.displayScale% = SCREEN_detect_display_scale%
    END IF
    
    ' Ensure minimum scale of 1
    IF SCRN.displayScale% < 1 THEN SCRN.displayScale% = 1
    
    SCRN.zoom! = 1.0      ' Start at 1x zoom
    SCRN.zoomMin! = 0.25  ' 25% minimum zoom
    SCRN.zoomMax! = 8.0   ' 8x maximum zoom
    SCRN.offsetX% = 0
    SCRN.offsetY% = 0
    SCRN.panning% = FALSE
    SCRN.panStartX% = 0
    SCRN.panStartY% = 0
    SCRN.panOrigOffsetX% = 0
    SCRN.panOrigOffsetY% = 0
    SCRN.showToolbar% = TRUE
    SCRN.showStatus% = TRUE
    SCRN.toolbarManuallyHidden% = FALSE
    SCRN.statusManuallyHidden% = FALSE
    
    ' Create image buffers at logical canvas size
    SCRN.CANVAS&   = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    SCRN.PAINTING& = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    SCRN.GUI&      = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    SCRN.CURSOR&   = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    
    ' Create window display buffer at scaled size
    winW& = SCRN.w& * SCRN.displayScale%
    winH& = SCRN.h& * SCRN.displayScale%
    SCRN.WINDOW_IMG& = _NEWIMAGE(winW&, winH&, 32)
    
    _DEST SCRN.PAINTING&
    CLS , _RGBA32(0, 0, 0, 0)
    _DEST SCRN.GUI&
    
    ' Use WINDOW_IMG as the screen (window size)
    SCREEN SCRN.WINDOW_IMG&
    _DEST SCRN.CANVAS&
    
    IF CFG.FULLSCREEN% THEN _FULLSCREEN _SQUAREPIXELS
    SCRN.bpp% = _PIXELSIZE
    ' Initialize tools
    LAYERS_init  ' Initialize layers system (must be after CONFIG_load)
    WORKSPACE_UNDO_init  ' Initialize workspace undo (must be after LAYERS_init)
    MOVE_init
    TEXT_init
    GRID_init
    PIXEL_GRID_init
    SYMMETRY_init
    STATUS_init
    PALETTE_LOADER_init
    PALETTE_STRIP_init
    CMD_init  ' Initialize command palette
END SUB


''
' Draws screen
' 
SUB SCREEN_render ()
    ' todo get status to hide when painting 
    _DEST SCRN.CANVAS&
    CLS
    
    ' Clear GUI layer and render toolbar/status conditionally
    ' Only redraw GUI elements when GUI_NEEDS_REDRAW is TRUE (optimization)
    IF GUI_NEEDS_REDRAW% THEN
        _DEST SCRN.GUI&
        CLS , _RGBA32(0, 0, 0, 0) ' Clear with transparency
        
        IF SCRN.showToolbar% THEN
            TOOLBAR_render 0, 0, 13  ' xPos parameter not used anymore
        END IF
        IF SCRN.showStatus% THEN 
            PALETTE_STRIP_render
            STATUS_render
        END IF
        
        ' Render layer panel if visible
        IF LAYER_PANEL.visible% THEN
            LAYER_PANEL_render SCRN.h&
        END IF
    END IF
    
    ' Switch back to canvas for main rendering
    _DEST SCRN.CANVAS&
    
    ' Calculate zoomed dimensions and position (using logical canvas dimensions)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.w& * SCRN.zoom!
    zh& = SCRN.h& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%
    
    ' Offset canvas X when layer panel is visible
    IF LAYER_PANEL.visible% THEN
        dx% = dx% + CFG.LAYER_PANEL_WIDTH%
    END IF
    
    ' Render transparency checkerboard first (behind all layers)
    TRANSPARENCY_render SCRN.CANVAS&, dx%, dy%, zw&, zh&
    
    ' Render all visible layers with zoom, compositing bottom-to-top
    _DEST SCRN.CANVAS&
    _BLEND SCRN.CANVAS&
    
    IF LAYER_COUNT% > 0 THEN
        ' Composite layers by zIndex (bottom to top)
        DIM layerZ AS INTEGER, layerI AS INTEGER
        DIM layerFound AS INTEGER
        DIM tempLayerImg AS LONG
        
        FOR layerZ% = 1 TO LAYER_COUNT%
            layerFound% = 0
            FOR layerI% = 1 TO 64
                IF LAYERS(layerI%).imgHandle& <> 0 AND LAYERS(layerI%).zIndex% = layerZ% THEN
                    layerFound% = layerI%
                    EXIT FOR
                END IF
            NEXT layerI%
            
            IF layerFound% > 0 AND LAYERS(layerFound%).visible% THEN
                ' Determine which image to render for this layer
                ' If MOVE tool is active on this layer, use the preview buffer instead
                DIM layerRenderSource AS LONG
                IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE AND layerFound% = CURRENT_LAYER% THEN
                    layerRenderSource& = MOVE_get_preview_buffer&
                    IF layerRenderSource& = 0 THEN layerRenderSource& = LAYERS(layerFound%).imgHandle&
                ELSE
                    layerRenderSource& = LAYERS(layerFound%).imgHandle&
                END IF
                
                ' Apply opacity if not fully opaque
                IF LAYERS(layerFound%).opacity% < 255 THEN
                    tempLayerImg& = _COPYIMAGE(layerRenderSource&, 32)
                    ' Apply opacity only to non-transparent pixels (preserve transparency)
                    DIM lx AS INTEGER, ly AS INTEGER
                    DIM lw AS INTEGER, lh AS INTEGER
                    DIM pixelColor AS _UNSIGNED LONG
                    DIM pixelAlpha AS INTEGER
                    DIM newAlpha AS INTEGER
                    DIM layerOpacity AS SINGLE
                    
                    lw% = _WIDTH(tempLayerImg&)
                    lh% = _HEIGHT(tempLayerImg&)
                    layerOpacity! = LAYERS(layerFound%).opacity% / 255.0
                    
                    DIM oldDest AS LONG, oldSource AS LONG
                    oldDest& = _DEST
                    oldSource& = _SOURCE
                    _SOURCE tempLayerImg&
                    _DEST tempLayerImg&
                    _DONTBLEND tempLayerImg&
                    
                    FOR ly% = 0 TO lh% - 1
                        FOR lx% = 0 TO lw% - 1
                            pixelColor~& = POINT(lx%, ly%)
                            pixelAlpha% = _ALPHA32(pixelColor~&)
                            IF pixelAlpha% > 0 THEN
                                ' Scale existing alpha by layer opacity
                                newAlpha% = INT(pixelAlpha% * layerOpacity!)
                                IF newAlpha% > 255 THEN newAlpha% = 255
                                IF newAlpha% < 0 THEN newAlpha% = 0
                                PSET (lx%, ly%), _RGBA32(_RED32(pixelColor~&), _GREEN32(pixelColor~&), _BLUE32(pixelColor~&), newAlpha%)
                            END IF
                        NEXT lx%
                    NEXT ly%
                    
                    _BLEND tempLayerImg&
                    _SOURCE oldSource&
                    _DEST oldDest&
                    
                    _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), tempLayerImg&
                    IF tempLayerImg& < -1 THEN _FREEIMAGE tempLayerImg&
                ELSE
                    _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), layerRenderSource&
                END IF
            END IF
        NEXT layerZ%
    ELSE
        ' Fallback: Use SCRN.PAINTING if no layers exist yet (legacy support)
        DIM paint_source AS LONG
        paint_source& = MOVE_get_preview_buffer&
        IF paint_source& <> 0 THEN
            ' Use preview buffer showing move transform in realtime
            _SOURCE paint_source&
            _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), paint_source&
        ELSE
            ' Normal painting layer render
            _SOURCE SCRN.PAINTING&
            _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), SCRN.PAINTING&
        END IF
    END IF
    
    ' Draw grid overlays (after painting, before border/GUI)
    ' Regular grid shows at 100%+ zoom if enabled
    IF GRID.SHOW% AND SCRN.zoom! >= 1.0 THEN
        _DEST SCRN.CANVAS&
        _SOURCE GRID.imgHandle&
        _BLEND SCRN.CANVAS&
        _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), GRID.imgHandle&, SCRN.CANVAS&
    END IF
    ' Pixel grid shows at 400%+ zoom if enabled (on top of regular grid)
    IF PIXEL_GRID.SHOW% AND SCRN.zoom! >= 4.0 THEN
        DIM pgx AS INTEGER, pgy AS INTEGER
        DIM pzoom AS INTEGER
        DIM pgImg AS LONG
        DIM pgColor AS _UNSIGNED LONG
        pzoom% = INT(SCRN.zoom!)
        ' Create temporary image for pixel grid with alpha
        pgImg& = _NEWIMAGE(zw& + 1, zh& + 1, 32)
        _DEST pgImg&
        CLS , _RGBA32(0, 0, 0, 0)  ' Clear with full transparency
        ' Use opaque color for drawing to avoid intersection artifacts
        pgColor~& = _RGB32(_RED32(THEME.PIXEL_GRID_color1~&), _GREEN32(THEME.PIXEL_GRID_color1~&), _BLUE32(THEME.PIXEL_GRID_color1~&))
        ' Draw vertical lines between each pixel column
        FOR pgx% = 0 TO SCRN.w&
            LINE (pgx% * pzoom%, 0)-(pgx% * pzoom%, zh&), pgColor~&
        NEXT pgx%
        ' Draw horizontal lines between each pixel row
        FOR pgy% = 0 TO SCRN.h&
            LINE (0, pgy% * pzoom%)-(zw&, pgy% * pzoom%), pgColor~&
        NEXT pgy%
        ' Apply 25% opacity globally to all drawn pixels (alpha 64)
        _SETALPHA 64, pgColor~& TO pgColor~&, pgImg&
        ' Composite with alpha blending onto canvas
        _DEST SCRN.CANVAS&
        _BLEND SCRN.CANVAS&
        _PUTIMAGE (dx%, dy%), pgImg&
        IF pgImg& < -1 THEN _FREEIMAGE pgImg&
    END IF
    
    ' Draw symmetry guide overlay (after grids, before border/GUI)
    IF SYMMETRY.MODE > 0 THEN
        ' Recreate guide image if size changed
        IF SYMMETRY.imgHandle& = 0 OR _WIDTH(SYMMETRY.imgHandle&) <> zw& OR _HEIGHT(SYMMETRY.imgHandle&) <> zh& THEN
            IF SYMMETRY.imgHandle& < -1 THEN _FREEIMAGE SYMMETRY.imgHandle&
            SYMMETRY.imgHandle& = _NEWIMAGE(zw&, zh&, 32)
            SYMMETRY.DIRTY% = TRUE
        END IF
        
        _LOGINFO "SCREEN: Compositing symmetry guides - imgHandle=" + ns$(SYMMETRY.imgHandle&) + " mode=" + ns$(SYMMETRY.MODE) + " size=(" + ns$(zw&) + "," + ns$(zh&) + ")"
        SYMMETRY_render_guides zw&, zh&, SCRN.zoom!
        _DEST SCRN.CANVAS&
        _BLEND SCRN.CANVAS&  ' Use alpha blending for transparency
        _PUTIMAGE (dx%, dy%), SYMMETRY.imgHandle&, SCRN.CANVAS&
    END IF
    
    ' Draw border around canvas (after painting layer)
    LINE (dx% - 1, dy% - 1)-(dx% + zw&, dy% + zh&), _RGB32(51, 51, 51), B
    
    ' ==== IMAGE IMPORT PREVIEW ====
    ' Draw import preview if in import mode (on top of painting, below GUI)
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        _DEST SCRN.CANVAS&
        IMAGE_IMPORT_draw SCRN.CANVAS&
    END IF
    ' ==== END IMAGE IMPORT PREVIEW ====
    
    ' ==== TOOL PREVIEWS (BEFORE GUI LAYER) ====
    ' Draw MARQUEE selection if active or dragging
    IF CURRENT_TOOL% = TOOL_MARQUEE AND (MARQUEE.ACTIVE% OR MARQUEE.DRAGGING%) THEN
        _DEST SCRN.CANVAS&
        MARQUEE_draw TRUE
    END IF
    ' Draw MOVE transform preview if active
    IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
        _DEST SCRN.CANVAS&
        MOVE_render_preview SCRN.CANVAS&
        ' Also draw marquee handles around the transformed selection
        MARQUEE_draw TRUE
    END IF
    ' Draw TEXT preview if editing
    IF CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE THEN
        _DEST SCRN.CANVAS&
        TEXT_render_preview SCRN.CANVAS&, dx%, dy%, SCRN.zoom!
    END IF
    ' Draw LINE preview while dragging (converted to zoomed screen coordinates)
    ' Skip when panning to avoid stale line rendering
    IF CURRENT_TOOL% = TOOL_LINE AND LINE_TOOL.DRAGGING AND NOT SCRN.panning% THEN
        _DEST SCRN.CANVAS&
        DIM lsx AS INTEGER, lsy AS INTEGER, lex AS INTEGER, ley AS INTEGER
        lsx% = dx% + INT(LINE_TOOL.START_X * SCRN.zoom!)
        lsy% = dy% + INT(LINE_TOOL.START_Y * SCRN.zoom!)
        lex% = dx% + INT(LINE_TOOL.END_X * SCRN.zoom!)
        ley% = dy% + INT(LINE_TOOL.END_Y * SCRN.zoom!)
        LINE (lsx%, lsy%)-(lex%, ley%), PAINT_COLOR~&
    END IF
    ' Draw POLY_LINE preview from last point to mouse cursor (converted to zoomed screen coordinates)
    ' Skip when panning to avoid stale line rendering
    IF (CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED) AND POLY_LINE.HAS_LAST AND NOT SCRN.panning% THEN
        _DEST SCRN.CANVAS&
        DIM plsx AS INTEGER, plsy AS INTEGER, plex AS INTEGER, pley AS INTEGER
        plsx% = dx% + INT(POLY_LINE.LAST_X * SCRN.zoom!)
        plsy% = dy% + INT(POLY_LINE.LAST_Y * SCRN.zoom!)
        plex% = dx% + INT(MOUSE.X% * SCRN.zoom!)
        pley% = dy% + INT(MOUSE.Y% * SCRN.zoom!)
        LINE (plsx%, plsy%)-(plex%, pley%), PAINT_COLOR~&
    END IF
    ' Draw RECT preview while dragging (converted to zoomed screen coordinates)
    ' Skip when panning to avoid stale preview rendering
    IF (CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED) AND RECT_TOOL.DRAGGING AND NOT SCRN.panning% THEN
        _DEST SCRN.CANVAS&
        DIM rsx AS INTEGER, rsy AS INTEGER, rex AS INTEGER, rey AS INTEGER
        rsx% = dx% + INT(RECT_TOOL.START_X * SCRN.zoom!)
        rsy% = dy% + INT(RECT_TOOL.START_Y * SCRN.zoom!)
        rex% = dx% + INT(RECT_TOOL.END_X * SCRN.zoom!)
        rey% = dy% + INT(RECT_TOOL.END_Y * SCRN.zoom!)
        
        ' Draw master rectangle at full opacity
        IF RECT_TOOL.FILLED THEN
            LINE (rsx%, rsy%)-(rex%, rey%), PAINT_COLOR~&, BF
        ELSE
            LINE (rsx%, rsy%)-(rex%, rey%), PAINT_COLOR~&, B
        END IF
        
        ' Draw symmetry rectangles at full opacity
        IF SYMMETRY.MODE > 0 THEN
            DIM rect_sx(0 TO 7) AS INTEGER, rect_sy(0 TO 7) AS INTEGER
            DIM rect_ex(0 TO 7) AS INTEGER, rect_ey(0 TO 7) AS INTEGER
            DIM rect_count AS INTEGER, rect_i AS INTEGER
            SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_sx%(), rect_sy%(), rect_count%
            SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_ex%(), rect_ey%(), rect_count%
            
            FOR rect_i% = 0 TO rect_count% - 1
                DIM rect_rsx AS INTEGER, rect_rsy AS INTEGER, rect_rex AS INTEGER, rect_rey AS INTEGER
                rect_rsx% = dx% + INT(rect_sx%(rect_i%) * SCRN.zoom!)
                rect_rsy% = dy% + INT(rect_sy%(rect_i%) * SCRN.zoom!)
                rect_rex% = dx% + INT(rect_ex%(rect_i%) * SCRN.zoom!)
                rect_rey% = dy% + INT(rect_ey%(rect_i%) * SCRN.zoom!)
                IF RECT_TOOL.FILLED THEN
                    LINE (rect_rsx%, rect_rsy%)-(rect_rex%, rect_rey%), PAINT_COLOR~&, BF
                ELSE
                    LINE (rect_rsx%, rect_rsy%)-(rect_rex%, rect_rey%), PAINT_COLOR~&, B
                END IF
            NEXT rect_i%
        END IF
    END IF
    ' Draw ELLIPSE preview while dragging (converted to zoomed screen coordinates)
    ' Skip when panning to avoid stale preview rendering
    IF (CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED) AND ELLIPSE_TOOL.DRAGGING AND NOT SCRN.panning% THEN
        DIM pcx AS INTEGER, pcy AS INTEGER, prx AS SINGLE, pry AS SINGLE, pasp AS SINGLE
        DIM esx AS INTEGER, esy AS INTEGER, eex AS INTEGER, eey AS INTEGER
        DIM prev_blend AS LONG
        ' Convert to screen coordinates
        esx% = dx% + INT(ELLIPSE_TOOL.START_X * SCRN.zoom!)
        esy% = dy% + INT(ELLIPSE_TOOL.START_Y * SCRN.zoom!)
        eex% = dx% + INT(ELLIPSE_TOOL.END_X * SCRN.zoom!)
        eey% = dy% + INT(ELLIPSE_TOOL.END_Y * SCRN.zoom!)
        pcx% = (esx% + eex%) \ 2
        pcy% = (esy% + eey%) \ 2
        prx! = ABS(eex% - esx%) / 2
        pry! = ABS(eey% - esy%) / 2
        IF prx! > 0 THEN pasp! = pry! / prx! ELSE pasp! = 1
        
        ' Save blend state once before any drawing
        prev_blend& = _BLEND(SCRN.CANVAS&)
        
        _DEST SCRN.CANVAS&
        IF prx! > 0 THEN
            IF ELLIPSE_TOOL.FILLED THEN
                ' Draw filled ellipse preview using temp transparent image to avoid PAINT issues
                DIM preview_temp AS LONG
                DIM preview_w AS INTEGER, preview_h AS INTEGER
                DIM temp_cx AS INTEGER, temp_cy AS INTEGER
                preview_w% = INT(prx! * 2 + 4)
                preview_h% = INT(pry! * 2 + 4)
                preview_temp& = _NEWIMAGE(preview_w%, preview_h%, 32)
                _DEST preview_temp&
                CLS , _RGBA32(0, 0, 0, 0)
                _CLEARCOLOR _RGBA32(0, 0, 0, 0), preview_temp&
                temp_cx% = preview_w% \ 2
                temp_cy% = preview_h% \ 2
                CIRCLE (temp_cx%, temp_cy%), prx!, PAINT_COLOR~&, , , pasp!
                PAINT (temp_cx%, temp_cy%), PAINT_COLOR~&, PAINT_COLOR~&
                _DEST SCRN.CANVAS&
                _BLEND SCRN.CANVAS&
                _PUTIMAGE (pcx% - temp_cx%, pcy% - temp_cy%), preview_temp&, SCRN.CANVAS&
                IF preview_temp& < -1 THEN _FREEIMAGE preview_temp&
            ELSE
                ' Draw ellipse outline
                CIRCLE (pcx%, pcy%), prx!, PAINT_COLOR~&, , , pasp!
            END IF
            
            ' Draw symmetry ellipses at full opacity
            IF SYMMETRY.MODE > 0 THEN
                DIM ell_csx(0 TO 7) AS INTEGER, ell_csy(0 TO 7) AS INTEGER
                DIM ell_count AS INTEGER, ell_i AS INTEGER
                DIM ell_cx AS INTEGER, ell_cy AS INTEGER
                ell_cx% = (ELLIPSE_TOOL.START_X + ELLIPSE_TOOL.END_X) \ 2
                ell_cy% = (ELLIPSE_TOOL.START_Y + ELLIPSE_TOOL.END_Y) \ 2
                SYMMETRY_get_mirrored_points ell_cx%, ell_cy%, ell_csx%(), ell_csy%(), ell_count%
                
                FOR ell_i% = 0 TO ell_count% - 1
                    DIM ell_scx AS INTEGER, ell_scy AS INTEGER
                    ell_scx% = dx% + INT(ell_csx%(ell_i%) * SCRN.zoom!)
                    ell_scy% = dy% + INT(ell_csy%(ell_i%) * SCRN.zoom!)
                    IF ELLIPSE_TOOL.FILLED THEN
                        ' Filled symmetry ellipse
                        preview_temp& = _NEWIMAGE(preview_w%, preview_h%, 32)
                        _DEST preview_temp&
                        CLS , _RGBA32(0, 0, 0, 0)
                        _CLEARCOLOR _RGBA32(0, 0, 0, 0), preview_temp&
                        CIRCLE (temp_cx%, temp_cy%), prx!, PAINT_COLOR~&, , , pasp!
                        PAINT (temp_cx%, temp_cy%), PAINT_COLOR~&, PAINT_COLOR~&
                        _DEST SCRN.CANVAS&
                        _BLEND SCRN.CANVAS&
                        _PUTIMAGE (ell_scx% - temp_cx%, ell_scy% - temp_cy%), preview_temp&, SCRN.CANVAS&
                        IF preview_temp& < -1 THEN _FREEIMAGE preview_temp&
                    ELSE
                        ' Outline symmetry ellipse
                        _DEST SCRN.CANVAS&
                        CIRCLE (ell_scx%, ell_scy%), prx!, PAINT_COLOR~&, , , pasp!
                    END IF
                NEXT ell_i%
            END IF
        END IF
        
        ' Restore blend state once at the end
        _DEST SCRN.CANVAS&
        IF prev_blend& = 0 THEN _DONTBLEND SCRN.CANVAS&
    END IF
    ' ==== END TOOL PREVIEWS ====
    
    ' ==== GUI LAYER (AFTER TOOL PREVIEWS) ====
    _DEST SCRN.CANVAS& : _SOURCE SCRN.GUI& : _PUTIMAGE
    
    ' ==== IMAGE IMPORT STATUS BAR (after GUI so it's visible) ====
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        _DEST SCRN.CANVAS&
        IMAGE_IMPORT_draw_status SCRN.CANVAS&
    END IF
    ' ==== END IMAGE IMPORT STATUS BAR ====
    
    ' ==== MOVE TOOL STATUS BAR (after GUI so it's visible) ====
    IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
        _DEST SCRN.CANVAS&
        MOVE_render_status SCRN.CANVAS&
    END IF
    ' ==== END MOVE TOOL STATUS BAR ====
    
    ' Render crosshair AFTER GUI layer so it's visible (using SHIFT key alone)
    ' Skip when Text tool is active (SHIFT is used for uppercase letters)
    ' Skip when CTRL or ALT are also held (those are modifier combos for other functions)
    DIM shiftHeld AS INTEGER, ctrlHeld AS INTEGER, altHeld AS INTEGER
    shiftHeld% = (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&))
    ctrlHeld% = (_KEYDOWN(100305) OR _KEYDOWN(100306))  ' LCTRL or RCTRL
    altHeld% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
    
    IF shiftHeld% AND NOT ctrlHeld% AND NOT altHeld% AND CURRENT_TOOL% <> TOOL_TEXT THEN 
        CROSSHAIR_render PAL_color(THEME.CROSSHAIR_fg%)
    END IF
    
    ' ==== COMMAND PALETTE (on top of everything except cursor) ====
    IF CMD_PALETTE.visible THEN
        CMD_render SCRN.CANVAS&
    END IF
    ' ==== END COMMAND PALETTE ====
    
    POINTER_update
    POINTER_render
    _DEST SCRN.CANVAS& : _SOURCE SCRN.CURSOR&
    _CLEARCOLOR _RGB32(0, 0, 0)
    _SETALPHA 0, _RGB32(0,0,0), SCRN.CURSOR&
    _BLEND SCRN.CURSOR&
    _PUTIMAGE
    
    ' Scale CANVAS to WINDOW_IMG for display (integer scaling, nearest neighbor)
    _DEST SCRN.WINDOW_IMG&
    _DONTBLEND SCRN.WINDOW_IMG&
    _PUTIMAGE (0, 0)-(_WIDTH(SCRN.WINDOW_IMG&) - 1, _HEIGHT(SCRN.WINDOW_IMG&) - 1), SCRN.CANVAS&, SCRN.WINDOW_IMG&
    
    _DISPLAY
    
    ' Reset GUI dirty flag at end of render
    GUI_NEEDS_REDRAW% = FALSE
END SUB
