''
' DRAW - OUTPUT/SCREEN.BM
' =============================================================================
' Screen output files subs and functions.
'
' @todo
' @depends ./SCREEN.BI
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Helper for console output in graphics mode
'
SUB ECHO_LOG (msg AS STRING)
    DIM d AS LONG
    d& = _DEST
    _DEST _CONSOLE
    PRINT msg
    _DEST d&
END SUB

''
' Mark GUI as needing redraw
' Call this when: tool switches, palette changes, window resizes, toolbar/status toggles
'
SUB GUI_mark_dirty ()
    GUI_NEEDS_REDRAW% = TRUE
END SUB

''
' Detects the resolution of the desktop and sets the width and height to It
' 
SUB SCREEN_detect_desktop_resolution()
    DO: _LIMIT CFG.FPS_LIMIT% : LOOP UNTIL _SCREENEXISTS
    SCRN.w& = _DESKTOPWIDTH : SCRN.h& = _DESKTOPHEIGHT
END SUB


''
' Detects optimal display scale based on desktop resolution
' Returns scale clamped to CFG.DISPLAY_SCALE_MAX%
' 
FUNCTION SCREEN_detect_display_scale% ()
    DIM desktopH AS INTEGER
    DIM scale AS INTEGER
    DIM maxFitW AS INTEGER, maxFitH AS INTEGER
    
    ' Wait for screen to exist and get valid desktop dimensions
    DO: _LIMIT CFG.FPS_LIMIT% : LOOP UNTIL _SCREENEXISTS
    DO
        desktopH% = _DESKTOPHEIGHT
        IF desktopH% <= 0 THEN _DELAY 0.01
    LOOP UNTIL desktopH% > 0
    
    ' Calculate scale based on desktop height
    ' 4K (2160+) = 4x, 1440p (1440+) = 3x, 1080p (1080+) = 2x, else 1x
    IF desktopH% >= 2160 THEN
        scale% = 4
    ELSEIF desktopH% >= 1440 THEN
        scale% = 3
    ELSEIF desktopH% >= 1080 THEN
        scale% = 2
    ELSE
        scale% = 1
    END IF
    
    ' Clamp to configured maximum
    IF scale% > CFG.DISPLAY_SCALE_MAX% THEN scale% = CFG.DISPLAY_SCALE_MAX%
    
    ' Also ensure window fits on desktop (leave some margin for taskbar/dock)
    ' Calculate max scale that fits
    IF SCRN.w& > 0 AND SCRN.h& > 0 THEN
        maxFitW% = (_DESKTOPWIDTH - 100) \ SCRN.w&
        maxFitH% = (_DESKTOPHEIGHT - 100) \ SCRN.h&
        IF maxFitW% < scale% THEN scale% = maxFitW%
        IF maxFitH% < scale% THEN scale% = maxFitH%
    END IF
    
    ' Minimum scale is 1
    IF scale% < 1 THEN scale% = 1
    
    SCREEN_detect_display_scale% = scale%
END FUNCTION


''
' Set display scale at runtime (for hotkey scaling)
' newScale: desired new scale (will be clamped to valid range)
' 
SUB SCREEN_set_display_scale (newScale AS INTEGER)
    DIM winW AS LONG, winH AS LONG
    DIM maxFitW AS INTEGER, maxFitH AS INTEGER
    DIM clampedScale AS INTEGER
    
    ' Don't allow scale changes in fullscreen mode
    IF CFG.FULLSCREEN% THEN EXIT SUB
    
    clampedScale% = newScale%
    
    ' Clamp to minimum of 1
    IF clampedScale% < 1 THEN clampedScale% = 1
    
    ' Clamp to configured maximum
    IF clampedScale% > CFG.DISPLAY_SCALE_MAX% THEN
        clampedScale% = CFG.DISPLAY_SCALE_MAX%
    END IF
    
    ' Clamp to fit on desktop (leave margin for taskbar/dock)
    maxFitW% = (_DESKTOPWIDTH - 100) \ SCRN.w&
    maxFitH% = (_DESKTOPHEIGHT - 100) \ SCRN.h&
    IF clampedScale% > maxFitW% THEN clampedScale% = maxFitW%
    IF clampedScale% > maxFitH% THEN clampedScale% = maxFitH%
    
    ' No change needed
    IF clampedScale% = SCRN.displayScale% THEN EXIT SUB
    
    ' Update display scale
    SCRN.displayScale% = clampedScale%
    
    ' Calculate new window size
    winW& = SCRN.w& * SCRN.displayScale%
    winH& = SCRN.h& * SCRN.displayScale%
    
    ' Create new window image FIRST (before freeing old one)
    DIM oldWindow AS LONG
    oldWindow& = SCRN.WINDOW_IMG&
    SCRN.WINDOW_IMG& = _NEWIMAGE(winW&, winH&, 32)
    
    ' Switch to new window
    SCREEN SCRN.WINDOW_IMG&
    _DEST SCRN.CANVAS&
    
    ' NOW free the old window image (after we're no longer using it as SCREEN)
    IF oldWindow& < -1 THEN _FREEIMAGE oldWindow&
    
    ' Reset input state after screen change
    DO WHILE _MOUSEINPUT: LOOP  ' Drain mouse buffer
    MOUSE_force_buttons_up       ' Reset button state
    _MOUSEHIDE                   ' Ensure system cursor stays hidden
    
    ' Mark GUI as needing redraw
    GUI_NEEDS_REDRAW% = TRUE
    
    ' Mark config as changed
    CFG.DISPLAY_SCALE_CHANGED% = TRUE
END SUB


''
' Initialize the screen and various images we will use
' 
SUB SCREEN_init ()
    DIM winW AS LONG, winH AS LONG
    
    ' Load configuration from disk
    CONFIG_load
    
    SCRN.w&   = 0
    SCRN.h&   = 0
    SCRN.bpp% = 0
    
    ' Get screen dimensions from config or auto-detect
    IF CFG.SCREEN_WIDTH% > 0 AND CFG.SCREEN_HEIGHT% > 0 THEN
        ' Use configured dimensions
        SCRN.w& = CFG.SCREEN_WIDTH%
        SCRN.h& = CFG.SCREEN_HEIGHT%
    ELSE
        ' Auto-detect desktop resolution
        SCREEN_detect_desktop_resolution
    END IF
    
    ' Determine display scale
    IF CFG.DISPLAY_SCALE% > 0 THEN
        ' Use explicit scale from config
        SCRN.displayScale% = CFG.DISPLAY_SCALE%
        ' Clamp to max
        IF SCRN.displayScale% > CFG.DISPLAY_SCALE_MAX% THEN
            SCRN.displayScale% = CFG.DISPLAY_SCALE_MAX%
        END IF
    ELSE
        ' Auto-detect optimal scale
        SCRN.displayScale% = SCREEN_detect_display_scale%
    END IF
    
    ' Ensure minimum scale of 1
    IF SCRN.displayScale% < 1 THEN SCRN.displayScale% = 1
    
    SCRN.zoom! = 1.0      ' Start at 1x zoom
    SCRN.zoomMin! = 0.25  ' 25% minimum zoom
    SCRN.zoomMax! = 8.0   ' 8x maximum zoom
    SCRN.offsetX% = 0
    SCRN.offsetY% = 0
    SCRN.panning% = FALSE
    SCRN.panStartX% = 0
    SCRN.panStartY% = 0
    SCRN.panOrigOffsetX% = 0
    SCRN.panOrigOffsetY% = 0
    SCRN.showToolbar% = TRUE
    SCRN.showStatus% = TRUE
    SCRN.toolbarManuallyHidden% = FALSE
    SCRN.statusManuallyHidden% = FALSE
    
    ' Create image buffers at logical canvas size
    SCRN.CANVAS&   = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    SCRN.PAINTING& = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    SCRN.GUI&      = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    ' SCRN.CURSOR& removed — cursors now draw directly onto SCRN.CANVAS&
    
    ' Create window display buffer at scaled size
    winW& = SCRN.w& * SCRN.displayScale%
    winH& = SCRN.h& * SCRN.displayScale%
    SCRN.WINDOW_IMG& = _NEWIMAGE(winW&, winH&, 32)
    
    _DEST SCRN.PAINTING&
    CLS , _RGBA32(0, 0, 0, 0)
    _DEST SCRN.GUI&
    
    ' Use WINDOW_IMG as the screen (window size)
    SCREEN SCRN.WINDOW_IMG&
    _DEST SCRN.CANVAS&
    
    ' Set window icon (cross-platform via SDL2)
    DIM iconHandle AS LONG
    iconHandle& = _LOADIMAGE("./ASSETS/ICONS/icon.png", 32)
    IF iconHandle& < -1 THEN
        _ICON iconHandle&
        _FREEIMAGE iconHandle&
    END IF
    
    IF CFG.FULLSCREEN% THEN _FULLSCREEN _SQUAREPIXELS
    SCRN.bpp% = _PIXELSIZE
    ' Initialize tools
    LAYERS_init  ' Initialize layers system (must be after CONFIG_load)
    WORKSPACE_UNDO_init  ' Initialize workspace undo (must be after LAYERS_init)
    MOVE_init
    TEXT_init
    GRID_init
    PIXEL_GRID_init
    SYMMETRY_init
    STATUS_init
    PALETTE_LOADER_init
    PALETTE_STRIP_init
    CMD_init  ' Initialize command palette
END SUB


''
' Draws screen
' 
SUB SCREEN_render ()
    ' ========================================================================
    ' GUI-ONLY REFRESH: When only GUI elements changed (e.g. brush size in
    ' status bar) but the scene (layers, grid) hasn't, re-composite just the
    ' GUI overlay onto the cached scene. Avoids expensive layer compositing,
    ' grid rendering, and transparency checkerboard.
    ' ========================================================================
    IF NOT SCENE_DIRTY% AND GUI_NEEDS_REDRAW% AND SCENE_CACHE& <> 0 THEN
        ' Re-render GUI elements with updated content
        _DEST SCRN.GUI&
        CLS , _RGBA32(0, 0, 0, 0)
        IF SCRN.showToolbar% THEN
            TOOLBAR_render 0, 0, 20
        END IF
        IF SCRN.showStatus% THEN
            PALETTE_STRIP_render
            STATUS_render
        END IF
        IF LAYER_PANEL.visible% THEN
            LAYER_PANEL_render SCRN.h&
        END IF

        ' Restore cached scene, overlay updated GUI, update cache
        _DEST SCRN.CANVAS&
        _DONTBLEND SCRN.CANVAS&
        _PUTIMAGE , SCENE_CACHE&, SCRN.CANVAS&
        _BLEND SCRN.CANVAS&
        _PUTIMAGE , SCRN.GUI&, SCRN.CANVAS&

        ' Save updated scene back to cache
        _DEST SCENE_CACHE&
        _DONTBLEND SCENE_CACHE&
        _PUTIMAGE , SCRN.CANVAS&, SCENE_CACHE&
        _BLEND SCENE_CACHE&
        _DEST SCRN.CANVAS&

        ' Jump to pointer+selection+upscale — must NOT fall through to
        ' dirty-rect, which only upscales the pointer region and would
        ' leave the updated GUI invisible in the window image.
        GOTO SkipToPointer
    END IF

    ' ========================================================================
    ' DIRTY-RECT FAST PATH: When the scene hasn't changed, restore+redraw
    ' only the regions that need updating (pointer area + selection overlay)
    ' instead of copying and scaling the full canvas every frame.
    ' ========================================================================
    IF NOT SCENE_DIRTY% AND SCENE_CACHE& <> 0 THEN
        DIM new_mx AS INTEGER, new_my AS INTEGER
        new_mx% = _MOUSEX \ SCRN.displayScale%
        new_my% = _MOUSEY \ SCRN.displayScale%

        ' Dynamic padding: covers cursor PNG + brush preview + overlays
        DIM ptr_pad AS INTEGER
        ptr_pad% = POINTER_get_dirty_pad%

        ' Build union bounding box of old + new pointer areas (canvas coords)
        DIM dr_x1 AS INTEGER, dr_y1 AS INTEGER
        DIM dr_x2 AS INTEGER, dr_y2 AS INTEGER

        IF POINTER.PREV_DRAW_X% <= -9999 THEN
            ' First frame after full render — use new position only
            dr_x1% = new_mx% - ptr_pad%
            dr_y1% = new_my% - ptr_pad%
            dr_x2% = new_mx% + ptr_pad%
            dr_y2% = new_my% + ptr_pad%
        ELSE
            ' Union of old rect + new rect
            DIM ox1 AS INTEGER, oy1 AS INTEGER, ox2 AS INTEGER, oy2 AS INTEGER
            ox1% = POINTER.PREV_DRAW_X% - ptr_pad%
            oy1% = POINTER.PREV_DRAW_Y% - ptr_pad%
            ox2% = POINTER.PREV_DRAW_X% + ptr_pad%
            oy2% = POINTER.PREV_DRAW_Y% + ptr_pad%

            dr_x1% = new_mx% - ptr_pad%
            dr_y1% = new_my% - ptr_pad%
            dr_x2% = new_mx% + ptr_pad%
            dr_y2% = new_my% + ptr_pad%

            IF ox1% < dr_x1% THEN dr_x1% = ox1%
            IF oy1% < dr_y1% THEN dr_y1% = oy1%
            IF ox2% > dr_x2% THEN dr_x2% = ox2%
            IF oy2% > dr_y2% THEN dr_y2% = oy2%
        END IF

        ' Expand dirty rect to include selection overlay (marching ants + handles)
        DIM has_sel AS INTEGER
        has_sel% = SELECTION_has_active%
        IF has_sel% THEN
            DIM sel_x1 AS INTEGER, sel_y1 AS INTEGER
            DIM sel_x2 AS INTEGER, sel_y2 AS INTEGER
            SELECTION_get_screen_bbox sel_x1%, sel_y1%, sel_x2%, sel_y2%
            IF sel_x1% < dr_x1% THEN dr_x1% = sel_x1%
            IF sel_y1% < dr_y1% THEN dr_y1% = sel_y1%
            IF sel_x2% > dr_x2% THEN dr_x2% = sel_x2%
            IF sel_y2% > dr_y2% THEN dr_y2% = sel_y2%
        END IF

        ' Clamp to canvas bounds
        IF dr_x1% < 0 THEN dr_x1% = 0
        IF dr_y1% < 0 THEN dr_y1% = 0
        IF dr_x2% >= SCRN.w& THEN dr_x2% = SCRN.w& - 1
        IF dr_y2% >= SCRN.h& THEN dr_y2% = SCRN.h& - 1

        ' Area check: if dirty rect > half the canvas, fall back to full copy
        DIM dr_area AS LONG, canvas_area AS LONG
        dr_area& = CLNG(dr_x2% - dr_x1% + 1) * CLNG(dr_y2% - dr_y1% + 1)
        canvas_area& = SCRN.w& * SCRN.h&

        IF dr_area& < (canvas_area& \ 2) AND dr_x2% > dr_x1% AND dr_y2% > dr_y1% THEN
            ' --- Partial restore from scene cache (erase old pointer + ants) ---
            _DEST SCRN.CANVAS&
            _DONTBLEND SCRN.CANVAS&
            _PUTIMAGE (dr_x1%, dr_y1%)-(dr_x2%, dr_y2%), SCENE_CACHE&, SCRN.CANVAS&, (dr_x1%, dr_y1%)-(dr_x2%, dr_y2%)
            _BLEND SCRN.CANVAS&

            ' --- Redraw selection overlay (marching ants animate each frame) ---
            IF has_sel% THEN
                IF MARQUEE.WAND_HAS_SELECTION AND MARQUEE.SELECTION_MASK < -1 THEN
                    _DEST SCRN.CANVAS&
                    MAGIC_WAND_draw_outline
                ELSEIF MARQUEE.ACTIVE% AND MARQUEE.USER_CREATED THEN
                    IF MARQUEE.DRAGGING% AND MARQUEE.SELECTION_MODE <> SEL_MODE_REPLACE THEN
                        _DEST SCRN.CANVAS&
                        MARQUEE_draw_existing_box TRUE
                    ELSE
                        _DEST SCRN.CANVAS&
                        MARQUEE_draw TRUE
                    END IF
                END IF
            END IF

            ' --- Draw pointer at new position ---
            POINTER_update
            POINTER_render

            ' --- Save pointer position for next frame ---
            POINTER.PREV_DRAW_X% = new_mx%
            POINTER.PREV_DRAW_Y% = new_my%

            ' --- Partial scale to WINDOW_IMG (only dirty rect) ---
            DIM sc AS INTEGER: sc% = SCRN.displayScale%
            _DEST SCRN.WINDOW_IMG&
            _DONTBLEND SCRN.WINDOW_IMG&
            _PUTIMAGE (dr_x1% * sc%, dr_y1% * sc%)-((dr_x2% + 1) * sc% - 1, (dr_y2% + 1) * sc% - 1), SCRN.CANVAS&, SCRN.WINDOW_IMG&, (dr_x1%, dr_y1%)-(dr_x2%, dr_y2%)

            _DISPLAY
            GUI_NEEDS_REDRAW% = FALSE
            EXIT SUB
        END IF
        ' --- Dirty rect too large: fall through to full-copy fast path ---

        ' Full-copy fast path (selection covers too much area)
        _DEST SCRN.CANVAS&
        _DONTBLEND SCRN.CANVAS&
        _PUTIMAGE , SCENE_CACHE&, SCRN.CANVAS&
        _BLEND SCRN.CANVAS&
        GOTO SkipToPointer
    END IF

    ' todo get status to hide when painting 
    _DEST SCRN.CANVAS&
    CLS
    
    ' Clear GUI layer and render toolbar/status conditionally
    ' Only redraw GUI elements when GUI_NEEDS_REDRAW is TRUE (optimization)
    IF GUI_NEEDS_REDRAW% THEN
        _DEST SCRN.GUI&
        CLS , _RGBA32(0, 0, 0, 0) ' Clear with transparency
        
        IF SCRN.showToolbar% THEN
            TOOLBAR_render 0, 0, 20  ' 3x7 layout: 21 buttons (0-20)
        END IF
        IF SCRN.showStatus% THEN 
            PALETTE_STRIP_render
            STATUS_render
        END IF
        
        ' Render layer panel if visible
        IF LAYER_PANEL.visible% THEN
            LAYER_PANEL_render SCRN.h&
        END IF
    END IF
    
    ' Switch back to canvas for main rendering
    _DEST SCRN.CANVAS&
    
    ' Calculate zoomed dimensions and position (using logical canvas dimensions)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.w& * SCRN.zoom!
    zh& = SCRN.h& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%
    
    ' Offset canvas X when layer panel is visible
    IF LAYER_PANEL.visible% THEN
        dx% = dx% + CFG.LAYER_PANEL_WIDTH%
    END IF
    
    ' Render transparency checkerboard first (behind all layers)
    TRANSPARENCY_render SCRN.CANVAS&, dx%, dy%, zw&, zh&
    
    ' Render all visible layers with zoom, compositing bottom-to-top
    _DEST SCRN.CANVAS&
    _BLEND SCRN.CANVAS&
    
    IF LAYER_COUNT% > 0 THEN
        ' Composite layers by zIndex (bottom to top)
        DIM layerI AS INTEGER
        DIM layerFound AS INTEGER
        DIM useComposite AS INTEGER
        DIM compositeImg AS LONG

        ' Check if we need per-pixel blending (any non-Normal blend mode)
        useComposite% = BLEND_needs_composite%

        ' Rebuild render order lookup table if dirty
        IF RENDER_ORDER_DIRTY% THEN RENDER_ORDER_rebuild

        ' Start index for layer loop (1 = full composite, >1 = partial cache hit)
        DIM compositeStartIdx AS INTEGER
        DIM savePartialCache AS INTEGER
        compositeStartIdx% = 1
        savePartialCache% = FALSE

        IF useComposite% THEN
            ' Reuse persistent composite buffer (avoid _NEWIMAGE/_FREEIMAGE every frame)
            IF COMPOSITE_BUFFER& = 0 OR _
               COMPOSITE_BUFFER_W& <> SCRN.w& OR _
               COMPOSITE_BUFFER_H& <> SCRN.h& THEN
                IF COMPOSITE_BUFFER& < -1 THEN _FREEIMAGE COMPOSITE_BUFFER&
                COMPOSITE_BUFFER& = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
                COMPOSITE_BUFFER_W& = SCRN.w&
                COMPOSITE_BUFFER_H& = SCRN.h&
            END IF
            compositeImg& = COMPOSITE_BUFFER&

            ' --- Partial composite cache: skip layers below current when only current changes ---
            DIM currentRenderIdx AS INTEGER
            DIM cri AS INTEGER
            currentRenderIdx% = 0
            FOR cri% = 1 TO RENDER_ORDER_COUNT%
                IF RENDER_ORDER%(cri%) = CURRENT_LAYER% THEN
                    currentRenderIdx% = cri%
                    EXIT FOR
                END IF
            NEXT cri%

            DIM compOldDest AS LONG
            compOldDest& = _DEST

            IF currentRenderIdx% > 1 AND COMPOSITE_BELOW_VALID% AND _
               COMPOSITE_BELOW_LAYER% = CURRENT_LAYER% AND _
               COMPOSITE_BELOW_CACHE& <> 0 THEN
                ' Partial cache hit — restore composite of layers below current
                _DEST compositeImg&
                _DONTBLEND compositeImg&
                _PUTIMAGE , COMPOSITE_BELOW_CACHE&, compositeImg&
                _BLEND compositeImg&
                _DEST compOldDest&
                compositeStartIdx% = currentRenderIdx%
            ELSE
                ' Full composite — clear buffer
                _DEST compositeImg&
                _DONTBLEND compositeImg&
                CLS , _RGBA32(0, 0, 0, 0)
                _BLEND compositeImg&
                _DEST compOldDest&
                ' Schedule partial cache save if current layer isn't the bottommost
                IF currentRenderIdx% > 1 THEN savePartialCache% = TRUE
            END IF
        END IF
        
        FOR layerI% = compositeStartIdx% TO RENDER_ORDER_COUNT%
            layerFound% = RENDER_ORDER%(layerI%)
            
            IF layerFound% > 0 THEN
                IF LAYERS(layerFound%).visible% THEN
                ' Determine which image to render for this layer
                ' If MOVE tool is active on this layer, use the preview buffer instead
                DIM layerRenderSource AS LONG
                DIM useMoveBuf AS INTEGER
                useMoveBuf% = FALSE
                IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE AND layerFound% = CURRENT_LAYER% THEN
                    layerRenderSource& = MOVE_get_preview_buffer&
                    IF layerRenderSource& = 0 THEN
                        layerRenderSource& = LAYERS(layerFound%).imgHandle&
                    ELSE
                        useMoveBuf% = TRUE
                    END IF
                ELSE
                    layerRenderSource& = LAYERS(layerFound%).imgHandle&
                END IF
                
                ' Get opacity-adjusted image (cached when possible)
                DIM opacityImg AS LONG
                DIM layerOpacityI AS INTEGER
                layerOpacityI% = LAYERS(layerFound%).opacity%
                IF layerOpacityI% < 255 AND NOT useMoveBuf% THEN
                    ' Check if opacity cache is valid
                    IF LAYERS(layerFound%).opacityCacheImg& <> 0 AND _
                       LAYERS(layerFound%).opacityCacheVal% = layerOpacityI% AND _
                       NOT LAYERS(layerFound%).contentDirty% THEN
                        ' Cache hit — use cached opacity image
                        opacityImg& = LAYERS(layerFound%).opacityCacheImg&
                    ELSE
                        ' Cache miss — rebuild opacity image
                        IF LAYERS(layerFound%).opacityCacheImg& = 0 THEN
                            LAYERS(layerFound%).opacityCacheImg& = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
                        END IF
                        ' Copy source to cache and apply opacity
                        _DEST LAYERS(layerFound%).opacityCacheImg&
                        _DONTBLEND LAYERS(layerFound%).opacityCacheImg&
                        _PUTIMAGE , layerRenderSource&, LAYERS(layerFound%).opacityCacheImg&
                        _BLEND LAYERS(layerFound%).opacityCacheImg&
                        DIM layerMem AS _MEM
                        layerMem = _MEMIMAGE(LAYERS(layerFound%).opacityCacheImg&)
                        DIM pixOffset AS _OFFSET
                        DIM pixVal AS _UNSIGNED LONG
                        DIM pixAlpha AS _UNSIGNED _BYTE
                        DIM newAlpha AS INTEGER
                        FOR pixOffset = layerMem.OFFSET TO layerMem.OFFSET + layerMem.SIZE - 4 STEP 4
                            _MEMGET layerMem, pixOffset, pixVal~&
                            pixAlpha~%% = _ALPHA32(pixVal~&)
                            IF pixAlpha~%% > 0 THEN
                                newAlpha% = (pixAlpha~%% * layerOpacityI%) \ 255
                                _MEMPUT layerMem, pixOffset + 3, newAlpha% AS _UNSIGNED _BYTE
                            END IF
                        NEXT pixOffset
                        _MEMFREE layerMem
                        _DEST SCRN.CANVAS&
                        LAYERS(layerFound%).opacityCacheVal% = layerOpacityI%
                        LAYERS(layerFound%).contentDirty% = FALSE
                        opacityImg& = LAYERS(layerFound%).opacityCacheImg&
                    END IF
                ELSEIF layerOpacityI% < 255 AND useMoveBuf% THEN
                    ' Move preview — can't cache, build temp copy
                    opacityImg& = _COPYIMAGE(layerRenderSource&, 32)
                    layerMem = _MEMIMAGE(opacityImg&)
                    FOR pixOffset = layerMem.OFFSET TO layerMem.OFFSET + layerMem.SIZE - 4 STEP 4
                        _MEMGET layerMem, pixOffset, pixVal~&
                        pixAlpha~%% = _ALPHA32(pixVal~&)
                        IF pixAlpha~%% > 0 THEN
                            newAlpha% = (pixAlpha~%% * layerOpacityI%) \ 255
                            _MEMPUT layerMem, pixOffset + 3, newAlpha% AS _UNSIGNED _BYTE
                        END IF
                    NEXT pixOffset
                    _MEMFREE layerMem
                ELSE
                    opacityImg& = 0 ' No opacity adjustment needed
                END IF
                
                ' Render the layer (using opacityImg if available, else layerRenderSource)
                DIM renderImg AS LONG
                IF opacityImg& <> 0 THEN
                    renderImg& = opacityImg&
                ELSE
                    renderImg& = layerRenderSource&
                END IF
                
                IF useComposite% THEN
                    ' --- Composite buffer path (blend modes) ---
                    IF LAYERS(layerFound%).blendMode% = BLEND_NORMAL THEN
                        _DEST compositeImg&
                        _PUTIMAGE , renderImg&
                        _DEST SCRN.CANVAS&
                    ELSE
                        ' Non-Normal blend: pass ORIGINAL image — blend function handles opacity
                        LAYER_blend_composite compositeImg&, layerRenderSource&, LAYERS(layerFound%).blendMode%, LAYERS(layerFound%).opacity%
                    END IF
                ELSE
                    ' --- Fast path (all Normal blend) ---
                    _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), renderImg&
                END IF
                
                ' Free temp image if we made one for move preview
                IF useMoveBuf% AND opacityImg& <> 0 THEN
                    IF opacityImg& < -1 THEN _FREEIMAGE opacityImg&
                END IF
                END IF  ' visible%
            END IF  ' layerFound% > 0

            ' Save partial composite cache at boundary just below current layer
            IF savePartialCache% AND layerI% = currentRenderIdx% - 1 THEN
                IF COMPOSITE_BELOW_CACHE& = 0 OR _
                   _WIDTH(COMPOSITE_BELOW_CACHE&) <> SCRN.w& OR _
                   _HEIGHT(COMPOSITE_BELOW_CACHE&) <> SCRN.h& THEN
                    IF COMPOSITE_BELOW_CACHE& < -1 THEN _FREEIMAGE COMPOSITE_BELOW_CACHE&
                    COMPOSITE_BELOW_CACHE& = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
                END IF
                DIM pcOldDest AS LONG
                pcOldDest& = _DEST
                _DEST COMPOSITE_BELOW_CACHE&
                _DONTBLEND COMPOSITE_BELOW_CACHE&
                _PUTIMAGE , compositeImg&, COMPOSITE_BELOW_CACHE&
                _BLEND COMPOSITE_BELOW_CACHE&
                _DEST pcOldDest&
                COMPOSITE_BELOW_LAYER% = CURRENT_LAYER%
                COMPOSITE_BELOW_VALID% = TRUE
                savePartialCache% = FALSE
            END IF
        NEXT layerI%

        ' If using composite, render the final composite to canvas with zoom
        IF useComposite% THEN
            _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), compositeImg&, SCRN.CANVAS&
            ' compositeImg& is persistent (COMPOSITE_BUFFER&), do NOT free it
        END IF
    ELSE
        ' Fallback: Use SCRN.PAINTING if no layers exist yet (legacy support)
        DIM paint_source AS LONG
        paint_source& = MOVE_get_preview_buffer&
        IF paint_source& <> 0 THEN
            ' Use preview buffer showing move transform in realtime
            _SOURCE paint_source&
            _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), paint_source&
        ELSE
            ' Normal painting layer render
            _SOURCE SCRN.PAINTING&
            _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), SCRN.PAINTING&
        END IF
    END IF
    
    ' Draw grid overlays (after painting, before border/GUI)
    ' Regular grid shows at 100%+ zoom if enabled
    IF GRID.SHOW% AND SCRN.zoom! >= 1.0 THEN
        _DEST SCRN.CANVAS&
        _SOURCE GRID.imgHandle&
        _BLEND SCRN.CANVAS&
        _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), GRID.imgHandle&, SCRN.CANVAS&
    END IF
    ' Pixel grid shows at 400%+ zoom if enabled (on top of regular grid)
    IF PIXEL_GRID.SHOW% AND SCRN.zoom! >= 4.0 THEN
        DIM pgx AS INTEGER, pgy AS INTEGER
        DIM pzoom AS INTEGER
        DIM pgColor AS _UNSIGNED LONG
        pzoom% = INT(SCRN.zoom!)
        pgColor~& = _RGB32(_RED32(THEME.PIXEL_GRID_color1~&), _GREEN32(THEME.PIXEL_GRID_color1~&), _BLUE32(THEME.PIXEL_GRID_color1~&))
        
        ' Reuse cached pixel grid image if zoom/size/color unchanged
        IF PG_CACHE_IMG& = 0 OR _
           PG_CACHE_ZW& <> zw& OR _
           PG_CACHE_ZH& <> zh& OR _
           PG_CACHE_ZOOM% <> pzoom% OR _
           PG_CACHE_COLOR~& <> pgColor~& THEN
            ' Cache miss — rebuild pixel grid image
            IF PG_CACHE_IMG& < -1 THEN _FREEIMAGE PG_CACHE_IMG&
            PG_CACHE_IMG& = _NEWIMAGE(zw& + 1, zh& + 1, 32)
            PG_CACHE_ZW& = zw&
            PG_CACHE_ZH& = zh&
            PG_CACHE_ZOOM% = pzoom%
            PG_CACHE_COLOR~& = pgColor~&
            _DEST PG_CACHE_IMG&
            CLS , _RGBA32(0, 0, 0, 0)
            ' Draw vertical lines between each pixel column
            FOR pgx% = 0 TO SCRN.w&
                LINE (pgx% * pzoom%, 0)-(pgx% * pzoom%, zh&), pgColor~&
            NEXT pgx%
            ' Draw horizontal lines between each pixel row
            FOR pgy% = 0 TO SCRN.h&
                LINE (0, pgy% * pzoom%)-(zw&, pgy% * pzoom%), pgColor~&
            NEXT pgy%
            ' Apply 25% opacity globally to all drawn pixels (alpha 64)
            _SETALPHA 64, pgColor~& TO pgColor~&, PG_CACHE_IMG&
        END IF
        ' Composite cached pixel grid onto canvas
        _DEST SCRN.CANVAS&
        _BLEND SCRN.CANVAS&
        _PUTIMAGE (dx%, dy%), PG_CACHE_IMG&
    END IF
    
    ' Draw symmetry guide overlay (after grids, before border/GUI)
    IF SYMMETRY.MODE > 0 THEN
        ' Recreate guide image if size changed
        IF SYMMETRY.imgHandle& = 0 OR _WIDTH(SYMMETRY.imgHandle&) <> zw& OR _HEIGHT(SYMMETRY.imgHandle&) <> zh& THEN
            IF SYMMETRY.imgHandle& < -1 THEN _FREEIMAGE SYMMETRY.imgHandle&
            SYMMETRY.imgHandle& = _NEWIMAGE(zw&, zh&, 32)
            SYMMETRY.DIRTY% = TRUE
        END IF
        
        ' (Logging removed from render path for performance)
        SYMMETRY_render_guides zw&, zh&, SCRN.zoom!
        _DEST SCRN.CANVAS&
        _BLEND SCRN.CANVAS&  ' Use alpha blending for transparency
        _PUTIMAGE (dx%, dy%), SYMMETRY.imgHandle&, SCRN.CANVAS&
    END IF
    
    ' Draw border around canvas (after painting layer)
    LINE (dx% - 1, dy% - 1)-(dx% + zw&, dy% + zh&), _RGB32(51, 51, 51), B
    
    ' ==== IMAGE IMPORT PREVIEW ====
    ' Draw import preview if in import mode (on top of painting, below GUI)
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        _DEST SCRN.CANVAS&
        IMAGE_IMPORT_draw SCRN.CANVAS&
    END IF
    ' ==== END IMAGE IMPORT PREVIEW ====
    
    ' ==== TOOL PREVIEWS (BEFORE GUI LAYER) ====
    ' NOTE: Selection marching ants rendering moved AFTER scene cache save
    ' (SkipToPointer section) so animated ants don't force full scene re-render.
    ' Draw MARQUEE dragging preview (only when using marquee tool)
    ' Show preview when dragging - uses dedicated function for clarity
    IF CURRENT_TOOL% = TOOL_MARQUEE AND MARQUEE.DRAGGING% THEN
        MARQUEE_draw_drag_preview
    END IF
    ' Draw MOVE transform preview if active
    IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
        _DEST SCRN.CANVAS&
        MOVE_render_preview SCRN.CANVAS&
        ' Only draw marquee handles if this was a user-created selection (not full-layer move)
        IF MARQUEE.USER_CREATED THEN
            MARQUEE_draw TRUE
        END IF
    END IF
    ' Draw TEXT preview if editing
    IF CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE THEN
        _DEST SCRN.CANVAS&
        TEXT_render_preview SCRN.CANVAS&, dx%, dy%, SCRN.zoom!
    END IF
    ' Draw ZOOM drag-to-region preview rectangle
    IF CURRENT_TOOL% = TOOL_ZOOM AND ZOOM.DRAGGING THEN
        DIM zx1 AS INTEGER, zy1 AS INTEGER, zx2 AS INTEGER, zy2 AS INTEGER
        zx1% = ZOOM.START_X: zy1% = ZOOM.START_Y
        zx2% = ZOOM.END_X: zy2% = ZOOM.END_Y
        DIM zDragDist AS INTEGER
        zDragDist% = ABS(zx2% - zx1%) + ABS(zy2% - zy1%)
        IF zDragDist% >= 8 THEN
            _DEST SCRN.CANVAS&
            ' Draw semi-transparent fill
            LINE (zx1%, zy1%)-(zx2%, zy2%), _RGBA32(255, 255, 255, 40), BF
            ' Draw white dashed border
            LINE (zx1%, zy1%)-(zx2%, zy2%), _RGB32(255, 255, 255), B
            ' Draw black border offset for contrast
            LINE (zx1% - 1, zy1% - 1)-(zx2% + 1, zy2% + 1), _RGB32(0, 0, 0), B
        END IF
    END IF
    ' Determine preview color - use white with black outline effect for transparent
    DIM preview_color AS _UNSIGNED LONG
    IF _ALPHA32(PAINT_COLOR~&) = 0 THEN
        ' Transparent mode: use alternating white/gray dashed pattern or solid white
        preview_color~& = _RGB32(255, 255, 255)
    ELSE
        preview_color~& = PAINT_COLOR~&
    END IF
    
    ' Draw LINE preview while dragging (converted to zoomed screen coordinates)
    ' Skip when panning to avoid stale line rendering
    IF CURRENT_TOOL% = TOOL_LINE AND LINE_TOOL.DRAGGING AND NOT SCRN.panning% THEN
        _DEST SCRN.CANVAS&
        DIM lsx AS INTEGER, lsy AS INTEGER, lex AS INTEGER, ley AS INTEGER
        lsx% = dx% + INT(LINE_TOOL.START_X * SCRN.zoom!)
        lsy% = dy% + INT(LINE_TOOL.START_Y * SCRN.zoom!)
        lex% = dx% + INT(LINE_TOOL.END_X * SCRN.zoom!)
        ley% = dy% + INT(LINE_TOOL.END_Y * SCRN.zoom!)
        ' Draw black outline for visibility when transparent
        IF _ALPHA32(PAINT_COLOR~&) = 0 THEN
            LINE (lsx% - 1, lsy%)-(lex% - 1, ley%), _RGB32(0, 0, 0)
            LINE (lsx% + 1, lsy%)-(lex% + 1, ley%), _RGB32(0, 0, 0)
            LINE (lsx%, lsy% - 1)-(lex%, ley% - 1), _RGB32(0, 0, 0)
            LINE (lsx%, lsy% + 1)-(lex%, ley% + 1), _RGB32(0, 0, 0)
        END IF
        LINE (lsx%, lsy%)-(lex%, ley%), preview_color~&
    END IF
    ' Draw POLY_LINE preview from last point to mouse cursor (converted to zoomed screen coordinates)
    ' Skip when panning to avoid stale line rendering
    IF (CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED) AND POLY_LINE.HAS_LAST AND NOT SCRN.panning% THEN
        _DEST SCRN.CANVAS&
        DIM plsx AS INTEGER, plsy AS INTEGER, plex AS INTEGER, pley AS INTEGER
        plsx% = dx% + INT(POLY_LINE.LAST_X * SCRN.zoom!)
        plsy% = dy% + INT(POLY_LINE.LAST_Y * SCRN.zoom!)
        plex% = dx% + INT(MOUSE.X% * SCRN.zoom!)
        pley% = dy% + INT(MOUSE.Y% * SCRN.zoom!)
        ' Draw black outline for visibility when transparent
        IF _ALPHA32(PAINT_COLOR~&) = 0 THEN
            LINE (plsx% - 1, plsy%)-(plex% - 1, pley%), _RGB32(0, 0, 0)
            LINE (plsx% + 1, plsy%)-(plex% + 1, pley%), _RGB32(0, 0, 0)
            LINE (plsx%, plsy% - 1)-(plex%, pley% - 1), _RGB32(0, 0, 0)
            LINE (plsx%, plsy% + 1)-(plex%, pley% + 1), _RGB32(0, 0, 0)
        END IF
        LINE (plsx%, plsy%)-(plex%, pley%), preview_color~&
    END IF
    ' Draw RECT preview while dragging (converted to zoomed screen coordinates)
    ' Skip when panning to avoid stale preview rendering
    IF (CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED) AND RECT_TOOL.DRAGGING AND NOT SCRN.panning% THEN
        _DEST SCRN.CANVAS&
        DIM rsx AS INTEGER, rsy AS INTEGER, rex AS INTEGER, rey AS INTEGER
        rsx% = dx% + INT(RECT_TOOL.START_X * SCRN.zoom!)
        rsy% = dy% + INT(RECT_TOOL.START_Y * SCRN.zoom!)
        rex% = dx% + INT(RECT_TOOL.END_X * SCRN.zoom!)
        rey% = dy% + INT(RECT_TOOL.END_Y * SCRN.zoom!)
        
        ' Draw black outline for visibility when transparent
        IF _ALPHA32(PAINT_COLOR~&) = 0 THEN
            IF RECT_TOOL.FILLED THEN
                LINE (rsx% - 1, rsy% - 1)-(rex% + 1, rey% + 1), _RGB32(0, 0, 0), B
            ELSE
                LINE (rsx% - 1, rsy% - 1)-(rex% + 1, rey% + 1), _RGB32(0, 0, 0), B
                LINE (rsx% + 1, rsy% + 1)-(rex% - 1, rey% - 1), _RGB32(0, 0, 0), B
            END IF
        END IF
        
        ' Draw master rectangle at full opacity
        IF RECT_TOOL.FILLED THEN
            LINE (rsx%, rsy%)-(rex%, rey%), preview_color~&, BF
        ELSE
            LINE (rsx%, rsy%)-(rex%, rey%), preview_color~&, B
        END IF
        
        ' Draw symmetry rectangles at full opacity
        IF SYMMETRY.MODE > 0 THEN
            DIM rect_sx(0 TO 7) AS INTEGER, rect_sy(0 TO 7) AS INTEGER
            DIM rect_ex(0 TO 7) AS INTEGER, rect_ey(0 TO 7) AS INTEGER
            DIM rect_count AS INTEGER, rect_i AS INTEGER
            SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_sx%(), rect_sy%(), rect_count%
            SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_ex%(), rect_ey%(), rect_count%
            
            FOR rect_i% = 0 TO rect_count% - 1
                DIM rect_rsx AS INTEGER, rect_rsy AS INTEGER, rect_rex AS INTEGER, rect_rey AS INTEGER
                rect_rsx% = dx% + INT(rect_sx%(rect_i%) * SCRN.zoom!)
                rect_rsy% = dy% + INT(rect_sy%(rect_i%) * SCRN.zoom!)
                rect_rex% = dx% + INT(rect_ex%(rect_i%) * SCRN.zoom!)
                rect_rey% = dy% + INT(rect_ey%(rect_i%) * SCRN.zoom!)
                IF RECT_TOOL.FILLED THEN
                    LINE (rect_rsx%, rect_rsy%)-(rect_rex%, rect_rey%), preview_color~&, BF
                ELSE
                    LINE (rect_rsx%, rect_rsy%)-(rect_rex%, rect_rey%), preview_color~&, B
                END IF
            NEXT rect_i%
        END IF
    END IF
    ' Draw ELLIPSE preview while dragging (converted to zoomed screen coordinates)
    ' Skip when panning to avoid stale preview rendering
    IF (CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED) AND ELLIPSE_TOOL.DRAGGING AND NOT SCRN.panning% THEN
        DIM pcx AS INTEGER, pcy AS INTEGER, prx AS SINGLE, pry AS SINGLE, pasp AS SINGLE
        DIM esx AS INTEGER, esy AS INTEGER, eex AS INTEGER, eey AS INTEGER
        DIM prev_blend AS LONG
        ' Convert to screen coordinates
        esx% = dx% + INT(ELLIPSE_TOOL.START_X * SCRN.zoom!)
        esy% = dy% + INT(ELLIPSE_TOOL.START_Y * SCRN.zoom!)
        eex% = dx% + INT(ELLIPSE_TOOL.END_X * SCRN.zoom!)
        eey% = dy% + INT(ELLIPSE_TOOL.END_Y * SCRN.zoom!)
        pcx% = (esx% + eex%) \ 2
        pcy% = (esy% + eey%) \ 2
        prx! = ABS(eex% - esx%) / 2
        pry! = ABS(eey% - esy%) / 2
        IF prx! > 0 THEN pasp! = pry! / prx! ELSE pasp! = 1
        
        ' Save blend state once before any drawing
        prev_blend& = _BLEND(SCRN.CANVAS&)
        
        _DEST SCRN.CANVAS&
        IF prx! > 0 THEN
            ' Draw black outline for visibility when transparent
            IF _ALPHA32(PAINT_COLOR~&) = 0 THEN
                CIRCLE (pcx%, pcy%), prx! + 1, _RGB32(0, 0, 0), , , pasp!
            END IF
            
            IF ELLIPSE_TOOL.FILLED THEN
                ' Draw filled ellipse preview using temp transparent image to avoid PAINT issues
                DIM preview_temp AS LONG
                DIM preview_w AS INTEGER, preview_h AS INTEGER
                DIM temp_cx AS INTEGER, temp_cy AS INTEGER
                preview_w% = INT(prx! * 2 + 4)
                preview_h% = INT(pry! * 2 + 4)
                preview_temp& = _NEWIMAGE(preview_w%, preview_h%, 32)
                _DEST preview_temp&
                CLS , _RGBA32(0, 0, 0, 0)
                _CLEARCOLOR _RGBA32(0, 0, 0, 0), preview_temp&
                temp_cx% = preview_w% \ 2
                temp_cy% = preview_h% \ 2
                CIRCLE (temp_cx%, temp_cy%), prx!, preview_color~&, , , pasp!
                PAINT (temp_cx%, temp_cy%), preview_color~&, preview_color~&
                _DEST SCRN.CANVAS&
                _BLEND SCRN.CANVAS&
                _PUTIMAGE (pcx% - temp_cx%, pcy% - temp_cy%), preview_temp&, SCRN.CANVAS&
                IF preview_temp& < -1 THEN _FREEIMAGE preview_temp&
            ELSE
                ' Draw ellipse outline
                CIRCLE (pcx%, pcy%), prx!, preview_color~&, , , pasp!
            END IF
            
            ' Draw symmetry ellipses at full opacity
            IF SYMMETRY.MODE > 0 THEN
                DIM ell_csx(0 TO 7) AS INTEGER, ell_csy(0 TO 7) AS INTEGER
                DIM ell_count AS INTEGER, ell_i AS INTEGER
                DIM ell_cx AS INTEGER, ell_cy AS INTEGER
                ell_cx% = (ELLIPSE_TOOL.START_X + ELLIPSE_TOOL.END_X) \ 2
                ell_cy% = (ELLIPSE_TOOL.START_Y + ELLIPSE_TOOL.END_Y) \ 2
                SYMMETRY_get_mirrored_points ell_cx%, ell_cy%, ell_csx%(), ell_csy%(), ell_count%
                
                FOR ell_i% = 0 TO ell_count% - 1
                    DIM ell_scx AS INTEGER, ell_scy AS INTEGER
                    ell_scx% = dx% + INT(ell_csx%(ell_i%) * SCRN.zoom!)
                    ell_scy% = dy% + INT(ell_csy%(ell_i%) * SCRN.zoom!)
                    IF ELLIPSE_TOOL.FILLED THEN
                        ' Filled symmetry ellipse
                        preview_temp& = _NEWIMAGE(preview_w%, preview_h%, 32)
                        _DEST preview_temp&
                        CLS , _RGBA32(0, 0, 0, 0)
                        _CLEARCOLOR _RGBA32(0, 0, 0, 0), preview_temp&
                        CIRCLE (temp_cx%, temp_cy%), prx!, preview_color~&, , , pasp!
                        PAINT (temp_cx%, temp_cy%), preview_color~&, preview_color~&
                        _DEST SCRN.CANVAS&
                        _BLEND SCRN.CANVAS&
                        _PUTIMAGE (ell_scx% - temp_cx%, ell_scy% - temp_cy%), preview_temp&, SCRN.CANVAS&
                        IF preview_temp& < -1 THEN _FREEIMAGE preview_temp&
                    ELSE
                        ' Outline symmetry ellipse
                        _DEST SCRN.CANVAS&
                        CIRCLE (ell_scx%, ell_scy%), prx!, preview_color~&, , , pasp!
                    END IF
                NEXT ell_i%
            END IF
        END IF
        
        ' Restore blend state once at the end
        _DEST SCRN.CANVAS&
        IF prev_blend& = 0 THEN _DONTBLEND SCRN.CANVAS&
    END IF
    ' ==== END TOOL PREVIEWS ====
    
    ' ==== GUI LAYER (AFTER TOOL PREVIEWS) ====
    _DEST SCRN.CANVAS& : _SOURCE SCRN.GUI& : _PUTIMAGE
    
    ' ==== IMAGE IMPORT STATUS BAR (after GUI so it's visible) ====
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        _DEST SCRN.CANVAS&
        IMAGE_IMPORT_draw_status SCRN.CANVAS&
    END IF
    ' ==== END IMAGE IMPORT STATUS BAR ====
    
    ' ==== MOVE TOOL STATUS BAR (after GUI so it's visible) ====
    IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
        _DEST SCRN.CANVAS&
        MOVE_render_status SCRN.CANVAS&
    END IF
    ' ==== END MOVE TOOL STATUS BAR ====
    
    ' Render crosshair AFTER GUI layer so it's visible (using SHIFT key alone)
    ' Skip when Text tool is active (SHIFT is used for uppercase letters)
    ' Skip when CTRL or ALT are also held (those are modifier combos for other functions)
    DIM shiftHeld AS INTEGER, ctrlHeld AS INTEGER, altHeld AS INTEGER
    shiftHeld% = (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&))
    ctrlHeld% = (_KEYDOWN(100305) OR _KEYDOWN(100306))  ' LCTRL or RCTRL
    altHeld% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
    
    IF shiftHeld% AND NOT ctrlHeld% AND NOT altHeld% AND CURRENT_TOOL% <> TOOL_TEXT THEN 
        CROSSHAIR_render PAL_color(THEME.CROSSHAIR_fg%)
    END IF
    
    ' ==== COMMAND PALETTE (on top of everything except cursor) ====
    IF CMD_PALETTE.visible THEN
        CMD_render SCRN.CANVAS&
    END IF
    ' ==== END COMMAND PALETTE ====
    
    ' Save scene to cache (everything rendered, before cursor)
    IF SCENE_CACHE& = 0 OR _WIDTH(SCENE_CACHE&) <> SCRN.w& OR _HEIGHT(SCENE_CACHE&) <> SCRN.h& THEN
        IF SCENE_CACHE& < -1 THEN _FREEIMAGE SCENE_CACHE&
        SCENE_CACHE& = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    END IF
    _DEST SCENE_CACHE&
    _DONTBLEND SCENE_CACHE&
    _PUTIMAGE , SCRN.CANVAS&, SCENE_CACHE&
    _BLEND SCENE_CACHE&
    _DEST SCRN.CANVAS&
    SCENE_DIRTY% = FALSE

    SkipToPointer:
    ' ==== SELECTION OVERLAY (after scene cache, animates without full re-render) ====
    ' Draw MARQUEE selection marching ants if active (from any tool)
    IF SELECTION_has_active% THEN
        IF MARQUEE.WAND_HAS_SELECTION AND MARQUEE.SELECTION_MASK < -1 THEN
            _DEST SCRN.CANVAS&
            MAGIC_WAND_draw_outline
        ELSEIF MARQUEE.ACTIVE% AND MARQUEE.USER_CREATED THEN
            IF MARQUEE.DRAGGING% AND MARQUEE.SELECTION_MODE <> SEL_MODE_REPLACE THEN
                _DEST SCRN.CANVAS&
                MARQUEE_draw_existing_box TRUE
            ELSE
                _DEST SCRN.CANVAS&
                MARQUEE_draw TRUE
            END IF
        END IF
    END IF
    ' ==== END SELECTION OVERLAY ====
    POINTER_update
    POINTER_render

    ' Save pointer position for next frame's dirty-rect optimization
    POINTER.PREV_DRAW_X% = _MOUSEX \ SCRN.displayScale%
    POINTER.PREV_DRAW_Y% = _MOUSEY \ SCRN.displayScale%
    
    ' Scale CANVAS to WINDOW_IMG for display (integer scaling, nearest neighbor)
    _DEST SCRN.WINDOW_IMG&
    _DONTBLEND SCRN.WINDOW_IMG&
    _PUTIMAGE (0, 0)-(_WIDTH(SCRN.WINDOW_IMG&) - 1, _HEIGHT(SCRN.WINDOW_IMG&) - 1), SCRN.CANVAS&, SCRN.WINDOW_IMG&
    
    _DISPLAY
    
    ' Reset GUI dirty flag at end of render
    GUI_NEEDS_REDRAW% = FALSE
END SUB
