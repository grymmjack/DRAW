''
' DRAW - OUTPUT/SCREEN.BM
' =============================================================================
' Screen output files subs and functions.
'
' @todo
' @depends ./SCREEN.BI
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Mark GUI as needing redraw
' Call this when: tool switches, palette changes, window resizes, toolbar/status toggles
'
SUB GUI_mark_dirty ()
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Get effective maximum viewport width, accounting for desktop and display scale.
' When WIN_MAX_WIDTH is 0 (unlimited), derives max from desktop / displayScale.
'
FUNCTION SCREEN_effective_max_w& ()
    DIM effMax AS LONG
    IF CFG.WIN_MAX_WIDTH% > 0 THEN
        effMax& = CFG.WIN_MAX_WIDTH%
    ELSE
        ' Auto-derive from desktop: viewport * displayScale must fit on screen
        ' Leave 100px margin for taskbar/dock
        IF SCRN.displayScale% > 0 THEN
            effMax& = (_DESKTOPWIDTH - 100) \ SCRN.displayScale%
        ELSE
            effMax& = _DESKTOPWIDTH - 100
        END IF
    END IF
    SCREEN_effective_max_w& = effMax&
END FUNCTION


''
' Get effective maximum viewport height, accounting for desktop and display scale.
' When WIN_MAX_HEIGHT is 0 (unlimited), derives max from desktop / displayScale.
'
FUNCTION SCREEN_effective_max_h& ()
    DIM effMax AS LONG
    IF CFG.WIN_MAX_HEIGHT% > 0 THEN
        effMax& = CFG.WIN_MAX_HEIGHT%
    ELSE
        ' Auto-derive from desktop: viewport * displayScale must fit on screen
        ' Leave 100px margin for taskbar/dock
        IF SCRN.displayScale% > 0 THEN
            effMax& = (_DESKTOPHEIGHT - 100) \ SCRN.displayScale%
        ELSE
            effMax& = _DESKTOPHEIGHT - 100
        END IF
    END IF
    SCREEN_effective_max_h& = effMax&
END FUNCTION

''
' Detects the resolution of the desktop and sets the width and height to It
' 
SUB SCREEN_detect_desktop_resolution()
    DO: _LIMIT CFG.FPS_LIMIT% : LOOP UNTIL _SCREENEXISTS
    SCRN.w& = _DESKTOPWIDTH : SCRN.h& = _DESKTOPHEIGHT
END SUB


''
' Detects optimal display scale based on desktop resolution
' Returns scale clamped to CFG.DISPLAY_SCALE_MAX%
' 
FUNCTION SCREEN_detect_display_scale% ()
    DIM desktopH AS INTEGER
    DIM scale AS INTEGER
    DIM maxFitW AS INTEGER, maxFitH AS INTEGER
    
    ' Wait for screen to exist and get valid desktop dimensions
    DO: _LIMIT CFG.FPS_LIMIT% : LOOP UNTIL _SCREENEXISTS
    DO
        desktopH% = _DESKTOPHEIGHT
        IF desktopH% <= 0 THEN _DELAY 0.01
    LOOP UNTIL desktopH% > 0
    
    ' Calculate scale based on desktop height
    ' 4K (2160+) = 4x, 1440p (1440+) = 3x, 1080p (1080+) = 2x, else 1x
    IF desktopH% >= 2160 THEN
        scale% = 4
    ELSEIF desktopH% >= 1440 THEN
        scale% = 3
    ELSEIF desktopH% >= 1080 THEN
        scale% = 2
    ELSE
        scale% = 1
    END IF
    
    ' Clamp to configured maximum
    IF scale% > CFG.DISPLAY_SCALE_MAX% THEN scale% = CFG.DISPLAY_SCALE_MAX%
    
    ' Also ensure window fits on desktop (leave some margin for taskbar/dock)
    ' Calculate max scale that fits
    IF SCRN.w& > 0 AND SCRN.h& > 0 THEN
        maxFitW% = (_DESKTOPWIDTH - 100) \ SCRN.w&
        maxFitH% = (_DESKTOPHEIGHT - 100) \ SCRN.h&
        IF maxFitW% < scale% THEN scale% = maxFitW%
        IF maxFitH% < scale% THEN scale% = maxFitH%
    END IF
    
    ' Minimum scale is 1
    IF scale% < 1 THEN scale% = 1
    
    SCREEN_detect_display_scale% = scale%
END FUNCTION


''
' Set display scale at runtime (for hotkey scaling)
' newScale: desired new scale (will be clamped to valid range)
' 
SUB SCREEN_set_display_scale (newScale AS INTEGER)
    DIM winW AS LONG, winH AS LONG
    DIM maxFitW AS INTEGER, maxFitH AS INTEGER
    DIM clampedScale AS INTEGER
    
    ' Don't allow scale changes in fullscreen mode
    IF CFG.FULLSCREEN% THEN EXIT SUB
    
    clampedScale% = newScale%
    
    ' Clamp to minimum of 1
    IF clampedScale% < 1 THEN clampedScale% = 1
    
    ' Clamp to configured maximum
    IF clampedScale% > CFG.DISPLAY_SCALE_MAX% THEN
        clampedScale% = CFG.DISPLAY_SCALE_MAX%
    END IF
    
    ' Clamp to fit on desktop (leave margin for taskbar/dock)
    maxFitW% = (_DESKTOPWIDTH - 100) \ SCRN.w&
    maxFitH% = (_DESKTOPHEIGHT - 100) \ SCRN.h&
    IF clampedScale% > maxFitW% THEN clampedScale% = maxFitW%
    IF clampedScale% > maxFitH% THEN clampedScale% = maxFitH%
    
    ' No change needed
    IF clampedScale% = SCRN.displayScale% THEN EXIT SUB
    
    ' Update display scale
    SCRN.displayScale% = clampedScale%
    
    ' Resize window — GPU scaling via $RESIZE:STRETCH handles the rest
    winW& = SCRN.w& * SCRN.displayScale%
    winH& = SCRN.h& * SCRN.displayScale%
    glutReshapeWindow winW&, winH&
    
    ' Reset input state after window resize
    MOUSE_cleanup_after_dialog FALSE  ' Clear buffers but don't move mouse (no dialog, but same cleanup needed)
    _MOUSEHIDE                         ' Ensure system cursor stays hidden
    
    ' Mark GUI as needing redraw
    GUI_NEEDS_REDRAW% = TRUE
    
    ' Mark config as changed
    CFG.DISPLAY_SCALE_CHANGED% = TRUE
END SUB


''
' Initialize the screen and various images we will use
' 
SUB SCREEN_init ()
    DIM winW AS LONG, winH AS LONG
    
    ' Load configuration from disk
    CONFIG_load
    
    SCRN.w&   = 0
    SCRN.h&   = 0
    SCRN.bpp% = 0
    
    ' Get screen dimensions from config or auto-detect
    IF CFG.SCREEN_WIDTH% > 0 AND CFG.SCREEN_HEIGHT% > 0 THEN
        ' Use configured dimensions
        SCRN.w& = CFG.SCREEN_WIDTH%
        SCRN.h& = CFG.SCREEN_HEIGHT%
    ELSE
        ' Auto-detect desktop resolution
        SCREEN_detect_desktop_resolution
    END IF
    
    ' Enforce WIN_MIN/MAX on initial viewport
    IF CFG.WIN_MIN_WIDTH% > 0 AND SCRN.w& < CFG.WIN_MIN_WIDTH% THEN
        SCRN.w& = CFG.WIN_MIN_WIDTH%
    END IF
    IF CFG.WIN_MIN_HEIGHT% > 0 AND SCRN.h& < CFG.WIN_MIN_HEIGHT% THEN
        SCRN.h& = CFG.WIN_MIN_HEIGHT%
    END IF
    IF CFG.WIN_MAX_WIDTH% > 0 AND SCRN.w& > CFG.WIN_MAX_WIDTH% THEN
        SCRN.w& = CFG.WIN_MAX_WIDTH%
    END IF
    IF CFG.WIN_MAX_HEIGHT% > 0 AND SCRN.h& > CFG.WIN_MAX_HEIGHT% THEN
        SCRN.h& = CFG.WIN_MAX_HEIGHT%
    END IF
    
    ' Determine display scale
    IF CFG.DISPLAY_SCALE% > 0 THEN
        ' Use explicit scale from config
        SCRN.displayScale% = CFG.DISPLAY_SCALE%
        ' Clamp to max
        IF SCRN.displayScale% > CFG.DISPLAY_SCALE_MAX% THEN
            SCRN.displayScale% = CFG.DISPLAY_SCALE_MAX%
        END IF
    ELSE
        ' Auto-detect optimal scale
        SCRN.displayScale% = SCREEN_detect_display_scale%
    END IF
    
    ' Ensure minimum scale of 1
    IF SCRN.displayScale% < 1 THEN SCRN.displayScale% = 1
    
    ' Canvas dimensions start equal to screen buffer at init
    SCRN.canvasW& = SCRN.w&
    SCRN.canvasH& = SCRN.h&
    
    SCRN.zoom! = 1.0      ' Start at 1x zoom
    SCRN.zoomMin! = 0.25  ' 25% minimum zoom
    SCRN.zoomMax! = 8.0   ' 8x maximum zoom
    SCRN.offsetX% = 0
    SCRN.offsetY% = 0
    SCRN.panning% = FALSE
    SCRN.panStartX% = 0
    SCRN.panStartY% = 0
    SCRN.panOrigOffsetX% = 0
    SCRN.panOrigOffsetY% = 0
    SCRN.showToolbar% = TRUE
    SCRN.showStatus% = TRUE
    SCRN.toolbarManuallyHidden% = FALSE
    SCRN.statusManuallyHidden% = FALSE
    SCRN.menubarManuallyHidden% = FALSE
    SCRN.layerPanelManuallyHidden% = FALSE
    
    ' Create image buffers (canvas at viewport size, painting at canvas size)
    SCRN.CANVAS&   = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    SCRN.PAINTING& = _NEWIMAGE(SCRN.canvasW&, SCRN.canvasH&, 32)
    SCRN.GUI&      = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    ' SCRN.CURSOR& removed — cursors now draw directly onto SCRN.CANVAS&
    
    _DEST SCRN.PAINTING&
    CLS , _RGBA32(0, 0, 0, 0)
    _DEST SCRN.GUI&
    
    ' Use CANVAS as the SCREEN — GPU scaling via $RESIZE:STRETCH
    SCREEN SCRN.CANVAS&
    _DEST SCRN.CANVAS&
    
    ' Set window to scaled size (GPU texture scaling, no software _PUTIMAGE)
    winW& = SCRN.w& * SCRN.displayScale%
    winH& = SCRN.h& * SCRN.displayScale%
    glutReshapeWindow winW&, winH&
    
    ' Set window icon (cross-platform via SDL2)
    DIM iconHandle AS LONG
    iconHandle& = _LOADIMAGE("./ASSETS/ICONS/icon.png", 32)
    IF iconHandle& < -1 THEN
        _ICON iconHandle&
        _FREEIMAGE iconHandle&
    END IF
    
    IF CFG.FULLSCREEN% THEN _FULLSCREEN _SQUAREPIXELS
    SCRN.bpp% = _PIXELSIZE
    ' Initialize tools
    LAYERS_init  ' Initialize layers system (must be after CONFIG_load)
    WORKSPACE_UNDO_init  ' Initialize workspace undo (must be after LAYERS_init)
    MOVE_init
    TEXT_init
    GRID_init
    PIXEL_GRID_init
    SYMMETRY_init
    STATUS_init
    PALETTE_LOADER_init
    PALETTE_STRIP_init
    CMD_init  ' Initialize command palette
    MENUBAR_init  ' Initialize menu bar (must be after CONFIG_load for theme)
    SCRN.showMenubar% = TRUE
END SUB


''
' Render all visible layers with zoom, compositing bottom-to-top.
' Handles blend modes, opacity caching, partial composite cache, and move preview.
'
' @param dx% X offset for zoomed canvas placement
' @param dy% Y offset for zoomed canvas placement
' @param zw& Zoomed canvas width
' @param zh& Zoomed canvas height
'
SUB RENDER_layers (dx AS INTEGER, dy AS INTEGER, zw AS LONG, zh AS LONG)
    _DEST SCRN.CANVAS&
    _BLEND SCRN.CANVAS&

    IF LAYER_COUNT% > 0 THEN
        ' Composite layers by zIndex (bottom to top)
        DIM layerI AS INTEGER
        DIM layerFound AS INTEGER
        DIM useComposite AS INTEGER
        DIM compositeImg AS LONG

        ' Check if we need per-pixel blending (any non-Normal blend mode)
        useComposite% = BLEND_needs_composite%

        ' Rebuild render order lookup table if dirty
        IF RENDER_ORDER_DIRTY% THEN RENDER_ORDER_rebuild

        ' Start index for layer loop (1 = full composite, >1 = partial cache hit)
        DIM compositeStartIdx AS INTEGER
        DIM savePartialCache AS INTEGER
        compositeStartIdx% = 1
        savePartialCache% = FALSE

        IF useComposite% THEN
            ' Reuse persistent composite buffer (avoid _NEWIMAGE/_FREEIMAGE every frame)
            IF COMPOSITE_BUFFER& = 0 OR _
               COMPOSITE_BUFFER_W& <> SCRN.canvasW& OR _
               COMPOSITE_BUFFER_H& <> SCRN.canvasH& THEN
                IF COMPOSITE_BUFFER& < -1 THEN _FREEIMAGE COMPOSITE_BUFFER&
                COMPOSITE_BUFFER& = _NEWIMAGE(SCRN.canvasW&, SCRN.canvasH&, 32)
                COMPOSITE_BUFFER_W& = SCRN.canvasW&
                COMPOSITE_BUFFER_H& = SCRN.canvasH&
            END IF
            compositeImg& = COMPOSITE_BUFFER&

            ' --- Partial composite cache: skip layers below current when only current changes ---
            DIM currentRenderIdx AS INTEGER
            DIM cri AS INTEGER
            currentRenderIdx% = 0
            FOR cri% = 1 TO RENDER_ORDER_COUNT%
                IF RENDER_ORDER%(cri%) = CURRENT_LAYER% THEN
                    currentRenderIdx% = cri%
                    EXIT FOR
                END IF
            NEXT cri%

            DIM compOldDest AS LONG
            compOldDest& = _DEST

            IF currentRenderIdx% > 1 AND COMPOSITE_BELOW_VALID% AND _
               COMPOSITE_BELOW_LAYER% = CURRENT_LAYER% AND _
               COMPOSITE_BELOW_CACHE& <> 0 THEN
                ' Partial cache hit — restore composite of layers below current
                _DEST compositeImg&
                _DONTBLEND compositeImg&
                _PUTIMAGE , COMPOSITE_BELOW_CACHE&, compositeImg&
                _BLEND compositeImg&
                _DEST compOldDest&
                compositeStartIdx% = currentRenderIdx%
            ELSE
                ' Full composite — clear buffer
                _DEST compositeImg&
                _DONTBLEND compositeImg&
                CLS , _RGBA32(0, 0, 0, 0)
                _BLEND compositeImg&
                _DEST compOldDest&
                ' Schedule partial cache save if current layer isn't the bottommost
                IF currentRenderIdx% > 1 THEN savePartialCache% = TRUE
            END IF
        END IF

        FOR layerI% = compositeStartIdx% TO RENDER_ORDER_COUNT%
            layerFound% = RENDER_ORDER%(layerI%)

            IF layerFound% > 0 THEN
                IF LAYERS(layerFound%).visible% THEN
                ' Determine which image to render for this layer
                ' If MOVE tool is active on this layer, use the preview buffer instead
                DIM layerRenderSource AS LONG
                DIM useMoveBuf AS INTEGER
                useMoveBuf% = FALSE
                IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE AND layerFound% = CURRENT_LAYER% THEN
                    layerRenderSource& = MOVE_get_preview_buffer&
                    IF layerRenderSource& = 0 THEN
                        layerRenderSource& = LAYERS(layerFound%).imgHandle&
                    ELSE
                        useMoveBuf% = TRUE
                    END IF
                ELSE
                    layerRenderSource& = LAYERS(layerFound%).imgHandle&
                END IF

                ' Get opacity-adjusted image (cached when possible)
                DIM opacityImg AS LONG
                DIM layerOpacityI AS INTEGER
                layerOpacityI% = LAYERS(layerFound%).opacity%
                IF layerOpacityI% < 255 AND NOT useMoveBuf% THEN
                    ' Check if opacity cache is valid
                    IF LAYERS(layerFound%).opacityCacheImg& <> 0 AND _
                       LAYERS(layerFound%).opacityCacheVal% = layerOpacityI% AND _
                       NOT LAYERS(layerFound%).contentDirty% THEN
                        ' Cache hit — use cached opacity image
                        opacityImg& = LAYERS(layerFound%).opacityCacheImg&
                    ELSE
                        ' Cache miss — rebuild opacity image
                        IF LAYERS(layerFound%).opacityCacheImg& = 0 THEN
                            LAYERS(layerFound%).opacityCacheImg& = _NEWIMAGE(SCRN.canvasW&, SCRN.canvasH&, 32)
                        END IF
                        ' Copy source to cache and apply opacity
                        _DEST LAYERS(layerFound%).opacityCacheImg&
                        _DONTBLEND LAYERS(layerFound%).opacityCacheImg&
                        _PUTIMAGE , layerRenderSource&, LAYERS(layerFound%).opacityCacheImg&
                        _BLEND LAYERS(layerFound%).opacityCacheImg&
                        DIM layerMem AS _MEM
                        layerMem = _MEMIMAGE(LAYERS(layerFound%).opacityCacheImg&)
                        DIM pixOffset AS _OFFSET
                        DIM pixVal AS _UNSIGNED LONG
                        DIM pixAlpha AS _UNSIGNED _BYTE
                        DIM newAlpha AS INTEGER
                        FOR pixOffset = layerMem.OFFSET TO layerMem.OFFSET + layerMem.SIZE - 4 STEP 4
                            _MEMGET layerMem, pixOffset, pixVal~&
                            pixAlpha~%% = _ALPHA32(pixVal~&)
                            IF pixAlpha~%% > 0 THEN
                                newAlpha% = (pixAlpha~%% * layerOpacityI%) \ 255
                                _MEMPUT layerMem, pixOffset + 3, newAlpha% AS _UNSIGNED _BYTE
                            END IF
                        NEXT pixOffset
                        _MEMFREE layerMem
                        _DEST SCRN.CANVAS&
                        LAYERS(layerFound%).opacityCacheVal% = layerOpacityI%
                        LAYERS(layerFound%).contentDirty% = FALSE
                        opacityImg& = LAYERS(layerFound%).opacityCacheImg&
                    END IF
                ELSEIF layerOpacityI% < 255 AND useMoveBuf% THEN
                    ' Move preview — can't cache, build temp copy
                    opacityImg& = _COPYIMAGE(layerRenderSource&, 32)
                    layerMem = _MEMIMAGE(opacityImg&)
                    FOR pixOffset = layerMem.OFFSET TO layerMem.OFFSET + layerMem.SIZE - 4 STEP 4
                        _MEMGET layerMem, pixOffset, pixVal~&
                        pixAlpha~%% = _ALPHA32(pixVal~&)
                        IF pixAlpha~%% > 0 THEN
                            newAlpha% = (pixAlpha~%% * layerOpacityI%) \ 255
                            _MEMPUT layerMem, pixOffset + 3, newAlpha% AS _UNSIGNED _BYTE
                        END IF
                    NEXT pixOffset
                    _MEMFREE layerMem
                ELSE
                    opacityImg& = 0 ' No opacity adjustment needed
                END IF

                ' Render the layer (using opacityImg if available, else layerRenderSource)
                DIM renderImg AS LONG
                IF opacityImg& <> 0 THEN
                    renderImg& = opacityImg&
                ELSE
                    renderImg& = layerRenderSource&
                END IF

                IF useComposite% THEN
                    ' --- Composite buffer path (blend modes) ---
                    IF LAYERS(layerFound%).blendMode% = BLEND_NORMAL THEN
                        _DEST compositeImg&
                        _PUTIMAGE , renderImg&
                        _DEST SCRN.CANVAS&
                    ELSE
                        ' Non-Normal blend: pass ORIGINAL image — blend function handles opacity
                        LAYER_blend_composite compositeImg&, layerRenderSource&, LAYERS(layerFound%).blendMode%, LAYERS(layerFound%).opacity%
                    END IF
                ELSE
                    ' --- Fast path (all Normal blend) ---
                    _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), renderImg&
                END IF

                ' Free temp image if we made one for move preview
                IF useMoveBuf% AND opacityImg& <> 0 THEN
                    IF opacityImg& < -1 THEN _FREEIMAGE opacityImg&
                END IF
                END IF  ' visible%
            END IF  ' layerFound% > 0

            ' Save partial composite cache at boundary just below current layer
            IF savePartialCache% AND layerI% = currentRenderIdx% - 1 THEN
                IF COMPOSITE_BELOW_CACHE& = 0 OR _
                   _WIDTH(COMPOSITE_BELOW_CACHE&) <> SCRN.canvasW& OR _
                   _HEIGHT(COMPOSITE_BELOW_CACHE&) <> SCRN.canvasH& THEN
                    IF COMPOSITE_BELOW_CACHE& < -1 THEN _FREEIMAGE COMPOSITE_BELOW_CACHE&
                    COMPOSITE_BELOW_CACHE& = _NEWIMAGE(SCRN.canvasW&, SCRN.canvasH&, 32)
                END IF
                DIM pcOldDest AS LONG
                pcOldDest& = _DEST
                _DEST COMPOSITE_BELOW_CACHE&
                _DONTBLEND COMPOSITE_BELOW_CACHE&
                _PUTIMAGE , compositeImg&, COMPOSITE_BELOW_CACHE&
                _BLEND COMPOSITE_BELOW_CACHE&
                _DEST pcOldDest&
                COMPOSITE_BELOW_LAYER% = CURRENT_LAYER%
                COMPOSITE_BELOW_VALID% = TRUE
                savePartialCache% = FALSE
            END IF
        NEXT layerI%

        ' If using composite, render the final composite to canvas with zoom
        IF useComposite% THEN
            _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), compositeImg&, SCRN.CANVAS&
            ' compositeImg& is persistent (COMPOSITE_BUFFER&), do NOT free it
        END IF
    ELSE
        ' Fallback: Use SCRN.PAINTING if no layers exist yet (legacy support)
        DIM paint_source AS LONG
        paint_source& = MOVE_get_preview_buffer&
        IF paint_source& <> 0 THEN
            _SOURCE paint_source&
            _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), paint_source&
        ELSE
            _SOURCE SCRN.PAINTING&
            _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), SCRN.PAINTING&
        END IF
    END IF
END SUB


''
' Render grid overlays (regular grid + pixel grid cache).
' Called after layer compositing, before border/GUI.
'
' @param dx% X offset for zoomed canvas placement
' @param dy% Y offset for zoomed canvas placement
' @param zw& Zoomed canvas width
' @param zh& Zoomed canvas height
'
SUB RENDER_grids (dx AS INTEGER, dy AS INTEGER, zw AS LONG, zh AS LONG)
    IF GRID.SHOW% AND SCRN.zoom! >= 1.0 THEN
        _DEST SCRN.CANVAS&
        _SOURCE GRID.imgHandle&
        _BLEND SCRN.CANVAS&
        _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), GRID.imgHandle&, SCRN.CANVAS&
    END IF
    ' Pixel grid shows at 400%+ zoom if enabled (on top of regular grid)
    IF PIXEL_GRID.SHOW% AND SCRN.zoom! >= 4.0 THEN
        DIM pgx AS INTEGER, pgy AS INTEGER
        DIM pzoom AS INTEGER
        DIM pgColor AS _UNSIGNED LONG
        DIM pgOpacity AS INTEGER
        pzoom% = INT(SCRN.zoom!)
        ' Resolve pixel grid color: config overrides theme (CFG 0 = use theme)
        IF CFG.PIXELGRID_COLOR_FG~& <> 0 THEN
            pgColor~& = CFG.PIXELGRID_COLOR_FG~&
        ELSE
            pgColor~& = _RGB32(_RED32(THEME.PIXEL_GRID_color_fg~&), _GREEN32(THEME.PIXEL_GRID_color_fg~&), _BLUE32(THEME.PIXEL_GRID_color_fg~&))
        END IF
        ' Resolve pixel grid opacity: config overrides theme (CFG 0 = use theme)
        IF CFG.PIXELGRID_OPACITY% > 0 THEN
            pgOpacity% = CFG.PIXELGRID_OPACITY%
        ELSE
            pgOpacity% = THEME.PIXEL_GRID_opacity%
        END IF

        ' Reuse cached pixel grid image if zoom/size/color/opacity unchanged
        IF PG_CACHE_IMG& = 0 OR _
           PG_CACHE_ZW& <> zw& OR _
           PG_CACHE_ZH& <> zh& OR _
           PG_CACHE_ZOOM% <> pzoom% OR _
           PG_CACHE_COLOR~& <> pgColor~& OR _
           PG_CACHE_OPACITY% <> pgOpacity% THEN
            ' Cache miss — rebuild pixel grid image
            IF PG_CACHE_IMG& < -1 THEN _FREEIMAGE PG_CACHE_IMG&
            PG_CACHE_IMG& = _NEWIMAGE(zw& + 1, zh& + 1, 32)
            PG_CACHE_ZW& = zw&
            PG_CACHE_ZH& = zh&
            PG_CACHE_ZOOM% = pzoom%
            PG_CACHE_COLOR~& = pgColor~&
            PG_CACHE_OPACITY% = pgOpacity%
            _DEST PG_CACHE_IMG&
            CLS , _RGBA32(0, 0, 0, 0)
            ' Draw vertical lines between each pixel column
            FOR pgx% = 0 TO SCRN.canvasW&
                LINE (pgx% * pzoom%, 0)-(pgx% * pzoom%, zh&), pgColor~&
            NEXT pgx%
            ' Draw horizontal lines between each pixel row
            FOR pgy% = 0 TO SCRN.canvasH&
                LINE (0, pgy% * pzoom%)-(zw&, pgy% * pzoom%), pgColor~&
            NEXT pgy%
            ' Apply resolved opacity globally to all drawn pixels
            _SETALPHA pgOpacity%, pgColor~& TO pgColor~&, PG_CACHE_IMG&
        END IF
        ' Composite cached pixel grid onto canvas
        _DEST SCRN.CANVAS&
        _BLEND SCRN.CANVAS&
        _PUTIMAGE (dx%, dy%), PG_CACHE_IMG&
    END IF
END SUB


''
' Render tool previews (line, rect, ellipse, polygon, marquee drag, move, text, zoom).
' Drawn on canvas after grids/symmetry/border/import, before GUI layer.
'
' @param dx% X offset for zoomed canvas placement
' @param dy% Y offset for zoomed canvas placement
' @param zw& Zoomed canvas width
' @param zh& Zoomed canvas height
'
SUB RENDER_tool_previews (dx AS INTEGER, dy AS INTEGER, zw AS LONG, zh AS LONG)
    ' NOTE: Selection marching ants rendering moved AFTER scene cache save
    ' (SkipToPointer section) so animated ants don't force full scene re-render.
    ' Draw MARQUEE dragging preview (only when using marquee tool)
    IF CURRENT_TOOL% = TOOL_MARQUEE AND MARQUEE.DRAGGING% THEN
        MARQUEE_draw_drag_preview
    END IF
    ' Draw MOVE transform preview if active
    IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
        _DEST SCRN.CANVAS&
        MOVE_render_preview SCRN.CANVAS&
        IF MARQUEE.USER_CREATED THEN
            MARQUEE_draw TRUE
        END IF
    END IF
    ' Draw TEXT preview if editing
    IF CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE THEN
        _DEST SCRN.CANVAS&
        TEXT_render_preview SCRN.CANVAS&, dx%, dy%, SCRN.zoom!
    END IF
    ' Draw ZOOM drag-to-region preview rectangle
    IF CURRENT_TOOL% = TOOL_ZOOM AND ZOOM.DRAGGING THEN
        DIM zx1 AS INTEGER, zy1 AS INTEGER, zx2 AS INTEGER, zy2 AS INTEGER
        zx1% = ZOOM.START_X: zy1% = ZOOM.START_Y
        zx2% = ZOOM.END_X: zy2% = ZOOM.END_Y
        DIM zDragDist AS INTEGER
        zDragDist% = ABS(zx2% - zx1%) + ABS(zy2% - zy1%)
        IF zDragDist% >= 8 THEN
            _DEST SCRN.CANVAS&
            LINE (zx1%, zy1%)-(zx2%, zy2%), _RGBA32(255, 255, 255, 40), BF
            LINE (zx1%, zy1%)-(zx2%, zy2%), _RGB32(255, 255, 255), B
            LINE (zx1% - 1, zy1% - 1)-(zx2% + 1, zy2% + 1), _RGB32(0, 0, 0), B
        END IF
    END IF
    ' Determine preview color - use white with black outline effect for transparent
    ' Use DRAW_COLOR~& so right-click previews background color
    DIM preview_color AS _UNSIGNED LONG
    IF _ALPHA32(DRAW_COLOR~&) = 0 THEN
        preview_color~& = _RGB32(255, 255, 255)
    ELSE
        preview_color~& = DRAW_COLOR~&
    END IF

    ' Shape tool previews: draw at canvas resolution, then _PUTIMAGE scale to
    ' screen so line/shape thickness scales proportionally with zoom level.
    DIM need_shape_preview AS INTEGER
    need_shape_preview% = FALSE
    IF NOT SCRN.panning% THEN
        IF CURRENT_TOOL% = TOOL_LINE AND LINE_TOOL.DRAGGING THEN need_shape_preview% = TRUE
        IF (CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED) AND POLY_LINE.HAS_LAST THEN need_shape_preview% = TRUE
        IF (CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED) AND RECT_TOOL.DRAGGING THEN need_shape_preview% = TRUE
        IF (CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED) AND ELLIPSE_TOOL.DRAGGING THEN need_shape_preview% = TRUE
    END IF

    IF need_shape_preview% THEN
        ' Create canvas-resolution overlay for shape previews
        DIM shpImg AS LONG
        shpImg& = _NEWIMAGE(SCRN.canvasW&, SCRN.canvasH&, 32)
        IF shpImg& < -1 THEN
            _DEST shpImg&
            CLS , _RGBA32(0, 0, 0, 0)

            ' --- LINE preview at canvas resolution ---
            IF CURRENT_TOOL% = TOOL_LINE AND LINE_TOOL.DRAGGING THEN
                DIM lnBrSz AS INTEGER
                lnBrSz% = BRUSH_SIZE_pixels%
                IF lnBrSz% > 1 AND NOT CUSTOM_BRUSH_is_active% THEN
                    ' Thick brush preview
                    IF _ALPHA32(PAINT_COLOR~&) = 0 THEN
                        PREVIEW_draw_brushed_line LINE_TOOL.START_X - 1, LINE_TOOL.START_Y, LINE_TOOL.END_X - 1, LINE_TOOL.END_Y, _RGB32(0, 0, 0)
                        PREVIEW_draw_brushed_line LINE_TOOL.START_X + 1, LINE_TOOL.START_Y, LINE_TOOL.END_X + 1, LINE_TOOL.END_Y, _RGB32(0, 0, 0)
                    END IF
                    PREVIEW_draw_brushed_line LINE_TOOL.START_X, LINE_TOOL.START_Y, LINE_TOOL.END_X, LINE_TOOL.END_Y, preview_color~&
                ELSE
                    ' 1px thin preview (brush size 1 or custom brush)
                    IF _ALPHA32(PAINT_COLOR~&) = 0 THEN
                        LINE (LINE_TOOL.START_X - 1, LINE_TOOL.START_Y)-(LINE_TOOL.END_X - 1, LINE_TOOL.END_Y), _RGB32(0, 0, 0)
                        LINE (LINE_TOOL.START_X + 1, LINE_TOOL.START_Y)-(LINE_TOOL.END_X + 1, LINE_TOOL.END_Y), _RGB32(0, 0, 0)
                        LINE (LINE_TOOL.START_X, LINE_TOOL.START_Y - 1)-(LINE_TOOL.END_X, LINE_TOOL.END_Y - 1), _RGB32(0, 0, 0)
                        LINE (LINE_TOOL.START_X, LINE_TOOL.START_Y + 1)-(LINE_TOOL.END_X, LINE_TOOL.END_Y + 1), _RGB32(0, 0, 0)
                    END IF
                    LINE (LINE_TOOL.START_X, LINE_TOOL.START_Y)-(LINE_TOOL.END_X, LINE_TOOL.END_Y), preview_color~&
                END IF
            END IF

            ' --- POLY_LINE (polygon) preview at canvas resolution ---
            IF (CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED) AND POLY_LINE.HAS_LAST THEN
                DIM plBrSz AS INTEGER
                plBrSz% = BRUSH_SIZE_pixels%
                IF plBrSz% > 1 AND NOT CUSTOM_BRUSH_is_active% AND NOT POLY_LINE.FILLED THEN
                    ' Thick brush preview
                    IF _ALPHA32(PAINT_COLOR~&) = 0 THEN
                        PREVIEW_draw_brushed_line POLY_LINE.LAST_X - 1, POLY_LINE.LAST_Y, MOUSE.X% - 1, MOUSE.Y%, _RGB32(0, 0, 0)
                        PREVIEW_draw_brushed_line POLY_LINE.LAST_X + 1, POLY_LINE.LAST_Y, MOUSE.X% + 1, MOUSE.Y%, _RGB32(0, 0, 0)
                    END IF
                    PREVIEW_draw_brushed_line POLY_LINE.LAST_X, POLY_LINE.LAST_Y, MOUSE.X%, MOUSE.Y%, preview_color~&
                ELSE
                    ' 1px thin preview
                    IF _ALPHA32(PAINT_COLOR~&) = 0 THEN
                        LINE (POLY_LINE.LAST_X - 1, POLY_LINE.LAST_Y)-(MOUSE.X% - 1, MOUSE.Y%), _RGB32(0, 0, 0)
                        LINE (POLY_LINE.LAST_X + 1, POLY_LINE.LAST_Y)-(MOUSE.X% + 1, MOUSE.Y%), _RGB32(0, 0, 0)
                        LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y - 1)-(MOUSE.X%, MOUSE.Y% - 1), _RGB32(0, 0, 0)
                        LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y + 1)-(MOUSE.X%, MOUSE.Y% + 1), _RGB32(0, 0, 0)
                    END IF
                    LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y)-(MOUSE.X%, MOUSE.Y%), preview_color~&
                END IF
            END IF

            ' --- RECT preview at canvas resolution ---
            IF (CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED) AND RECT_TOOL.DRAGGING THEN
                DIM rtBrSz AS INTEGER
                rtBrSz% = BRUSH_SIZE_pixels%
                IF rtBrSz% > 1 AND NOT RECT_TOOL.FILLED AND NOT CUSTOM_BRUSH_is_active% THEN
                    ' Thick brush outline rect preview (4 brushed lines)
                    DIM rsx AS INTEGER, rsy AS INTEGER, rex AS INTEGER, rey AS INTEGER
                    rsx% = RECT_TOOL.START_X : rsy% = RECT_TOOL.START_Y
                    rex% = RECT_TOOL.END_X : rey% = RECT_TOOL.END_Y
                    PREVIEW_draw_brushed_line rsx%, rsy%, rex%, rsy%, preview_color~&
                    PREVIEW_draw_brushed_line rex%, rsy%, rex%, rey%, preview_color~&
                    PREVIEW_draw_brushed_line rex%, rey%, rsx%, rey%, preview_color~&
                    PREVIEW_draw_brushed_line rsx%, rey%, rsx%, rsy%, preview_color~&
                    ' Symmetry
                    IF SYMMETRY.MODE > 0 THEN
                        DIM rect_sx(0 TO 7) AS INTEGER, rect_sy(0 TO 7) AS INTEGER
                        DIM rect_ex(0 TO 7) AS INTEGER, rect_ey(0 TO 7) AS INTEGER
                        DIM rect_count AS INTEGER, rect_i AS INTEGER
                        SYMMETRY_get_mirrored_points rsx%, rsy%, rect_sx%(), rect_sy%(), rect_count%
                        SYMMETRY_get_mirrored_points rex%, rey%, rect_ex%(), rect_ey%(), rect_count%
                        FOR rect_i% = 0 TO rect_count% - 1
                            PREVIEW_draw_brushed_line rect_sx%(rect_i%), rect_sy%(rect_i%), rect_ex%(rect_i%), rect_sy%(rect_i%), preview_color~&
                            PREVIEW_draw_brushed_line rect_ex%(rect_i%), rect_sy%(rect_i%), rect_ex%(rect_i%), rect_ey%(rect_i%), preview_color~&
                            PREVIEW_draw_brushed_line rect_ex%(rect_i%), rect_ey%(rect_i%), rect_sx%(rect_i%), rect_ey%(rect_i%), preview_color~&
                            PREVIEW_draw_brushed_line rect_sx%(rect_i%), rect_ey%(rect_i%), rect_sx%(rect_i%), rect_sy%(rect_i%), preview_color~&
                        NEXT rect_i%
                    END IF
                ELSE
                    ' 1px rect preview (or filled rect)
                    IF _ALPHA32(PAINT_COLOR~&) = 0 THEN
                        IF RECT_TOOL.FILLED THEN
                            LINE (RECT_TOOL.START_X - 1, RECT_TOOL.START_Y - 1)-(RECT_TOOL.END_X + 1, RECT_TOOL.END_Y + 1), _RGB32(0, 0, 0), B
                        ELSE
                            LINE (RECT_TOOL.START_X - 1, RECT_TOOL.START_Y - 1)-(RECT_TOOL.END_X + 1, RECT_TOOL.END_Y + 1), _RGB32(0, 0, 0), B
                            LINE (RECT_TOOL.START_X + 1, RECT_TOOL.START_Y + 1)-(RECT_TOOL.END_X - 1, RECT_TOOL.END_Y - 1), _RGB32(0, 0, 0), B
                        END IF
                    END IF
                    IF RECT_TOOL.FILLED THEN
                        LINE (RECT_TOOL.START_X, RECT_TOOL.START_Y)-(RECT_TOOL.END_X, RECT_TOOL.END_Y), preview_color~&, BF
                    ELSE
                        LINE (RECT_TOOL.START_X, RECT_TOOL.START_Y)-(RECT_TOOL.END_X, RECT_TOOL.END_Y), preview_color~&, B
                    END IF
                    ' Draw symmetry rectangles at canvas resolution
                    IF SYMMETRY.MODE > 0 THEN
                        DIM rect_sx2(0 TO 7) AS INTEGER, rect_sy2(0 TO 7) AS INTEGER
                        DIM rect_ex2(0 TO 7) AS INTEGER, rect_ey2(0 TO 7) AS INTEGER
                        DIM rect_count2 AS INTEGER, rect_i2 AS INTEGER
                        SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_sx2%(), rect_sy2%(), rect_count2%
                        SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_ex2%(), rect_ey2%(), rect_count2%
                        FOR rect_i2% = 0 TO rect_count2% - 1
                            IF RECT_TOOL.FILLED THEN
                                LINE (rect_sx2%(rect_i2%), rect_sy2%(rect_i2%))-(rect_ex2%(rect_i2%), rect_ey2%(rect_i2%)), preview_color~&, BF
                            ELSE
                                LINE (rect_sx2%(rect_i2%), rect_sy2%(rect_i2%))-(rect_ex2%(rect_i2%), rect_ey2%(rect_i2%)), preview_color~&, B
                            END IF
                        NEXT rect_i2%
                    END IF
                END IF
            END IF

            ' --- ELLIPSE preview at canvas resolution ---
            IF (CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED) AND ELLIPSE_TOOL.DRAGGING THEN
                DIM pcx AS INTEGER, pcy AS INTEGER, prx AS SINGLE, pry AS SINGLE, pasp AS SINGLE
                pcx% = (ELLIPSE_TOOL.START_X + ELLIPSE_TOOL.END_X) \ 2
                pcy% = (ELLIPSE_TOOL.START_Y + ELLIPSE_TOOL.END_Y) \ 2
                prx! = ABS(ELLIPSE_TOOL.END_X - ELLIPSE_TOOL.START_X) / 2
                pry! = ABS(ELLIPSE_TOOL.END_Y - ELLIPSE_TOOL.START_Y) / 2
                IF prx! > 0 THEN pasp! = pry! / prx! ELSE pasp! = 1

                IF prx! > 0 THEN
                    DIM elBrSz AS INTEGER
                    elBrSz% = BRUSH_SIZE_pixels%
                    IF elBrSz% > 1 AND NOT ELLIPSE_TOOL.FILLED AND NOT CUSTOM_BRUSH_is_active% THEN
                        ' Thick brush ellipse outline preview
                        PREVIEW_draw_brushed_ellipse pcx%, pcy%, prx!, pry!, preview_color~&
                        ' Symmetry
                        IF SYMMETRY.MODE > 0 THEN
                            DIM ell_csx(0 TO 7) AS INTEGER, ell_csy(0 TO 7) AS INTEGER
                            DIM ell_count AS INTEGER, ell_i AS INTEGER
                            SYMMETRY_get_mirrored_points pcx%, pcy%, ell_csx%(), ell_csy%(), ell_count%
                            FOR ell_i% = 0 TO ell_count% - 1
                                PREVIEW_draw_brushed_ellipse ell_csx%(ell_i%), ell_csy%(ell_i%), prx!, pry!, preview_color~&
                            NEXT ell_i%
                        END IF
                    ELSE
                        ' 1px (or filled) ellipse preview
                        IF _ALPHA32(PAINT_COLOR~&) = 0 THEN
                            CIRCLE (pcx%, pcy%), prx! + 1, _RGB32(0, 0, 0), , , pasp!
                        END IF
                        IF ELLIPSE_TOOL.FILLED THEN
                            DIM preview_temp AS LONG
                            DIM preview_w AS INTEGER, preview_h AS INTEGER
                            DIM temp_cx AS INTEGER, temp_cy AS INTEGER
                            preview_w% = INT(prx! * 2 + 4)
                            preview_h% = INT(pry! * 2 + 4)
                            preview_temp& = _NEWIMAGE(preview_w%, preview_h%, 32)
                            _DEST preview_temp&
                            CLS , _RGBA32(0, 0, 0, 0)
                            _CLEARCOLOR _RGBA32(0, 0, 0, 0), preview_temp&
                            temp_cx% = preview_w% \ 2
                            temp_cy% = preview_h% \ 2
                            CIRCLE (temp_cx%, temp_cy%), prx!, preview_color~&, , , pasp!
                            PAINT (temp_cx%, temp_cy%), preview_color~&, preview_color~&
                            _DEST shpImg&
                            _PUTIMAGE (pcx% - temp_cx%, pcy% - temp_cy%), preview_temp&, shpImg&
                            IF preview_temp& < -1 THEN _FREEIMAGE preview_temp&
                        ELSE
                            CIRCLE (pcx%, pcy%), prx!, preview_color~&, , , pasp!
                        END IF
                        ' Symmetry for 1px / filled path
                        IF SYMMETRY.MODE > 0 THEN
                            DIM ell_csx2(0 TO 7) AS INTEGER, ell_csy2(0 TO 7) AS INTEGER
                            DIM ell_count2 AS INTEGER, ell_i2 AS INTEGER
                            SYMMETRY_get_mirrored_points pcx%, pcy%, ell_csx2%(), ell_csy2%(), ell_count2%
                            FOR ell_i2% = 0 TO ell_count2% - 1
                                IF ELLIPSE_TOOL.FILLED THEN
                                    preview_temp& = _NEWIMAGE(preview_w%, preview_h%, 32)
                                    _DEST preview_temp&
                                    CLS , _RGBA32(0, 0, 0, 0)
                                    _CLEARCOLOR _RGBA32(0, 0, 0, 0), preview_temp&
                                    CIRCLE (temp_cx%, temp_cy%), prx!, preview_color~&, , , pasp!
                                    PAINT (temp_cx%, temp_cy%), preview_color~&, preview_color~&
                                    _DEST shpImg&
                                    _PUTIMAGE (ell_csx2%(ell_i2%) - temp_cx%, ell_csy2%(ell_i2%) - temp_cy%), preview_temp&, shpImg&
                                    IF preview_temp& < -1 THEN _FREEIMAGE preview_temp&
                                ELSE
                                    CIRCLE (ell_csx2%(ell_i2%), ell_csy2%(ell_i2%)), prx!, preview_color~&, , , pasp!
                                END IF
                            NEXT ell_i2%
                        END IF
                    END IF
                END IF
            END IF

            ' Scale canvas-resolution overlay to screen with zoom
            DIM prev_blend AS LONG
            prev_blend& = _BLEND(SCRN.CANVAS&)
            _DEST SCRN.CANVAS&
            _BLEND SCRN.CANVAS&
            _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), shpImg&, SCRN.CANVAS&
            IF prev_blend& = 0 THEN _DONTBLEND SCRN.CANVAS&
            _FREEIMAGE shpImg&
        END IF
    END IF
END SUB


''
' Render selection overlay (marching ants) after scene cache save.
' Drawn every active frame regardless of SCENE_DIRTY since ants animate.
'
SUB RENDER_selection_overlay ()
    IF SELECTION_has_active% THEN
        IF MARQUEE.WAND_HAS_SELECTION AND MARQUEE.SELECTION_MASK < -1 THEN
            _DEST SCRN.CANVAS&
            MAGIC_WAND_draw_outline
        ELSEIF MARQUEE.ACTIVE% AND MARQUEE.USER_CREATED THEN
            IF MARQUEE.DRAGGING% AND MARQUEE.SELECTION_MODE <> SEL_MODE_REPLACE THEN
                _DEST SCRN.CANVAS&
                MARQUEE_draw_existing_box TRUE
            ELSE
                _DEST SCRN.CANVAS&
                MARQUEE_draw TRUE
            END IF
        END IF
    END IF
END SUB


''
' Render crosshair overlay and command palette.
' Crosshair shown when SHIFT held (without CTRL/ALT), not over UI, not in text mode.
'
SUB RENDER_crosshair_and_command_palette ()
    DIM shiftHeld AS INTEGER, ctrlHeld AS INTEGER, altHeld AS INTEGER
    shiftHeld% = (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&))
    ctrlHeld% = (_KEYDOWN(100305) OR _KEYDOWN(100306))
    $IF MAC THEN
        altHeld% = MAC_ALT_HELD%
    $ELSE
        altHeld% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
    $END IF

    ' Check if mouse is over any UI element (suppress crosshair over all UI)
    DIM crosshairOverUI AS INTEGER
    crosshairOverUI% = FALSE
    DIM cmx AS INTEGER, cmy AS INTEGER
    cmx% = _MOUSEX: cmy% = _MOUSEY
    IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(cmx%, cmy%) THEN crosshairOverUI% = TRUE
    IF NOT crosshairOverUI% AND LAYER_PANEL.visible% AND cmx% < CFG.LAYER_PANEL_WIDTH% THEN crosshairOverUI% = TRUE
    IF NOT crosshairOverUI% AND SCRN.showMenubar% AND MENU_BAR.visible% THEN
        IF (cmy% < MENU_BAR_HEIGHT AND cmx% >= MENU_BAR.barX%) OR MENUBAR_submenu_in_bounds%(cmx%, cmy%) THEN
            crosshairOverUI% = TRUE
        END IF
    END IF
    IF NOT crosshairOverUI% AND SCRN.showStatus% THEN
        DIM ch_strip_top AS INTEGER
        ch_strip_top% = SCRN.h& - THEME.STATUS_height% - PALETTE_STRIP_get_height%
        IF cmy% >= ch_strip_top% THEN crosshairOverUI% = TRUE
    END IF
    IF NOT crosshairOverUI% AND PALETTE_MENU_VISIBLE% THEN crosshairOverUI% = TRUE

    IF shiftHeld% AND NOT ctrlHeld% AND NOT altHeld% AND CURRENT_TOOL% <> TOOL_TEXT AND NOT MENUBAR_is_open% AND NOT crosshairOverUI% THEN
        CROSSHAIR_render
    END IF

    ' Command palette on top of everything except cursor
    IF CMD_PALETTE.visible THEN
        CMD_render SCRN.CANVAS&
    END IF
END SUB


''
' Render GUI elements (toolbar, status bar, palette strip, layer panel, menu bar).
' Only redraws when GUI_NEEDS_REDRAW% is TRUE.
'
SUB RENDER_gui_elements ()
    IF GUI_NEEDS_REDRAW% THEN
        _DEST SCRN.GUI&
        CLS , _RGBA32(0, 0, 0, 0)

        IF SCRN.showToolbar% THEN
            TOOLBAR_render 0, 0, 20
            ' Organizer sits directly beneath toolbar
            DIM org_scale AS INTEGER
            DIM org_tb_y2 AS INTEGER
            org_scale% = CFG.TOOLBAR_SCALE%
            IF org_scale% < 1 THEN org_scale% = 1
            IF org_scale% > 4 THEN org_scale% = 4
            org_tb_y2% = TB_TOP + (7 * TB_BTN_H * org_scale%) + (6 * TB_BTN_PADDING * org_scale%)
            ORGANIZER_render org_tb_y2%
        END IF
        IF SCRN.showStatus% THEN
            PALETTE_STRIP_render
            STATUS_render
        END IF

        IF LAYER_PANEL.visible% THEN
            LAYER_PANEL_render SCRN.h&
        END IF

        ' Menu bar renders LAST so submenus overlay other widgets
        IF SCRN.showMenubar% AND MENU_BAR.visible% THEN
            MENUBAR_render
        END IF

        ' Palette menu renders AFTER menubar so it overlays the bar
        IF PALETTE_MENU_VISIBLE% THEN PALETTE_MENU_render
    END IF

    _DEST SCRN.CANVAS&
END SUB


''
' Draws screen
' 
SUB SCREEN_render ()
    PERF_start PERF_RENDER_TOTAL
    ' ========================================================================
    ' GUI-ONLY REFRESH: When only GUI elements changed (e.g. brush size in
    ' status bar) but the scene (layers, grid) hasn't, re-composite just the
    ' GUI overlay onto the cached scene. Avoids expensive layer compositing,
    ' grid rendering, and transparency checkerboard.
    ' ========================================================================
    IF NOT SCENE_DIRTY% AND GUI_NEEDS_REDRAW% AND SCENE_CACHE& <> 0 THEN
        PERF_start PERF_GUI_ONLY_PATH
        ' Re-render GUI elements with updated content
        _DEST SCRN.GUI&
        CLS , _RGBA32(0, 0, 0, 0)
        IF SCRN.showToolbar% THEN
            TOOLBAR_render 0, 0, 20
            ' Organizer sits directly beneath toolbar
            DIM org_s2 AS INTEGER
            DIM org_ty2 AS INTEGER
            org_s2% = CFG.TOOLBAR_SCALE%
            IF org_s2% < 1 THEN org_s2% = 1
            IF org_s2% > 4 THEN org_s2% = 4
            org_ty2% = TB_TOP + (7 * TB_BTN_H * org_s2%) + (6 * TB_BTN_PADDING * org_s2%)
            ORGANIZER_render org_ty2%
        END IF
        IF SCRN.showStatus% THEN
            PALETTE_STRIP_render
            STATUS_render
        END IF
        IF LAYER_PANEL.visible% THEN
            LAYER_PANEL_render SCRN.h&
        END IF

        ' Menu bar renders LAST so submenus overlay other widgets
        IF SCRN.showMenubar% AND MENU_BAR.visible% THEN
            MENUBAR_render
        END IF

        ' Palette menu renders AFTER menubar so it overlays the bar
        IF PALETTE_MENU_VISIBLE% THEN PALETTE_MENU_render

        ' Restore cached scene, overlay updated GUI, update cache
        _DEST SCRN.CANVAS&
        _DONTBLEND SCRN.CANVAS&
        _PUTIMAGE , SCENE_CACHE&, SCRN.CANVAS&
        _BLEND SCRN.CANVAS&
        _PUTIMAGE , SCRN.GUI&, SCRN.CANVAS&

        ' Scrollbar overlay (on top of GUI)
        SCROLLBAR_update
        SCROLLBAR_render

        ' Save updated scene back to cache
        _DEST SCENE_CACHE&
        _DONTBLEND SCENE_CACHE&
        _PUTIMAGE , SCRN.CANVAS&, SCENE_CACHE&
        _BLEND SCENE_CACHE&
        _DEST SCRN.CANVAS&

        ' Jump to pointer+selection+upscale — must NOT fall through to
        ' dirty-rect, which only upscales the pointer region and would
        ' leave the updated GUI invisible in the window image.
        PERF_stop PERF_GUI_ONLY_PATH
        GOTO SkipToPointer
    END IF

    ' ========================================================================
    ' DIRTY-RECT FAST PATH: When the scene hasn't changed, restore+redraw
    ' only the regions that need updating (pointer area + selection overlay)
    ' instead of copying and scaling the full canvas every frame.
    ' ========================================================================
    IF NOT SCENE_DIRTY% AND SCENE_CACHE& <> 0 THEN
        PERF_start PERF_DIRTY_RECT_PATH
        DIM new_mx AS INTEGER, new_my AS INTEGER
        new_mx% = _MOUSEX
        new_my% = _MOUSEY

        ' Dynamic padding: covers cursor PNG + brush preview + overlays
        DIM ptr_pad AS INTEGER
        ptr_pad% = POINTER_get_dirty_pad%

        ' Build union bounding box of old + new pointer areas (canvas coords)
        DIM dr_x1 AS INTEGER, dr_y1 AS INTEGER
        DIM dr_x2 AS INTEGER, dr_y2 AS INTEGER

        IF POINTER.PREV_DRAW_X% <= -9999 THEN
            ' First frame after full render — use new position only
            dr_x1% = new_mx% - ptr_pad%
            dr_y1% = new_my% - ptr_pad%
            dr_x2% = new_mx% + ptr_pad%
            dr_y2% = new_my% + ptr_pad%
        ELSE
            ' Union of old rect + new rect
            DIM ox1 AS INTEGER, oy1 AS INTEGER, ox2 AS INTEGER, oy2 AS INTEGER
            ox1% = POINTER.PREV_DRAW_X% - ptr_pad%
            oy1% = POINTER.PREV_DRAW_Y% - ptr_pad%
            ox2% = POINTER.PREV_DRAW_X% + ptr_pad%
            oy2% = POINTER.PREV_DRAW_Y% + ptr_pad%

            dr_x1% = new_mx% - ptr_pad%
            dr_y1% = new_my% - ptr_pad%
            dr_x2% = new_mx% + ptr_pad%
            dr_y2% = new_my% + ptr_pad%

            IF ox1% < dr_x1% THEN dr_x1% = ox1%
            IF oy1% < dr_y1% THEN dr_y1% = oy1%
            IF ox2% > dr_x2% THEN dr_x2% = ox2%
            IF oy2% > dr_y2% THEN dr_y2% = oy2%
        END IF

        ' Expand dirty rect to include selection overlay (marching ants + handles)
        DIM has_sel AS INTEGER
        has_sel% = SELECTION_has_active%
        IF has_sel% THEN
            DIM sel_x1 AS INTEGER, sel_y1 AS INTEGER
            DIM sel_x2 AS INTEGER, sel_y2 AS INTEGER
            SELECTION_get_screen_bbox sel_x1%, sel_y1%, sel_x2%, sel_y2%
            IF sel_x1% < dr_x1% THEN dr_x1% = sel_x1%
            IF sel_y1% < dr_y1% THEN dr_y1% = sel_y1%
            IF sel_x2% > dr_x2% THEN dr_x2% = sel_x2%
            IF sel_y2% > dr_y2% THEN dr_y2% = sel_y2%
        END IF

        ' Clamp to canvas bounds
        IF dr_x1% < 0 THEN dr_x1% = 0
        IF dr_y1% < 0 THEN dr_y1% = 0
        IF dr_x2% >= SCRN.w& THEN dr_x2% = SCRN.w& - 1
        IF dr_y2% >= SCRN.h& THEN dr_y2% = SCRN.h& - 1

        ' Area check: if dirty rect > half the canvas, fall back to full copy
        DIM dr_area AS LONG, canvas_area AS LONG
        dr_area& = CLNG(dr_x2% - dr_x1% + 1) * CLNG(dr_y2% - dr_y1% + 1)
        canvas_area& = SCRN.w& * SCRN.h&

        IF dr_area& < (canvas_area& \ 2) AND dr_x2% > dr_x1% AND dr_y2% > dr_y1% THEN
            ' --- Partial restore from scene cache (erase old pointer + ants) ---
            _DEST SCRN.CANVAS&
            _DONTBLEND SCRN.CANVAS&
            _PUTIMAGE (dr_x1%, dr_y1%)-(dr_x2%, dr_y2%), SCENE_CACHE&, SCRN.CANVAS&, (dr_x1%, dr_y1%)-(dr_x2%, dr_y2%)
            _BLEND SCRN.CANVAS&

            ' --- Redraw selection overlay (marching ants animate each frame) ---
            IF has_sel% THEN
                IF MARQUEE.WAND_HAS_SELECTION AND MARQUEE.SELECTION_MASK < -1 THEN
                    _DEST SCRN.CANVAS&
                    MAGIC_WAND_draw_outline
                ELSEIF MARQUEE.ACTIVE% AND MARQUEE.USER_CREATED THEN
                    IF MARQUEE.DRAGGING% AND MARQUEE.SELECTION_MODE <> SEL_MODE_REPLACE THEN
                        _DEST SCRN.CANVAS&
                        MARQUEE_draw_existing_box TRUE
                    ELSE
                        _DEST SCRN.CANVAS&
                        MARQUEE_draw TRUE
                    END IF
                END IF
            END IF

            ' --- Re-composite GUI so ants don't show over UI elements ---
            _DEST SCRN.CANVAS&
            _PUTIMAGE (dr_x1%, dr_y1%)-(dr_x2%, dr_y2%), SCRN.GUI&, SCRN.CANVAS&, (dr_x1%, dr_y1%)-(dr_x2%, dr_y2%)

            ' --- Draw pointer at new position ---
            POINTER_update
            POINTER_render
            
            ' --- Re-composite full GUI so brush previews don't show over UI elements ---
            _DEST SCRN.CANVAS& : _SOURCE SCRN.GUI& : _PUTIMAGE
            
            ' --- Scrollbar overlay on top of GUI ---
            SCROLLBAR_render
            
            ' --- Redraw cursor on top of GUI ---
            POINTER_render_cursor_overlay

            ' --- Save pointer position for next frame ---
            POINTER.PREV_DRAW_X% = new_mx%
            POINTER.PREV_DRAW_Y% = new_my%

            ' --- GPU scaling via $RESIZE:STRETCH handles display ---

            PERF_stop PERF_DIRTY_RECT_PATH
            PERF_start PERF_DISPLAY_CALL
            _DISPLAY
            PERF_stop PERF_DISPLAY_CALL
            GUI_NEEDS_REDRAW% = FALSE
            PERF_stop PERF_RENDER_TOTAL
            EXIT SUB
        END IF
        ' --- Dirty rect too large: fall through to full-copy fast path ---

        ' Full-copy fast path (selection covers too much area)
        PERF_stop PERF_DIRTY_RECT_PATH
        _DEST SCRN.CANVAS&
        _DONTBLEND SCRN.CANVAS&
        _PUTIMAGE , SCENE_CACHE&, SCRN.CANVAS&
        _BLEND SCRN.CANVAS&
        GOTO SkipToPointer
    END IF

    ' todo get status to hide when painting 
    PERF_start PERF_FULL_CLS_GUI
    _DEST SCRN.CANVAS&
    CLS
    
    ' Clear GUI layer and render toolbar/status conditionally
    ' Only redraw GUI elements when GUI_NEEDS_REDRAW is TRUE (optimization)
    RENDER_gui_elements
    PERF_stop PERF_FULL_CLS_GUI
    
    ' Calculate zoomed dimensions and position (using canvas dimensions, centered in viewport)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.canvasW& * SCRN.zoom!
    zh& = SCRN.canvasH& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%
    
    ' Render transparency checkerboard first (behind all layers)
    PERF_start PERF_FULL_CHECKERBOARD
    TRANSPARENCY_render SCRN.CANVAS&, dx%, dy%, zw&, zh&
    PERF_stop PERF_FULL_CHECKERBOARD
    
    ' ==== REFERENCE IMAGE (behind layers, behind grid) ====
    IF REFIMG.IMAGE < -1 AND REFIMG.VISIBLE THEN
        REFIMG_render SCRN.CANVAS&, dx%, dy%, zw&, zh&
    END IF
    ' ==== END REFERENCE IMAGE ====
    
    ' Render all visible layers with zoom, compositing bottom-to-top
    PERF_start PERF_FULL_LAYERS
    RENDER_layers dx%, dy%, zw&, zh&
    PERF_stop PERF_FULL_LAYERS
    
    ' Draw grid overlays (after painting, before border/GUI)
    PERF_start PERF_FULL_GRIDS
    RENDER_grids dx%, dy%, zw&, zh&
    PERF_stop PERF_FULL_GRIDS
    
    ' Draw symmetry guide overlay (after grids, before border/GUI)
    PERF_start PERF_FULL_SYMMETRY
    IF SYMMETRY.MODE > 0 THEN
        ' Recreate guide image if size changed
        IF SYMMETRY.imgHandle& = 0 OR _WIDTH(SYMMETRY.imgHandle&) <> zw& OR _HEIGHT(SYMMETRY.imgHandle&) <> zh& THEN
            IF SYMMETRY.imgHandle& < -1 THEN _FREEIMAGE SYMMETRY.imgHandle&
            SYMMETRY.imgHandle& = _NEWIMAGE(zw&, zh&, 32)
            SYMMETRY.DIRTY% = TRUE
        END IF
        
        ' (Logging removed from render path for performance)
        SYMMETRY_render_guides zw&, zh&, SCRN.zoom!
        _DEST SCRN.CANVAS&
        _BLEND SCRN.CANVAS&  ' Use alpha blending for transparency
        _PUTIMAGE (dx%, dy%), SYMMETRY.imgHandle&, SCRN.CANVAS&
    END IF
    PERF_stop PERF_FULL_SYMMETRY
    
    ' Draw border around canvas (after painting layer)
    LINE (dx% - 1, dy% - 1)-(dx% + zw&, dy% + zh&), _RGB32(51, 51, 51), B
    
    ' ==== IMAGE IMPORT PREVIEW ====
    ' Draw import preview if in import mode (on top of painting, below GUI)
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        _DEST SCRN.CANVAS&
        IMAGE_IMPORT_draw SCRN.CANVAS&
    END IF
    ' ==== END IMAGE IMPORT PREVIEW ====
    
    ' ==== TOOL PREVIEWS (BEFORE GUI LAYER) ====
    PERF_start PERF_FULL_TOOL_PREVIEW
    RENDER_tool_previews dx%, dy%, zw&, zh&
    PERF_stop PERF_FULL_TOOL_PREVIEW
    
    ' ==== GUI LAYER (AFTER TOOL PREVIEWS) ====
    PERF_start PERF_FULL_GUI_OVERLAY
    _DEST SCRN.CANVAS& : _SOURCE SCRN.GUI& : _PUTIMAGE
    PERF_stop PERF_FULL_GUI_OVERLAY
    
    ' Render crosshair AFTER GUI layer so it's visible (using SHIFT key alone)
    ' Skip when Text tool is active (SHIFT is used for uppercase letters)
    ' Skip when CTRL or ALT are also held (those are modifier combos for other functions)
    PERF_start PERF_FULL_CROSSHAIR_CMD
    RENDER_crosshair_and_command_palette
    PERF_stop PERF_FULL_CROSSHAIR_CMD
    
    ' Render scrollbars on top of GUI (overlay when canvas > viewport)
    SCROLLBAR_update
    SCROLLBAR_render
    
    ' Save scene to cache (everything rendered, before cursor)
    PERF_start PERF_SCENE_CACHE_SAVE
    IF SCENE_CACHE& = 0 OR _WIDTH(SCENE_CACHE&) <> SCRN.w& OR _HEIGHT(SCENE_CACHE&) <> SCRN.h& THEN
        IF SCENE_CACHE& < -1 THEN _FREEIMAGE SCENE_CACHE&
        SCENE_CACHE& = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    END IF
    _DEST SCENE_CACHE&
    _DONTBLEND SCENE_CACHE&
    _PUTIMAGE , SCRN.CANVAS&, SCENE_CACHE&
    _BLEND SCENE_CACHE&
    _DEST SCRN.CANVAS&
    SCENE_DIRTY% = FALSE
    PERF_stop PERF_SCENE_CACHE_SAVE

    SkipToPointer:
    ' ==== SELECTION OVERLAY (after scene cache, animates without full re-render) ====
    PERF_start PERF_SELECTION_OVERLAY
    RENDER_selection_overlay
    PERF_stop PERF_SELECTION_OVERLAY
    PERF_start PERF_POINTER_RENDER
    POINTER_update
    POINTER_render
    PERF_stop PERF_POINTER_RENDER
    
    ' Re-composite GUI so brush previews and marching ants don't show over UI elements
    ' This must happen AFTER POINTER_render since brush previews are drawn there
    _DEST SCRN.CANVAS& : _SOURCE SCRN.GUI& : _PUTIMAGE
    
    ' Re-render scrollbars after GUI re-composite (they must stay on top)
    SCROLLBAR_render
    
    ' ==== CONTEXTUAL STATUS BARS (after second GUI composite so they're visible) ====
    ' These hint bars replace the regular status bar area with contextual keyboard hints
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        _DEST SCRN.CANVAS&
        IMAGE_IMPORT_draw_status SCRN.CANVAS&
    ELSEIF REFIMG.REPOSITION THEN
        _DEST SCRN.CANVAS&
        REFIMG_render_status SCRN.CANVAS&
    ELSEIF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
        _DEST SCRN.CANVAS&
        MOVE_render_status SCRN.CANVAS&
    END IF
    ' ==== END CONTEXTUAL STATUS BARS ====
    
    ' Redraw cursor on top of GUI (cursor must be visible above all UI elements)
    POINTER_render_cursor_overlay

    ' Save pointer position for next frame's dirty-rect optimization
    POINTER.PREV_DRAW_X% = _MOUSEX
    POINTER.PREV_DRAW_Y% = _MOUSEY
    
    ' GPU scaling via $RESIZE:STRETCH — no software scale needed
    PERF_start PERF_FINAL_SCALE
    ' (eliminated: glutReshapeWindow + $RESIZE:STRETCH handles scaling in _DISPLAY)
    PERF_stop PERF_FINAL_SCALE
    
    PERF_start PERF_DISPLAY_CALL
    _DISPLAY
    PERF_stop PERF_DISPLAY_CALL
    
    ' Reset GUI dirty flag at end of render
    GUI_NEEDS_REDRAW% = FALSE
    PERF_stop PERF_RENDER_TOTAL
END SUB
