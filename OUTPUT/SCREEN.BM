''
' DRAW - OUTPUT/SCREEN.BM
' =============================================================================
' Screen output files subs and functions.
'
' @todo
' @depends ./SCREEN.BI
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Helper for console output in graphics mode
'
SUB ECHO_LOG (msg AS STRING)
    DIM d AS LONG
    d& = _DEST
    _DEST _CONSOLE
    PRINT msg
    _DEST d&
END SUB

''
' Detects the resolution of the desktop and sets the width and height to It
' 
SUB SCREEN_detect_desktop_resolution()
    DO: _LIMIT CFG.FPS_LIMIT% : LOOP UNTIL _SCREENEXISTS
    SCRN.w& = _DESKTOPWIDTH : SCRN.h& = _DESKTOPHEIGHT
END SUB


''
' Initialize the screen and various images we will use
' 
SUB SCREEN_init ()
    SCRN.w&   = 0
    SCRN.h&   = 0
    SCRN.bpp% = 0
    SCREEN_detect_desktop_resolution
    'override for 320x200
    SCRN.w& = 640
    SCRN.h& = 480 
    SCRN.zoom! = 1.0      ' Start at 1x zoom
    SCRN.zoomMin! = 0.25  ' 25% minimum zoom
    SCRN.zoomMax! = 8.0   ' 8x maximum zoom
    SCRN.offsetX% = 0
    SCRN.offsetY% = 0
    SCRN.panning% = FALSE
    SCRN.panStartX% = 0
    SCRN.panStartY% = 0
    SCRN.panOrigOffsetX% = 0
    SCRN.panOrigOffsetY% = 0
    SCRN.showToolbar% = TRUE
    SCRN.showStatus% = TRUE
    SCRN.toolbarManuallyHidden% = FALSE
    SCRN.statusManuallyHidden% = FALSE
    SCRN.CANVAS&   = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    SCRN.PAINTING& = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    SCRN.GUI&      = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    SCRN.CURSOR&   = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    _DEST SCRN.PAINTING&
    CLS , _RGBA32(0, 0, 0, 0)
    _DEST SCRN.GUI&
    SCREEN SCRN.CANVAS&
    _DEST SCRN.CANVAS&
    IF CFG.FULLSCREEN% THEN _FULLSCREEN _SQUAREPIXELS
    SCRN.bpp% = _PIXELSIZE
    ' Initialize tools
    MOVE_init
    TEXT_init
    GRID_init
    PIXEL_GRID_init
    STATUS_init
    PALETTE_LOADER_init
    PALETTE_STRIP_init
END SUB


''
' Draws screen
' 
SUB SCREEN_render ()
    ' todo get status to hide when painting 
    _DEST SCRN.CANVAS&
    CLS
    
    ' Clear GUI layer and render toolbar/status conditionally
    _DEST SCRN.GUI&
    CLS , _RGBA32(0, 0, 0, 0) ' Clear with transparency
    
    IF SCRN.showToolbar% THEN
        TOOLBAR_render 0, 0, 13  ' xPos parameter not used anymore
    END IF
    IF SCRN.showStatus% THEN 
        PALETTE_STRIP_render
        STATUS_render
    END IF
    
    ' Switch back to canvas for main rendering
    _DEST SCRN.CANVAS&
    
    ' Calculate zoomed dimensions and position
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.w& * SCRN.zoom!
    zh& = SCRN.h& * SCRN.zoom!
    dx% = (_WIDTH - zw&) \ 2 + SCRN.offsetX%
    dy% = (_HEIGHT - zh&) \ 2 + SCRN.offsetY%
    
    ' Render painting layer with zoom
    ' Use MOVE preview buffer if move tool is active for realtime preview
    _DEST SCRN.CANVAS&
    DIM paint_source AS LONG
    paint_source& = MOVE_get_preview_buffer&
    IF paint_source& <> 0 THEN
        ' Use preview buffer showing move transform in realtime
        _SOURCE paint_source&
        _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), paint_source&
    ELSE
        ' Normal painting layer render
        _SOURCE SCRN.PAINTING&
        _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), SCRN.PAINTING&
    END IF
    
    ' Draw grid overlays (after painting, before border/GUI)
    ' Regular grid shows at 100%+ zoom if enabled
    IF GRID.SHOW% AND SCRN.zoom! >= 1.0 THEN
        _DEST SCRN.CANVAS&
        _SOURCE GRID.imgHandle&
        _BLEND GRID.imgHandle&
        _PUTIMAGE (dx%, dy%)-(dx% + zw& - 1, dy% + zh& - 1), GRID.imgHandle&, SCRN.CANVAS&
    END IF
    ' Pixel grid shows at 400%+ zoom if enabled (on top of regular grid)
    IF PIXEL_GRID.SHOW% AND SCRN.zoom! >= 4.0 THEN
        DIM pgx AS INTEGER, pgy AS INTEGER
        DIM pzoom AS INTEGER
        DIM pgImg AS LONG
        DIM pgColor AS _UNSIGNED LONG
        pzoom% = INT(SCRN.zoom!)
        ' Create temporary image for pixel grid with alpha
        pgImg& = _NEWIMAGE(zw& + 1, zh& + 1, 32)
        _DEST pgImg&
        CLS , _RGBA32(0, 0, 0, 0)  ' Clear with full transparency
        ' Use opaque color for drawing to avoid intersection artifacts
        pgColor~& = _RGB32(_RED32(THEME.PIXEL_GRID_color1~&), _GREEN32(THEME.PIXEL_GRID_color1~&), _BLUE32(THEME.PIXEL_GRID_color1~&))
        ' Draw vertical lines between each pixel column
        FOR pgx% = 0 TO SCRN.w&
            LINE (pgx% * pzoom%, 0)-(pgx% * pzoom%, zh&), pgColor~&
        NEXT pgx%
        ' Draw horizontal lines between each pixel row
        FOR pgy% = 0 TO SCRN.h&
            LINE (0, pgy% * pzoom%)-(zw&, pgy% * pzoom%), pgColor~&
        NEXT pgy%
        ' Apply 25% opacity globally to all drawn pixels (alpha 64)
        _SETALPHA 64, pgColor~& TO pgColor~&, pgImg&
        ' Composite with alpha blending onto canvas
        _DEST SCRN.CANVAS&
        _BLEND pgImg&
        _PUTIMAGE (dx%, dy%), pgImg&
        _FREEIMAGE pgImg&
    END IF
    
    ' Draw border around canvas (after painting layer)
    LINE (dx% - 1, dy% - 1)-(dx% + zw&, dy% + zh&), _RGB32(51, 51, 51), B
    
    ' ==== IMAGE IMPORT PREVIEW ====
    ' Draw import preview if in import mode (on top of painting, below GUI)
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        _DEST SCRN.CANVAS&
        IMAGE_IMPORT_draw SCRN.CANVAS&
    END IF
    ' ==== END IMAGE IMPORT PREVIEW ====
    
    _DEST SCRN.CANVAS& : _SOURCE SCRN.GUI& : _PUTIMAGE
    ' Draw MARQUEE selection if active or dragging (after all layers so it's on top)
    IF CURRENT_TOOL% = TOOL_MARQUEE AND (MARQUEE.ACTIVE% OR MARQUEE.DRAGGING%) THEN
        _DEST SCRN.CANVAS&
        MARQUEE_draw TRUE
    END IF
    ' Draw MOVE transform preview if active
    IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
        _DEST SCRN.CANVAS&
        MOVE_render_preview SCRN.CANVAS&
        ' Also draw marquee handles around the transformed selection
        MARQUEE_draw TRUE
    END IF
    ' Draw TEXT preview if editing
    IF CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE THEN
        _DEST SCRN.CANVAS&
        TEXT_render_preview SCRN.CANVAS&
    END IF
    ' Draw LINE preview while dragging (converted to zoomed screen coordinates)
    IF CURRENT_TOOL% = TOOL_LINE AND LINE_TOOL.DRAGGING THEN
        _DEST SCRN.CANVAS&
        DIM lsx AS INTEGER, lsy AS INTEGER, lex AS INTEGER, ley AS INTEGER
        lsx% = dx% + INT(LINE_TOOL.START_X * SCRN.zoom!)
        lsy% = dy% + INT(LINE_TOOL.START_Y * SCRN.zoom!)
        lex% = dx% + INT(LINE_TOOL.END_X * SCRN.zoom!)
        ley% = dy% + INT(LINE_TOOL.END_Y * SCRN.zoom!)
        LINE (lsx%, lsy%)-(lex%, ley%), PAINT_COLOR~&
    END IF
    ' Draw POLY_LINE preview from last point to mouse cursor (converted to zoomed screen coordinates)
    IF (CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED) AND POLY_LINE.HAS_LAST THEN
        _DEST SCRN.CANVAS&
        DIM plsx AS INTEGER, plsy AS INTEGER, plex AS INTEGER, pley AS INTEGER
        plsx% = dx% + INT(POLY_LINE.LAST_X * SCRN.zoom!)
        plsy% = dy% + INT(POLY_LINE.LAST_Y * SCRN.zoom!)
        plex% = dx% + INT(MOUSE.X% * SCRN.zoom!)
        pley% = dy% + INT(MOUSE.Y% * SCRN.zoom!)
        LINE (plsx%, plsy%)-(plex%, pley%), PAINT_COLOR~&
    END IF
    ' Draw RECT preview while dragging (converted to zoomed screen coordinates)
    IF (CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED) AND RECT_TOOL.DRAGGING THEN
        _DEST SCRN.CANVAS&
        DIM rsx AS INTEGER, rsy AS INTEGER, rex AS INTEGER, rey AS INTEGER
        rsx% = dx% + INT(RECT_TOOL.START_X * SCRN.zoom!)
        rsy% = dy% + INT(RECT_TOOL.START_Y * SCRN.zoom!)
        rex% = dx% + INT(RECT_TOOL.END_X * SCRN.zoom!)
        rey% = dy% + INT(RECT_TOOL.END_Y * SCRN.zoom!)
        IF RECT_TOOL.FILLED THEN
            LINE (rsx%, rsy%)-(rex%, rey%), PAINT_COLOR~&, BF
        ELSE
            LINE (rsx%, rsy%)-(rex%, rey%), PAINT_COLOR~&, B
        END IF
    END IF
    ' Draw ELLIPSE preview while dragging (converted to zoomed screen coordinates)
    IF (CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED) AND ELLIPSE_TOOL.DRAGGING THEN
        DIM pcx AS INTEGER, pcy AS INTEGER, prx AS SINGLE, pry AS SINGLE, pasp AS SINGLE
        DIM esx AS INTEGER, esy AS INTEGER, eex AS INTEGER, eey AS INTEGER
        ' Convert to screen coordinates
        esx% = dx% + INT(ELLIPSE_TOOL.START_X * SCRN.zoom!)
        esy% = dy% + INT(ELLIPSE_TOOL.START_Y * SCRN.zoom!)
        eex% = dx% + INT(ELLIPSE_TOOL.END_X * SCRN.zoom!)
        eey% = dy% + INT(ELLIPSE_TOOL.END_Y * SCRN.zoom!)
        pcx% = (esx% + eex%) \ 2
        pcy% = (esy% + eey%) \ 2
        prx! = ABS(eex% - esx%) / 2
        pry! = ABS(eey% - esy%) / 2
        IF prx! > 0 THEN pasp! = pry! / prx! ELSE pasp! = 1
        _DEST SCRN.CANVAS&
        IF prx! > 0 THEN
            IF ELLIPSE_TOOL.FILLED THEN
                ' Draw filled ellipse using CIRCLE outline + PAINT
                CIRCLE (pcx%, pcy%), prx!, PAINT_COLOR~&, , , pasp!
                PAINT (pcx%, pcy%), PAINT_COLOR~&, PAINT_COLOR~&
            ELSE
                ' Draw ellipse outline
                CIRCLE (pcx%, pcy%), prx!, PAINT_COLOR~&, , , pasp!
            END IF
        END IF
    END IF
    ' Render crosshair AFTER GUI layer so it's visible (using SHIFT key)
    ' Skip when Text tool is active (SHIFT is used for uppercase letters)
    IF (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&)) AND CURRENT_TOOL% <> TOOL_TEXT THEN 
        CROSSHAIR_render PAL_color(THEME.CROSSHAIR_fg%)
    END IF
    POINTER_update
    POINTER_render
    _DEST SCRN.CANVAS& : _SOURCE SCRN.CURSOR&
    _CLEARCOLOR _RGB32(0, 0, 0)
    _SETALPHA 0, _RGB32(0,0,0), SCRN.CURSOR&
    _BLEND SCRN.CURSOR&
    _PUTIMAGE
    _DISPLAY
END SUB
