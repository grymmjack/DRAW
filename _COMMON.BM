''
' DRAW - COMMON.BM
' =============================================================================
' Common subs and functions
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

'' 
' Apply paint opacity to a color value.
' Modulates the color's alpha channel by PAINT_OPACITY% (10-100).
' Eraser colors (alpha=0) pass through unchanged.
'
FUNCTION PAINT_apply_opacity~& (col AS _UNSIGNED LONG)
    IF PAINT_OPACITY% >= 100 OR _ALPHA32(col~&) = 0 THEN
        PAINT_apply_opacity~& = col~&
    ELSE
        DIM opA AS INTEGER
        opA% = INT(_ALPHA32(col~&) * PAINT_OPACITY% / 100)
        IF opA% < 0 THEN opA% = 0
        IF opA% > 255 THEN opA% = 255
        PAINT_apply_opacity~& = _RGBA32(_RED32(col~&), _GREEN32(col~&), _BLUE32(col~&), opA%)
    END IF
END FUNCTION


''
' Begin a stroke for opacity compositing.
' Saves a backup of the current layer so we can blend at commit time.
' All drawing during the stroke happens at full opacity on the real layer.
' Call STROKE_commit when the stroke/operation finishes.
'
SUB STROKE_begin ()
    IF PAINT_OPACITY% >= 100 THEN EXIT SUB        ' Full opacity needs no buffering
    IF STROKE_ACTIVE% THEN EXIT SUB               ' Already in a stroke

    DIM layerImg AS LONG
    layerImg& = LAYERS(CURRENT_LAYER%).imgHandle&
    IF layerImg& >= -1 THEN EXIT SUB               ' Invalid image handle

    ' Free any stale backup
    IF STROKE_BACKUP& < -1 THEN _FREEIMAGE STROKE_BACKUP&

    ' Save current layer state
    STROKE_BACKUP& = _COPYIMAGE(layerImg&, 32)
    STROKE_ACTIVE% = TRUE
END SUB


''
' Commit (end) a stroke, applying paint opacity.
' For each pixel that changed during the stroke, lerps between the backup
' (original) and current (full-opacity stroke) by PAINT_OPACITY%.
' This ensures overlapping brush dabs within a stroke don't compound opacity.
'
SUB STROKE_commit ()
    IF NOT STROKE_ACTIVE% THEN EXIT SUB
    STROKE_ACTIVE% = FALSE

    ' If opacity was changed to 100% mid-stroke, just clean up
    IF PAINT_OPACITY% >= 100 THEN
        IF STROKE_BACKUP& < -1 THEN _FREEIMAGE STROKE_BACKUP&
        STROKE_BACKUP& = 0
        EXIT SUB
    END IF

    DIM layerImg AS LONG
    layerImg& = LAYERS(CURRENT_LAYER%).imgHandle&
    IF layerImg& >= -1 OR STROKE_BACKUP& >= -1 THEN
        IF STROKE_BACKUP& < -1 THEN _FREEIMAGE STROKE_BACKUP&
        STROKE_BACKUP& = 0
        EXIT SUB
    END IF

    ' Use _MEM for fast pixel-level blending
    DIM mLayer AS _MEM, mBackup AS _MEM
    mLayer = _MEMIMAGE(layerImg&)
    mBackup = _MEMIMAGE(STROKE_BACKUP&)

    DIM opPct AS INTEGER
    opPct% = PAINT_OPACITY%

    DIM pxOffset AS _OFFSET
    DIM curPixel AS _UNSIGNED LONG
    DIM bakPixel AS _UNSIGNED LONG
    DIM cr AS INTEGER, cg AS INTEGER, cb AS INTEGER, ca AS INTEGER
    DIM br AS INTEGER, bg AS INTEGER, bb AS INTEGER, ba AS INTEGER
    DIM nr AS INTEGER, ng AS INTEGER, nb AS INTEGER, na AS INTEGER

    FOR pxOffset = 0 TO mLayer.SIZE - 4 STEP 4
        _MEMGET mLayer, mLayer.OFFSET + pxOffset, curPixel~&
        _MEMGET mBackup, mBackup.OFFSET + pxOffset, bakPixel~&

        IF curPixel~& <> bakPixel~& THEN
            ' Pixel was changed by the stroke â€” lerp toward original by (1 - opacity)
            cr% = _RED32(curPixel~&):   cg% = _GREEN32(curPixel~&)
            cb% = _BLUE32(curPixel~&):  ca% = _ALPHA32(curPixel~&)
            br% = _RED32(bakPixel~&):   bg% = _GREEN32(bakPixel~&)
            bb% = _BLUE32(bakPixel~&):  ba% = _ALPHA32(bakPixel~&)

            nr% = br% + (cr% - br%) * opPct% \ 100
            ng% = bg% + (cg% - bg%) * opPct% \ 100
            nb% = bb% + (cb% - bb%) * opPct% \ 100
            na% = ba% + (ca% - ba%) * opPct% \ 100

            _MEMPUT mLayer, mLayer.OFFSET + pxOffset, _RGBA32(nr%, ng%, nb%, na%) AS _UNSIGNED LONG
        END IF
    NEXT

    _MEMFREE mLayer
    _MEMFREE mBackup

    ' Clean up backup
    IF STROKE_BACKUP& < -1 THEN _FREEIMAGE STROKE_BACKUP&
    STROKE_BACKUP& = 0
END SUB


''
' Update window title bar to reflect current state
' Format: DRAW vX.X.X - filename *
'
SUB TITLE_update ()
    DIM t$
    DIM fn$
    
    t$ = "DRAW v" + APP_VERSION$
    
    ' Determine active filename (prefer .draw project, fall back to image file)
    IF CURRENT_DRW_FILENAME$ <> "" THEN
        fn$ = CURRENT_DRW_FILENAME$
    ELSEIF CURRENT_FILENAME$ <> "" THEN
        fn$ = CURRENT_FILENAME$
    END IF
    
    ' Extract just the filename (no path)
    IF fn$ <> "" THEN
        DIM i AS INTEGER
        DIM baseName$
        baseName$ = fn$
        FOR i% = LEN(fn$) TO 1 STEP -1
            IF MID$(fn$, i%, 1) = "/" OR MID$(fn$, i%, 1) = "\" THEN
                baseName$ = MID$(fn$, i% + 1)
                EXIT FOR
            END IF
        NEXT i%
        t$ = t$ + " - " + baseName$
    END IF
    
    ' Dirty indicator
    IF CANVAS_DIRTY% THEN t$ = t$ + " *"
    
    _TITLE t$
    
    ' Update tracking state
    TITLE_PREV_DIRTY% = CANVAS_DIRTY%
    TITLE_PREV_FILENAME$ = fn$
END SUB

''
' Check if title needs updating and call TITLE_update if so
'
SUB TITLE_check ()
    DIM fn$
    IF CURRENT_DRW_FILENAME$ <> "" THEN
        fn$ = CURRENT_DRW_FILENAME$
    ELSEIF CURRENT_FILENAME$ <> "" THEN
        fn$ = CURRENT_FILENAME$
    END IF
    
    IF CANVAS_DIRTY% <> TITLE_PREV_DIRTY% OR fn$ <> TITLE_PREV_FILENAME$ THEN
        TITLE_update
    END IF
END SUB

''
' Returns an int as a trimmed string
' @param INTEGER64 v&& integer to return as string
'  
FUNCTION ns$ (v&&)
    ns$ = _TRIM$(STR$(v&&))
END FUNCTION


''
' Snap a line endpoint to the nearest angle increment (e.g., 45 degrees)
' Used when drawing lines/polygons with Ctrl+Shift held for precise angles
' 
' @param INTEGER start_x Starting X coordinate
' @param INTEGER start_y Starting Y coordinate
' @param INTEGER end_x Current end X coordinate (will be modified)
' @param INTEGER end_y Current end Y coordinate (will be modified)
' @param INTEGER snap_degrees Angle snap increment (15, 30, 45, 90, etc.)
'
SUB SNAP_to_angle (start_x AS INTEGER, start_y AS INTEGER, end_x AS INTEGER, end_y AS INTEGER, snap_degrees AS INTEGER)
    ' Calculate the current angle from start to end point
    DIM dx AS SINGLE, dy AS SINGLE, angle AS SINGLE, distance AS SINGLE
    DIM snapped_angle AS SINGLE, snap_rad AS SINGLE
    
    dx! = end_x - start_x
    dy! = end_y - start_y
    
    ' If start and end are the same point, nothing to snap
    IF dx! = 0 AND dy! = 0 THEN EXIT SUB
    
    ' Calculate angle in degrees (-180 to 180)
    angle! = _ATAN2(dy!, dx!) * 180 / _PI
    
    ' Calculate distance from start to end
    distance! = SQR(dx! * dx! + dy! * dy!)
    
    ' Snap angle to nearest increment
    snapped_angle! = INT(angle! / snap_degrees + 0.5) * snap_degrees
    
    ' Convert back to radians
    snap_rad! = snapped_angle! * _PI / 180
    
    ' Calculate new endpoint at snapped angle with same distance
    end_x = start_x + INT(COS(snap_rad!) * distance! + 0.5)
    end_y = start_y + INT(SIN(snap_rad!) * distance! + 0.5)
END SUB

