''
' DRAW - INPUT/MOUSE.BM
' =============================================================================
' Mouse input handling subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

DECLARE FUNCTION MOUSE_handle_image_import% ()
DECLARE FUNCTION MOUSE_handle_command_palette_click% (rawX AS INTEGER, rawY AS INTEGER)
DECLARE FUNCTION MOUSE_handle_menubar_click% (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_menubar_mouse_move (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_autocommit_move_if_click_on_gui (rawX AS INTEGER, rawY AS INTEGER)
DECLARE FUNCTION MOUSE_handle_palette_menu_close% (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_layer_panel (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
DECLARE SUB MOUSE_handle_toolbar_status_palette (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_b3_dblclick_reset_zoom ()
DECLARE SUB MOUSE_handle_ui_autohide_restore (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_panning (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_right_click ()
DECLARE SUB MOUSE_handle_shift_constrain ()
DECLARE SUB MOUSE_handle_wheel (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
DECLARE SUB MOUSE_dispatch_tool_hold (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_dispatch_tool_release (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_symmetry_ctrl_click ()
DECLARE SUB MOUSE_update_draw_color ()
DECLARE SUB MOUSE_handle_alt_picker (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_space_pan ()
DECLARE FUNCTION MOUSE_handle_suppress_frames% ()
DECLARE FUNCTION MOUSE_should_skip_tool_actions% ()
DECLARE SUB MOUSE_handle_tool_phase (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_crop_drag ()
DECLARE FUNCTION MOUSE_handle_gui_early% (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_gui_panels (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
DECLARE SUB MOUSE_post_process (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
DECLARE FUNCTION MOUSE_process_frame% (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
DECLARE SUB MOUSE_cleanup_after_dialog (centerMouse AS INTEGER)
DECLARE SUB MOUSE_tool_fill ()
DECLARE SUB MOUSE_tool_picker ()
DECLARE SUB MOUSE_tool_save ()
DECLARE SUB MOUSE_tool_open ()
DECLARE SUB MOUSE_tool_text ()
DECLARE SUB MOUSE_tool_marquee ()
DECLARE SUB MOUSE_tool_move ()
DECLARE SUB MOUSE_tool_line ()
DECLARE SUB MOUSE_tool_poly ()
DECLARE SUB MOUSE_tool_rect ()
DECLARE SUB MOUSE_tool_ellip ()
DECLARE SUB MOUSE_tool_brush ()
DECLARE SUB MOUSE_tool_dot ()
DECLARE SUB MOUSE_tool_spray ()
DECLARE SUB MOUSE_tool_zoom (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_release_zoom (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_release_marquee ()
DECLARE SUB MOUSE_release_move ()
DECLARE SUB MOUSE_release_line ()
DECLARE SUB MOUSE_release_rect ()
DECLARE SUB MOUSE_release_ellip ()
DECLARE SUB MOUSE_release_brush ()
DECLARE SUB MOUSE_release_dot ()
DECLARE SUB MOUSE_release_text ()
DECLARE SUB MOUSE_release_spray ()

''
' Drain all buffered mouse events and update MOUSE state ONCE with final values.
' - Accumulates wheel delta (returned via wheel_delta%)
' - Updates MOUSE.RAW_X/Y, MOUSE.X/Y (with grid snap + clamp)
' - Updates MOUSE.B1/B2/B3 (with macOS trackpad tap-to-click workaround)
'
SUB MOUSE_drain_update_state (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
    wheel_delta% = 0

    $IF MAC THEN
        ' macOS: Capture button states during drain to fix trackpad tap-to-click
        ' SDL2 on macOS doesn't always preserve button state after _MOUSEINPUT drain
        DIM mac_b1 AS INTEGER, mac_b2 AS INTEGER, mac_b3 AS INTEGER
        mac_b1% = FALSE: mac_b2% = FALSE: mac_b3% = FALSE
        DO WHILE _MOUSEINPUT
            wheel_delta% = wheel_delta% + _MOUSEWHEEL
            ' Capture any button presses during the drain
            IF _MOUSEBUTTON(1) THEN mac_b1% = TRUE
            IF _MOUSEBUTTON(2) THEN mac_b2% = TRUE
            IF _MOUSEBUTTON(3) THEN mac_b3% = TRUE
        LOOP
    $ELSE
        DO WHILE _MOUSEINPUT
            wheel_delta% = wheel_delta% + _MOUSEWHEEL
        LOOP
    $END IF

    ' Get window coordinates and scale down by display scale
    rawX% = _MOUSEX
    rawY% = _MOUSEY

    ' Store raw screen coordinates for GUI hover detection
    MOUSE.RAW_X% = rawX%
    MOUSE.RAW_Y% = rawY%

    ' Calculate zoomed canvas position on screen (using canvas dimensions, centered in viewport)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.canvasW& * SCRN.zoom!
    zh& = SCRN.canvasH& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%

    ' Convert screen coords to canvas coords
    MOUSE.X% = INT((rawX% - dx%) / SCRN.zoom!)
    MOUSE.Y% = INT((rawY% - dy%) / SCRN.zoom!)

    ' Store unsnapped coordinates (for fill, picker, and other pixel-exact tools)
    MOUSE.UNSNAPPED_X% = MOUSE.X%
    MOUSE.UNSNAPPED_Y% = MOUSE.Y%

    ' Clamp unsnapped coords to canvas bounds (needed for Ctrl+Shift grid override)
    IF MOUSE.UNSNAPPED_X% < 0 THEN MOUSE.UNSNAPPED_X% = 0
    IF MOUSE.UNSNAPPED_Y% < 0 THEN MOUSE.UNSNAPPED_Y% = 0
    IF MOUSE.UNSNAPPED_X% >= SCRN.canvasW& THEN MOUSE.UNSNAPPED_X% = SCRN.canvasW& - 1
    IF MOUSE.UNSNAPPED_Y% >= SCRN.canvasH& THEN MOUSE.UNSNAPPED_Y% = SCRN.canvasH& - 1

    ' Apply snap-to-grid if enabled (handles rotated grid angle too)
    ' Ctrl+Shift bypasses grid snap so user can start lines/shapes off-grid
    IF NOT MODIFIERS.ctrlShift% THEN
        GRID_snap_xy MOUSE.X%, MOUSE.Y%
    END IF

    ' Clamp to canvas bounds
    IF MOUSE.X% < 0 THEN MOUSE.X% = 0
    IF MOUSE.Y% < 0 THEN MOUSE.Y% = 0
    IF MOUSE.X% >= SCRN.canvasW& THEN MOUSE.X% = SCRN.canvasW& - 1
    IF MOUSE.Y% >= SCRN.canvasH& THEN MOUSE.Y% = SCRN.canvasH& - 1

    ' Update button states from hardware
    $IF MAC THEN
        ' macOS: Use captured states OR current hardware state (whichever shows pressed)
        MOUSE.B1% = mac_b1% OR _MOUSEBUTTON(1)
        MOUSE.B2% = mac_b2% OR _MOUSEBUTTON(2)
        MOUSE.B3% = mac_b3% OR _MOUSEBUTTON(3)
    $ELSE
        MOUSE.B1% = _MOUSEBUTTON(1)
        MOUSE.B2% = _MOUSEBUTTON(2)
        MOUSE.B3% = _MOUSEBUTTON(3)
    $END IF
END SUB

''
' Initializes the mouse
' 
SUB MOUSE_init ()
    MOUSE.X%     = 1
    MOUSE.Y%     = 1
    MOUSE.OLD_X% = 1
    MOUSE.OLD_Y% = 1
    MOUSE.CON_X% = 0
    MOUSE.CON_Y% = 0
    MOUSE.UNSNAPPED_X% = 1
    MOUSE.UNSNAPPED_Y% = 1
    MOUSE.OSW%   = 0
    MOUSE.B1%    = FALSE
    MOUSE.B2%    = FALSE
    MOUSE.B3%    = FALSE
    MOUSE.OLD_B1% = FALSE
    MOUSE.OLD_B3% = FALSE
    MOUSE.DRAG$  = ""
    MOUSE.B3_CLICK_TIME# = 0
    MOUSE.DEFERRED_ACTION% = 0
END SUB


''
' Reset mouse button states (call after dialogs to prevent button state desync)
' Syncs current and old states to actual hardware state to prevent false clicks
'
SUB MOUSE_reset_buttons ()
    ' Clear any pending mouse input first
    DO WHILE _MOUSEINPUT : LOOP
    
    ' Read actual current button states from hardware
    DIM current_b1 AS INTEGER
    DIM current_b2 AS INTEGER
    DIM current_b3 AS INTEGER
    current_b1% = _MOUSEBUTTON(1)
    current_b2% = _MOUSEBUTTON(2)
    current_b3% = _MOUSEBUTTON(3)
    
    ' Set both current AND old to same values (no transition = no click detection)
    MOUSE.B1% = current_b1%
    MOUSE.B2% = current_b2%
    MOUSE.B3% = current_b3%
    MOUSE.OLD_B1% = current_b1%
    MOUSE.OLD_B2% = current_b2%
    MOUSE.OLD_B3% = current_b3%
    MOUSE.TOOLBAR_CLICKED% = FALSE
END SUB


''
' Forces all mouse buttons to UP state (used after dialogs to prevent phantom clicks)
'
SUB MOUSE_force_buttons_up ()
    ' Clear any pending mouse input first
    DO WHILE _MOUSEINPUT : LOOP
    
    ' Force all buttons to UP (FALSE) state
    MOUSE.B1% = FALSE
    MOUSE.B2% = FALSE
    MOUSE.B3% = FALSE
    MOUSE.OLD_B1% = FALSE
    MOUSE.OLD_B2% = FALSE
    MOUSE.OLD_B3% = FALSE
    MOUSE.TOOLBAR_CLICKED% = FALSE

    ' Suppress button input for next 2 frames to catch late-arriving SDL events
    ' after native dialogs (file open/save, message boxes) close
    MOUSE.SUPPRESS_FRAMES% = 2
END SUB


''
' Comprehensive cleanup after native dialogs (file open/save, message boxes, input boxes).
' Consolidates the scattered cleanup patterns found throughout the codebase.
' 
' WHAT IT DOES:
' - Drains mouse input buffer (prevents buffered clicks from triggering after dialog)
' - Forces all mouse buttons to UP state
' - Sets SUPPRESS_FRAMES to prevent SDL event leakage
' - Clears keyboard buffer (prevents buffered keys from triggering after dialog)
' - Centers mouse position (optional, helps reorient after dialog movement)
'
' WHEN TO USE:
' - After _OPENFILEDIALOG$(), _SAVEFILEDIALOG$()
' - After _MESSAGEBOX()
' - After _INPUTBOX$()
' - After any native dialog that may interfere with input state
' - After POINTER_show_after_dialog (this function completes the cleanup sequence)
'
' @param centerMouse% TRUE to center mouse at (_WIDTH\2, _HEIGHT\2), FALSE to leave position alone
'
SUB MOUSE_cleanup_after_dialog (centerMouse AS INTEGER)
    ' Drain mouse input buffer
    DO WHILE _MOUSEINPUT: LOOP
    
    ' Force all mouse buttons to UP state
    MOUSE.B1% = FALSE
    MOUSE.B2% = FALSE
    MOUSE.B3% = FALSE
    MOUSE.OLD_B1% = FALSE
    MOUSE.OLD_B2% = FALSE
    MOUSE.OLD_B3% = FALSE
    MOUSE.TOOLBAR_CLICKED% = FALSE
    
    ' Suppress button input for next 2 frames (catches late SDL events)
    MOUSE.SUPPRESS_FRAMES% = 2
    
    ' Clear keyboard buffer
    _KEYCLEAR
    
    ' Optionally center mouse cursor (helps reorient user after dialog)
    IF centerMouse% THEN
        _MOUSEMOVE _WIDTH \ 2, _HEIGHT \ 2
    END IF
END SUB


''
' Reference image reposition mode mouse handling.
' Returns TRUE when reposition is active and input was handled.
'
FUNCTION MOUSE_handle_refimg_reposition% ()
    MOUSE_handle_refimg_reposition% = FALSE
    IF NOT REFIMG.REPOSITION THEN EXIT FUNCTION
    
    ' Drain mouse input and accumulate wheel
    DIM wheel_delta AS INTEGER
    DIM rawX AS INTEGER, rawY AS INTEGER
    wheel_delta% = 0
    DO WHILE _MOUSEINPUT
        wheel_delta% = wheel_delta% + _MOUSEWHEEL
    LOOP
    rawX% = _MOUSEX
    rawY% = _MOUSEY
    
    ' Convert to canvas coordinates (canvas dimensions, centered in viewport)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.canvasW& * SCRN.zoom!
    zh& = SCRN.canvasH& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%
    DIM canvasX AS INTEGER, canvasY AS INTEGER
    canvasX% = INT((rawX% - dx%) / SCRN.zoom!)
    canvasY% = INT((rawY% - dy%) / SCRN.zoom!)
    
    ' Button states
    DIM b1 AS INTEGER
    b1% = _MOUSEBUTTON(1)
    
    ' Mouse wheel: resize reference image
    IF wheel_delta% <> 0 THEN
        REFIMG_reposition_wheel wheel_delta%
    END IF
    
    ' Mouse button press/release/drag
    STATIC wasDown AS INTEGER
    IF b1% AND NOT wasDown% THEN
        REFIMG_reposition_mouse_down canvasX%, canvasY%
    ELSEIF b1% AND wasDown% THEN
        REFIMG_reposition_mouse_move canvasX%, canvasY%
    ELSEIF NOT b1% AND wasDown% THEN
        REFIMG_reposition_mouse_up
    END IF
    wasDown% = b1%
    
    FRAME_IDLE% = FALSE
    MOUSE_handle_refimg_reposition% = TRUE
END FUNCTION


''
' Image import mode mouse handling.
' Returns TRUE when IMG_IMPORT is active and input was handled (caller should EXIT SUB).
'
FUNCTION MOUSE_handle_image_import% ()
    MOUSE_handle_image_import% = FALSE
    IF IMG_IMPORT.STATE <= IMPORT_STATE_IDLE THEN EXIT FUNCTION

    ' Accumulate wheel delta while clearing buffered input
    DIM wheel_delta AS INTEGER
    wheel_delta% = 0
    $IF MAC THEN
        ' macOS: Capture button states during drain to fix trackpad tap-to-click
        ' SDL2 on macOS doesn't always preserve button state after _MOUSEINPUT drain
        DIM mac_b1 AS INTEGER, mac_b2 AS INTEGER, mac_b3 AS INTEGER
        mac_b1% = FALSE: mac_b2% = FALSE: mac_b3% = FALSE
        DO WHILE _MOUSEINPUT
            wheel_delta% = wheel_delta% + _MOUSEWHEEL
            ' Capture any button presses during the drain
            IF _MOUSEBUTTON(1) THEN mac_b1% = TRUE
            IF _MOUSEBUTTON(2) THEN mac_b2% = TRUE
            IF _MOUSEBUTTON(3) THEN mac_b3% = TRUE
        LOOP
    $ELSE
        DO WHILE _MOUSEINPUT
            wheel_delta% = wheel_delta% + _MOUSEWHEEL
        LOOP
    $END IF

    ' Get current mouse state directly (not buffered)
    DIM imp_rawX AS INTEGER, imp_rawY AS INTEGER
    DIM imp_zw AS LONG, imp_zh AS LONG, imp_dx AS INTEGER, imp_dy AS INTEGER

    ' Get window coordinates and scale down by display scale
    imp_rawX% = _MOUSEX
    imp_rawY% = _MOUSEY

    ' Store raw screen coordinates
    MOUSE.RAW_X% = imp_rawX%
    MOUSE.RAW_Y% = imp_rawY%

    ' Calculate zoomed canvas position on screen (canvas dimensions, centered in viewport)
    imp_zw& = SCRN.canvasW& * SCRN.zoom!
    imp_zh& = SCRN.canvasH& * SCRN.zoom!
    imp_dx% = (SCRN.w& - imp_zw&) \ 2 + SCRN.offsetX%
    imp_dy% = (SCRN.h& - imp_zh&) \ 2 + SCRN.offsetY%

    ' Convert screen coords to canvas coords
    MOUSE.X% = INT((imp_rawX% - imp_dx%) / SCRN.zoom!)
    MOUSE.Y% = INT((imp_rawY% - imp_dy%) / SCRN.zoom!)

    ' Clamp to canvas bounds
    IF MOUSE.X% < 0 THEN MOUSE.X% = 0
    IF MOUSE.Y% < 0 THEN MOUSE.Y% = 0
    IF MOUSE.X% >= SCRN.canvasW& THEN MOUSE.X% = SCRN.canvasW& - 1
    IF MOUSE.Y% >= SCRN.canvasH& THEN MOUSE.Y% = SCRN.canvasH& - 1

    ' Get button states
    $IF MAC THEN
        ' macOS: Use captured states OR current hardware state (whichever shows pressed)
        MOUSE.B1% = mac_b1% OR _MOUSEBUTTON(1)
        MOUSE.B2% = mac_b2% OR _MOUSEBUTTON(2)
        MOUSE.B3% = mac_b3% OR _MOUSEBUTTON(3)
    $ELSE
        MOUSE.B1% = _MOUSEBUTTON(1)
        MOUSE.B2% = _MOUSEBUTTON(2)
        MOUSE.B3% = _MOUSEBUTTON(3)
    $END IF

    ' Suppress button input after native dialogs (same as normal mode)
    IF MOUSE.SUPPRESS_FRAMES% > 0 THEN
        DO WHILE _MOUSEINPUT: LOOP
        MOUSE.B1% = FALSE
        MOUSE.B2% = FALSE
        MOUSE.B3% = FALSE
        MOUSE.OLD_B1% = FALSE
        MOUSE.OLD_B2% = FALSE
        MOUSE.OLD_B3% = FALSE
        MOUSE.SUPPRESS_FRAMES% = MOUSE.SUPPRESS_FRAMES% - 1
        MOUSE.OLD_X% = MOUSE.X%
        MOUSE.OLD_Y% = MOUSE.Y%
        MOUSE_handle_image_import% = TRUE
        EXIT FUNCTION
    END IF

    ' Handle mouse wheel for zoom (accumulated from buffer)
    IF wheel_delta% <> 0 THEN
        IMAGE_IMPORT_zoom -wheel_delta%  ' Negative: wheel up = zoom in
    END IF

    ' Track hover handle for visual feedback
    IF IMG_IMPORT.STATE >= IMPORT_STATE_PLACING AND NOT IMG_IMPORT.RESIZING THEN
        IMG_IMPORT.HOVER_HANDLE = IMAGE_IMPORT_get_handle_at%(MOUSE.X%, MOUSE.Y%)
    ELSE
        IMG_IMPORT.HOVER_HANDLE = 0
    END IF

    ' Handle mouse button interactions
    IF MOUSE.B1% THEN
        IF NOT MOUSE.OLD_B1% THEN
            ' Button just pressed - determine action based on state
            IF IMG_IMPORT.STATE = IMPORT_STATE_LOADED THEN
                ' No marquee yet - start drawing one
                IMAGE_IMPORT_start_placement MOUSE.X%, MOUSE.Y%
            ELSEIF IMG_IMPORT.STATE >= IMPORT_STATE_PLACING THEN
                ' Have a placement - check for handle/pan/new marquee
                DIM import_handle AS INTEGER
                import_handle% = IMAGE_IMPORT_get_handle_at%(MOUSE.X%, MOUSE.Y%)
                IF import_handle% > 0 THEN
                    IMAGE_IMPORT_start_resize import_handle%, MOUSE.X%, MOUSE.Y%
                ELSEIF IMAGE_IMPORT_is_point_inside%(MOUSE.X%, MOUSE.Y%) THEN
                    IMAGE_IMPORT_start_pan MOUSE.X%, MOUSE.Y%
                ELSE
                    ' Click outside - start new marquee
                    IMG_IMPORT.STATE = IMPORT_STATE_LOADED
                    IMAGE_IMPORT_start_placement MOUSE.X%, MOUSE.Y%
                END IF
            END IF
        ELSE
            ' Button held - update current operation
            IF IMG_IMPORT.DRAGGING THEN
                IMAGE_IMPORT_update_placement MOUSE.X%, MOUSE.Y%
            ELSEIF IMG_IMPORT.RESIZING THEN
                IMAGE_IMPORT_update_resize MOUSE.X%, MOUSE.Y%
            ELSEIF IMG_IMPORT.PANNING THEN
                IMAGE_IMPORT_update_pan MOUSE.X%, MOUSE.Y%
            END IF
        END IF
    ELSE
        ' Button released - finish current operation
        IF IMG_IMPORT.DRAGGING THEN
            IMAGE_IMPORT_finish_placement
        ELSEIF IMG_IMPORT.RESIZING THEN
            IMAGE_IMPORT_finish_resize
        ELSEIF IMG_IMPORT.PANNING THEN
            IMAGE_IMPORT_finish_pan
        END IF
    END IF

    ' Update old mouse state
    MOUSE.OLD_B1% = MOUSE.B1%
    MOUSE.OLD_B2% = MOUSE.B2%
    MOUSE.OLD_B3% = MOUSE.B3%
    MOUSE.OLD_X% = MOUSE.X%
    MOUSE.OLD_Y% = MOUSE.Y%

    MOUSE_handle_image_import% = TRUE
END FUNCTION


''
' Command palette click handling.
' Returns TRUE if click was consumed (caller should EXIT SUB).
'
FUNCTION MOUSE_handle_command_palette_click% (rawX AS INTEGER, rawY AS INTEGER)
    MOUSE_handle_command_palette_click% = FALSE
    IF NOT CMD_PALETTE.visible THEN EXIT FUNCTION
    IF NOT (MOUSE.B1% AND NOT MOUSE.OLD_B1%) THEN EXIT FUNCTION

    CMD_handle_click rawX%, rawY%

    ' Don't process other clicks when palette is visible
    MOUSE.OLD_B1% = MOUSE.B1%
    MOUSE.OLD_B2% = MOUSE.B2%
    MOUSE.OLD_B3% = MOUSE.B3%
    MOUSE.OLD_X% = MOUSE.X%
    MOUSE.OLD_Y% = MOUSE.Y%
    MOUSE_handle_command_palette_click% = TRUE
END FUNCTION


''
' Menu bar click handling.
' Returns TRUE if click was consumed (caller should EXIT SUB).
'
FUNCTION MOUSE_handle_menubar_click% (rawX AS INTEGER, rawY AS INTEGER)
    MOUSE_handle_menubar_click% = FALSE
    IF NOT (SCRN.showMenubar% AND MENU_BAR.visible%) THEN EXIT FUNCTION
    IF NOT (MOUSE.B1% AND NOT MOUSE.OLD_B1%) THEN EXIT FUNCTION

    IF MENUBAR_in_bounds%(rawX%, rawY%) OR MENUBAR_submenu_in_bounds%(rawX%, rawY%) OR MENUBAR_recent_in_bounds%(rawX%, rawY%) THEN
        MENUBAR_handle_click rawX%, rawY%
        MOUSE.TOOLBAR_CLICKED% = TRUE
        MOUSE.OLD_B1% = MOUSE.B1%
        MOUSE.OLD_B2% = MOUSE.B2%
        MOUSE.OLD_B3% = MOUSE.B3%
        MOUSE.OLD_X% = MOUSE.X%
        MOUSE.OLD_Y% = MOUSE.Y%
        MOUSE_handle_menubar_click% = TRUE
    ELSEIF MENUBAR_is_open% THEN
        ' Clicked outside menu bar while submenu is open — close it
        MENUBAR_close_all
        GUI_NEEDS_REDRAW% = TRUE
    END IF
END FUNCTION


''
' Menu bar hover tracking (menu switching on mouse move).
'
SUB MOUSE_handle_menubar_mouse_move (rawX AS INTEGER, rawY AS INTEGER)
    IF SCRN.showMenubar% AND MENU_BAR.visible% THEN
        MENUBAR_handle_mouse_move rawX%, rawY%
    END IF
END SUB


''
' Auto-apply move transform when clicking GUI controls (without marquee selection).
'
SUB MOUSE_autocommit_move_if_click_on_gui (rawX AS INTEGER, rawY AS INTEGER)
    IF NOT (MOUSE.B1% AND NOT MOUSE.OLD_B1%) THEN EXIT SUB
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE >= -1 THEN EXIT SUB
    ' Only skip autocommit for user-created marquee selections (e.g. user drew a marquee
    ' then activated move). Auto-created marquees (full-layer move) should NOT block
    ' the autocommit, otherwise GUI clicks fail to commit the pending transform.
    IF MARQUEE.ACTIVE% AND MARQUEE.INITIALIZED% AND MARQUEE.USER_CREATED THEN EXIT SUB

    ' Check if click is on any GUI element (not canvas)
    DIM clickOnGUI AS INTEGER
    clickOnGUI% = FALSE
    IF LAYER_PANEL.visible% AND LAYER_PANEL_in_bounds%(rawX%, rawY%) THEN clickOnGUI% = TRUE
    IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN clickOnGUI% = TRUE
    IF SCRN.showToolbar% AND ORGANIZER_is_over_area%(rawX%, rawY%) THEN clickOnGUI% = TRUE
    IF SCRN.showStatus% AND rawY% >= (SCRN.h& - 10) THEN clickOnGUI% = TRUE
    IF SCRN.showStatus% AND PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN clickOnGUI% = TRUE
    IF SCRN.showMenubar% AND MENU_BAR.visible% AND MENUBAR_in_bounds%(rawX%, rawY%) THEN clickOnGUI% = TRUE

    IF clickOnGUI% THEN
        MOVE_apply_transform
        MOVE_reset
    END IF
END SUB


''
' Close palette menu when clicking outside its bounds.
' Returns TRUE if palette menu was closed.
'
FUNCTION MOUSE_handle_palette_menu_close% (rawX AS INTEGER, rawY AS INTEGER)
    MOUSE_handle_palette_menu_close% = FALSE
    IF NOT PALETTE_MENU_VISIBLE% THEN EXIT FUNCTION
    IF NOT (MOUSE.B1% AND NOT MOUSE.OLD_B1%) THEN EXIT FUNCTION

    IF NOT PALETTE_MENU_in_bounds%(rawX%, rawY%) THEN
        ' Check if click is NOT on the palette name trigger area (to prevent reopening)
        IF NOT PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN
            PALETTE_MENU_hide
            GUI_NEEDS_REDRAW% = TRUE
            MOUSE_handle_palette_menu_close% = TRUE
        END IF
    END IF
END FUNCTION


''
' Layer panel input handling.
' May consume wheel_delta% (sets to 0) so it doesn't propagate to canvas zoom.
'
SUB MOUSE_handle_layer_panel (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
    ' Check for layer panel clicks (only when not panning)
    IF NOT SCRN.panning% AND LAYER_PANEL.visible% THEN
        IF LAYER_PANEL_in_bounds%(rawX%, rawY%) THEN
            ' Handle left-click on layer panel
            IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                IF LAYER_PANEL_handle_click%(rawX%, rawY%, 1) THEN
                    MOUSE.TOOLBAR_CLICKED% = TRUE  ' Block canvas action
                END IF
            END IF
            ' Handle right-click on layer panel
            IF MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
                IF LAYER_PANEL_handle_click%(rawX%, rawY%, 2) THEN
                    MOUSE.TOOLBAR_CLICKED% = TRUE  ' Block canvas action
                END IF
            END IF
            ' Handle mouse wheel for scrolling layer list or adjusting opacity
            IF wheel_delta% <> 0 THEN
                LAYER_PANEL_handle_wheel rawX%, rawY%, wheel_delta%
                wheel_delta% = 0  ' Consume wheel event - don't zoom canvas
            END IF
        END IF

        ' Handle visibility swipe (takes priority over drag-reorder)
        IF LAYER_PANEL.visSwiping% THEN
            IF MOUSE.B1% THEN
                LAYER_PANEL_handle_vis_swipe rawX%, rawY%
                MOUSE.TOOLBAR_CLICKED% = TRUE
            ELSE
                LAYER_PANEL_end_vis_swipe
            END IF
        ' Handle opacity slider drag (outside panel bounds is fine - keep dragging)
        ELSEIF LAYER_PANEL.opacityDrag% THEN
            IF MOUSE.B1% THEN
                LAYER_PANEL_handle_opacity_drag rawX%
                MOUSE.TOOLBAR_CLICKED% = TRUE
            ELSE
                LAYER_PANEL.opacityDrag% = FALSE
            END IF
        ' Handle layer drag movement (even if outside panel bounds)
        ELSEIF LAYER_PANEL_is_dragging% THEN
            IF MOUSE.B1% THEN
                ' Continue dragging - update drop target
                LAYER_PANEL_handle_drag rawX%, rawY%
                MOUSE.TOOLBAR_CLICKED% = TRUE  ' Block canvas action
            ELSE
                ' Mouse button released - complete the drop
                LAYER_PANEL_handle_drop
            END IF
        END IF
    ELSEIF LAYER_PANEL.visSwiping% THEN
        ' Swipe may have moved outside panel
        IF MOUSE.B1% THEN
            LAYER_PANEL_handle_vis_swipe rawX%, rawY%
            MOUSE.TOOLBAR_CLICKED% = TRUE
        ELSE
            LAYER_PANEL_end_vis_swipe
        END IF
    ELSEIF LAYER_PANEL.opacityDrag% THEN
        ' Opacity drag may continue outside panel
        IF MOUSE.B1% THEN
            LAYER_PANEL_handle_opacity_drag rawX%
            MOUSE.TOOLBAR_CLICKED% = TRUE
        ELSE
            LAYER_PANEL.opacityDrag% = FALSE
        END IF
    ELSEIF LAYER_PANEL_is_dragging% THEN
        ' Layer drag may have moved outside panel - still need to handle
        IF MOUSE.B1% THEN
            LAYER_PANEL_handle_drag rawX%, rawY%
            MOUSE.TOOLBAR_CLICKED% = TRUE
        ELSE
            LAYER_PANEL_handle_drop
        END IF
    END IF
END SUB


''
' Toolbar/status/palette click handling.
'
SUB MOUSE_handle_toolbar_status_palette (rawX AS INTEGER, rawY AS INTEGER)
    ' Check for toolbar clicks (only when not panning)
    IF NOT SCRN.panning% AND MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
        ' Check if clicking on toolbar area (raw screen coordinates)
        IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN
            DIM tbClicked AS INTEGER
            tbClicked% = TOOLBAR_handle_click%(rawX%, rawY%)  ' Try to activate a button
            MOUSE.TOOLBAR_CLICKED% = TRUE  ' Always block canvas actions over toolbar area
        END IF
        ' Check if clicking on organizer area (beneath toolbar)
        IF SCRN.showToolbar% AND ORGANIZER_is_over_area%(rawX%, rawY%) THEN
            IF ORGANIZER_handle_click%(rawX%, rawY%) THEN
                MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
            END IF
        END IF
        ' Check if clicking on status bar area (bottom of screen)
        IF SCRN.showStatus% AND rawY% >= (SCRN.h& - 10) THEN
            STATUS_handle_click rawX%, rawY%
            MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
        END IF
        ' Check if clicking on palette strip area (above status bar) or menu
        IF SCRN.showStatus% AND (PALETTE_STRIP_in_bounds%(rawX%, rawY%) OR PALETTE_MENU_in_bounds%(rawX%, rawY%)) THEN
            PALETTE_STRIP_handle_click rawX%, rawY%
            MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
        END IF
    END IF

    ' Check for right-click on palette strip (for background color)
    IF NOT SCRN.panning% AND MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
        IF SCRN.showStatus% AND PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN
            PALETTE_STRIP_handle_click rawX%, rawY%
            MOUSE.TOOLBAR_CLICKED% = TRUE
        END IF
    END IF

    ' Check for right-click on toolbar (for alternate tool modes)
    IF NOT SCRN.panning% AND MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
        IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN
            TOOLBAR_handle_right_click rawX%, rawY%
            MOUSE.TOOLBAR_CLICKED% = TRUE  ' Block canvas actions over toolbar area
        END IF
        ' Check for right-click on organizer
        IF SCRN.showToolbar% AND ORGANIZER_is_over_area%(rawX%, rawY%) THEN
            IF ORGANIZER_handle_right_click%(rawX%, rawY%) THEN
                MOUSE.TOOLBAR_CLICKED% = TRUE
            END IF
        END IF
    END IF

    ' Check for middle-click on toolbar (for custom font loading on text tool)
    IF NOT SCRN.panning% AND MOUSE.B3% AND NOT MOUSE.OLD_B3% THEN
        IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN
            TOOLBAR_handle_middle_click rawX%, rawY%
            MOUSE.TOOLBAR_CLICKED% = TRUE  ' Block canvas actions over toolbar area
        END IF
        ' Check for middle-click on organizer (crop tool)
        IF SCRN.showToolbar% AND ORGANIZER_is_over_area%(rawX%, rawY%) THEN
            IF ORGANIZER_handle_middle_click%(rawX%, rawY%) THEN
                MOUSE.TOOLBAR_CLICKED% = TRUE
            END IF
        END IF
    END IF
END SUB


''
' Double middle-click (B3) to reset zoom and position.
'
SUB MOUSE_handle_b3_dblclick_reset_zoom ()
    IF MOUSE.B3% AND NOT MOUSE.OLD_B3% THEN
        DIM clickTime AS DOUBLE
        clickTime# = TIMER
        IF clickTime# - MOUSE.B3_CLICK_TIME# < 0.3 THEN ' 300ms double-click threshold
            ' Double-click detected - reset zoom and position
            SCRN.zoom! = 1.0
            SCRN.offsetX% = 0
            SCRN.offsetY% = 0
            MOUSE.B3_CLICK_TIME# = 0 ' Reset to prevent triple-click triggering
        ELSE
            MOUSE.B3_CLICK_TIME# = clickTime#
        END IF
    END IF
END SUB


''
' Auto-hide UI while actively drawing; restore after release.
'
SUB MOUSE_handle_ui_autohide_restore (rawX AS INTEGER, rawY AS INTEGER)
    ' Auto-hide UI when actively dragging with a tool (not when clicking toolbar)
    ' Only hide when button was already down (OLD_B1%) and we're not clicking on UI
    ' Skip auto-hide for NULL tool - let user freely access toolbar/status
    ' Also check shape tools that are in "drawing" state (LINE, RECT, ELLIPSE, POLY_LINE)
    DIM shapeToolDrawing AS INTEGER
    shapeToolDrawing% = LINE_TOOL.DRAGGING OR RECT_TOOL.DRAGGING OR ELLIPSE_TOOL.DRAGGING OR POLY_LINE.HAS_LAST

    DIM activelyDrawing AS INTEGER
    activelyDrawing% = ((MOUSE.B1% AND MOUSE.OLD_B1%) OR (MOUSE.B2% AND MOUSE.OLD_B2%)) OR shapeToolDrawing%

    IF CURRENT_TOOL% <> TOOL_NULL AND activelyDrawing% AND NOT SCRN.panning% AND NOT MOUSE.TOOLBAR_CLICKED% THEN
        ' Check if mouse is over an actual toolbar button or organizer (not empty toolbar area)
        IF SCRN.showToolbar% AND (TOOLBAR_is_over_button%(rawX%, rawY%) OR ORGANIZER_is_over_area%(rawX%, rawY%)) THEN
            SCRN.showToolbar% = FALSE
            SCRN.toolbarManuallyHidden% = FALSE ' This is auto-hide, not manual
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
        END IF
        ' Check if mouse is over status bar/palette strip while drawing
        IF SCRN.showStatus% THEN
            DIM autoHideStripTop AS INTEGER
            autoHideStripTop% = SCRN.h& - THEME.STATUS_height% - PALETTE_STRIP_get_height%
            IF rawY% >= autoHideStripTop% THEN
                SCRN.showStatus% = FALSE
                SCRN.statusManuallyHidden% = FALSE ' This is auto-hide, not manual
                GUI_NEEDS_REDRAW% = TRUE
                SCENE_DIRTY% = TRUE
            END IF
        END IF
        ' Check if mouse is over menu bar while drawing
        IF SCRN.showMenubar% AND MENU_BAR.visible% THEN
            IF rawY% < MENU_BAR_HEIGHT AND rawX% >= MENU_BAR.barX% THEN
                SCRN.showMenubar% = FALSE
                MENU_BAR.visible% = FALSE
                SCRN.menubarManuallyHidden% = FALSE
                MENUBAR_close_all
                GUI_NEEDS_REDRAW% = TRUE
                SCENE_DIRTY% = TRUE
            END IF
        END IF
        ' Check if mouse is over layer panel while drawing
        IF LAYER_PANEL.visible% THEN
            IF rawX% < CFG.LAYER_PANEL_WIDTH% THEN
                LAYER_PANEL.visible% = FALSE
                SCRN.layerPanelManuallyHidden% = FALSE ' This is auto-hide, not manual
                GUI_NEEDS_REDRAW% = TRUE
                SCENE_DIRTY% = TRUE
            END IF
        END IF
    END IF

    ' Restore UI when mouse is released (only if auto-hidden, not manually hidden)
    ' For shape tools, also check that they're no longer in drawing state
    DIM canRestoreUI AS INTEGER
    canRestoreUI% = NOT MOUSE.B1% AND NOT shapeToolDrawing%

    IF canRestoreUI% THEN
        DIM uiRestored AS INTEGER
        uiRestored% = FALSE
        ' Restore toolbar if it was auto-hidden (not manually hidden by user)
        IF NOT SCRN.showToolbar% AND NOT SCRN.toolbarManuallyHidden% THEN
            SCRN.showToolbar% = TRUE
            uiRestored% = TRUE
        END IF
        ' Restore status bar if it was auto-hidden (not manually hidden by user)
        IF NOT SCRN.showStatus% AND NOT SCRN.statusManuallyHidden% THEN
            SCRN.showStatus% = TRUE
            uiRestored% = TRUE
        END IF
        ' Restore menu bar if it was auto-hidden (not manually hidden by user)
        IF NOT SCRN.showMenubar% AND NOT SCRN.menubarManuallyHidden% THEN
            SCRN.showMenubar% = TRUE
            MENU_BAR.visible% = TRUE
            uiRestored% = TRUE
        END IF
        ' Restore layer panel if it was auto-hidden (not manually hidden by user)
        IF NOT LAYER_PANEL.visible% AND NOT SCRN.layerPanelManuallyHidden% THEN
            LAYER_PANEL.visible% = TRUE
            uiRestored% = TRUE
        END IF
        IF uiRestored% THEN
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
        END IF
    END IF
END SUB


''
' Pan mode (spacebar + LMB OR MMB OR PAN tool + LMB).
'
SUB MOUSE_handle_panning (rawX AS INTEGER, rawY AS INTEGER)
    ' Block spacebar pan when text tool is active (SPACE needed for typing)
    DIM allowSpacePan AS INTEGER
    allowSpacePan% = NOT (CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE)

    DIM panToolActive AS INTEGER
    panToolActive% = (CURRENT_TOOL% = TOOL_PAN AND MOUSE.B1%)

    ' Block MMB pan initiation when mouse is over any GUI element
    DIM allowB3Pan AS INTEGER
    allowB3Pan% = MOUSE.B3%
    IF allowB3Pan% AND NOT SCRN.panning% THEN
        ' Only block on pan START (not while already panning)
        IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN allowB3Pan% = FALSE
        IF SCRN.showToolbar% AND ORGANIZER_is_over_area%(rawX%, rawY%) THEN allowB3Pan% = FALSE
        IF LAYER_PANEL.visible% AND LAYER_PANEL_in_bounds%(rawX%, rawY%) THEN allowB3Pan% = FALSE
        IF SCRN.showStatus% AND rawY% >= (SCRN.h& - THEME.STATUS_height%) THEN allowB3Pan% = FALSE
        IF SCRN.showStatus% AND PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN allowB3Pan% = FALSE
        IF SCRN.showMenubar% AND MENU_BAR.visible% AND MENUBAR_in_bounds%(rawX%, rawY%) THEN allowB3Pan% = FALSE
    END IF

    IF ((_KEYDOWN(32) AND allowSpacePan%) AND MOUSE.B1%) OR allowB3Pan% OR panToolActive% THEN ' Spacebar+LMB or MMB or PAN tool+LMB
        IF NOT SCRN.panning% THEN
            ' Start panning
            SCRN.panning% = TRUE
            SCRN.panStartX% = rawX%
            SCRN.panStartY% = rawY%
            SCRN.panOrigOffsetX% = SCRN.offsetX%
            SCRN.panOrigOffsetY% = SCRN.offsetY%
        ELSE
            ' Continue dragging
            SCRN.offsetX% = SCRN.panOrigOffsetX% + (rawX% - SCRN.panStartX%)
            SCRN.offsetY% = SCRN.panOrigOffsetY% + (rawY% - SCRN.panStartY%)

            ' If spacebar mode: reset on new button press
            IF _KEYDOWN(32) AND MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                SCRN.panStartX% = rawX%
                SCRN.panStartY% = rawY%
                SCRN.panOrigOffsetX% = SCRN.offsetX%
                SCRN.panOrigOffsetY% = SCRN.offsetY%
            END IF
        END IF
    ELSE
        ' Exit pan mode when both methods released
        IF SCRN.panning% THEN SCRN.panning% = FALSE
    END IF
END SUB


''
' Tool handler: Fill.
'
SUB MOUSE_tool_fill ()
    ' Flood fill on click (only on button press, not while held)
    ' Use unsnapped coordinates so grid snap doesn't affect fill behavior
    IF FILL.ACTIVE% AND ((MOUSE.B1% AND NOT MOUSE.OLD_B1%) OR (MOUSE.B2% AND NOT MOUSE.OLD_B2%)) AND NOT UNDO_saved_this_frame% THEN
        UNDO_saved_this_frame% = TRUE
        FILL.COLOR~& = DRAW_COLOR~&
        STROKE_begin
        ' Grid cell fill mode: when enabled and grid visible, fill the grid cell
        IF GRID.CELL_FILL% AND GRID.SHOW% THEN
            GRID_fill_cell MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%, FILL.COLOR~&
            ' Also fill symmetry-mirrored cells
            IF SYMMETRY.MODE% > 0 THEN
                DIM gfc_mx(7) AS INTEGER, gfc_my(7) AS INTEGER, gfc_count AS INTEGER
                SYMMETRY_get_mirrored_points MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%, gfc_mx%(), gfc_my%(), gfc_count%
                DIM gfc_i AS INTEGER
                FOR gfc_i% = 0 TO gfc_count% - 1
                    GRID_fill_cell gfc_mx%(gfc_i%), gfc_my%(gfc_i%), FILL.COLOR~&
                NEXT gfc_i%
            END IF
        ELSE
            FILL_flood MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
        END IF
        STROKE_commit
        UNDO_save_state ' Save state after fill
    END IF
END SUB


''
' Tool handler: Picker.
'
SUB MOUSE_tool_picker ()
    ' Pick color on click (only on button press, not while held)
    ' Use unsnapped coordinates so grid snap doesn't affect color picking
    IF PICKER.ACTIVE% AND NOT MOUSE.OLD_B1% THEN
        PICKER_pick_color MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%, 1 ' 1 = left button/foreground
    END IF
END SUB


''
' Tool handler: Save.
'
SUB MOUSE_tool_save ()
    ' SAVE tool: Defer save dialog to avoid calling from within mouse loop
    IF NOT MOUSE.OLD_B1% THEN
        MOUSE.DEFERRED_ACTION% = 1 ' 1 = save
        ' Return to previous tool after save is triggered
        CURRENT_TOOL% = PREVIOUS_TOOL%
        GUI_NEEDS_REDRAW% = TRUE
    END IF
END SUB


''
' Tool handler: Open.
'
SUB MOUSE_tool_open ()
    ' LOAD tool: Defer load dialog to avoid calling from within mouse loop
    IF NOT MOUSE.OLD_B1% THEN
        MOUSE.DEFERRED_ACTION% = 2 ' 2 = load
        ' Return to previous tool after load is triggered
        CURRENT_TOOL% = PREVIOUS_TOOL%
        GUI_NEEDS_REDRAW% = TRUE
    END IF
END SUB


''
' Tool handler: Text.
'
SUB MOUSE_tool_text ()
    ' TEXT tool: Click to start or reposition text entry
    IF NOT MOUSE.OLD_B1% THEN
        TEXT_start MOUSE.X%, MOUSE.Y%
    END IF
END SUB


''
' Tool handler: Marquee (all selection variants).
'
SUB MOUSE_tool_marquee ()
    ' Determine selection mode based on modifiers (shared by all variants)
    DIM selMode AS INTEGER
    DIM selIsShift AS INTEGER, selIsAlt AS INTEGER
    selIsShift% = MODIFIERS.shift%
    selIsAlt% = MODIFIERS.alt%
    IF selIsShift% THEN
        selMode% = SEL_MODE_ADD
    ELSEIF selIsAlt% THEN
        selMode% = SEL_MODE_SUBTRACT
    ELSE
        selMode% = SEL_MODE_REPLACE
    END IF

    SELECT CASE MARQUEE.VARIANT
        ' ----------------------------------------------------------------
        ' Magic Wand: single-click flood fill color match
        ' ----------------------------------------------------------------
        CASE TOOL_SELECT_WAND
            IF NOT MOUSE.OLD_B1% THEN
                MAGIC_WAND_select_with_mode MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%, selMode%
                GUI_NEEDS_REDRAW% = TRUE
            END IF

        ' ----------------------------------------------------------------
        ' Freehand (lasso): drag to draw freeform selection outline
        ' ----------------------------------------------------------------
        CASE TOOL_SELECT_FREE
            IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                ' Fresh press - start freehand selection
                MARQUEE.SELECTION_MODE = selMode%
                FREEHAND_SEL_start MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
            ELSEIF MOUSE.B1% THEN
                ' Dragging - add points
                IF MARQUEE.FREE_DRAWING THEN
                    FREEHAND_SEL_update MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
                END IF
            END IF

        ' ----------------------------------------------------------------
        ' Polygon: click to add vertices, close to finish
        ' ----------------------------------------------------------------
        CASE TOOL_SELECT_POLY
            IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                ' Fresh click - add vertex to polygon
                IF NOT MARQUEE.POLY_DRAWING THEN
                    MARQUEE.SELECTION_MODE = selMode%
                END IF
                POLY_SEL_add_point MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
            END IF

        ' ----------------------------------------------------------------
        ' Ellipse: drag to define bounding box for ellipse selection
        ' ----------------------------------------------------------------
        CASE TOOL_SELECT_ELLIPSE
            IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                ' Fresh press - start ellipse selection
                MARQUEE.SELECTION_MODE = selMode%
                ELLIPSE_SEL_start MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
            ELSEIF MOUSE.B1% THEN
                ' Dragging - update end point
                IF MARQUEE.ELLIP_DRAGGING THEN
                    ELLIPSE_SEL_update MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
                END IF
            END IF

        ' ----------------------------------------------------------------
        ' Rectangle: the original marquee selection (drag box)
        ' ----------------------------------------------------------------
        CASE ELSE ' TOOL_SELECT_RECT or default
            IF NOT MOUSE.OLD_B1% THEN
                MARQUEE.SELECTION_MODE = selMode%

                ' In add/subtract mode, always start a new marquee drag
                ' (don't allow move/resize - those only work in replace mode)
                IF MARQUEE.SELECTION_MODE <> SEL_MODE_REPLACE THEN
                    MARQUEE_start MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
                ELSE
                    ' Replace mode: Check if clicking on a handle or inside selection
                    DIM handle AS INTEGER
                    handle% = MARQUEE_get_handle_at%(MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%)
                    IF handle% > 0 THEN
                        MARQUEE_start_resize handle%, MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
                    ELSEIF MARQUEE_is_point_inside%(MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%) THEN
                        MARQUEE_start_move MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
                    ELSE
                        MARQUEE_start MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
                    END IF
                END IF
            END IF
            ' Update resize, move, or drag position while button is held
            IF MARQUEE.RESIZING% THEN
                IF MODIFIERS.shift% THEN
                    DIM marqResX AS INTEGER, marqResY AS INTEGER
                    marqResX% = MOUSE.UNSNAPPED_X% : marqResY% = MOUSE.UNSNAPPED_Y%
                    DIM savedSnapR AS INTEGER : savedSnapR% = GRID.SNAP%
                    GRID.SNAP% = TRUE
                    GRID_snap_xy marqResX%, marqResY%
                    GRID.SNAP% = savedSnapR%
                    MARQUEE_update_resize marqResX%, marqResY%
                ELSE
                    MARQUEE_update_resize MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
                END IF
            ELSEIF MARQUEE.MOVING% THEN
                IF MODIFIERS.shift% THEN
                    DIM marqMovX AS INTEGER, marqMovY AS INTEGER
                    marqMovX% = MOUSE.UNSNAPPED_X% : marqMovY% = MOUSE.UNSNAPPED_Y%
                    DIM savedSnapM AS INTEGER : savedSnapM% = GRID.SNAP%
                    GRID.SNAP% = TRUE
                    GRID_snap_xy marqMovX%, marqMovY%
                    GRID.SNAP% = savedSnapM%
                    MARQUEE_update_move marqMovX%, marqMovY%
                ELSE
                    MARQUEE_update_move MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
                END IF
            ELSE
                IF MODIFIERS.shift% AND MARQUEE.SELECTION_MODE = SEL_MODE_REPLACE THEN
                    DIM marqDrgX AS INTEGER, marqDrgY AS INTEGER
                    marqDrgX% = MOUSE.UNSNAPPED_X% : marqDrgY% = MOUSE.UNSNAPPED_Y%
                    DIM savedSnapD AS INTEGER : savedSnapD% = GRID.SNAP%
                    GRID.SNAP% = TRUE
                    GRID_snap_xy marqDrgX%, marqDrgY%
                    GRID.SNAP% = savedSnapD%
                    MARQUEE_update marqDrgX%, marqDrgY%
                ELSE
                    MARQUEE_update MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
                END IF
            END IF
    END SELECT
END SUB


''
' Tool handler: Move.
'
SUB MOUSE_tool_move ()
    ' MOVE tool: Transform the selected pixels
    IF MOVE.ACTIVE THEN
        ' Check ALT state for clone mode
        DIM moveIsAlt AS INTEGER
        moveIsAlt% = MODIFIERS.alt%
        MOVE.CLONING = moveIsAlt%

        IF NOT MOUSE.OLD_B1% THEN
            ' Fresh click - start a drag/transform
            ' Check if clicking on a handle or inside selection
            DIM move_handle AS INTEGER
            DIM marquee_handle AS INTEGER
            marquee_handle% = MARQUEE_get_handle_at%(MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%)
            IF marquee_handle% > 0 THEN
                ' Remap MARQUEE handle to MOVE handle numbering:
                ' MARQUEE: 1=TL, 2=T, 3=TR, 4=L, 5=R, 6=BL, 7=B, 8=BR
                ' MOVE:    1=TL, 2=TR, 3=BR, 4=BL, 5=T, 6=R, 7=B, 8=L
                SELECT CASE marquee_handle%
                    CASE 1: move_handle% = 1 ' TL corner
                    CASE 3: move_handle% = 2 ' TR corner
                    CASE 8: move_handle% = 3 ' BR corner
                    CASE 6: move_handle% = 4 ' BL corner
                    CASE 2: move_handle% = 5 ' T edge
                    CASE 5: move_handle% = 6 ' R edge
                    CASE 7: move_handle% = 7 ' B edge
                    CASE 4: move_handle% = 8 ' L edge
                END SELECT
                ' Start resizing/scaling from this handle
                MOVE_start_transform move_handle%, MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
            ELSEIF MARQUEE_is_point_inside%(MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%) THEN
                ' Start moving from center (handle 0)
                MOVE_start_transform 0, MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
            ELSE
                ' Clicking outside the selection commits the move (standard UX pattern
                ' matching Photoshop, GIMP, Krita). Without this, the transform stays
                ' floating indefinitely and no undo state is created until tool switch.
                MOVE_apply_transform
                MOVE_reset
                ' Now start a fresh capture at the clicked position so user can
                ' immediately begin a new move operation
                MOVE_capture_selection
                MOVE_start_transform 0, MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
            END IF
        ELSE
            ' Update transform while dragging
            IF MOVE.TRANSFORMING THEN
                MOVE_update_transform MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
            END IF
        END IF
    ELSE
        ' MOVE tool is selected but not active - capture selection on click
        IF NOT MOUSE.OLD_B1% THEN
            ' Fresh click - capture the layer (or marquee if active) and start move
            MOVE_capture_selection
            ' Immediately start a move transform from this click position
            MOVE_start_transform 0, MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%
        END IF
    END IF
END SUB


''
' Tool handler: Line.
'
SUB MOUSE_tool_line ()
    ' LINE tool: Click and drag with preview
    IF (MOUSE.B1% AND NOT MOUSE.OLD_B1%) OR (MOUSE.B2% AND NOT MOUSE.OLD_B2%) THEN
        ' Start dragging on first click
        STROKE_begin
        LINE_TOOL.DRAGGING = TRUE
        ' Use unsnapped coords when Ctrl+Shift held so angle snap overrides grid snap
        IF MODIFIERS.ctrlShift% THEN
            LINE_TOOL.START_X = MOUSE.UNSNAPPED_X%
            LINE_TOOL.START_Y = MOUSE.UNSNAPPED_Y%
            LINE_TOOL.END_X = MOUSE.UNSNAPPED_X%
            LINE_TOOL.END_Y = MOUSE.UNSNAPPED_Y%
        ELSE
            LINE_TOOL.START_X = MOUSE.X%
            LINE_TOOL.START_Y = MOUSE.Y%
            LINE_TOOL.END_X = MOUSE.X%
            LINE_TOOL.END_Y = MOUSE.Y%
        END IF
    ELSEIF LINE_TOOL.DRAGGING THEN
        ' Update end position while dragging
        IF MODIFIERS.ctrlShift% THEN
            ' Use unsnapped coords so angle snap overrides grid snap
            LINE_TOOL.END_X = MOUSE.UNSNAPPED_X%
            LINE_TOOL.END_Y = MOUSE.UNSNAPPED_Y%
            SNAP_to_angle LINE_TOOL.START_X, LINE_TOOL.START_Y, LINE_TOOL.END_X, LINE_TOOL.END_Y, CFG.ANGLE_SNAP_DEGREES%
        ELSE
            LINE_TOOL.END_X = MOUSE.X%
            LINE_TOOL.END_Y = MOUSE.Y%
        END IF
    END IF
END SUB


''
' Tool handler: Polygon/Polygon filled.
'
SUB MOUSE_tool_poly ()
    ' POLY_LINE tool: Click to click connected lines (B1 only — B2 finishes via right-click handler)
    ' On macOS, Ctrl+Click is mapped to right-click (B2) by the OS. When the user holds
    ' Ctrl+Shift for angle snapping and clicks, we get B2 instead of B1. Detect this
    ' and treat it as a normal point placement.
    DIM poly_b1_pressed AS INTEGER
    poly_b1_pressed% = (MOUSE.B1% AND NOT MOUSE.OLD_B1%)
    $IF MAC THEN
        ' macOS Ctrl+Click = B2. When Ctrl+Shift is held (angle snap), treat B2 as B1.
        IF MODIFIERS.ctrlShift% AND (MOUSE.B2% AND NOT MOUSE.OLD_B2%) THEN
            poly_b1_pressed% = TRUE
        END IF
    $END IF
    IF poly_b1_pressed% THEN
        DIM poly_x AS INTEGER, poly_y AS INTEGER
        ' Use unsnapped coords when Ctrl+Shift held so angle snap overrides grid snap
        IF MODIFIERS.ctrlShift% THEN
            poly_x% = MOUSE.UNSNAPPED_X%
            poly_y% = MOUSE.UNSNAPPED_Y%
        ELSE
            poly_x% = MOUSE.X%
            poly_y% = MOUSE.Y%
        END IF

        ' Apply angle snapping if Ctrl+Shift are both held and we have a previous point
        IF POLY_LINE.HAS_LAST AND MODIFIERS.ctrlShift% THEN
            SNAP_to_angle POLY_LINE.LAST_X, POLY_LINE.LAST_Y, poly_x%, poly_y%, CFG.ANGLE_SNAP_DEGREES%
        END IF

        IF POLY_LINE.HAS_LAST THEN
            ' Draw line from last position to current (snapped) position
            ' Note: Undo is saved only when starting the polygon, not for each segment
            DIM poly_target AS LONG
            DIM poly_is_transparent AS INTEGER
            poly_target& = LAYER_current_image&
            _DEST poly_target&

            ' Check if drawing with transparent color
            poly_is_transparent% = (_ALPHA32(PAINT_COLOR~&) = 0)
            IF poly_is_transparent% THEN _DONTBLEND poly_target&

            IF CUSTOM_BRUSH_is_active% THEN
                ' Use custom brush stamps along polygon edges
                CUSTOM_BRUSH_stamp_line POLY_LINE.LAST_X, POLY_LINE.LAST_Y, poly_x%, poly_y%
            ELSEIF BRUSH_SIZE_pixels% > 1 THEN
                ' Thick brush line - stamp brush shapes along the path
                LINE_draw_brushed POLY_LINE.LAST_X, POLY_LINE.LAST_Y, poly_x%, poly_y%, PAINT_COLOR~&
            ELSEIF SELECTION_has_active% OR LAYERS(CURRENT_LAYER%).opacityLock% THEN
                ' Use clipped line drawing when selection is active or opacity lock is on
                LINE_draw_clipped POLY_LINE.LAST_X, POLY_LINE.LAST_Y, poly_x%, poly_y%, PAINT_COLOR~&
            ELSE
                ' Normal line drawing
                LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y)-(poly_x%, poly_y%), PAINT_COLOR~&
            END IF

            IF poly_is_transparent% THEN _BLEND poly_target&
            _DEST SCRN.CANVAS&
            CANVAS_DIRTY% = TRUE
        ELSE
            ' First point - save undo state NOW so the pixel undo timestamp
            ' is newer than any prior workspace undo (e.g. layer add).
            ' Without this, CTRL+Z during multi-click polygon drawing would
            ' see a stale pixel timestamp and route to workspace undo instead,
            ' removing the layer instead of undoing the polyline.
            IF NOT UNDO_saved_this_frame% THEN
                UNDO_save_state
                UNDO_saved_this_frame% = TRUE
            END IF
            STROKE_begin
            POLY_LINE.FIRST_X = poly_x%
            POLY_LINE.FIRST_Y = poly_y%
            POLY_LINE.POINT_COUNT = 0
        END IF
        ' Store this point in the array
        IF POLY_LINE.POINT_COUNT < 1000 THEN
            POLY_POINTS_X(POLY_LINE.POINT_COUNT) = poly_x%
            POLY_POINTS_Y(POLY_LINE.POINT_COUNT) = poly_y%
            POLY_LINE.POINT_COUNT = POLY_LINE.POINT_COUNT + 1
        END IF
        ' Update last position to current (snapped) click
        POLY_LINE.LAST_X = poly_x%
        POLY_LINE.LAST_Y = poly_y%
        POLY_LINE.HAS_LAST = TRUE
    END IF
END SUB


''
' Tool handler: Rect/Rect filled.
'
SUB MOUSE_tool_rect ()
    ' RECT tool: Click and drag with preview
    IF (MOUSE.B1% AND NOT MOUSE.OLD_B1%) OR (MOUSE.B2% AND NOT MOUSE.OLD_B2%) THEN
        ' Start dragging on first click
        STROKE_begin
        RECT_TOOL.DRAGGING = TRUE
        RECT_TOOL.START_X = MOUSE.X%
        RECT_TOOL.START_Y = MOUSE.Y%
        RECT_TOOL.CENTER_X = MOUSE.X%
        RECT_TOOL.CENTER_Y = MOUSE.Y%
        RECT_TOOL.END_X = MOUSE.X%
        RECT_TOOL.END_Y = MOUSE.Y%
        RECT_TOOL.FILLED = (CURRENT_TOOL% = TOOL_RECT_FILLED)
    ELSEIF RECT_TOOL.DRAGGING THEN
        ' Update end position while dragging
        DIM temp_end_x AS INTEGER, temp_end_y AS INTEGER
        temp_end_x% = MOUSE.X%
        temp_end_y% = MOUSE.Y%

        ' SHIFT: Constrain to square (calculate from center)
        IF MODIFIERS.shift% THEN
            DIM size AS INTEGER
            size% = INT(SQR((temp_end_x% - RECT_TOOL.CENTER_X) ^ 2 + (temp_end_y% - RECT_TOOL.CENTER_Y) ^ 2))
            IF temp_end_x% < RECT_TOOL.CENTER_X THEN size% = -size%
            temp_end_x% = RECT_TOOL.CENTER_X + size%
            temp_end_y% = RECT_TOOL.CENTER_Y + size%
        END IF

        ' CTRL: Draw from center
        IF MODIFIERS.ctrl% THEN
            DIM offset_x AS INTEGER, offset_y AS INTEGER
            ' Calculate offset from center to mouse
            offset_x% = temp_end_x% - RECT_TOOL.CENTER_X
            offset_y% = temp_end_y% - RECT_TOOL.CENTER_Y
            ' Set corners mirrored around center
            RECT_TOOL.START_X = RECT_TOOL.CENTER_X - offset_x%
            RECT_TOOL.START_Y = RECT_TOOL.CENTER_Y - offset_y%
            RECT_TOOL.END_X = RECT_TOOL.CENTER_X + offset_x%
            RECT_TOOL.END_Y = RECT_TOOL.CENTER_Y + offset_y%
        ELSE
            ' Normal mode: draw from corner
            RECT_TOOL.START_X = RECT_TOOL.CENTER_X
            RECT_TOOL.START_Y = RECT_TOOL.CENTER_Y
            RECT_TOOL.END_X = temp_end_x%
            RECT_TOOL.END_Y = temp_end_y%
        END IF
    END IF
END SUB


''
' Tool handler: Ellipse/Ellipse filled.
'
SUB MOUSE_tool_ellip ()
    ' ELLIPSE tool: Click and drag with preview
    IF (MOUSE.B1% AND NOT MOUSE.OLD_B1%) OR (MOUSE.B2% AND NOT MOUSE.OLD_B2%) THEN
        ' Start dragging on first click
        STROKE_begin
        ELLIPSE_TOOL.DRAGGING = TRUE
        ELLIPSE_TOOL.START_X = MOUSE.X%
        ELLIPSE_TOOL.START_Y = MOUSE.Y%
        ELLIPSE_TOOL.CENTER_X = MOUSE.X%
        ELLIPSE_TOOL.CENTER_Y = MOUSE.Y%
        ELLIPSE_TOOL.END_X = MOUSE.X%
        ELLIPSE_TOOL.END_Y = MOUSE.Y%
        ELLIPSE_TOOL.FILLED = (CURRENT_TOOL% = TOOL_ELLIPSE_FILLED)
    ELSEIF ELLIPSE_TOOL.DRAGGING THEN
        ' Update end position while dragging
        DIM temp_ex AS INTEGER, temp_ey AS INTEGER
        temp_ex% = MOUSE.X%
        temp_ey% = MOUSE.Y%

        ' SHIFT: Constrain to circle (calculate from center)
        IF MODIFIERS.shift% THEN
            DIM esize AS INTEGER
            esize% = INT(SQR((temp_ex% - ELLIPSE_TOOL.CENTER_X) ^ 2 + (temp_ey% - ELLIPSE_TOOL.CENTER_Y) ^ 2))
            IF temp_ex% < ELLIPSE_TOOL.CENTER_X THEN esize% = -esize%
            temp_ex% = ELLIPSE_TOOL.CENTER_X + esize%
            temp_ey% = ELLIPSE_TOOL.CENTER_Y + esize%
        END IF

        ' CTRL: Draw from center
        IF MODIFIERS.ctrl% THEN
            DIM eoffset_x AS INTEGER, eoffset_y AS INTEGER
            ' Calculate offset from center to mouse
            eoffset_x% = temp_ex% - ELLIPSE_TOOL.CENTER_X
            eoffset_y% = temp_ey% - ELLIPSE_TOOL.CENTER_Y
            ' Set corners mirrored around center
            ELLIPSE_TOOL.START_X = ELLIPSE_TOOL.CENTER_X - eoffset_x%
            ELLIPSE_TOOL.START_Y = ELLIPSE_TOOL.CENTER_Y - eoffset_y%
            ELLIPSE_TOOL.END_X = ELLIPSE_TOOL.CENTER_X + eoffset_x%
            ELLIPSE_TOOL.END_Y = ELLIPSE_TOOL.CENTER_Y + eoffset_y%
        ELSE
            ' Normal mode: draw from corner
            ELLIPSE_TOOL.START_X = ELLIPSE_TOOL.CENTER_X
            ELLIPSE_TOOL.START_Y = ELLIPSE_TOOL.CENTER_Y
            ELLIPSE_TOOL.END_X = temp_ex%
            ELLIPSE_TOOL.END_Y = temp_ey%
        END IF
    END IF
END SUB


''
' Tool handler: Brush.
'
SUB MOUSE_tool_brush ()
    ' Reset pixel-perfect stroke on first mouse down
    IF (MOUSE.B1% AND NOT MOUSE.OLD_B1%) OR (MOUSE.B2% AND NOT MOUSE.OLD_B2% AND NOT MODIFIERS.shift%) THEN
        IF PP_BACKUP& < -1 THEN _FREEIMAGE PP_BACKUP&: PP_BACKUP& = 0
        PP_STROKE_COUNT% = 0
        STROKE_begin
    END IF
    ' Draw while LEFT or RIGHT button is held
    ' Right-click with SHIFT is for connecting lines, handled separately in MOUSE_handle_right_click
    IF MOUSE.B1% OR (MOUSE.B2% AND NOT MODIFIERS.shift%) THEN
        IF MOUSE.X% < MOUSE.OLD_X% THEN MOUSE.DRAG$ = "L"
        IF MOUSE.X% > MOUSE.OLD_X% THEN MOUSE.DRAG$ = "R"
        IF MOUSE.Y% < MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "U"
        IF MOUSE.Y% > MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "D"
        PAINT_on
    END IF
END SUB


''
' Tool handler: Dot.
'
SUB MOUSE_tool_dot ()
    ' DOT stamps a single point on initial click only (no drag)
    IF (MOUSE.B1% AND NOT MOUSE.OLD_B1%) OR (MOUSE.B2% AND NOT MOUSE.OLD_B2% AND NOT MODIFIERS.shift%) THEN
        IF PP_BACKUP& < -1 THEN _FREEIMAGE PP_BACKUP&: PP_BACKUP& = 0
        PP_STROKE_COUNT% = 0
        STROKE_begin
        ' Set old position to current to prevent line interpolation
        MOUSE.OLD_X% = MOUSE.X%
        MOUSE.OLD_Y% = MOUSE.Y%
        PAINT_on
    END IF
END SUB


''
' Tool handler: Spray.
'
SUB MOUSE_tool_spray ()
    ' Spray paint on left mouse button hold
    IF MOUSE.B1% THEN
        ' Begin stroke on first press (for opacity compositing)
        IF NOT MOUSE.OLD_B1% THEN
            STROKE_begin
        END IF
        ' Track drag direction for SHIFT axis constraint
        IF MOUSE.X% < MOUSE.OLD_X% THEN MOUSE.DRAG$ = "L"
        IF MOUSE.X% > MOUSE.OLD_X% THEN MOUSE.DRAG$ = "R"
        IF MOUSE.Y% < MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "U"
        IF MOUSE.Y% > MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "D"
        SPRAY.ACTIVE = TRUE
        ' Apply axis constraint if active
        DIM sprayX AS INTEGER, sprayY AS INTEGER
        IF CONSTRAIN_X% THEN
            sprayX% = MOUSE.CON_X%: sprayY% = MOUSE.Y%
        ELSEIF CONSTRAIN_Y% THEN
            sprayX% = MOUSE.X%: sprayY% = MOUSE.CON_Y%
        ELSE
            sprayX% = MOUSE.X%: sprayY% = MOUSE.Y%
        END IF
        SPRAY_on sprayX%, sprayY%, DRAW_COLOR~&
    ELSEIF MOUSE.B2% THEN
        ' Right button sprays with BG color
        IF NOT MOUSE.OLD_B2% THEN
            STROKE_begin
        END IF
        ' Track drag direction for SHIFT axis constraint
        IF MOUSE.X% < MOUSE.OLD_X% THEN MOUSE.DRAG$ = "L"
        IF MOUSE.X% > MOUSE.OLD_X% THEN MOUSE.DRAG$ = "R"
        IF MOUSE.Y% < MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "U"
        IF MOUSE.Y% > MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "D"
        SPRAY.ACTIVE = TRUE
        IF CONSTRAIN_X% THEN
            sprayX% = MOUSE.CON_X%: sprayY% = MOUSE.Y%
        ELSEIF CONSTRAIN_Y% THEN
            sprayX% = MOUSE.X%: sprayY% = MOUSE.CON_Y%
        ELSE
            sprayX% = MOUSE.X%: sprayY% = MOUSE.Y%
        END IF
        SPRAY_on sprayX%, sprayY%, PAINT_BG_COLOR~&
    END IF
END SUB


''
' Tool handler: Zoom.
'
SUB MOUSE_tool_zoom (rawX AS INTEGER, rawY AS INTEGER)
    ' Zoom tool: click to zoom in at cursor, alt+click to zoom out
    ' Drag to zoom into a region
    IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
        ' Mouse just pressed - start drag tracking
        ZOOM.DRAGGING = TRUE
        ZOOM.START_X = rawX%
        ZOOM.START_Y = rawY%
        ZOOM.END_X = rawX%
        ZOOM.END_Y = rawY%
    ELSEIF MOUSE.B1% AND ZOOM.DRAGGING THEN
        ' Continue dragging - update end position
        ZOOM.END_X = rawX%
        ZOOM.END_Y = rawY%
    END IF
END SUB


''
' Mouse release handler: Zoom.
'
SUB MOUSE_release_zoom (rawX AS INTEGER, rawY AS INTEGER)
    ' Zoom tool release - check if it was a click or a drag
    IF ZOOM.DRAGGING THEN
        DIM zDragW AS INTEGER, zDragH AS INTEGER
        zDragW% = ABS(ZOOM.END_X - ZOOM.START_X)
        zDragH% = ABS(ZOOM.END_Y - ZOOM.START_Y)
        IF zDragW% >= 8 AND zDragH% >= 8 THEN
            ' Drag was large enough - zoom to region
            ZOOM_to_region ZOOM.START_X, ZOOM.START_Y, ZOOM.END_X, ZOOM.END_Y
        ELSE
            ' Small drag or click - zoom in/out at cursor
            DIM zScreenX AS INTEGER, zScreenY AS INTEGER
            zScreenX% = rawX%
            zScreenY% = rawY%
            IF MODIFIERS.alt% THEN
                ZOOM_out_at zScreenX%, zScreenY%
            ELSE
                ZOOM_in_at zScreenX%, zScreenY%
            END IF
        END IF
        ZOOM_drag_reset
    END IF
END SUB


''
' Mouse release handler: Marquee.
'
SUB MOUSE_release_marquee ()
    SELECT CASE MARQUEE.VARIANT
        CASE TOOL_SELECT_FREE
            ' Freehand: finish on mouse up (auto-close path)
            IF MARQUEE.FREE_DRAWING THEN
                FREEHAND_SEL_finish MARQUEE.SELECTION_MODE
            END IF
        CASE TOOL_SELECT_ELLIPSE
            ' Ellipse: finish on mouse up (generate ellipse mask)
            IF MARQUEE.ELLIP_DRAGGING THEN
                ELLIPSE_SEL_finish MARQUEE.SELECTION_MODE
            END IF
        CASE TOOL_SELECT_POLY
            ' Polygon: don't do anything on B1 release (vertices are added on press)
            ' Close is handled via right-click or proximity to first vertex
        CASE TOOL_SELECT_WAND
            ' Wand: nothing to do on release (all work happens on press)
        CASE ELSE ' TOOL_SELECT_RECT
            ' Rect marquee: finish drag, resize, or move
            IF MARQUEE.DRAGGING% THEN
                MARQUEE_finish_drag
            ELSEIF MARQUEE.RESIZING% THEN
                MARQUEE_finish_resize
            ELSEIF MARQUEE.MOVING% THEN
                MARQUEE_finish_move
            END IF
    END SELECT
END SUB


''
' Mouse release handler: Move.
'
SUB MOUSE_release_move ()
    ' Mouse released after dragging
    IF MOVE.ACTIVE AND MOVE.TRANSFORMING THEN
        DIM moveReleaseAlt AS INTEGER
        moveReleaseAlt% = MODIFIERS.alt%

        IF moveReleaseAlt% THEN
            ' ALT held on release = stamp a copy and stay in clone mode
            MOVE_stamp
        ELSE
            ' Commit the drag to canvas (creates an undo state), then sync the
            ' base position so the next drag starts from the committed location.
            ' We do NOT call MOVE_capture_selection here — that would re-read
            ' pixels from the layer at the new offset with the full original W/H,
            ' clipping any content that extends to the canvas edge.
            MOVE_apply_transform
            MOVE_sync_base
        END IF

        MOVE.TRANSFORMING = FALSE
    END IF
END SUB


''
' Mouse release handler: Line.
'
SUB MOUSE_release_line ()
    ' Draw the final line on mouse release
    IF LINE_TOOL.DRAGGING THEN
        DIM line_mx(0 TO 7) AS INTEGER
        DIM line_my(0 TO 7) AS INTEGER
        DIM line_sx(0 TO 7) AS INTEGER
        DIM line_sy(0 TO 7) AS INTEGER
        DIM line_count AS INTEGER
        DIM line_i AS INTEGER
        DIM line_target AS LONG
        DIM line_is_transparent AS INTEGER

        line_target& = LAYER_current_image&
        _DEST line_target&

        ' Check if drawing with transparent color
        line_is_transparent% = (_ALPHA32(DRAW_COLOR~&) = 0)
        IF line_is_transparent% THEN _DONTBLEND line_target&

        IF CUSTOM_BRUSH_is_active% THEN
            ' Use custom brush stamps along the line
            CUSTOM_BRUSH_stamp_line LINE_TOOL.START_X, LINE_TOOL.START_Y, LINE_TOOL.END_X, LINE_TOOL.END_Y
            ' TODO: Add symmetry support for custom brush lines
        ELSEIF BRUSH_SIZE_pixels% > 1 THEN
            ' Thick brush line - stamp brush shapes along the path
            ' Symmetry handled internally by PAINT_stamp_brush
            LINE_draw_brushed LINE_TOOL.START_X, LINE_TOOL.START_Y, LINE_TOOL.END_X, LINE_TOOL.END_Y, DRAW_COLOR~&
        ELSEIF SELECTION_has_active% OR LAYERS(CURRENT_LAYER%).opacityLock% THEN
            ' Use clipped line drawing when selection is active or opacity lock is on
            LINE_draw_clipped LINE_TOOL.START_X, LINE_TOOL.START_Y, LINE_TOOL.END_X, LINE_TOOL.END_Y, DRAW_COLOR~&

            ' Draw clipped symmetry lines
            IF SYMMETRY.MODE > 0 THEN
                SYMMETRY_get_mirrored_points LINE_TOOL.START_X, LINE_TOOL.START_Y, line_sx%(), line_sy%(), line_count%
                SYMMETRY_get_mirrored_points LINE_TOOL.END_X, LINE_TOOL.END_Y, line_mx%(), line_my%(), line_count%

                FOR line_i% = 0 TO line_count% - 1
                    LINE_draw_clipped line_sx%(line_i%), line_sy%(line_i%), line_mx%(line_i%), line_my%(line_i%), DRAW_COLOR~&
                NEXT line_i%
            END IF
        ELSE
            ' Draw master line at full opacity
            LINE (LINE_TOOL.START_X, LINE_TOOL.START_Y)-(LINE_TOOL.END_X, LINE_TOOL.END_Y), DRAW_COLOR~&

            ' Draw symmetry lines
            IF SYMMETRY.MODE > 0 THEN
                SYMMETRY_get_mirrored_points LINE_TOOL.START_X, LINE_TOOL.START_Y, line_sx%(), line_sy%(), line_count%
                SYMMETRY_get_mirrored_points LINE_TOOL.END_X, LINE_TOOL.END_Y, line_mx%(), line_my%(), line_count%

                FOR line_i% = 0 TO line_count% - 1
                    LINE (line_sx%(line_i%), line_sy%(line_i%))-(line_mx%(line_i%), line_my%(line_i%)), DRAW_COLOR~&
                NEXT line_i%
            END IF
        END IF

        IF line_is_transparent% THEN _BLEND line_target&
        _DEST SCRN.CANVAS&
        LINE_TOOL.DRAGGING = FALSE
        CANVAS_DIRTY% = TRUE
        STROKE_commit
        IF NOT UNDO_saved_this_frame% THEN
            UNDO_save_state ' Save state after drawing line
            UNDO_saved_this_frame% = TRUE
        END IF
    END IF
END SUB


''
' Mouse release handler: Rect.
'
SUB MOUSE_release_rect ()
    ' Draw the final rectangle on mouse release
    IF RECT_TOOL.DRAGGING THEN
        DIM rect_fsx(0 TO 7) AS INTEGER, rect_fsy(0 TO 7) AS INTEGER
        DIM rect_fex(0 TO 7) AS INTEGER, rect_fey(0 TO 7) AS INTEGER
        DIM rect_fcount AS INTEGER, rect_fi AS INTEGER
        DIM rect_target AS LONG
        DIM rect_is_transparent AS INTEGER
        DIM rect_has_selection AS INTEGER

        rect_target& = LAYER_current_image&
        _DEST rect_target&

        ' Check if there's an active selection for clipping
        rect_has_selection% = SELECTION_has_active%

        ' Check if drawing with transparent color
        rect_is_transparent% = (_ALPHA32(DRAW_COLOR~&) = 0)
        IF rect_is_transparent% THEN _DONTBLEND rect_target&

        IF CUSTOM_BRUSH_is_active% AND NOT RECT_TOOL.FILLED THEN
            ' Use custom brush stamps for outline only
            CUSTOM_BRUSH_stamp_line RECT_TOOL.START_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.START_Y ' Top
            CUSTOM_BRUSH_stamp_line RECT_TOOL.END_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.END_Y     ' Right
            CUSTOM_BRUSH_stamp_line RECT_TOOL.END_X, RECT_TOOL.END_Y, RECT_TOOL.START_X, RECT_TOOL.END_Y     ' Bottom
            CUSTOM_BRUSH_stamp_line RECT_TOOL.START_X, RECT_TOOL.END_Y, RECT_TOOL.START_X, RECT_TOOL.START_Y ' Left
            ' TODO: Add symmetry support for custom brush rectangles
        ELSEIF NOT RECT_TOOL.FILLED AND BRUSH_SIZE_pixels% > 1 THEN
            ' Thick brush rect outline - draw 4 thick brush lines for edges
            ' Symmetry handled internally by PAINT_stamp_brush
            LINE_draw_brushed RECT_TOOL.START_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.START_Y, DRAW_COLOR~& ' Top
            LINE_draw_brushed RECT_TOOL.END_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.END_Y, DRAW_COLOR~&     ' Right
            LINE_draw_brushed RECT_TOOL.END_X, RECT_TOOL.END_Y, RECT_TOOL.START_X, RECT_TOOL.END_Y, DRAW_COLOR~&     ' Bottom
            LINE_draw_brushed RECT_TOOL.START_X, RECT_TOOL.END_Y, RECT_TOOL.START_X, RECT_TOOL.START_Y, DRAW_COLOR~& ' Left
        ELSE
            ' Normal rectangle drawing
            IF RECT_TOOL.FILLED THEN
                IF rect_has_selection% OR LAYERS(CURRENT_LAYER%).opacityLock% THEN
                    ' Use clipped filled rect when selection is active or opacity lock is on
                    RECT_draw_clipped_filled RECT_TOOL.START_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.END_Y, DRAW_COLOR~&

                    ' Draw clipped symmetry rectangles
                    IF SYMMETRY.MODE > 0 THEN
                        SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_fsx%(), rect_fsy%(), rect_fcount%
                        SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_fex%(), rect_fey%(), rect_fcount%

                        FOR rect_fi% = 0 TO rect_fcount% - 1
                            RECT_draw_clipped_filled rect_fsx%(rect_fi%), rect_fsy%(rect_fi%), rect_fex%(rect_fi%), rect_fey%(rect_fi%), DRAW_COLOR~&
                        NEXT rect_fi%
                    END IF
                ELSE
                    ' Solid fill - draw master rectangle
                    LINE (RECT_TOOL.START_X, RECT_TOOL.START_Y)-(RECT_TOOL.END_X, RECT_TOOL.END_Y), DRAW_COLOR~&, BF

                    ' Draw symmetry rectangles
                    IF SYMMETRY.MODE > 0 THEN
                        SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_fsx%(), rect_fsy%(), rect_fcount%
                        SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_fex%(), rect_fey%(), rect_fcount%

                        FOR rect_fi% = 0 TO rect_fcount% - 1
                            LINE (rect_fsx%(rect_fi%), rect_fsy%(rect_fi%))-(rect_fex%(rect_fi%), rect_fey%(rect_fi%)), DRAW_COLOR~&, BF
                        NEXT rect_fi%
                    END IF
                END IF
            ELSEIF rect_has_selection% OR LAYERS(CURRENT_LAYER%).opacityLock% THEN
                ' Use clipped outline when selection is active or opacity lock is on
                RECT_draw_clipped_outline RECT_TOOL.START_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.END_Y, DRAW_COLOR~&

                ' Draw clipped symmetry rectangles
                IF SYMMETRY.MODE > 0 THEN
                    SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_fsx%(), rect_fsy%(), rect_fcount%
                    SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_fex%(), rect_fey%(), rect_fcount%

                    FOR rect_fi% = 0 TO rect_fcount% - 1
                        RECT_draw_clipped_outline rect_fsx%(rect_fi%), rect_fsy%(rect_fi%), rect_fex%(rect_fi%), rect_fey%(rect_fi%), DRAW_COLOR~&
                    NEXT rect_fi%
                END IF
            ELSE
                ' Outline - draw master rectangle
                LINE (RECT_TOOL.START_X, RECT_TOOL.START_Y)-(RECT_TOOL.END_X, RECT_TOOL.END_Y), DRAW_COLOR~&, B

                ' Draw symmetry rectangles
                IF SYMMETRY.MODE > 0 THEN
                    SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_fsx%(), rect_fsy%(), rect_fcount%
                    SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_fex%(), rect_fey%(), rect_fcount%

                    FOR rect_fi% = 0 TO rect_fcount% - 1
                        LINE (rect_fsx%(rect_fi%), rect_fsy%(rect_fi%))-(rect_fex%(rect_fi%), rect_fey%(rect_fi%)), DRAW_COLOR~&, B
                    NEXT rect_fi%
                END IF
            END IF
        END IF

        IF rect_is_transparent% THEN _BLEND rect_target&
        _DEST SCRN.CANVAS&
        RECT_TOOL.DRAGGING = FALSE
        CANVAS_DIRTY% = TRUE
        STROKE_commit
        IF NOT UNDO_saved_this_frame% THEN
            UNDO_save_state ' Save state after drawing rectangle
            UNDO_saved_this_frame% = TRUE
        END IF
    END IF
END SUB


''
' Mouse release handler: Ellipse.
'
SUB MOUSE_release_ellip ()
    ' Draw the final ellipse on mouse release
    IF ELLIPSE_TOOL.DRAGGING THEN
        DIM ecx AS INTEGER, ecy AS INTEGER, erx AS SINGLE, ery AS SINGLE, easp AS SINGLE
        ecx% = (ELLIPSE_TOOL.START_X + ELLIPSE_TOOL.END_X) \ 2
        ecy% = (ELLIPSE_TOOL.START_Y + ELLIPSE_TOOL.END_Y) \ 2
        erx! = ABS(ELLIPSE_TOOL.END_X - ELLIPSE_TOOL.START_X) / 2
        ery! = ABS(ELLIPSE_TOOL.END_Y - ELLIPSE_TOOL.START_Y) / 2
        IF erx! > 0 THEN easp! = ery! / erx! ELSE easp! = 1

        DIM ell_fcsx(0 TO 7) AS INTEGER, ell_fcsy(0 TO 7) AS INTEGER
        DIM ell_fcount AS INTEGER, ell_fi AS INTEGER
        DIM ell_target AS LONG
        DIM ell_is_transparent AS INTEGER
        DIM ell_has_selection AS INTEGER

        ell_target& = LAYER_current_image&
        _DEST ell_target&

        ' Check if there's an active selection for clipping
        ell_has_selection% = SELECTION_has_active%

        ' Check if drawing with transparent color
        ell_is_transparent% = (_ALPHA32(DRAW_COLOR~&) = 0)
        IF ell_is_transparent% THEN _DONTBLEND ell_target&

        IF erx! > 0 THEN
            IF CUSTOM_BRUSH_is_active% AND NOT ELLIPSE_TOOL.FILLED THEN
                ' Use custom brush stamps for outline only
                CUSTOM_BRUSH_stamp_ellipse ecx%, ecy%, erx!, ery!
                ' TODO: Add symmetry support for custom brush ellipses
            ELSEIF NOT ELLIPSE_TOOL.FILLED AND BRUSH_SIZE_pixels% > 1 THEN
                ' Thick brush ellipse outline - stamp brush shapes along path
                ' Symmetry handled internally by PAINT_stamp_brush
                ELLIPSE_draw_brushed ecx%, ecy%, erx!, ery!, DRAW_COLOR~&
            ELSE
                ' Normal ellipse drawing
                IF ELLIPSE_TOOL.FILLED THEN
                    ' Draw filled ellipse using scanline algorithm (already handles selection)
                    ' Skip CIRCLE outline if opacity lock is on (scanline fill will handle it)
                    IF NOT ell_has_selection% AND NOT LAYERS(CURRENT_LAYER%).opacityLock% THEN
                        CIRCLE (ecx%, ecy%), erx!, DRAW_COLOR~&, , , easp!
                    END IF
                    ELLIPSE_fill_scanline ecx%, ecy%, erx!, ery!, DRAW_COLOR~&, LAYER_current_image&

                    ' Draw symmetry ellipses
                    IF SYMMETRY.MODE > 0 THEN
                        SYMMETRY_get_mirrored_points ecx%, ecy%, ell_fcsx%(), ell_fcsy%(), ell_fcount%

                        FOR ell_fi% = 0 TO ell_fcount% - 1
                            IF NOT ell_has_selection% AND NOT LAYERS(CURRENT_LAYER%).opacityLock% THEN
                                CIRCLE (ell_fcsx%(ell_fi%), ell_fcsy%(ell_fi%)), erx!, DRAW_COLOR~&, , , easp!
                            END IF
                            ELLIPSE_fill_scanline ell_fcsx%(ell_fi%), ell_fcsy%(ell_fi%), erx!, ery!, DRAW_COLOR~&, LAYER_current_image&
                        NEXT ell_fi%
                    END IF
                ELSEIF ell_has_selection% OR LAYERS(CURRENT_LAYER%).opacityLock% THEN
                    ' Use clipped ellipse outline when selection is active or opacity lock is on
                    ELLIPSE_draw_clipped_outline ecx%, ecy%, erx!, ery!, DRAW_COLOR~&

                    ' Draw clipped symmetry ellipses
                    IF SYMMETRY.MODE > 0 THEN
                        SYMMETRY_get_mirrored_points ecx%, ecy%, ell_fcsx%(), ell_fcsy%(), ell_fcount%

                        FOR ell_fi% = 0 TO ell_fcount% - 1
                            ELLIPSE_draw_clipped_outline ell_fcsx%(ell_fi%), ell_fcsy%(ell_fi%), erx!, ery!, DRAW_COLOR~&
                        NEXT ell_fi%
                    END IF
                ELSE
                    ' Draw ellipse outline
                    CIRCLE (ecx%, ecy%), erx!, DRAW_COLOR~&, , , easp!

                    ' Draw symmetry ellipses
                    IF SYMMETRY.MODE > 0 THEN
                        SYMMETRY_get_mirrored_points ecx%, ecy%, ell_fcsx%(), ell_fcsy%(), ell_fcount%

                        FOR ell_fi% = 0 TO ell_fcount% - 1
                            CIRCLE (ell_fcsx%(ell_fi%), ell_fcsy%(ell_fi%)), erx!, DRAW_COLOR~&, , , easp!
                        NEXT ell_fi%
                    END IF
                END IF
            END IF
        END IF

        IF ell_is_transparent% THEN _BLEND ell_target&
        _DEST SCRN.CANVAS&
        ELLIPSE_TOOL.DRAGGING = FALSE
        CANVAS_DIRTY% = TRUE
        STROKE_commit
        IF NOT UNDO_saved_this_frame% THEN
            UNDO_save_state ' Save state after drawing ellipse
            UNDO_saved_this_frame% = TRUE
        END IF
    END IF
END SUB


''
' Mouse release handler: Brush.
'
SUB MOUSE_release_brush ()
    ' Draw collected pixel perfect stroke if enabled
    IF BRUSH_SIZE.PIXEL_PERFECT AND PP_STROKE_COUNT% > 0 THEN
        PAINT_draw_pixel_perfect
    END IF
    CANVAS_DIRTY% = TRUE
    IF PP_BACKUP& < -1 THEN _FREEIMAGE PP_BACKUP&: PP_BACKUP& = 0
    PP_STROKE_COUNT% = 0
    STROKE_commit
    IF NOT UNDO_saved_this_frame% THEN
        UNDO_save_state
        UNDO_saved_this_frame% = TRUE
    END IF
    ' Update DOT.LAST position for SHIFT+RightClick dynamic lines
    ' This captures the final position after any mouse movement
    DOT.LAST_X = MOUSE.X%
    DOT.LAST_Y = MOUSE.Y%
    DOT.HAS_LAST = TRUE
END SUB


''
' Mouse release handler: Dot.
'
SUB MOUSE_release_dot ()
    ' DOT stamps single pixel - just finalize
    CANVAS_DIRTY% = TRUE
    STROKE_commit
    IF NOT UNDO_saved_this_frame% THEN
        UNDO_save_state
        UNDO_saved_this_frame% = TRUE
    END IF
    DOT.LAST_X = MOUSE.X%
    DOT.LAST_Y = MOUSE.Y%
    DOT.HAS_LAST = TRUE
END SUB


''
' Mouse release handler: Text.
'
SUB MOUSE_release_text ()
    ' TEXT tool applies via ESC key or clicking elsewhere
    ' TEXT_apply() saves undo, so just set flag to prevent double-save
    ' Note: This case only triggers if mouse was released after TEXT.ACTIVE
    _LOGINFO "MOUSE release TOOL_TEXT: TEXT.ACTIVE=" + STR$(TEXT.ACTIVE) + " flag=" + STR$(UNDO_saved_this_frame%)
    IF TEXT.ACTIVE THEN
        UNDO_saved_this_frame% = TRUE
    END IF
END SUB


''
' Mouse release handler: Spray.
'
SUB MOUSE_release_spray ()
    ' Spray tool - reset active flag on release
    SPRAY.ACTIVE = FALSE
    STROKE_commit
    IF NOT UNDO_saved_this_frame% THEN
        UNDO_save_state
        UNDO_saved_this_frame% = TRUE
    END IF
    CANVAS_DIRTY% = TRUE
END SUB


''
' Right-click handling for tools.
'
SUB MOUSE_handle_right_click ()
    ' Skip right-click handler for tools that use B2 for drawing with BG color.
    ' Brush/Dot without SHIFT use B2 for drawing; Line/Rect/Ellipse/Fill use B2 for shapes.
    ' Only process right-click for: Picker (pick BG), SHIFT+Brush/Dot (connecting line),
    ' Polygon select (close shape), and Marquee.
    SELECT CASE CURRENT_TOOL%
        CASE TOOL_LINE, TOOL_RECT, TOOL_RECT_FILLED, TOOL_ELLIPSE, TOOL_ELLIPSE_FILLED, TOOL_FILL
            EXIT SUB
        CASE TOOL_BRUSH, TOOL_DOT, TOOL_ERASER
            IF NOT MODIFIERS.shift% THEN EXIT SUB ' B2 without SHIFT = draw with BG
        CASE TOOL_SPRAY
            EXIT SUB ' Spray already handles B2 in tool_spray
    END SELECT

    ' Right-click on polygon select: close the polygon
    IF CURRENT_TOOL% = TOOL_MARQUEE AND MARQUEE.VARIANT = TOOL_SELECT_POLY THEN
        IF MARQUEE.POLY_DRAWING AND MARQUEE.POLY_POINT_COUNT >= 3 THEN
            POLY_SEL_close MARQUEE.SELECTION_MODE
        END IF
        EXIT SUB
    END IF

    _LOGINFO "Right-click detected: B2=" + STR$(MOUSE.B2%) + " OLD_B2=" + STR$(MOUSE.OLD_B2%)
    _LOGINFO "Current tool=" + STR$(CURRENT_TOOL%) + " (DOT=3, BRUSH=1)"
    _LOGINFO "SHIFT held: " + STR$(MODIFIERS.shift%)
    _LOGINFO "MOUSE position at right-click: X=" + STR$(MOUSE.X%) + " Y=" + STR$(MOUSE.Y%)
    _LOGINFO "RAW mouse position: _MOUSEX=" + STR$(_MOUSEX) + " _MOUSEY=" + STR$(_MOUSEY)

    ' Right-click with picker: pick background color
    IF CURRENT_TOOL% = TOOL_PICKER AND PICKER.ACTIVE% THEN
        PICKER_pick_color MOUSE.X%, MOUSE.Y%, 2 ' 2 = right button/background
        EXIT SUB
    END IF

    ' SHIFT + Right Click: Draw line from last dot/brush to current position
    IF (CURRENT_TOOL% = TOOL_DOT OR CURRENT_TOOL% = TOOL_BRUSH OR CURRENT_TOOL% = TOOL_ERASER) AND MODIFIERS.shift% THEN
        _LOGINFO "SHIFT+Right-click on BRUSH/DOT tool - checking DOT.HAS_LAST=" + STR$(DOT.HAS_LAST)
        _LOGINFO "BEFORE drawing: DOT.LAST_X=" + STR$(DOT.LAST_X) + " DOT.LAST_Y=" + STR$(DOT.LAST_Y)
        _LOGINFO "BEFORE drawing: MOUSE.X%=" + STR$(MOUSE.X%) + " MOUSE.Y%=" + STR$(MOUSE.Y%)
        IF DOT.HAS_LAST THEN
            ' Compute endpoint with optional angle snap (Ctrl+Shift)
            DIM srl_end_x AS INTEGER, srl_end_y AS INTEGER
            IF MODIFIERS.ctrlShift% THEN
                srl_end_x% = MOUSE.UNSNAPPED_X%
                srl_end_y% = MOUSE.UNSNAPPED_Y%
                SNAP_to_angle DOT.LAST_X, DOT.LAST_Y, srl_end_x%, srl_end_y%, CFG.ANGLE_SNAP_DEGREES%
            ELSE
                srl_end_x% = MOUSE.X%
                srl_end_y% = MOUSE.Y%
            END IF
            _LOGINFO "Drawing dynamic line from (" + STR$(DOT.LAST_X) + "," + STR$(DOT.LAST_Y) + ") to (" + STR$(srl_end_x%) + "," + STR$(srl_end_y%) + ")"
            _LOGINFO "Using PAINT_COLOR=" + STR$(PAINT_COLOR~&) + " (not PAINT_BG_COLOR=" + STR$(PAINT_BG_COLOR~&) + ")"
            ' Draw line from last position to current position using FOREGROUND color
            ' Note: SHIFT+Right-click always uses FG color (PAINT_COLOR~&), not DRAW_COLOR~&
            STROKE_begin
            _DEST LAYER_current_image&
            IF CUSTOM_BRUSH_is_active% THEN
                ' Use custom brush stamps along the line
                CUSTOM_BRUSH_stamp_line DOT.LAST_X, DOT.LAST_Y, srl_end_x%, srl_end_y%
            ELSE
                ' Draw line using current brush size/shape
                DIM srl_pixel_size AS INTEGER
                DIM srl_radius AS INTEGER
                DIM srl_dx AS INTEGER, srl_dy AS INTEGER
                DIM srl_steps AS INTEGER, srl_i AS INTEGER
                DIM srl_t AS SINGLE
                DIM srl_cx AS INTEGER, srl_cy AS INTEGER
                srl_pixel_size% = BRUSH_SIZE_pixels%
                IF srl_pixel_size% = 1 THEN
                    ' Single pixel - simple line
                    LINE (DOT.LAST_X, DOT.LAST_Y)-(srl_end_x%, srl_end_y%), PAINT_COLOR~&
                ELSEIF srl_pixel_size% = 3 AND BRUSH_SIZE.SHAPE = 0 THEN
                    ' Plus sign for size 3 circle
                    srl_dx% = srl_end_x% - DOT.LAST_X
                    srl_dy% = srl_end_y% - DOT.LAST_Y
                    srl_steps% = INT(SQR(srl_dx% * srl_dx% + srl_dy% * srl_dy%)) + 1
                    IF srl_steps% < 1 THEN srl_steps% = 1
                    DIM srl_px AS INTEGER, srl_py AS INTEGER
                    FOR srl_i% = 0 TO srl_steps%
                        srl_t! = srl_i% / srl_steps%
                        srl_cx% = DOT.LAST_X + INT(srl_dx% * srl_t!)
                        srl_cy% = DOT.LAST_Y + INT(srl_dy% * srl_t!)
                        FOR srl_py% = srl_cy% - 1 TO srl_cy% + 1
                            PAINT_pset_with_symmetry srl_cx%, srl_py%, PAINT_COLOR~&, TRUE
                        NEXT
                        FOR srl_px% = srl_cx% - 1 TO srl_cx% + 1
                            PAINT_pset_with_symmetry srl_px%, srl_cy%, PAINT_COLOR~&, TRUE
                        NEXT
                    NEXT srl_i%
                ELSE
                    ' Brush size > 1 - stamp filled shapes along line
                    srl_radius% = srl_pixel_size% \ 2
                    srl_dx% = srl_end_x% - DOT.LAST_X
                    srl_dy% = srl_end_y% - DOT.LAST_Y
                    srl_steps% = INT(SQR(srl_dx% * srl_dx% + srl_dy% * srl_dy%)) + 1
                    IF srl_steps% < 1 THEN srl_steps% = 1
                    FOR srl_i% = 0 TO srl_steps%
                        srl_t! = srl_i% / srl_steps%
                        srl_cx% = DOT.LAST_X + INT(srl_dx% * srl_t!)
                        srl_cy% = DOT.LAST_Y + INT(srl_dy% * srl_t!)
                        IF BRUSH_SIZE.SHAPE = 0 THEN
                            PAINT_draw_filled_circle srl_cx%, srl_cy%, srl_radius%, PAINT_COLOR~&
                        ELSE
                            PAINT_draw_filled_square srl_cx%, srl_cy%, srl_pixel_size%, PAINT_COLOR~&
                        END IF
                    NEXT srl_i%
                END IF
            END IF
            _DEST SCRN.CANVAS&
            ' Update last position to current (snapped) position
            DOT.LAST_X = srl_end_x%
            DOT.LAST_Y = srl_end_y%
            ' Save undo state
            STROKE_commit
            IF NOT UNDO_saved_this_frame% THEN
                UNDO_save_state
                UNDO_saved_this_frame% = TRUE
            END IF
            CANVAS_DIRTY% = TRUE
        ELSE
            _LOGINFO "DOT.HAS_LAST is FALSE - no previous point to draw from"
        END IF
        EXIT SUB
    END IF

    ' Right Click on POLY_LINE tool: finish poly line (stop drawing)
    ' On macOS, Ctrl+Shift+Click arrives as B2. Skip finishing when Ctrl+Shift
    ' is held — that B2 is already handled as a point placement in MOUSE_tool_poly.
    IF CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED THEN
        $IF MAC THEN
            IF MODIFIERS.ctrlShift% THEN EXIT SUB
        $END IF
        ' Close the shape if filled polygon
        IF CURRENT_TOOL% = TOOL_POLYGON_FILLED AND POLY_LINE.HAS_LAST AND POLY_LINE.POINT_COUNT >= 3 THEN
            ' Draw closing line
            DIM polyfill_target AS LONG
            DIM polyfill_is_transparent AS INTEGER
            polyfill_target& = LAYER_current_image&
            _DEST polyfill_target&

            ' Check if drawing with transparent color
            polyfill_is_transparent% = (_ALPHA32(PAINT_COLOR~&) = 0)
            IF polyfill_is_transparent% THEN _DONTBLEND polyfill_target&

            IF CUSTOM_BRUSH_is_active% THEN
                ' Use custom brush stamps for closing line
                CUSTOM_BRUSH_stamp_line POLY_LINE.LAST_X, POLY_LINE.LAST_Y, POLY_LINE.FIRST_X, POLY_LINE.FIRST_Y
            ELSEIF BRUSH_SIZE_pixels% > 1 THEN
                ' Thick brush line for closing line
                LINE_draw_brushed POLY_LINE.LAST_X, POLY_LINE.LAST_Y, POLY_LINE.FIRST_X, POLY_LINE.FIRST_Y, PAINT_COLOR~&
            ELSEIF SELECTION_has_active% OR LAYERS(CURRENT_LAYER%).opacityLock% THEN
                ' Use clipped line drawing for closing line when selection is active or opacity lock is on
                LINE_draw_clipped POLY_LINE.LAST_X, POLY_LINE.LAST_Y, POLY_LINE.FIRST_X, POLY_LINE.FIRST_Y, PAINT_COLOR~&
            ELSE
                ' Normal line drawing
                LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y)-(POLY_LINE.FIRST_X, POLY_LINE.FIRST_Y), PAINT_COLOR~&
            END IF
            ' Use scanline fill algorithm for proper polygon filling (only if not using custom brush)
            IF NOT CUSTOM_BRUSH_is_active% THEN
                POLY_FILL_scanline POLY_POINTS_X(), POLY_POINTS_Y(), POLY_LINE.POINT_COUNT, PAINT_COLOR~&, polyfill_target&
            END IF

            IF polyfill_is_transparent% THEN _BLEND polyfill_target&
            _DEST SCRN.CANVAS&
            CANVAS_DIRTY% = TRUE
        END IF
        ' Save undo AFTER polygon is complete (like LINE tool)
        STROKE_commit
        IF NOT UNDO_saved_this_frame% THEN
            UNDO_save_state
            UNDO_saved_this_frame% = TRUE
        END IF
        POLY_LINE_reset
        ' Keep tool selected so user can draw more polygons
        GUI_NEEDS_REDRAW% = TRUE
        EXIT SUB
    END IF
END SUB


''
' Shift-constrain handling for directional drags.
'
SUB MOUSE_handle_shift_constrain ()
    IF MODIFIERS.shift% AND NOT CONSTRAIN_X% AND NOT CONSTRAIN_Y% THEN
        IF MOUSE.DRAG$ = "L" OR MOUSE.DRAG$ = "R" THEN
            MOUSE.CON_Y% = MOUSE.Y%
            CONSTRAIN_X% = FALSE
            CONSTRAIN_Y% = TRUE
        ELSEIF MOUSE.DRAG$ = "U" OR MOUSE.DRAG$ = "D" THEN
            MOUSE.CON_X% = MOUSE.X%
            CONSTRAIN_X% = TRUE
            CONSTRAIN_Y% = FALSE
        END IF
    END IF
END SUB


''
' Mouse wheel handler (GUI scroll, brush size, zoom).
'
SUB MOUSE_handle_wheel (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
    ' Process accumulated wheel delta for zoom/brush size (outside event loop)
    IF wheel_delta% <> 0 THEN
        MOUSE.SW% = wheel_delta%

        ' Check if command palette is visible — scroll its list, never zoom
        IF CMD_PALETTE.visible AND CMD_in_bounds%(rawX%, rawY%) THEN
            IF MOUSE.SW% > 0 THEN
                CMD_navigate_down
            ELSEIF MOUSE.SW% < 0 THEN
                CMD_navigate_up
            END IF
            MOUSE.SW% = 0 ' Consume — palette scroll doesn't change the scene
        ' Check if command palette is visible but pointer outside — still consume 
        ELSEIF CMD_PALETTE.visible THEN
            MOUSE.SW% = 0 ' Consume — don't zoom behind modal overlay
        ' Check if menubar submenu is open — consume wheel, never zoom
        ELSEIF MENUBAR_is_open% THEN
            MOUSE.SW% = 0 ' Consume — don't zoom behind open menu
        ' Check if palette menu is visible - always handle wheel for menu scrolling, never zoom
        ELSEIF PALETTE_MENU_VISIBLE% THEN
            PALETTE_STRIP_handle_wheel MOUSE.SW%
            MOUSE.SW% = 0 ' Consume — menu scroll doesn't change the scene
        ' Check if over layer panel first - use RAW screen coords for GUI bounds checks!
        ELSEIF LAYER_PANEL.visible% AND LAYER_PANEL_in_bounds%(rawX%, rawY%) THEN
            LAYER_PANEL_handle_wheel rawX%, rawY%, MOUSE.SW%
            MOUSE.SW% = 0 ' Consume — panel scroll doesn't change the scene
        ' Check if over palette dropdown button (closed menu) - ignore wheel
        ELSEIF PALETTE_STRIP_dropdown_in_bounds%(rawX%, rawY%) THEN
            MOUSE.SW% = 0 ' Consume — ignored
        ' Check if over palette strip (excluding dropdown) - use RAW screen coords
        ELSEIF PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN
            PALETTE_STRIP_handle_wheel MOUSE.SW%
            MOUSE.SW% = 0 ' Consume — palette scroll doesn't change the scene
        ' Check if over toolbar (don't zoom when over toolbar) - use RAW screen coords
        ELSEIF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN
            MOUSE.SW% = 0 ' Consume — ignored
        ' Check if over organizer - cycle widgets when scrolling
        ELSEIF SCRN.showToolbar% AND ORGANIZER_is_over_area%(rawX%, rawY%) THEN
            ORGANIZER_handle_wheel rawX%, rawY%, MOUSE.SW%
            MOUSE.SW% = 0 ' Consume — organizer interaction doesn't zoom
        ' Check if over status bar area (don't zoom when over status bar) - use RAW screen coords
        ELSEIF SCRN.showStatus% AND rawY% >= SCRN.h& - THEME.STATUS_height% - PALETTE_STRIP_get_height% THEN
            MOUSE.SW% = 0 ' Consume — ignored
        ' Check if CTRL+SHIFT is held for reference image opacity adjustment
        ELSEIF MODIFIERS.ctrl% AND MODIFIERS.shift% THEN
            IF REFIMG.IMAGE < -1 THEN
                IF MOUSE.SW% < 0 THEN
                    REFIMG_adjust_opacity REFIMG_OPACITY_STEP%
                ELSEIF MOUSE.SW% > 0 THEN
                    REFIMG_adjust_opacity -REFIMG_OPACITY_STEP%
                END IF
                IF REFIMG.VISIBLE THEN
                    SCENE_DIRTY% = TRUE
                    FRAME_IDLE% = FALSE ' Force immediate re-render
                END IF
            END IF
            MOUSE.SW% = 0 ' Consume
        ' Check if CTRL is held for brush size adjustment
        ELSEIF MODIFIERS.ctrl% THEN
            ' CTRL+Wheel adjusts brush size
            ' Wheel up (negative) should increase, wheel down (positive) should decrease
            IF MOUSE.SW% < 0 THEN
                BRUSH_SIZE_increase
            ELSEIF MOUSE.SW% > 0 THEN
                BRUSH_SIZE_decrease
            END IF
            MOUSE.SW% = 0 ' Consume wheel — brush resize doesn't change the scene
        ELSE
            ' Mouse wheel without CTRL: zoom in/out (only when over canvas)
            ' Above 100%: Always use 100% increments (both in and out)
            ' At/below 100%: Zoom IN snaps to 100%, Zoom OUT uses 25%
            ' Zoom centered on mouse cursor position
            DIM oldZoom AS SINGLE
            DIM mouseScreenX AS INTEGER, mouseScreenY AS INTEGER
            oldZoom! = SCRN.zoom!

            ' Get mouse screen position BEFORE zoom changes (scaled to logical coords)
            mouseScreenX% = _MOUSEX
            mouseScreenY% = _MOUSEY

            IF MOUSE.SW% < 0 THEN
                ' Wheel down = zoom in
                IF SCRN.zoom! < 1.0 THEN
                    SCRN.zoom! = 1.0  ' Snap to 100% from any fractional zoom
                ELSE
                    SCRN.zoom! = INT(SCRN.zoom!) + 1.0  ' Next whole 100% (200%, 300%, etc.)
                END IF
                IF SCRN.zoom! > SCRN.zoomMax! THEN SCRN.zoom! = SCRN.zoomMax!
            ELSEIF MOUSE.SW% > 0 THEN
                ' Wheel up = zoom out
                IF SCRN.zoom! > 1.0 THEN
                    ' Above 100%: zoom out by whole 100% (200% → 100%, 300% → 200%)
                    SCRN.zoom! = INT(SCRN.zoom!) - 1.0
                ELSE
                    ' At/below 100%: zoom out by 25% (100% → 75% → 50% → 25%)
                    SCRN.zoom! = SCRN.zoom! - 0.25
                END IF
                IF SCRN.zoom! < SCRN.zoomMin! THEN SCRN.zoom! = SCRN.zoomMin!
            END IF

            ' Adjust offset to keep mouse over same canvas point
            IF SCRN.zoom! <> oldZoom! THEN
                GUI_NEEDS_REDRAW% = TRUE
                ' Calculate canvas center offset at old zoom (canvas dimensions, centered in viewport)
                DIM old_zw AS LONG, old_zh AS LONG
                old_zw& = SCRN.canvasW& * oldZoom!
                old_zh& = SCRN.canvasH& * oldZoom!
                DIM old_center_x AS INTEGER, old_center_y AS INTEGER
                old_center_x% = (SCRN.w& - old_zw&) \ 2
                old_center_y% = (SCRN.h& - old_zh&) \ 2

                ' Canvas position under mouse at old zoom
                DIM canvasX AS SINGLE, canvasY AS SINGLE
                canvasX! = (mouseScreenX% - old_center_x% - SCRN.offsetX%) / oldZoom!
                canvasY! = (mouseScreenY% - old_center_y% - SCRN.offsetY%) / oldZoom!

                ' Calculate new canvas center offset at new zoom (canvas dimensions, centered in viewport)
                DIM new_zw AS LONG, new_zh AS LONG
                new_zw& = SCRN.canvasW& * SCRN.zoom!
                new_zh& = SCRN.canvasH& * SCRN.zoom!
                DIM new_center_x AS INTEGER, new_center_y AS INTEGER
                new_center_x% = (SCRN.w& - new_zw&) \ 2
                new_center_y% = (SCRN.h& - new_zh&) \ 2

                ' Calculate new offset to keep canvas point at mouse screen position
                SCRN.offsetX% = mouseScreenX% - new_center_x% - (canvasX! * SCRN.zoom!)
                SCRN.offsetY% = mouseScreenY% - new_center_y% - (canvasY! * SCRN.zoom!)
            END IF
        END IF
        MOUSE.OSW% = MOUSE.SW%
    END IF
END SUB


''
' Tool dispatcher: button held.
'
SUB MOUSE_dispatch_tool_hold (rawX AS INTEGER, rawY AS INTEGER)
    ' Handle different tools based on CURRENT_TOOL (B1=left=FG, B2=right=BG)
    SELECT CASE CURRENT_TOOL%
        CASE TOOL_NULL
            ' Null tool - does nothing (used during dialogs to prevent phantom events)
            ' Intentionally empty
        CASE TOOL_MARQUEE
            MOUSE_tool_marquee
        CASE TOOL_MOVE
            MOUSE_tool_move
        CASE TOOL_FILL
            MOUSE_tool_fill
        CASE TOOL_PICKER
            MOUSE_tool_picker
        CASE TOOL_SAVE
            MOUSE_tool_save
        CASE TOOL_OPEN
            MOUSE_tool_open
        CASE TOOL_TEXT
            MOUSE_tool_text
        CASE TOOL_LINE
            MOUSE_tool_line
        CASE TOOL_POLYGON, TOOL_POLYGON_FILLED
            MOUSE_tool_poly
        CASE TOOL_RECT, TOOL_RECT_FILLED
            MOUSE_tool_rect
        CASE TOOL_ELLIPSE, TOOL_ELLIPSE_FILLED
            MOUSE_tool_ellip
        CASE TOOL_BRUSH, TOOL_ERASER
            MOUSE_tool_brush
        CASE TOOL_DOT
            MOUSE_tool_dot
        CASE TOOL_SPRAY
            MOUSE_tool_spray
        CASE TOOL_ZOOM
            MOUSE_tool_zoom rawX%, rawY%
    END SELECT
END SUB


''
' Tool dispatcher: button released.
'
SUB MOUSE_dispatch_tool_release (rawX AS INTEGER, rawY AS INTEGER)
    ' Button released - save undo state if we were drawing
    IF (MOUSE.OLD_B1% OR MOUSE.OLD_B2%) AND NOT UNDO_saved_this_frame% THEN
        SELECT CASE CURRENT_TOOL%
            CASE TOOL_ZOOM
                MOUSE_release_zoom rawX%, rawY%
            CASE TOOL_MARQUEE
                MOUSE_release_marquee
            CASE TOOL_MOVE
                MOUSE_release_move
            CASE TOOL_LINE
                MOUSE_release_line
            CASE TOOL_RECT, TOOL_RECT_FILLED
                MOUSE_release_rect
            CASE TOOL_ELLIPSE, TOOL_ELLIPSE_FILLED
                MOUSE_release_ellip
            CASE TOOL_BRUSH, TOOL_ERASER
                MOUSE_release_brush
            CASE TOOL_DOT
                MOUSE_release_dot
            CASE TOOL_TEXT
                MOUSE_release_text
            CASE TOOL_SPRAY
                MOUSE_release_spray
        END SELECT
    END IF
END SUB


''
' CTRL+click sets symmetry center (CTRL+B2 too, for macOS CTRL-click → right-click quirk).
'
SUB MOUSE_handle_symmetry_ctrl_click ()
    DIM ctrlClicked AS INTEGER
    ctrlClicked% = FALSE

    ' Use ctrlOnly% (not ctrl%) so Ctrl+Shift passes through to tool handlers
    ' (Ctrl+Shift is used for angle snap with grid snap override)
    IF MODIFIERS.ctrlOnly% THEN
        IF (MOUSE.B1% AND NOT MOUSE.OLD_B1%) OR (MOUSE.B2% AND NOT MOUSE.OLD_B2%) THEN
            ctrlClicked% = TRUE
        END IF
    END IF

    IF ctrlClicked% THEN
        SYMMETRY_set_center MOUSE.X%, MOUSE.Y%
        ' Mark as toolbar clicked to prevent drawing action
        MOUSE.TOOLBAR_CLICKED% = TRUE
    END IF
END SUB


''
' Set drawing color based on active mouse button (B1=FG, B2=BG).
'
SUB MOUSE_update_draw_color ()
    ' Use BG color when B2 is pressed OR was just released (OLD_B2),
    ' so release handlers still see the correct draw color on the release frame.
    IF MOUSE.B2% OR MOUSE.OLD_B2% THEN
        DRAW_COLOR~& = PAINT_BG_COLOR~&
    ELSE
        DRAW_COLOR~& = PAINT_COLOR~&
    END IF
END SUB


''
' ALT temporary picker mode state machine.
'
SUB MOUSE_handle_alt_picker (rawX AS INTEGER, rawY AS INTEGER)
    ' Check for ALT key press to activate temporary color picker
    ' Only for drawing tools - NOT for MOVE (ALT=clone), MARQUEE, IMAGE_IMPORT, NULL, etc.
    ' Also skip if CTRL or SHIFT are held (likely a hotkey combo like CTRL+ALT+SHIFT)
    DIM isDrawingTool%
    DIM isCtrlOrShiftHeld%
    DIM altHeld%
    STATIC altWasHeld% ' Track ALT state from previous frame
    STATIC pickerFromAlt% ' Track if we entered picker via ALT key

    isCtrlOrShiftHeld% = (MODIFIERS.ctrl% OR MODIFIERS.shift%)
    altHeld% = MODIFIERS.alt%

    ' Check if current tool (or previous tool if in picker mode) is a drawing tool
    IF CURRENT_TOOL% = TOOL_PICKER AND pickerFromAlt% THEN
        ' When in ALT-triggered picker mode, check PREVIOUS_TOOL to know if we came from a drawing tool
        isDrawingTool% = (PREVIOUS_TOOL% = TOOL_DOT OR PREVIOUS_TOOL% = TOOL_BRUSH OR _
                         PREVIOUS_TOOL% = TOOL_ERASER OR _
                         PREVIOUS_TOOL% = TOOL_LINE OR PREVIOUS_TOOL% = TOOL_RECT OR _
                         PREVIOUS_TOOL% = TOOL_RECT_FILLED OR PREVIOUS_TOOL% = TOOL_ELLIPSE OR _
                         PREVIOUS_TOOL% = TOOL_ELLIPSE_FILLED OR PREVIOUS_TOOL% = TOOL_FILL OR _
                         PREVIOUS_TOOL% = TOOL_POLYGON OR PREVIOUS_TOOL% = TOOL_POLYGON_FILLED OR _
                         PREVIOUS_TOOL% = TOOL_TEXT OR PREVIOUS_TOOL% = TOOL_SPRAY)
    ELSE
        isDrawingTool% = (CURRENT_TOOL% = TOOL_DOT OR CURRENT_TOOL% = TOOL_BRUSH OR _
                         CURRENT_TOOL% = TOOL_ERASER OR _
                         CURRENT_TOOL% = TOOL_LINE OR CURRENT_TOOL% = TOOL_RECT OR _
                         CURRENT_TOOL% = TOOL_RECT_FILLED OR CURRENT_TOOL% = TOOL_ELLIPSE OR _
                         CURRENT_TOOL% = TOOL_ELLIPSE_FILLED OR CURRENT_TOOL% = TOOL_FILL OR _
                         CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED OR _
                         CURRENT_TOOL% = TOOL_TEXT OR CURRENT_TOOL% = TOOL_SPRAY)
    END IF

    ' Only ENTER picker mode when ALT is FIRST pressed (transition), not just held
    ' This prevents re-entering picker when releasing other modifiers while ALT is still held
    DIM altJustPressed%
    altJustPressed% = (altHeld% AND NOT altWasHeld%)

    ' Skip ALT picker when mouse is over menu bar
    DIM overMenuBar%
    overMenuBar% = FALSE
    IF SCRN.showMenubar% AND MENU_BAR.visible% THEN
        overMenuBar% = MENUBAR_in_bounds%(rawX%, rawY%) OR MENUBAR_submenu_in_bounds%(rawX%, rawY%) OR MENUBAR_is_open%
    END IF

    IF altJustPressed% AND isDrawingTool% AND NOT isCtrlOrShiftHeld% AND NOT overMenuBar% THEN
        ' ALT just pressed alone with a drawing tool - enter picker mode
        IF CURRENT_TOOL% <> TOOL_PICKER THEN
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_PICKER
            GUI_NEEDS_REDRAW% = TRUE
            PICKER_activate
            FILL_deactivate
            pickerFromAlt% = TRUE
            ' Suppress menu bar ALT-tap so releasing ALT won't open the menu
            MENU_BAR.altTapped% = FALSE
        END IF
    ELSEIF pickerFromAlt% THEN
        ' We're in ALT-triggered picker mode - check if we should exit
        IF NOT altHeld% OR isCtrlOrShiftHeld% THEN
            ' Exit picker mode: ALT released OR other modifiers added
            IF CURRENT_TOOL% = TOOL_PICKER AND PREVIOUS_TOOL% <> TOOL_PICKER THEN
                CURRENT_TOOL% = PREVIOUS_TOOL%
                GUI_NEEDS_REDRAW% = TRUE
                PICKER_deactivate
                IF CURRENT_TOOL% = TOOL_FILL THEN
                    FILL_activate
                END IF
            END IF
            pickerFromAlt% = FALSE
            ' Suppress menu bar ALT-tap so menu doesn't open after picking
            MENU_BAR.altTapped% = FALSE
            MENU_BAR.altWasDown% = FALSE
        END IF
    END IF

    ' Pick color on click while in ALT-picker mode
    ' Left click = foreground, Right click = background
    IF pickerFromAlt% AND CURRENT_TOOL% = TOOL_PICKER THEN
        IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
            PICKER_pick_color MOUSE.X%, MOUSE.Y%, 1
        ELSEIF MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
            PICKER_pick_color MOUSE.X%, MOUSE.Y%, 2
        END IF
    END IF

    ' Update ALT state for next frame
    altWasHeld% = altHeld%
END SUB


''
' Spacebar temporary pan tool switch.
' When spacebar is pressed, temporarily switches to PAN tool.
' When released, restores the previous tool. Similar to ALT→picker pattern.
'
SUB MOUSE_handle_space_pan ()
    STATIC spaceWasHeld%
    STATIC panFromSpace%

    DIM spaceHeld AS INTEGER
    spaceHeld% = _KEYDOWN(32)

    ' Don't activate if text tool is active (space needed for typing)
    DIM allowSpacePan AS INTEGER
    allowSpacePan% = NOT (CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE)

    DIM spaceJustPressed AS INTEGER
    spaceJustPressed% = (spaceHeld% AND NOT spaceWasHeld%)

    IF spaceJustPressed% AND allowSpacePan% AND CURRENT_TOOL% <> TOOL_PAN THEN
        ' Spacebar just pressed — enter pan mode
        PREVIOUS_TOOL% = CURRENT_TOOL%
        CURRENT_TOOL% = TOOL_PAN
        GUI_NEEDS_REDRAW% = TRUE
        FRAME_IDLE% = FALSE
        panFromSpace% = TRUE
    ELSEIF panFromSpace% THEN
        ' We're in space-triggered pan mode — check if we should exit
        IF NOT spaceHeld% THEN
            ' Space released — restore previous tool
            IF CURRENT_TOOL% = TOOL_PAN AND PREVIOUS_TOOL% <> TOOL_PAN THEN
                CURRENT_TOOL% = PREVIOUS_TOOL%
                GUI_NEEDS_REDRAW% = TRUE
                FRAME_IDLE% = FALSE
            END IF
            panFromSpace% = FALSE
        END IF
    END IF

    spaceWasHeld% = spaceHeld%
END SUB


''
' Handles post-dialog mouse suppression frames.
' Returns TRUE when current frame input should be suppressed.
'
FUNCTION MOUSE_handle_suppress_frames% ()
    IF MOUSE.SUPPRESS_FRAMES% > 0 THEN
        DO WHILE _MOUSEINPUT : LOOP ' Drain any late-arriving events
        MOUSE.B1% = FALSE
        MOUSE.B2% = FALSE
        MOUSE.B3% = FALSE
        MOUSE.OLD_B1% = FALSE
        MOUSE.OLD_B2% = FALSE
        MOUSE.OLD_B3% = FALSE
        MOUSE.SUPPRESS_FRAMES% = MOUSE.SUPPRESS_FRAMES% - 1
        MOUSE.OLD_X% = MOUSE.X%
        MOUSE.OLD_Y% = MOUSE.Y%
        MOUSE_handle_suppress_frames% = TRUE
    ELSE
        MOUSE_handle_suppress_frames% = FALSE
    END IF
END FUNCTION


''
' Returns TRUE when tool actions should be skipped for this frame.
'
FUNCTION MOUSE_should_skip_tool_actions% ()
    IF MOUSE.TOOLBAR_CLICKED% THEN
        MOUSE.OLD_B1% = MOUSE.B1%
        MOUSE.OLD_B2% = MOUSE.B2%
        MOUSE.OLD_B3% = MOUSE.B3%
        MOUSE.OLD_X% = MOUSE.X%
        MOUSE.OLD_Y% = MOUSE.Y%
        ' Reset the flag once all buttons are released.
        ' This MUST happen here (after consuming OLD_B* transition),
        ' not earlier in the frame — otherwise MOUSE_dispatch_tool_release
        ' sees OLD_B1=TRUE with TOOLBAR_CLICKED already cleared and
        ' creates a spurious undo state on every GUI click-release cycle.
        IF NOT MOUSE.B1% AND NOT MOUSE.B2% THEN
            MOUSE.TOOLBAR_CLICKED% = FALSE
        END IF
        MOUSE_should_skip_tool_actions% = TRUE
    ELSE
        MOUSE_should_skip_tool_actions% = FALSE
    END IF
END FUNCTION


''
' Tool phase orchestration: panning, hold/release dispatch, right-click, constrain.
'
SUB MOUSE_handle_tool_phase (rawX AS INTEGER, rawY AS INTEGER)
    ' Skip normal tool behavior if panning
    IF SCRN.panning% THEN
        ' Don't process tools while panning
    ELSEIF MOUSE.B1% OR MOUSE.B2% THEN
        MOUSE_dispatch_tool_hold rawX%, rawY%
    ELSEIF NOT MOUSE.B1% THEN
        MOUSE_dispatch_tool_release rawX%, rawY%
        MOUSE.DRAG$ = ""
        MOUSE.CON_X% = 0 : MOUSE.CON_Y% = 0
        CONSTRAIN_X% = FALSE : CONSTRAIN_Y% = FALSE
    END IF

    ' Right Click handling for different tools
    IF MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
        MOUSE_handle_right_click
    END IF

    MOUSE_handle_shift_constrain
END SUB


''
' GUI pre-dispatch routing with early-exit semantics.
'
FUNCTION MOUSE_handle_gui_early% (rawX AS INTEGER, rawY AS INTEGER)
    ' Auto-apply move transform when clicking GUI controls (without marquee selection)
    ' This ensures moving an entire layer is committed when user clicks elsewhere
    MOUSE_autocommit_move_if_click_on_gui rawX%, rawY%

    ' Handle command palette clicks first (takes priority)
    IF MOUSE_handle_command_palette_click%(rawX%, rawY%) THEN
        MOUSE_handle_gui_early% = TRUE
        EXIT FUNCTION
    END IF

    ' Handle menu bar mouse move (hover tracking with menu switching)
    MOUSE_handle_menubar_mouse_move rawX%, rawY%

    ' Handle menu bar clicks (after command palette, before other GUI)
    IF MOUSE_handle_menubar_click%(rawX%, rawY%) THEN
        MOUSE_handle_gui_early% = TRUE
        EXIT FUNCTION
    END IF

    ' Close palette menu when clicking outside its bounds
    DIM paletteClosed AS INTEGER
    paletteClosed% = MOUSE_handle_palette_menu_close%(rawX%, rawY%)

    MOUSE_handle_gui_early% = FALSE
END FUNCTION


''
' GUI panel handlers (layer panel + toolbar/status/palette).
'
SUB MOUSE_handle_gui_panels (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
    ' Layer panel
    MOUSE_handle_layer_panel rawX%, rawY%, wheel_delta%

    ' Toolbar/status/palette
    MOUSE_handle_toolbar_status_palette rawX%, rawY%
END SUB


''
' End-of-frame mouse post processing.
'
SUB MOUSE_post_process (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
    ' Trigger redraw when palette menu is visible (for continuous hover highlighting)
    IF PALETTE_MENU_VISIBLE% THEN
        GUI_NEEDS_REDRAW% = TRUE
    END IF

    MOUSE_handle_wheel rawX%, rawY%, wheel_delta%

    ' Update marquee every frame for keyboard controls and handle hover detection
    IF CURRENT_TOOL% = TOOL_MARQUEE AND MARQUEE.ACTIVE% THEN
        MARQUEE_update MOUSE.X%, MOUSE.Y%
    END IF
END SUB


''
' Main per-frame mouse processing after image-import mode check.
' Returns TRUE when post-processing should run; FALSE means early-exit frame.
'
FUNCTION MOUSE_process_frame% (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
    MOUSE_drain_update_state rawX%, rawY%, wheel_delta%

    ' Suppress button input after native dialogs to prevent phantom clicks
    ' SDL can produce spurious button events when the window regains focus
    ' after a GTK/native dialog closes, arriving after MOUSE_force_buttons_up
    IF MOUSE_handle_suppress_frames% THEN
        MOUSE_process_frame% = FALSE
        EXIT FUNCTION
    END IF

    IF MOUSE_handle_gui_early%(rawX%, rawY%) THEN
        MOUSE_process_frame% = FALSE
        EXIT FUNCTION
    END IF

    ' CTRL+click sets symmetry center
    MOUSE_handle_symmetry_ctrl_click

    ' Set drawing color based on active mouse button
    ' Left button (B1) uses foreground, Right button (B2) uses background
    MOUSE_update_draw_color

    ' NOTE: TOOLBAR_CLICKED% reset moved into MOUSE_should_skip_tool_actions%
    ' so the release-frame OLD_B1/B2 transition is consumed before the flag clears.
    ' Resetting here (before the skip check) caused spurious UNDO_save_state calls
    ' on every GUI click-release cycle (menu, toolbar, palette strip, etc.).

    ' Scrollbar interaction (before other GUI panels so scrollbar clicks are consumed)
    IF SCROLLBAR_handle_mouse%(rawX%, rawY%, MOUSE.B1%, MOUSE.OLD_B1%) THEN
        MOUSE.TOOLBAR_CLICKED% = TRUE
        MOUSE_process_frame% = FALSE
        EXIT FUNCTION
    END IF

    MOUSE_handle_gui_panels rawX%, rawY%, wheel_delta%

    MOUSE_handle_alt_picker rawX%, rawY%

    ' Spacebar temporary pan tool switch
    MOUSE_handle_space_pan

    ' Double middle-click reset + UI auto-hide/restore
    MOUSE_handle_b3_dblclick_reset_zoom
    MOUSE_handle_ui_autohide_restore rawX%, rawY%

    ' Pan mode (spacebar + LMB OR MMB OR PAN tool + LMB)
    MOUSE_handle_panning rawX%, rawY%

    ' Skip tool actions if we just clicked on the toolbar
    IF MOUSE_should_skip_tool_actions% THEN
        MOUSE_process_frame% = FALSE
        EXIT FUNCTION
    END IF

    MOUSE_handle_tool_phase rawX%, rawY%
    MOUSE_process_frame% = TRUE
END FUNCTION


''
' Handles mouse input
' 
SUB MOUSE_input_handler ()
    ' ==== REFERENCE IMAGE REPOSITION MODE ====
    ' When repositioning, handle mouse directly for drag/resize
    IF REFIMG.REPOSITION THEN
        IF MOUSE_handle_refimg_reposition% THEN EXIT SUB
    END IF
    ' ==== END REFERENCE IMAGE REPOSITION MODE ====
    
    ' ==== IMAGE IMPORT MODE - PROCESS OUTSIDE LOOP FOR PERFORMANCE ====
    ' When in image import mode, skip the normal buffered mouse processing
    ' and use direct polling for responsive interaction
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        IF MOUSE_handle_image_import% THEN EXIT SUB
    END IF
    ' ==== END IMAGE IMPORT MODE ====

    DIM wheel_delta AS INTEGER
    DIM rawX AS INTEGER, rawY AS INTEGER
    
    ' ==== DRAIN-THEN-PROCESS PATTERN FOR PERFORMANCE ====
    ' Now process ONCE with final mouse state (not per-event)
    IF NOT MOUSE_process_frame%(rawX%, rawY%, wheel_delta%) THEN EXIT SUB
    
    MOUSE_post_process rawX%, rawY%, wheel_delta%
END SUB


''
' Finishing stuff in the mouse input loop
' 
SUB MOUSE_input_handler_loop ()
    MOUSE.OLD_X% = MOUSE.X% : MOUSE.OLD_Y% = MOUSE.Y%
    MOUSE.OLD_B1% = MOUSE.B1%
    MOUSE.OLD_B2% = MOUSE.B2%
    MOUSE.OLD_B3% = MOUSE.B3%
    
    ' Process deferred actions (file dialogs) after all mouse processing is complete
    ' Actions: 1=save, 2=import image (to active layer), 3=open DRW project
    IF MOUSE.DEFERRED_ACTION% = 1 THEN
        ' Save action
        SAVE_image
        MOUSE.DEFERRED_ACTION% = 0
    ELSEIF MOUSE.DEFERRED_ACTION% = 2 THEN
        ' Import image action (right-click on open) - imports to active layer
        IMPORT_image
        MOUSE.DEFERRED_ACTION% = 0
    ELSEIF MOUSE.DEFERRED_ACTION% = 3 THEN
        ' Open DRW project action (left-click on open)
        DRW_open_dialog
        MOUSE.DEFERRED_ACTION% = 0
    ELSEIF MOUSE.DEFERRED_ACTION% = 4 THEN
        ' Export selection action
        SAVE_selection
        MOUSE.DEFERRED_ACTION% = 0
    END IF
END SUB


''

