''
' DRAW - INPUT/MOUSE.BM
' =============================================================================
' Mouse input handling subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initializes the mouse
' 
SUB MOUSE_init ()
    MOUSE.X%     = 1
    MOUSE.Y%     = 1
    MOUSE.OLD_X% = 1
    MOUSE.OLD_Y% = 1
    MOUSE.CON_X% = 0
    MOUSE.CON_Y% = 0
    MOUSE.OSW%   = 0
    MOUSE.B1%    = FALSE
    MOUSE.B2%    = FALSE
    MOUSE.B3%    = FALSE
    MOUSE.OLD_B1% = FALSE
    MOUSE.OLD_B3% = FALSE
    MOUSE.DRAG$  = ""
    MOUSE.B3_CLICK_TIME# = 0
    MOUSE.DEFERRED_ACTION% = 0
END SUB


''
' Reset mouse button states (call after dialogs to prevent button state desync)
' Syncs current and old states to actual hardware state to prevent false clicks
'
SUB MOUSE_reset_buttons ()
    ' Clear any pending mouse input first
    DO WHILE _MOUSEINPUT : LOOP
    
    ' Read actual current button states from hardware
    DIM current_b1 AS INTEGER
    DIM current_b2 AS INTEGER
    DIM current_b3 AS INTEGER
    current_b1% = _MOUSEBUTTON(1)
    current_b2% = _MOUSEBUTTON(2)
    current_b3% = _MOUSEBUTTON(3)
    
    ' Set both current AND old to same values (no transition = no click detection)
    MOUSE.B1% = current_b1%
    MOUSE.B2% = current_b2%
    MOUSE.B3% = current_b3%
    MOUSE.OLD_B1% = current_b1%
    MOUSE.OLD_B2% = current_b2%
    MOUSE.OLD_B3% = current_b3%
    MOUSE.TOOLBAR_CLICKED% = FALSE
END SUB


''
' Forces all mouse buttons to UP state (used after dialogs to prevent phantom clicks)
'
SUB MOUSE_force_buttons_up ()
    ' Clear any pending mouse input first
    DO WHILE _MOUSEINPUT : LOOP
    
    ' Force all buttons to UP (FALSE) state
    MOUSE.B1% = FALSE
    MOUSE.B2% = FALSE
    MOUSE.B3% = FALSE
    MOUSE.OLD_B1% = FALSE
    MOUSE.OLD_B2% = FALSE
    MOUSE.OLD_B3% = FALSE
    MOUSE.TOOLBAR_CLICKED% = FALSE
    
    $IF WINDOWS THEN
        ' On Windows, grab window focus after dialogs
        DIM result AS LONG
        result& = SetForegroundWindow&(_WINDOWHANDLE)
    $END IF
END SUB


''
' Handles mouse input
' 
SUB MOUSE_input_handler ()
    DIM saved_state_this_frame AS INTEGER
    saved_state_this_frame% = FALSE
    
    ' Skip mouse input processing when window doesn't have focus (Windows fix)
    IF NOT _WINDOWHASFOCUS THEN EXIT SUB
    
    WHILE _MOUSEINPUT:
        ' Get raw screen coordinates and convert to canvas coordinates
        DIM rawX AS INTEGER, rawY AS INTEGER
        DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
        rawX% = _MOUSEX
        rawY% = _MOUSEY
        
        ' Calculate zoomed canvas position on screen
        zw& = SCRN.w& * SCRN.zoom!
        zh& = SCRN.h& * SCRN.zoom!
        dx% = (_WIDTH - zw&) \ 2 + SCRN.offsetX%
        dy% = (_HEIGHT - zh&) \ 2 + SCRN.offsetY%
        
        ' Convert screen coords to canvas coords
        MOUSE.X% = (rawX% - dx%) / SCRN.zoom!
        MOUSE.Y% = (rawY% - dy%) / SCRN.zoom!
        
        ' Clamp to canvas bounds
        IF MOUSE.X% < 0 THEN MOUSE.X% = 0
        IF MOUSE.Y% < 0 THEN MOUSE.Y% = 0
        IF MOUSE.X% >= SCRN.w& THEN MOUSE.X% = SCRN.w& - 1
        IF MOUSE.Y% >= SCRN.h& THEN MOUSE.Y% = SCRN.h& - 1
        
        ' Update button states from hardware
        MOUSE.B1% = _MOUSEBUTTON(1)
        MOUSE.B2% = _MOUSEBUTTON(2)
        MOUSE.B3% = _MOUSEBUTTON(3)
        
        ' Reset toolbar clicked flag only when mouse button is released
        IF NOT MOUSE.B1% THEN
            MOUSE.TOOLBAR_CLICKED% = FALSE
        END IF
        
        ' Check for toolbar clicks (only when not panning)
        IF NOT SCRN.panning% AND MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
            ' Check if clicking on toolbar area (raw screen coordinates)
            IF SCRN.showToolbar% AND (rawX% >= TB_LEFT AND rawX% <= TB_RIGHT + TB_BTN_W) THEN
                TOOLBAR_handle_click rawX%, rawY%
                MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
            END IF
            ' Check if clicking on status bar area (bottom of screen)
            IF SCRN.showStatus% AND rawY% >= (SCRN.h& - 10) THEN
                MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
            END IF
        END IF
        
        ' Check for ALT key press to activate temporary color picker
        IF (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&)) THEN
            ' Store current tool if not already in picker mode
            IF CURRENT_TOOL% <> TOOL_PICKER THEN
                PREVIOUS_TOOL% = CURRENT_TOOL%
                CURRENT_TOOL% = TOOL_PICKER
                PICKER_activate
                ' Deactivate other tools
                FILL_deactivate
            END IF
            ' Pick color on left click while ALT is held
            IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                PICKER_pick_color MOUSE.X%, MOUSE.Y%, 1
            END IF
        ELSE
            ' Check for ALT key release to return to previous tool
            IF CURRENT_TOOL% = TOOL_PICKER AND PREVIOUS_TOOL% <> TOOL_PICKER THEN
                ' Return to previous tool when ALT is released
                CURRENT_TOOL% = PREVIOUS_TOOL%
                PICKER_deactivate
                ' Reactivate previous tool if needed
                IF CURRENT_TOOL% = TOOL_FILL THEN
                    FILL_activate
                END IF
            END IF
        END IF
        
        ' Check for double middle-click to reset zoom and position
        IF MOUSE.B3% AND NOT MOUSE.OLD_B3% THEN
            DIM clickTime AS DOUBLE
            clickTime# = TIMER
            IF clickTime# - MOUSE.B3_CLICK_TIME# < 0.3 THEN ' 300ms double-click threshold
                ' Double-click detected - reset zoom and position
                SCRN.zoom! = 1.0
                SCRN.offsetX% = 0
                SCRN.offsetY% = 0
                MOUSE.B3_CLICK_TIME# = 0 ' Reset to prevent triple-click triggering
            ELSE
                MOUSE.B3_CLICK_TIME# = clickTime#
            END IF
        END IF
        
        ' Auto-hide UI when actively dragging with a tool (not when clicking toolbar)
        ' Only hide when button was already down (OLD_B1%) and we're not clicking on UI
        ' Skip auto-hide for NULL tool - let user freely access toolbar/status
        IF CURRENT_TOOL% <> TOOL_NULL AND MOUSE.B1% AND MOUSE.OLD_B1% AND NOT SCRN.panning% AND NOT MOUSE.TOOLBAR_CLICKED% THEN
            ' Check if mouse is over toolbar area while drawing
            IF SCRN.showToolbar% AND (rawX% >= TB_LEFT AND rawX% <= TB_RIGHT + TB_BTN_W) THEN
                SCRN.showToolbar% = FALSE
                SCRN.toolbarManuallyHidden% = FALSE ' This is auto-hide, not manual
            END IF
            ' Check if mouse is over status bar while drawing
            IF SCRN.showStatus% AND rawY% >= (SCRN.h& - 10) THEN
                SCRN.showStatus% = FALSE
                SCRN.statusManuallyHidden% = FALSE ' This is auto-hide, not manual
            END IF
        END IF
        
        ' Restore UI when mouse is released (only if auto-hidden, not manually hidden)
        IF NOT MOUSE.B1% THEN
            ' Restore toolbar if it was auto-hidden (not manually hidden by user)
            IF NOT SCRN.showToolbar% AND NOT SCRN.toolbarManuallyHidden% THEN
                SCRN.showToolbar% = TRUE
            END IF
            ' Restore status bar if it was auto-hidden (not manually hidden by user)
            IF NOT SCRN.showStatus% AND NOT SCRN.statusManuallyHidden% THEN
                SCRN.showStatus% = TRUE
            END IF
        END IF
        
        ' Check for pan mode (spacebar + left button OR middle mouse button)
        IF (_KEYDOWN(32) AND MOUSE.B1%) OR MOUSE.B3% THEN ' Spacebar+LMB or MMB
            IF NOT SCRN.panning% THEN
                ' Start panning
                SCRN.panning% = TRUE
                SCRN.panStartX% = rawX%
                SCRN.panStartY% = rawY%
                SCRN.panOrigOffsetX% = SCRN.offsetX%
                SCRN.panOrigOffsetY% = SCRN.offsetY%
            ELSE
                ' Continue dragging
                SCRN.offsetX% = SCRN.panOrigOffsetX% + (rawX% - SCRN.panStartX%)
                SCRN.offsetY% = SCRN.panOrigOffsetY% + (rawY% - SCRN.panStartY%)
                
                ' If spacebar mode: reset on new button press
                IF _KEYDOWN(32) AND MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                    SCRN.panStartX% = rawX%
                    SCRN.panStartY% = rawY%
                    SCRN.panOrigOffsetX% = SCRN.offsetX%
                    SCRN.panOrigOffsetY% = SCRN.offsetY%
                END IF
            END IF
        ELSE
            ' Exit pan mode when both methods released
            IF SCRN.panning% THEN SCRN.panning% = FALSE
        END IF
        
        ' Skip tool actions if we just clicked on the toolbar
        IF MOUSE.TOOLBAR_CLICKED% THEN
            MOUSE.OLD_B1% = MOUSE.B1%
            MOUSE.OLD_B2% = MOUSE.B2%
            MOUSE.OLD_B3% = MOUSE.B3%
            MOUSE.OLD_X% = MOUSE.X%
            MOUSE.OLD_Y% = MOUSE.Y%
            EXIT SUB
        END IF
        
        ' Skip normal tool behavior if panning
        IF SCRN.panning% THEN
            ' Don't process tools while panning
        ELSEIF MOUSE.B1% THEN
            ' Handle different tools based on CURRENT_TOOL
            SELECT CASE CURRENT_TOOL%
                CASE TOOL_NULL
                    ' Null tool - does nothing (used during dialogs to prevent phantom events)
                    ' Intentionally empty
                CASE TOOL_MARQUEE
                    ' Start marquee selection, resize, or move on first click
                    IF NOT MOUSE.OLD_B1% THEN
                        ' Check if clicking on a handle
                        DIM handle AS INTEGER
                        handle% = MARQUEE_get_handle_at%(MOUSE.X%, MOUSE.Y%)
                        IF handle% > 0 THEN
                            ' Start resizing from this handle
                            MARQUEE_start_resize handle%, MOUSE.X%, MOUSE.Y%
                        ELSEIF MARQUEE_is_point_inside%(MOUSE.X%, MOUSE.Y%) THEN
                            ' Start moving the box
                            MARQUEE_start_move MOUSE.X%, MOUSE.Y%
                        ELSE
                            ' Start new marquee selection (clicking outside)
                            MARQUEE_start MOUSE.X%, MOUSE.Y%
                        END IF
                    END IF
                    ' Update resize, move, or drag position while button is held
                    IF MARQUEE.RESIZING% THEN
                        MARQUEE_update_resize MOUSE.X%, MOUSE.Y%
                    ELSEIF MARQUEE.MOVING% THEN
                        MARQUEE_update_move MOUSE.X%, MOUSE.Y%
                    ELSE
                        MARQUEE_update MOUSE.X%, MOUSE.Y%
                    END IF
                CASE TOOL_MOVE
                    ' MOVE tool: Transform the selected pixels
                    IF MOVE.ACTIVE THEN
                        IF NOT MOUSE.OLD_B1% THEN
                            ' Check if clicking on a handle or inside selection
                            DIM move_handle AS INTEGER
                            DIM marquee_handle AS INTEGER
                            marquee_handle% = MARQUEE_get_handle_at%(MOUSE.X%, MOUSE.Y%)
                            IF marquee_handle% > 0 THEN
                                ' Remap MARQUEE handle to MOVE handle numbering:
                                ' MARQUEE: 1=TL, 2=T, 3=TR, 4=L, 5=R, 6=BL, 7=B, 8=BR
                                ' MOVE:    1=TL, 2=TR, 3=BR, 4=BL, 5=T, 6=R, 7=B, 8=L
                                SELECT CASE marquee_handle%
                                    CASE 1: move_handle% = 1 ' TL corner
                                    CASE 3: move_handle% = 2 ' TR corner
                                    CASE 8: move_handle% = 3 ' BR corner
                                    CASE 6: move_handle% = 4 ' BL corner
                                    CASE 2: move_handle% = 5 ' T edge
                                    CASE 5: move_handle% = 6 ' R edge
                                    CASE 7: move_handle% = 7 ' B edge
                                    CASE 4: move_handle% = 8 ' L edge
                                END SELECT
                                ' Start resizing/scaling from this handle
                                MOVE_start_transform move_handle%, MOUSE.X%, MOUSE.Y%
                            ELSEIF MARQUEE_is_point_inside%(MOUSE.X%, MOUSE.Y%) THEN
                                ' Start moving from center (handle 0)
                                MOVE_start_transform 0, MOUSE.X%, MOUSE.Y%
                            END IF
                        ELSE
                            ' Update transform while dragging
                            IF MOVE.TRANSFORMING THEN
                                MOVE_update_transform MOUSE.X%, MOUSE.Y%
                            END IF
                        END IF
                    END IF
                CASE TOOL_FILL
                    ' Flood fill on click (only on button press, not while held)
                    IF FILL.ACTIVE% AND NOT MOUSE.OLD_B1% AND NOT saved_state_this_frame% THEN
                        saved_state_this_frame% = TRUE
                        FILL.COLOR~& = PAINT_COLOR~&
                        FILL_flood MOUSE.X%, MOUSE.Y%
                        UNDO_save_state ' Save state after fill
                    END IF
                CASE TOOL_PICKER
                    ' Pick color on click (only on button press, not while held)
                    IF PICKER.ACTIVE% AND NOT MOUSE.OLD_B1% THEN
                        PICKER_pick_color MOUSE.X%, MOUSE.Y%, 1  ' 1 = left button/foreground
                    END IF
                CASE TOOL_SAVE
                    ' SAVE tool: Defer save dialog to avoid calling from within mouse loop
                    IF NOT MOUSE.OLD_B1% THEN
                        MOUSE.DEFERRED_ACTION% = 1  ' 1 = save
                        ' Return to previous tool after save is triggered
                        CURRENT_TOOL% = PREVIOUS_TOOL%
                    END IF
                CASE TOOL_OPEN
                    ' LOAD tool: Defer load dialog to avoid calling from within mouse loop
                    IF NOT MOUSE.OLD_B1% THEN
                        MOUSE.DEFERRED_ACTION% = 2  ' 2 = load
                        ' Return to previous tool after load is triggered
                        CURRENT_TOOL% = PREVIOUS_TOOL%
                    END IF
                CASE TOOL_TEXT
                    ' TEXT tool: Click to start or reposition text entry
                    IF NOT MOUSE.OLD_B1% THEN
                        TEXT_start MOUSE.X%, MOUSE.Y%
                    END IF
                CASE TOOL_LINE
                    ' LINE tool: Click and drag with preview
                    IF NOT MOUSE.OLD_B1% THEN
                        ' Start dragging on first click
                        UNDO_save_state ' Save state before starting line
                        LINE_TOOL.DRAGGING = TRUE
                        LINE_TOOL.START_X = MOUSE.X%
                        LINE_TOOL.START_Y = MOUSE.Y%
                        LINE_TOOL.END_X = MOUSE.X%
                        LINE_TOOL.END_Y = MOUSE.Y%
                    ELSE
                        ' Update end position while dragging
                        LINE_TOOL.END_X = MOUSE.X%
                        LINE_TOOL.END_Y = MOUSE.Y%
                    END IF
                CASE TOOL_POLYGON, TOOL_POLYGON_FILLED
                    ' POLY_LINE tool: Click to click connected lines
                    IF NOT MOUSE.OLD_B1% THEN
                        IF POLY_LINE.HAS_LAST THEN
                            ' Draw line from last position to current position
                            UNDO_save_state ' Save state before drawing
                            _DEST SCRN.PAINTING&
                            LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y)-(MOUSE.X%, MOUSE.Y%), PAINT_COLOR~&
                            _DEST SCRN.CANVAS&
                            CANVAS_DIRTY% = TRUE
                        ELSE
                            ' First point - save it for closing the shape
                            POLY_LINE.FIRST_X = MOUSE.X%
                            POLY_LINE.FIRST_Y = MOUSE.Y%
                            POLY_LINE.POINT_COUNT = 0
                        END IF
                        ' Store this point in the array
                        IF POLY_LINE.POINT_COUNT < 1000 THEN
                            POLY_POINTS_X(POLY_LINE.POINT_COUNT) = MOUSE.X%
                            POLY_POINTS_Y(POLY_LINE.POINT_COUNT) = MOUSE.Y%
                            POLY_LINE.POINT_COUNT = POLY_LINE.POINT_COUNT + 1
                        END IF
                        ' Update last position to current click
                        POLY_LINE.LAST_X = MOUSE.X%
                        POLY_LINE.LAST_Y = MOUSE.Y%
                        POLY_LINE.HAS_LAST = TRUE
                    END IF
                CASE TOOL_RECT, TOOL_RECT_FILLED
                    ' RECT tool: Click and drag with preview
                    IF NOT MOUSE.OLD_B1% THEN
                        ' Start dragging on first click
                        UNDO_save_state ' Save state before starting rectangle
                        RECT_TOOL.DRAGGING = TRUE
                        RECT_TOOL.START_X = MOUSE.X%
                        RECT_TOOL.START_Y = MOUSE.Y%
                        RECT_TOOL.CENTER_X = MOUSE.X%
                        RECT_TOOL.CENTER_Y = MOUSE.Y%
                        RECT_TOOL.END_X = MOUSE.X%
                        RECT_TOOL.END_Y = MOUSE.Y%
                        RECT_TOOL.FILLED = (CURRENT_TOOL% = TOOL_RECT_FILLED)
                    ELSE
                        ' Update end position while dragging
                        DIM temp_end_x AS INTEGER, temp_end_y AS INTEGER
                        temp_end_x% = MOUSE.X%
                        temp_end_y% = MOUSE.Y%
                        
                        ' SHIFT: Constrain to square (calculate from center)
                        IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                            DIM size AS INTEGER
                            size% = INT(SQR((temp_end_x% - RECT_TOOL.CENTER_X) ^ 2 + (temp_end_y% - RECT_TOOL.CENTER_Y) ^ 2))
                            IF temp_end_x% < RECT_TOOL.CENTER_X THEN size% = -size%
                            temp_end_x% = RECT_TOOL.CENTER_X + size%
                            temp_end_y% = RECT_TOOL.CENTER_Y + size%
                        END IF
                        
                        ' CTRL: Draw from center
                        IF _KEYDOWN(KEY_LCTRL&) OR _KEYDOWN(KEY_RCTRL&) THEN
                            DIM offset_x AS INTEGER, offset_y AS INTEGER
                            ' Calculate offset from center to mouse
                            offset_x% = temp_end_x% - RECT_TOOL.CENTER_X
                            offset_y% = temp_end_y% - RECT_TOOL.CENTER_Y
                            ' Set corners mirrored around center
                            RECT_TOOL.START_X = RECT_TOOL.CENTER_X - offset_x%
                            RECT_TOOL.START_Y = RECT_TOOL.CENTER_Y - offset_y%
                            RECT_TOOL.END_X = RECT_TOOL.CENTER_X + offset_x%
                            RECT_TOOL.END_Y = RECT_TOOL.CENTER_Y + offset_y%
                        ELSE
                            ' Normal mode: draw from corner
                            RECT_TOOL.START_X = RECT_TOOL.CENTER_X
                            RECT_TOOL.START_Y = RECT_TOOL.CENTER_Y
                            RECT_TOOL.END_X = temp_end_x%
                            RECT_TOOL.END_Y = temp_end_y%
                        END IF
                    END IF
                CASE TOOL_ELLIPSE, TOOL_ELLIPSE_FILLED
                    ' ELLIPSE tool: Click and drag with preview
                    IF NOT MOUSE.OLD_B1% THEN
                        ' Start dragging on first click
                        UNDO_save_state ' Save state before starting ellipse
                        ELLIPSE_TOOL.DRAGGING = TRUE
                        ELLIPSE_TOOL.START_X = MOUSE.X%
                        ELLIPSE_TOOL.START_Y = MOUSE.Y%
                        ELLIPSE_TOOL.CENTER_X = MOUSE.X%
                        ELLIPSE_TOOL.CENTER_Y = MOUSE.Y%
                        ELLIPSE_TOOL.END_X = MOUSE.X%
                        ELLIPSE_TOOL.END_Y = MOUSE.Y%
                        ELLIPSE_TOOL.FILLED = (CURRENT_TOOL% = TOOL_ELLIPSE_FILLED)
                    ELSE
                        ' Update end position while dragging
                        DIM temp_ex AS INTEGER, temp_ey AS INTEGER
                        temp_ex% = MOUSE.X%
                        temp_ey% = MOUSE.Y%
                        
                        ' SHIFT: Constrain to circle (calculate from center)
                        IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                            DIM esize AS INTEGER
                            esize% = INT(SQR((temp_ex% - ELLIPSE_TOOL.CENTER_X) ^ 2 + (temp_ey% - ELLIPSE_TOOL.CENTER_Y) ^ 2))
                            IF temp_ex% < ELLIPSE_TOOL.CENTER_X THEN esize% = -esize%
                            temp_ex% = ELLIPSE_TOOL.CENTER_X + esize%
                            temp_ey% = ELLIPSE_TOOL.CENTER_Y + esize%
                        END IF
                        
                        ' CTRL: Draw from center
                        IF _KEYDOWN(KEY_LCTRL&) OR _KEYDOWN(KEY_RCTRL&) THEN
                            DIM eoffset_x AS INTEGER, eoffset_y AS INTEGER
                            ' Calculate offset from center to mouse
                            eoffset_x% = temp_ex% - ELLIPSE_TOOL.CENTER_X
                            eoffset_y% = temp_ey% - ELLIPSE_TOOL.CENTER_Y
                            ' Set corners mirrored around center
                            ELLIPSE_TOOL.START_X = ELLIPSE_TOOL.CENTER_X - eoffset_x%
                            ELLIPSE_TOOL.START_Y = ELLIPSE_TOOL.CENTER_Y - eoffset_y%
                            ELLIPSE_TOOL.END_X = ELLIPSE_TOOL.CENTER_X + eoffset_x%
                            ELLIPSE_TOOL.END_Y = ELLIPSE_TOOL.CENTER_Y + eoffset_y%
                        ELSE
                            ' Normal mode: draw from corner
                            ELLIPSE_TOOL.START_X = ELLIPSE_TOOL.CENTER_X
                            ELLIPSE_TOOL.START_Y = ELLIPSE_TOOL.CENTER_Y
                            ELLIPSE_TOOL.END_X = temp_ex%
                            ELLIPSE_TOOL.END_Y = temp_ey%
                        END IF
                    END IF
                CASE TOOL_BRUSH, TOOL_DOT
                    ' Always draw while button is held
                    IF MOUSE.X% < MOUSE.OLD_X% THEN MOUSE.DRAG$ = "L"
                    IF MOUSE.X% > MOUSE.OLD_X% THEN MOUSE.DRAG$ = "R"
                    IF MOUSE.Y% < MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "U"
                    IF MOUSE.Y% > MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "D"
                    PAINT_on
            END SELECT
        ELSEIF NOT MOUSE.B1% THEN
            ' Button released - save undo state if we were drawing
            IF MOUSE.OLD_B1% AND NOT saved_state_this_frame% THEN
                SELECT CASE CURRENT_TOOL%
                    CASE TOOL_MARQUEE
                        ' Finish the marquee drag, resize, or move
                        IF MARQUEE.DRAGGING% THEN
                            MARQUEE_finish_drag
                        ELSEIF MARQUEE.RESIZING% THEN
                            MARQUEE_finish_resize
                        ELSEIF MARQUEE.MOVING% THEN
                            MARQUEE_finish_move
                        END IF
                    CASE TOOL_MOVE
                        ' Mouse released - update base selection to current position for next transform
                        ' This allows multiple adjustments before ENTER confirms
                        IF MOVE.ACTIVE THEN
                            MOVE.SELECTION_X = MOVE.CURRENT_X
                            MOVE.SELECTION_Y = MOVE.CURRENT_Y
                            MOVE.SELECTION_W = MOVE.CURRENT_W
                            MOVE.SELECTION_H = MOVE.CURRENT_H
                            MOVE.TRANSFORMING = FALSE
                        END IF
                    CASE TOOL_LINE
                        ' Draw the final line on mouse release
                        IF LINE_TOOL.DRAGGING THEN
                            _DEST SCRN.PAINTING&
                            LINE (LINE_TOOL.START_X, LINE_TOOL.START_Y)-(LINE_TOOL.END_X, LINE_TOOL.END_Y), PAINT_COLOR~&
                            _DEST SCRN.CANVAS&
                            LINE_TOOL.DRAGGING = FALSE
                            CANVAS_DIRTY% = TRUE
                        END IF
                    CASE TOOL_RECT, TOOL_RECT_FILLED
                        ' Draw the final rectangle on mouse release
                        IF RECT_TOOL.DRAGGING THEN
                            _DEST SCRN.PAINTING&
                            IF RECT_TOOL.FILLED THEN
                                LINE (RECT_TOOL.START_X, RECT_TOOL.START_Y)-(RECT_TOOL.END_X, RECT_TOOL.END_Y), PAINT_COLOR~&, BF
                            ELSE
                                LINE (RECT_TOOL.START_X, RECT_TOOL.START_Y)-(RECT_TOOL.END_X, RECT_TOOL.END_Y), PAINT_COLOR~&, B
                            END IF
                            _DEST SCRN.CANVAS&
                            RECT_TOOL.DRAGGING = FALSE
                            CANVAS_DIRTY% = TRUE
                        END IF
                    CASE TOOL_ELLIPSE, TOOL_ELLIPSE_FILLED
                        ' Draw the final ellipse on mouse release
                        IF ELLIPSE_TOOL.DRAGGING THEN
                            DIM ecx AS INTEGER, ecy AS INTEGER, erx AS SINGLE, ery AS SINGLE, easp AS SINGLE
                            ecx% = (ELLIPSE_TOOL.START_X + ELLIPSE_TOOL.END_X) \ 2
                            ecy% = (ELLIPSE_TOOL.START_Y + ELLIPSE_TOOL.END_Y) \ 2
                            erx! = ABS(ELLIPSE_TOOL.END_X - ELLIPSE_TOOL.START_X) / 2
                            ery! = ABS(ELLIPSE_TOOL.END_Y - ELLIPSE_TOOL.START_Y) / 2
                            IF erx! > 0 THEN easp! = ery! / erx! ELSE easp! = 1
                            _DEST SCRN.PAINTING&
                            IF erx! > 0 THEN
                                IF ELLIPSE_TOOL.FILLED THEN
                                    ' Draw filled ellipse using CIRCLE outline + PAINT
                                    CIRCLE (ecx%, ecy%), erx!, PAINT_COLOR~&, , , easp!
                                    PAINT (ecx%, ecy%), PAINT_COLOR~&, PAINT_COLOR~&
                                ELSE
                                    ' Draw ellipse outline
                                    CIRCLE (ecx%, ecy%), erx!, PAINT_COLOR~&, , , easp!
                                END IF
                            END IF
                            _DEST SCRN.CANVAS&
                            ELLIPSE_TOOL.DRAGGING = FALSE
                            CANVAS_DIRTY% = TRUE
                        END IF
                    CASE TOOL_BRUSH, TOOL_DOT
                        UNDO_save_state
                        saved_state_this_frame% = TRUE
                END SELECT
            END IF
            MOUSE.DRAG$ = ""
            MOUSE.CON_X% = 0 : MOUSE.CON_Y% = 0
            CONSTRAIN_X% = FALSE : CONSTRAIN_Y% = FALSE
        END IF
        
        ' Right Click handling for different tools
        IF MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
            ' SHIFT + Right Click: Draw line from last dot to current position (DOT tool only)
            IF CURRENT_TOOL% = TOOL_DOT AND (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&)) THEN
                IF DOT.HAS_LAST THEN
                    ' Undo the origin dot first (so the line replaces it, not adds to it)
                    UNDO_undo
                    ' Draw line from last position to current position
                    _DEST SCRN.PAINTING&
                    LINE (DOT.LAST_X, DOT.LAST_Y)-(MOUSE.X%, MOUSE.Y%), PAINT_COLOR~&
                    _DEST SCRN.CANVAS&
                    ' Update last position to current position
                    DOT.LAST_X = MOUSE.X%
                    DOT.LAST_Y = MOUSE.Y%
                    ' Save undo state (captures just the line, not the origin dot)
                    UNDO_save_state
                    CANVAS_DIRTY% = TRUE
                END IF
            ' Right Click on POLY_LINE tool: finish poly line (stop drawing)
            ELSEIF CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED THEN
                ' Close the shape if filled polygon
                IF CURRENT_TOOL% = TOOL_POLYGON_FILLED AND POLY_LINE.HAS_LAST AND POLY_LINE.POINT_COUNT >= 3 THEN
                    ' Draw closing line
                    _DEST SCRN.PAINTING&
                    LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y)-(POLY_LINE.FIRST_X, POLY_LINE.FIRST_Y), PAINT_COLOR~&
                    ' Use scanline fill algorithm for proper polygon filling
                    POLY_FILL_scanline POLY_POINTS_X(), POLY_POINTS_Y(), POLY_LINE.POINT_COUNT, PAINT_COLOR~&, SCRN.PAINTING&
                    _DEST SCRN.CANVAS&
                    CANVAS_DIRTY% = TRUE
                END IF
                POLY_LINE_reset
            END IF
        END IF
        
        ' Right button handlers (B2)
        IF MOUSE.B2% THEN
            ' Right click with picker: pick background color
            IF CURRENT_TOOL% = TOOL_PICKER AND PICKER.ACTIVE% AND NOT MOUSE.OLD_B2% THEN
                PICKER_pick_color MOUSE.X%, MOUSE.Y%, 2  ' 2 = right button/background
            END IF
        END IF
        
        IF MOUSE.SW% <> 0 THEN
            ' Check if CTRL is held for brush size adjustment
            IF (_KEYDOWN(100305) OR _KEYDOWN(100306)) THEN ' Right or Left CTRL
                ' CTRL+Wheel adjusts brush size
                ' Wheel up (negative) should increase, wheel down (positive) should decrease
                IF MOUSE.SW% < 0 THEN
                    BRUSH_SIZE_increase
                ELSEIF MOUSE.SW% > 0 THEN
                    BRUSH_SIZE_decrease
                END IF
            ELSE
                ' Mouse wheel without CTRL: zoom in/out
                ' Above 100%: Always use 100% increments (both in and out)
                ' At/below 100%: Zoom IN snaps to 100%, Zoom OUT uses 25%
                ' Zoom centered on mouse cursor position
                DIM oldZoom AS SINGLE
                DIM mouseScreenX AS INTEGER, mouseScreenY AS INTEGER
                oldZoom! = SCRN.zoom!
                
                ' Get mouse screen position BEFORE zoom changes
                mouseScreenX% = _MOUSEX
                mouseScreenY% = _MOUSEY
                
                IF MOUSE.SW% < 0 THEN
                    ' Wheel down = zoom in
                    IF SCRN.zoom! < 1.0 THEN
                        SCRN.zoom! = 1.0  ' Snap to 100% from any fractional zoom
                    ELSE
                        SCRN.zoom! = INT(SCRN.zoom!) + 1.0  ' Next whole 100% (200%, 300%, etc.)
                    END IF
                    IF SCRN.zoom! > SCRN.zoomMax! THEN SCRN.zoom! = SCRN.zoomMax!
                ELSEIF MOUSE.SW% > 0 THEN
                    ' Wheel up = zoom out
                    IF SCRN.zoom! > 1.0 THEN
                        ' Above 100%: zoom out by whole 100% (200% → 100%, 300% → 200%)
                        SCRN.zoom! = INT(SCRN.zoom!) - 1.0
                    ELSE
                        ' At/below 100%: zoom out by 25% (100% → 75% → 50% → 25%)
                        SCRN.zoom! = SCRN.zoom! - 0.25
                    END IF
                    IF SCRN.zoom! < SCRN.zoomMin! THEN SCRN.zoom! = SCRN.zoomMin!
                END IF
                
                ' Adjust offset to keep mouse over same canvas point
                IF SCRN.zoom! <> oldZoom! THEN
                    ' Calculate canvas center offset at old zoom
                    DIM old_zw AS LONG, old_zh AS LONG
                    old_zw& = SCRN.w& * oldZoom!
                    old_zh& = SCRN.h& * oldZoom!
                    DIM old_center_x AS INTEGER, old_center_y AS INTEGER
                    old_center_x% = (_WIDTH - old_zw&) \ 2
                    old_center_y% = (_HEIGHT - old_zh&) \ 2
                    
                    ' Canvas position under mouse at old zoom
                    DIM canvasX AS SINGLE, canvasY AS SINGLE
                    canvasX! = (mouseScreenX% - old_center_x% - SCRN.offsetX%) / oldZoom!
                    canvasY! = (mouseScreenY% - old_center_y% - SCRN.offsetY%) / oldZoom!
                    
                    ' Calculate new canvas center offset at new zoom
                    DIM new_zw AS LONG, new_zh AS LONG
                    new_zw& = SCRN.w& * SCRN.zoom!
                    new_zh& = SCRN.h& * SCRN.zoom!
                    DIM new_center_x AS INTEGER, new_center_y AS INTEGER
                    new_center_x% = (_WIDTH - new_zw&) \ 2
                    new_center_y% = (_HEIGHT - new_zh&) \ 2
                    
                    ' Calculate new offset to keep canvas point at mouse screen position
                    SCRN.offsetX% = mouseScreenX% - new_center_x% - (canvasX! * SCRN.zoom!)
                    SCRN.offsetY% = mouseScreenY% - new_center_y% - (canvasY! * SCRN.zoom!)
                END IF
            END IF
            MOUSE.OSW% = MOUSE.SW%
        END IF
        MOUSE.SW% = _MOUSEWHEEL

        ' DO: LOOP UNTIL _MOUSEINPUT = 0

        IF (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&)) AND NOT CONSTRAIN_X% AND NOT CONSTRAIN_Y% THEN
            IF MOUSE.DRAG$ = "L" OR MOUSE.DRAG$ = "R" THEN
                MOUSE.CON_Y% = MOUSE.Y%
                CONSTRAIN_X% = FALSE
                CONSTRAIN_Y% = TRUE
            ELSEIF MOUSE.DRAG$ = "U" OR MOUSE.DRAG$ = "D" THEN
                MOUSE.CON_X% = MOUSE.X%
                CONSTRAIN_X% = TRUE
                CONSTRAIN_Y% = FALSE
            END IF
        END IF
    WEND
    
    ' Update marquee every frame for keyboard controls and handle hover detection
    IF CURRENT_TOOL% = TOOL_MARQUEE AND MARQUEE.ACTIVE% THEN
        MARQUEE_update MOUSE.X%, MOUSE.Y%
    END IF
END SUB


''
' Finishing stuff in the mouse input loop
' 
SUB MOUSE_input_handler_loop ()
    MOUSE.OLD_X% = MOUSE.X% : MOUSE.OLD_Y% = MOUSE.Y%
    MOUSE.OLD_B1% = MOUSE.B1%
    MOUSE.OLD_B3% = MOUSE.B3%
    
    ' Process deferred actions (file dialogs) after all mouse processing is complete
    IF MOUSE.DEFERRED_ACTION% = 1 THEN
        ' Save action
        SAVE_image
        MOUSE.DEFERRED_ACTION% = 0
    ELSEIF MOUSE.DEFERRED_ACTION% = 2 THEN
        ' Load action
        LOAD_image
        MOUSE.DEFERRED_ACTION% = 0
    END IF
END SUB
