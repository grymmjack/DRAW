''
' DRAW - INPUT/MOUSE.BM
' =============================================================================
' Mouse input handling subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initializes the mouse
' 
SUB MOUSE_init ()
    MOUSE.X%     = 1
    MOUSE.Y%     = 1
    MOUSE.OLD_X% = 1
    MOUSE.OLD_Y% = 1
    MOUSE.CON_X% = 0
    MOUSE.CON_Y% = 0
    MOUSE.OSW%   = 0
    MOUSE.B1%    = FALSE
    MOUSE.B2%    = FALSE
    MOUSE.B3%    = FALSE
    MOUSE.OLD_B1% = FALSE
    MOUSE.OLD_B3% = FALSE
    MOUSE.DRAG$  = ""
    MOUSE.B3_CLICK_TIME# = 0
    MOUSE.DEFERRED_ACTION% = 0
END SUB


''
' Reset mouse button states (call after dialogs to prevent button state desync)
' Syncs current and old states to actual hardware state to prevent false clicks
'
SUB MOUSE_reset_buttons ()
    ' Clear any pending mouse input first
    DO WHILE _MOUSEINPUT : LOOP
    
    ' Read actual current button states from hardware
    DIM current_b1 AS INTEGER
    DIM current_b2 AS INTEGER
    DIM current_b3 AS INTEGER
    current_b1% = _MOUSEBUTTON(1)
    current_b2% = _MOUSEBUTTON(2)
    current_b3% = _MOUSEBUTTON(3)
    
    ' Set both current AND old to same values (no transition = no click detection)
    MOUSE.B1% = current_b1%
    MOUSE.B2% = current_b2%
    MOUSE.B3% = current_b3%
    MOUSE.OLD_B1% = current_b1%
    MOUSE.OLD_B2% = current_b2%
    MOUSE.OLD_B3% = current_b3%
    MOUSE.TOOLBAR_CLICKED% = FALSE
END SUB


''
' Forces all mouse buttons to UP state (used after dialogs to prevent phantom clicks)
'
SUB MOUSE_force_buttons_up ()
    ' Clear any pending mouse input first
    DO WHILE _MOUSEINPUT : LOOP
    
    ' Force all buttons to UP (FALSE) state
    MOUSE.B1% = FALSE
    MOUSE.B2% = FALSE
    MOUSE.B3% = FALSE
    MOUSE.OLD_B1% = FALSE
    MOUSE.OLD_B2% = FALSE
    MOUSE.OLD_B3% = FALSE
    MOUSE.TOOLBAR_CLICKED% = FALSE
END SUB


''
' Handles mouse input
' 
SUB MOUSE_input_handler ()
    ' ==== IMAGE IMPORT MODE - PROCESS OUTSIDE LOOP FOR PERFORMANCE ====
    ' When in image import mode, skip the normal buffered mouse processing
    ' and use direct polling for responsive interaction
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        ' Accumulate wheel delta while clearing buffered input
        DIM wheel_delta AS INTEGER
        wheel_delta% = 0
        DO WHILE _MOUSEINPUT
            wheel_delta% = wheel_delta% + _MOUSEWHEEL
        LOOP
        
        ' Get current mouse state directly (not buffered)
        DIM imp_rawX AS INTEGER, imp_rawY AS INTEGER
        DIM imp_zw AS LONG, imp_zh AS LONG, imp_dx AS INTEGER, imp_dy AS INTEGER
        imp_rawX% = _MOUSEX
        imp_rawY% = _MOUSEY
        
        ' Store raw screen coordinates
        MOUSE.RAW_X% = imp_rawX%
        MOUSE.RAW_Y% = imp_rawY%
        
        ' Calculate zoomed canvas position on screen
        imp_zw& = SCRN.w& * SCRN.zoom!
        imp_zh& = SCRN.h& * SCRN.zoom!
        imp_dx% = (_WIDTH - imp_zw&) \ 2 + SCRN.offsetX%
        imp_dy% = (_HEIGHT - imp_zh&) \ 2 + SCRN.offsetY%
        
        ' Convert screen coords to canvas coords
        MOUSE.X% = INT((imp_rawX% - imp_dx%) / SCRN.zoom!)
        MOUSE.Y% = INT((imp_rawY% - imp_dy%) / SCRN.zoom!)
        
        ' Clamp to canvas bounds
        IF MOUSE.X% < 0 THEN MOUSE.X% = 0
        IF MOUSE.Y% < 0 THEN MOUSE.Y% = 0
        IF MOUSE.X% >= SCRN.w& THEN MOUSE.X% = SCRN.w& - 1
        IF MOUSE.Y% >= SCRN.h& THEN MOUSE.Y% = SCRN.h& - 1
        
        ' Get button states
        MOUSE.B1% = _MOUSEBUTTON(1)
        MOUSE.B2% = _MOUSEBUTTON(2)
        MOUSE.B3% = _MOUSEBUTTON(3)
        
        ' Handle mouse wheel for zoom (accumulated from buffer)
        IF wheel_delta% <> 0 THEN
            IMAGE_IMPORT_zoom -wheel_delta%  ' Negative: wheel up = zoom in
        END IF
        
        ' Handle mouse button interactions
        IF MOUSE.B1% THEN
            IF NOT MOUSE.OLD_B1% THEN
                ' Button just pressed - determine action based on state
                IF IMG_IMPORT.STATE = IMPORT_STATE_LOADED THEN
                    ' No marquee yet - start drawing one
                    IMAGE_IMPORT_start_placement MOUSE.X%, MOUSE.Y%
                ELSEIF IMG_IMPORT.STATE >= IMPORT_STATE_PLACING THEN
                    ' Have a placement - check for handle/pan/new marquee
                    DIM import_handle AS INTEGER
                    import_handle% = IMAGE_IMPORT_get_handle_at%(MOUSE.X%, MOUSE.Y%)
                    IF import_handle% > 0 THEN
                        IMAGE_IMPORT_start_resize import_handle%, MOUSE.X%, MOUSE.Y%
                    ELSEIF IMAGE_IMPORT_is_point_inside%(MOUSE.X%, MOUSE.Y%) THEN
                        IMAGE_IMPORT_start_pan MOUSE.X%, MOUSE.Y%
                    ELSE
                        ' Click outside - start new marquee
                        IMG_IMPORT.STATE = IMPORT_STATE_LOADED
                        IMAGE_IMPORT_start_placement MOUSE.X%, MOUSE.Y%
                    END IF
                END IF
            ELSE
                ' Button held - update current operation
                IF IMG_IMPORT.DRAGGING THEN
                    IMAGE_IMPORT_update_placement MOUSE.X%, MOUSE.Y%
                ELSEIF IMG_IMPORT.RESIZING THEN
                    IMAGE_IMPORT_update_resize MOUSE.X%, MOUSE.Y%
                ELSEIF IMG_IMPORT.PANNING THEN
                    IMAGE_IMPORT_update_pan MOUSE.X%, MOUSE.Y%
                END IF
            END IF
        ELSE
            ' Button released - finish current operation
            IF IMG_IMPORT.DRAGGING THEN
                IMAGE_IMPORT_finish_placement
            ELSEIF IMG_IMPORT.RESIZING THEN
                IMAGE_IMPORT_finish_resize
            ELSEIF IMG_IMPORT.PANNING THEN
                IMAGE_IMPORT_finish_pan
            END IF
        END IF
        
        ' Update old mouse state
        MOUSE.OLD_B1% = MOUSE.B1%
        MOUSE.OLD_B2% = MOUSE.B2%
        MOUSE.OLD_B3% = MOUSE.B3%
        MOUSE.OLD_X% = MOUSE.X%
        MOUSE.OLD_Y% = MOUSE.Y%
        
        ' Exit early - don't process normal mouse handling during import
        EXIT SUB
    END IF
    ' ==== END IMAGE IMPORT MODE ====
    
    ' ==== DRAIN-THEN-PROCESS PATTERN FOR PERFORMANCE ====
    ' Drain all buffered mouse events and accumulate wheel delta
    wheel_delta% = 0
    DO WHILE _MOUSEINPUT
        wheel_delta% = wheel_delta% + _MOUSEWHEEL
    LOOP
    
    ' Now process ONCE with final mouse state (not per-event)
    IF TRUE THEN ' Block for consistent indentation
        ' Get raw screen coordinates and convert to canvas coordinates
        DIM rawX AS INTEGER, rawY AS INTEGER
        DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
        DIM AS INTEGER TB_RIGHT, TB_LEFT
        
        ' Calculate toolbar position dynamically to align to right edge of screen
        TB_RIGHT = SCRN.w& - TB_BTN_W - 1  ' Right column: 1px from right edge
        TB_LEFT = TB_RIGHT - TB_BTN_W - TB_BTN_PADDING  ' Left column: to the left of right column
        
        rawX% = _MOUSEX
        rawY% = _MOUSEY
        
        ' Store raw screen coordinates for GUI hover detection
        MOUSE.RAW_X% = rawX%
        MOUSE.RAW_Y% = rawY%
        
        ' Calculate zoomed canvas position on screen
        zw& = SCRN.w& * SCRN.zoom!
        zh& = SCRN.h& * SCRN.zoom!
        dx% = (_WIDTH - zw&) \ 2 + SCRN.offsetX%
        dy% = (_HEIGHT - zh&) \ 2 + SCRN.offsetY%
        
        ' Convert screen coords to canvas coords
        MOUSE.X% = INT((rawX% - dx%) / SCRN.zoom!)
        MOUSE.Y% = INT((rawY% - dy%) / SCRN.zoom!)
        
        ' Apply snap-to-grid if enabled
        IF GRID.SNAP% THEN
            MOUSE.X% = GRID_snap%(MOUSE.X%)
            MOUSE.Y% = GRID_snap%(MOUSE.Y%)
        END IF
        
        ' Clamp to canvas bounds
        IF MOUSE.X% < 0 THEN MOUSE.X% = 0
        IF MOUSE.Y% < 0 THEN MOUSE.Y% = 0
        IF MOUSE.X% >= SCRN.w& THEN MOUSE.X% = SCRN.w& - 1
        IF MOUSE.Y% >= SCRN.h& THEN MOUSE.Y% = SCRN.h& - 1
        
        ' Update button states from hardware
        MOUSE.B1% = _MOUSEBUTTON(1)
        MOUSE.B2% = _MOUSEBUTTON(2)
        MOUSE.B3% = _MOUSEBUTTON(3)
        
        ' Set drawing color based on active mouse button
        ' Left button (B1) uses foreground, Right button (B2) uses background
        DIM draw_button AS INTEGER
        draw_button% = MOUSE.B1% OR MOUSE.B2%
        IF MOUSE.B2% THEN
            DRAW_COLOR~& = PAINT_BG_COLOR~&
        ELSE
            DRAW_COLOR~& = PAINT_COLOR~&
        END IF
        
        ' Reset toolbar clicked flag only when mouse button is released
        IF NOT MOUSE.B1% AND NOT MOUSE.B2% THEN
            MOUSE.TOOLBAR_CLICKED% = FALSE
        END IF
        
        ' Check for toolbar clicks (only when not panning)
        IF NOT SCRN.panning% AND MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
            ' Check if clicking on toolbar area (raw screen coordinates)
            IF SCRN.showToolbar% AND (rawX% >= TB_LEFT AND rawX% <= TB_RIGHT + TB_BTN_W) THEN
                ' Only set TOOLBAR_CLICKED if an actual button was hit
                IF TOOLBAR_handle_click%(rawX%, rawY%) THEN
                    MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
                END IF
            END IF
            ' Check if clicking on status bar area (bottom of screen)
            IF SCRN.showStatus% AND rawY% >= (SCRN.h& - 10) THEN
                STATUS_handle_click rawX%, rawY%
                MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
            END IF
            ' Check if clicking on palette strip area (above status bar) or menu
            IF SCRN.showStatus% AND (PALETTE_STRIP_in_bounds%(rawX%, rawY%) OR PALETTE_MENU_in_bounds%(rawX%, rawY%)) THEN
                PALETTE_STRIP_handle_click rawX%, rawY%
                MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
            END IF
        END IF
        
        ' Check for right-click on palette strip (for background color)
        IF NOT SCRN.panning% AND MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
            IF SCRN.showStatus% AND PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN
                PALETTE_STRIP_handle_click rawX%, rawY%
                MOUSE.TOOLBAR_CLICKED% = TRUE
            END IF
        END IF
        
        ' Check for right-click on toolbar (for alternate tool modes)
        IF NOT SCRN.panning% AND MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
            IF SCRN.showToolbar% AND (rawX% >= TB_LEFT AND rawX% <= TB_RIGHT + TB_BTN_W) THEN
                TOOLBAR_handle_right_click rawX%, rawY%
            END IF
        END IF
        
        ' Check for middle-click on toolbar (for custom font loading on text tool)
        IF NOT SCRN.panning% AND MOUSE.B3% AND NOT MOUSE.OLD_B3% THEN
            IF SCRN.showToolbar% AND (rawX% >= TB_LEFT AND rawX% <= TB_RIGHT + TB_BTN_W) THEN
                TOOLBAR_handle_middle_click rawX%, rawY%
            END IF
        END IF
        
        ' Check for ALT key press to activate temporary color picker
        IF (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&)) THEN
            ' Store current tool if not already in picker mode
            IF CURRENT_TOOL% <> TOOL_PICKER THEN
                PREVIOUS_TOOL% = CURRENT_TOOL%
                CURRENT_TOOL% = TOOL_PICKER
                PICKER_activate
                ' Deactivate other tools
                FILL_deactivate
            END IF
            ' Pick color on left click while ALT is held
            IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                PICKER_pick_color MOUSE.X%, MOUSE.Y%, 1
            END IF
        ELSE
            ' Check for ALT key release to return to previous tool
            IF CURRENT_TOOL% = TOOL_PICKER AND PREVIOUS_TOOL% <> TOOL_PICKER THEN
                ' Return to previous tool when ALT is released
                CURRENT_TOOL% = PREVIOUS_TOOL%
                PICKER_deactivate
                ' Reactivate previous tool if needed
                IF CURRENT_TOOL% = TOOL_FILL THEN
                    FILL_activate
                END IF
            END IF
        END IF
        
        ' Check for double middle-click to reset zoom and position
        IF MOUSE.B3% AND NOT MOUSE.OLD_B3% THEN
            DIM clickTime AS DOUBLE
            clickTime# = TIMER
            IF clickTime# - MOUSE.B3_CLICK_TIME# < 0.3 THEN ' 300ms double-click threshold
                ' Double-click detected - reset zoom and position
                SCRN.zoom! = 1.0
                SCRN.offsetX% = 0
                SCRN.offsetY% = 0
                MOUSE.B3_CLICK_TIME# = 0 ' Reset to prevent triple-click triggering
            ELSE
                MOUSE.B3_CLICK_TIME# = clickTime#
            END IF
        END IF
        
        ' Auto-hide UI when actively dragging with a tool (not when clicking toolbar)
        ' Only hide when button was already down (OLD_B1%) and we're not clicking on UI
        ' Skip auto-hide for NULL tool - let user freely access toolbar/status
        IF CURRENT_TOOL% <> TOOL_NULL AND MOUSE.B1% AND MOUSE.OLD_B1% AND NOT SCRN.panning% AND NOT MOUSE.TOOLBAR_CLICKED% THEN
            ' Check if mouse is over an actual toolbar button (not empty toolbar area)
            IF SCRN.showToolbar% AND TOOLBAR_is_over_button%(rawX%, rawY%) THEN
                SCRN.showToolbar% = FALSE
                SCRN.toolbarManuallyHidden% = FALSE ' This is auto-hide, not manual
            END IF
            ' Check if mouse is over status bar while drawing
            IF SCRN.showStatus% AND rawY% >= (SCRN.h& - 10) THEN
                SCRN.showStatus% = FALSE
                SCRN.statusManuallyHidden% = FALSE ' This is auto-hide, not manual
            END IF
        END IF
        
        ' Restore UI when mouse is released (only if auto-hidden, not manually hidden)
        IF NOT MOUSE.B1% THEN
            ' Restore toolbar if it was auto-hidden (not manually hidden by user)
            IF NOT SCRN.showToolbar% AND NOT SCRN.toolbarManuallyHidden% THEN
                SCRN.showToolbar% = TRUE
            END IF
            ' Restore status bar if it was auto-hidden (not manually hidden by user)
            IF NOT SCRN.showStatus% AND NOT SCRN.statusManuallyHidden% THEN
                SCRN.showStatus% = TRUE
            END IF
        END IF
        
        ' Check for pan mode (spacebar + left button OR middle mouse button)
        IF (_KEYDOWN(32) AND MOUSE.B1%) OR MOUSE.B3% THEN ' Spacebar+LMB or MMB
            IF NOT SCRN.panning% THEN
                ' Start panning
                SCRN.panning% = TRUE
                SCRN.panStartX% = rawX%
                SCRN.panStartY% = rawY%
                SCRN.panOrigOffsetX% = SCRN.offsetX%
                SCRN.panOrigOffsetY% = SCRN.offsetY%
            ELSE
                ' Continue dragging
                SCRN.offsetX% = SCRN.panOrigOffsetX% + (rawX% - SCRN.panStartX%)
                SCRN.offsetY% = SCRN.panOrigOffsetY% + (rawY% - SCRN.panStartY%)
                
                ' If spacebar mode: reset on new button press
                IF _KEYDOWN(32) AND MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                    SCRN.panStartX% = rawX%
                    SCRN.panStartY% = rawY%
                    SCRN.panOrigOffsetX% = SCRN.offsetX%
                    SCRN.panOrigOffsetY% = SCRN.offsetY%
                END IF
            END IF
        ELSE
            ' Exit pan mode when both methods released
            IF SCRN.panning% THEN SCRN.panning% = FALSE
        END IF
        
        ' Skip tool actions if we just clicked on the toolbar
        IF MOUSE.TOOLBAR_CLICKED% THEN
            MOUSE.OLD_B1% = MOUSE.B1%
            MOUSE.OLD_B2% = MOUSE.B2%
            MOUSE.OLD_B3% = MOUSE.B3%
            MOUSE.OLD_X% = MOUSE.X%
            MOUSE.OLD_Y% = MOUSE.Y%
            EXIT SUB
        END IF
        
        ' Skip normal tool behavior if panning
        IF SCRN.panning% THEN
            ' Don't process tools while panning
        ELSEIF MOUSE.B1% OR MOUSE.B2% THEN
            ' Handle different tools based on CURRENT_TOOL (B1=left=FG, B2=right=BG)
            SELECT CASE CURRENT_TOOL%
                CASE TOOL_NULL
                    ' Null tool - does nothing (used during dialogs to prevent phantom events)
                    ' Intentionally empty
                CASE TOOL_MARQUEE
                    ' Start marquee selection, resize, or move on first click
                    IF NOT MOUSE.OLD_B1% THEN
                        ' Check if clicking on a handle
                        DIM handle AS INTEGER
                        handle% = MARQUEE_get_handle_at%(MOUSE.X%, MOUSE.Y%)
                        IF handle% > 0 THEN
                            ' Start resizing from this handle
                            MARQUEE_start_resize handle%, MOUSE.X%, MOUSE.Y%
                        ELSEIF MARQUEE_is_point_inside%(MOUSE.X%, MOUSE.Y%) THEN
                            ' Start moving the box
                            MARQUEE_start_move MOUSE.X%, MOUSE.Y%
                        ELSE
                            ' Start new marquee selection (clicking outside)
                            MARQUEE_start MOUSE.X%, MOUSE.Y%
                        END IF
                    END IF
                    ' Update resize, move, or drag position while button is held
                    IF MARQUEE.RESIZING% THEN
                        MARQUEE_update_resize MOUSE.X%, MOUSE.Y%
                    ELSEIF MARQUEE.MOVING% THEN
                        MARQUEE_update_move MOUSE.X%, MOUSE.Y%
                    ELSE
                        MARQUEE_update MOUSE.X%, MOUSE.Y%
                    END IF
                CASE TOOL_MOVE
                    ' MOVE tool: Transform the selected pixels
                    IF MOVE.ACTIVE THEN
                        IF NOT MOUSE.OLD_B1% THEN
                            ' Check if clicking on a handle or inside selection
                            DIM move_handle AS INTEGER
                            DIM marquee_handle AS INTEGER
                            marquee_handle% = MARQUEE_get_handle_at%(MOUSE.X%, MOUSE.Y%)
                            IF marquee_handle% > 0 THEN
                                ' Remap MARQUEE handle to MOVE handle numbering:
                                ' MARQUEE: 1=TL, 2=T, 3=TR, 4=L, 5=R, 6=BL, 7=B, 8=BR
                                ' MOVE:    1=TL, 2=TR, 3=BR, 4=BL, 5=T, 6=R, 7=B, 8=L
                                SELECT CASE marquee_handle%
                                    CASE 1: move_handle% = 1 ' TL corner
                                    CASE 3: move_handle% = 2 ' TR corner
                                    CASE 8: move_handle% = 3 ' BR corner
                                    CASE 6: move_handle% = 4 ' BL corner
                                    CASE 2: move_handle% = 5 ' T edge
                                    CASE 5: move_handle% = 6 ' R edge
                                    CASE 7: move_handle% = 7 ' B edge
                                    CASE 4: move_handle% = 8 ' L edge
                                END SELECT
                                ' Start resizing/scaling from this handle
                                MOVE_start_transform move_handle%, MOUSE.X%, MOUSE.Y%
                            ELSEIF MARQUEE_is_point_inside%(MOUSE.X%, MOUSE.Y%) THEN
                                ' Start moving from center (handle 0)
                                MOVE_start_transform 0, MOUSE.X%, MOUSE.Y%
                            END IF
                        ELSE
                            ' Update transform while dragging
                            IF MOVE.TRANSFORMING THEN
                                MOVE_update_transform MOUSE.X%, MOUSE.Y%
                            END IF
                        END IF
                    END IF
                CASE TOOL_FILL
                    ' Flood fill on click (only on button press, not while held)
                    IF FILL.ACTIVE% AND NOT MOUSE.OLD_B1% AND NOT UNDO_saved_this_frame% THEN
                        UNDO_saved_this_frame% = TRUE
                        FILL.COLOR~& = PAINT_COLOR~&
                        FILL_flood MOUSE.X%, MOUSE.Y%
                        UNDO_save_state ' Save state after fill
                    END IF
                CASE TOOL_PICKER
                    ' Pick color on click (only on button press, not while held)
                    IF PICKER.ACTIVE% AND NOT MOUSE.OLD_B1% THEN
                        PICKER_pick_color MOUSE.X%, MOUSE.Y%, 1  ' 1 = left button/foreground
                    END IF
                CASE TOOL_SAVE
                    ' SAVE tool: Defer save dialog to avoid calling from within mouse loop
                    IF NOT MOUSE.OLD_B1% THEN
                        MOUSE.DEFERRED_ACTION% = 1  ' 1 = save
                        ' Return to previous tool after save is triggered
                        CURRENT_TOOL% = PREVIOUS_TOOL%
                    END IF
                CASE TOOL_OPEN
                    ' LOAD tool: Defer load dialog to avoid calling from within mouse loop
                    IF NOT MOUSE.OLD_B1% THEN
                        MOUSE.DEFERRED_ACTION% = 2  ' 2 = load
                        ' Return to previous tool after load is triggered
                        CURRENT_TOOL% = PREVIOUS_TOOL%
                    END IF
                CASE TOOL_TEXT
                    ' TEXT tool: Click to start or reposition text entry
                    IF NOT MOUSE.OLD_B1% THEN
                        TEXT_start MOUSE.X%, MOUSE.Y%
                    END IF
                CASE TOOL_LINE
                    ' LINE tool: Click and drag with preview
                    IF NOT MOUSE.OLD_B1% THEN
                        ' Start dragging on first click
                        LINE_TOOL.DRAGGING = TRUE
                        LINE_TOOL.START_X = MOUSE.X%
                        LINE_TOOL.START_Y = MOUSE.Y%
                        LINE_TOOL.END_X = MOUSE.X%
                        LINE_TOOL.END_Y = MOUSE.Y%
                    ELSE
                        ' Update end position while dragging
                        LINE_TOOL.END_X = MOUSE.X%
                        LINE_TOOL.END_Y = MOUSE.Y%
                    END IF
                CASE TOOL_POLYGON, TOOL_POLYGON_FILLED
                    ' POLY_LINE tool: Click to click connected lines
                    IF NOT MOUSE.OLD_B1% THEN
                        IF POLY_LINE.HAS_LAST THEN
                            ' Draw line from last position to current position
                            ' Note: Undo is saved only when starting the polygon, not for each segment
                            _DEST SCRN.PAINTING&
                            IF CUSTOM_BRUSH_is_active% THEN
                                ' Use custom brush stamps along polygon edges
                                CUSTOM_BRUSH_stamp_line POLY_LINE.LAST_X, POLY_LINE.LAST_Y, MOUSE.X%, MOUSE.Y%
                            ELSE
                                ' Normal line drawing
                                LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y)-(MOUSE.X%, MOUSE.Y%), PAINT_COLOR~&
                            END IF
                            _DEST SCRN.CANVAS&
                            CANVAS_DIRTY% = TRUE
                        ELSE
                            ' First point - save undo state only once at the start
                            UNDO_save_state ' Save state before starting polygon
                            POLY_LINE.FIRST_X = MOUSE.X%
                            POLY_LINE.FIRST_Y = MOUSE.Y%
                            POLY_LINE.POINT_COUNT = 0
                        END IF
                        ' Store this point in the array
                        IF POLY_LINE.POINT_COUNT < 1000 THEN
                            POLY_POINTS_X(POLY_LINE.POINT_COUNT) = MOUSE.X%
                            POLY_POINTS_Y(POLY_LINE.POINT_COUNT) = MOUSE.Y%
                            POLY_LINE.POINT_COUNT = POLY_LINE.POINT_COUNT + 1
                        END IF
                        ' Update last position to current click
                        POLY_LINE.LAST_X = MOUSE.X%
                        POLY_LINE.LAST_Y = MOUSE.Y%
                        POLY_LINE.HAS_LAST = TRUE
                    END IF
                CASE TOOL_RECT, TOOL_RECT_FILLED
                    ' RECT tool: Click and drag with preview
                    IF NOT MOUSE.OLD_B1% THEN
                        ' Start dragging on first click
                        RECT_TOOL.DRAGGING = TRUE
                        RECT_TOOL.START_X = MOUSE.X%
                        RECT_TOOL.START_Y = MOUSE.Y%
                        RECT_TOOL.CENTER_X = MOUSE.X%
                        RECT_TOOL.CENTER_Y = MOUSE.Y%
                        RECT_TOOL.END_X = MOUSE.X%
                        RECT_TOOL.END_Y = MOUSE.Y%
                        RECT_TOOL.FILLED = (CURRENT_TOOL% = TOOL_RECT_FILLED)
                    ELSE
                        ' Update end position while dragging
                        DIM temp_end_x AS INTEGER, temp_end_y AS INTEGER
                        temp_end_x% = MOUSE.X%
                        temp_end_y% = MOUSE.Y%
                        
                        ' SHIFT: Constrain to square (calculate from center)
                        IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                            DIM size AS INTEGER
                            size% = INT(SQR((temp_end_x% - RECT_TOOL.CENTER_X) ^ 2 + (temp_end_y% - RECT_TOOL.CENTER_Y) ^ 2))
                            IF temp_end_x% < RECT_TOOL.CENTER_X THEN size% = -size%
                            temp_end_x% = RECT_TOOL.CENTER_X + size%
                            temp_end_y% = RECT_TOOL.CENTER_Y + size%
                        END IF
                        
                        ' CTRL: Draw from center
                        IF _KEYDOWN(KEY_LCTRL&) OR _KEYDOWN(KEY_RCTRL&) THEN
                            DIM offset_x AS INTEGER, offset_y AS INTEGER
                            ' Calculate offset from center to mouse
                            offset_x% = temp_end_x% - RECT_TOOL.CENTER_X
                            offset_y% = temp_end_y% - RECT_TOOL.CENTER_Y
                            ' Set corners mirrored around center
                            RECT_TOOL.START_X = RECT_TOOL.CENTER_X - offset_x%
                            RECT_TOOL.START_Y = RECT_TOOL.CENTER_Y - offset_y%
                            RECT_TOOL.END_X = RECT_TOOL.CENTER_X + offset_x%
                            RECT_TOOL.END_Y = RECT_TOOL.CENTER_Y + offset_y%
                        ELSE
                            ' Normal mode: draw from corner
                            RECT_TOOL.START_X = RECT_TOOL.CENTER_X
                            RECT_TOOL.START_Y = RECT_TOOL.CENTER_Y
                            RECT_TOOL.END_X = temp_end_x%
                            RECT_TOOL.END_Y = temp_end_y%
                        END IF
                    END IF
                CASE TOOL_ELLIPSE, TOOL_ELLIPSE_FILLED
                    ' ELLIPSE tool: Click and drag with preview
                    IF NOT MOUSE.OLD_B1% THEN
                        ' Start dragging on first click
                        ELLIPSE_TOOL.DRAGGING = TRUE
                        ELLIPSE_TOOL.START_X = MOUSE.X%
                        ELLIPSE_TOOL.START_Y = MOUSE.Y%
                        ELLIPSE_TOOL.CENTER_X = MOUSE.X%
                        ELLIPSE_TOOL.CENTER_Y = MOUSE.Y%
                        ELLIPSE_TOOL.END_X = MOUSE.X%
                        ELLIPSE_TOOL.END_Y = MOUSE.Y%
                        ELLIPSE_TOOL.FILLED = (CURRENT_TOOL% = TOOL_ELLIPSE_FILLED)
                    ELSE
                        ' Update end position while dragging
                        DIM temp_ex AS INTEGER, temp_ey AS INTEGER
                        temp_ex% = MOUSE.X%
                        temp_ey% = MOUSE.Y%
                        
                        ' SHIFT: Constrain to circle (calculate from center)
                        IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                            DIM esize AS INTEGER
                            esize% = INT(SQR((temp_ex% - ELLIPSE_TOOL.CENTER_X) ^ 2 + (temp_ey% - ELLIPSE_TOOL.CENTER_Y) ^ 2))
                            IF temp_ex% < ELLIPSE_TOOL.CENTER_X THEN esize% = -esize%
                            temp_ex% = ELLIPSE_TOOL.CENTER_X + esize%
                            temp_ey% = ELLIPSE_TOOL.CENTER_Y + esize%
                        END IF
                        
                        ' CTRL: Draw from center
                        IF _KEYDOWN(KEY_LCTRL&) OR _KEYDOWN(KEY_RCTRL&) THEN
                            DIM eoffset_x AS INTEGER, eoffset_y AS INTEGER
                            ' Calculate offset from center to mouse
                            eoffset_x% = temp_ex% - ELLIPSE_TOOL.CENTER_X
                            eoffset_y% = temp_ey% - ELLIPSE_TOOL.CENTER_Y
                            ' Set corners mirrored around center
                            ELLIPSE_TOOL.START_X = ELLIPSE_TOOL.CENTER_X - eoffset_x%
                            ELLIPSE_TOOL.START_Y = ELLIPSE_TOOL.CENTER_Y - eoffset_y%
                            ELLIPSE_TOOL.END_X = ELLIPSE_TOOL.CENTER_X + eoffset_x%
                            ELLIPSE_TOOL.END_Y = ELLIPSE_TOOL.CENTER_Y + eoffset_y%
                        ELSE
                            ' Normal mode: draw from corner
                            ELLIPSE_TOOL.START_X = ELLIPSE_TOOL.CENTER_X
                            ELLIPSE_TOOL.START_Y = ELLIPSE_TOOL.CENTER_Y
                            ELLIPSE_TOOL.END_X = temp_ex%
                            ELLIPSE_TOOL.END_Y = temp_ey%
                        END IF
                    END IF
                CASE TOOL_BRUSH, TOOL_DOT
                    ' Reset pixel-perfect stroke on first mouse down
                    IF NOT MOUSE.OLD_B1% THEN
                        PP_STROKE_COUNT% = 0
                    END IF
                    ' Always draw while button is held
                    IF MOUSE.X% < MOUSE.OLD_X% THEN MOUSE.DRAG$ = "L"
                    IF MOUSE.X% > MOUSE.OLD_X% THEN MOUSE.DRAG$ = "R"
                    IF MOUSE.Y% < MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "U"
                    IF MOUSE.Y% > MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "D"
                    PAINT_on
            END SELECT
        ELSEIF NOT MOUSE.B1% THEN
            ' Button released - save undo state if we were drawing
            IF MOUSE.OLD_B1% AND NOT UNDO_saved_this_frame% THEN
                SELECT CASE CURRENT_TOOL%
                    CASE TOOL_MARQUEE
                        ' Finish the marquee drag, resize, or move
                        IF MARQUEE.DRAGGING% THEN
                            MARQUEE_finish_drag
                        ELSEIF MARQUEE.RESIZING% THEN
                            MARQUEE_finish_resize
                        ELSEIF MARQUEE.MOVING% THEN
                            MARQUEE_finish_move
                        END IF
                    CASE TOOL_MOVE
                        ' Mouse released - update base selection to current position for next transform
                        ' This allows multiple adjustments before ENTER confirms
                        IF MOVE.ACTIVE THEN
                            MOVE.SELECTION_X = MOVE.CURRENT_X
                            MOVE.SELECTION_Y = MOVE.CURRENT_Y
                            MOVE.SELECTION_W = MOVE.CURRENT_W
                            MOVE.SELECTION_H = MOVE.CURRENT_H
                            MOVE.TRANSFORMING = FALSE
                        END IF
                    CASE TOOL_LINE
                        ' Draw the final line on mouse release
                        IF LINE_TOOL.DRAGGING THEN
                            _DEST SCRN.PAINTING&
                            IF CUSTOM_BRUSH_is_active% THEN
                                ' Use custom brush stamps along the line
                                CUSTOM_BRUSH_stamp_line LINE_TOOL.START_X, LINE_TOOL.START_Y, LINE_TOOL.END_X, LINE_TOOL.END_Y
                            ELSE
                                ' Normal line drawing
                                LINE (LINE_TOOL.START_X, LINE_TOOL.START_Y)-(LINE_TOOL.END_X, LINE_TOOL.END_Y), PAINT_COLOR~&
                            END IF
                            _DEST SCRN.CANVAS&
                            LINE_TOOL.DRAGGING = FALSE
                            CANVAS_DIRTY% = TRUE
                            UNDO_save_state ' Save state after drawing line
                            UNDO_saved_this_frame% = TRUE
                        END IF
                    CASE TOOL_RECT, TOOL_RECT_FILLED
                        ' Draw the final rectangle on mouse release
                        IF RECT_TOOL.DRAGGING THEN
                            _DEST SCRN.PAINTING&
                            IF CUSTOM_BRUSH_is_active% AND NOT RECT_TOOL.FILLED THEN
                                ' Use custom brush stamps for outline only
                                CUSTOM_BRUSH_stamp_line RECT_TOOL.START_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.START_Y ' Top
                                CUSTOM_BRUSH_stamp_line RECT_TOOL.END_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.END_Y     ' Right
                                CUSTOM_BRUSH_stamp_line RECT_TOOL.END_X, RECT_TOOL.END_Y, RECT_TOOL.START_X, RECT_TOOL.END_Y     ' Bottom
                                CUSTOM_BRUSH_stamp_line RECT_TOOL.START_X, RECT_TOOL.END_Y, RECT_TOOL.START_X, RECT_TOOL.START_Y ' Left
                            ELSE
                                ' Normal rectangle drawing
                                IF RECT_TOOL.FILLED THEN
                                    ' Check if NumLock is OFF and dither pattern is active
                                    IF NOT _NUMLOCK AND BRUSH_DITHER_ACTIVE > 0 THEN
                                        ' Use dither pattern fill
                                        DIM rx AS INTEGER, ry AS INTEGER
                                        DIM min_x AS INTEGER, max_x AS INTEGER, min_y AS INTEGER, max_y AS INTEGER
                                        min_x% = RECT_TOOL.START_X: max_x% = RECT_TOOL.END_X
                                        IF min_x% > max_x% THEN SWAP min_x%, max_x%
                                        min_y% = RECT_TOOL.START_Y: max_y% = RECT_TOOL.END_Y
                                        IF min_y% > max_y% THEN SWAP min_y%, max_y%
                                        FOR ry% = min_y% TO max_y%
                                            FOR rx% = min_x% TO max_x%
                                                IF BRUSH_DITHERS_should_draw%(rx%, ry%) THEN
                                                    PSET (rx%, ry%), PAINT_COLOR~&
                                                END IF
                                            NEXT rx%
                                        NEXT ry%
                                    ELSE
                                        LINE (RECT_TOOL.START_X, RECT_TOOL.START_Y)-(RECT_TOOL.END_X, RECT_TOOL.END_Y), PAINT_COLOR~&, BF
                                    END IF
                                ELSE
                                    LINE (RECT_TOOL.START_X, RECT_TOOL.START_Y)-(RECT_TOOL.END_X, RECT_TOOL.END_Y), PAINT_COLOR~&, B
                                END IF
                            END IF
                            _DEST SCRN.CANVAS&
                            RECT_TOOL.DRAGGING = FALSE
                            CANVAS_DIRTY% = TRUE
                            UNDO_save_state ' Save state after drawing rectangle
                            UNDO_saved_this_frame% = TRUE
                        END IF
                    CASE TOOL_ELLIPSE, TOOL_ELLIPSE_FILLED
                        ' Draw the final ellipse on mouse release
                        IF ELLIPSE_TOOL.DRAGGING THEN
                            DIM ecx AS INTEGER, ecy AS INTEGER, erx AS SINGLE, ery AS SINGLE, easp AS SINGLE
                            ecx% = (ELLIPSE_TOOL.START_X + ELLIPSE_TOOL.END_X) \ 2
                            ecy% = (ELLIPSE_TOOL.START_Y + ELLIPSE_TOOL.END_Y) \ 2
                            erx! = ABS(ELLIPSE_TOOL.END_X - ELLIPSE_TOOL.START_X) / 2
                            ery! = ABS(ELLIPSE_TOOL.END_Y - ELLIPSE_TOOL.START_Y) / 2
                            IF erx! > 0 THEN easp! = ery! / erx! ELSE easp! = 1
                            _DEST SCRN.PAINTING&
                            IF erx! > 0 THEN
                                IF CUSTOM_BRUSH_is_active% AND NOT ELLIPSE_TOOL.FILLED THEN
                                    ' Use custom brush stamps for outline only
                                    CUSTOM_BRUSH_stamp_ellipse ecx%, ecy%, erx!, ery!
                                ELSE
                                    ' Normal ellipse drawing
                                    IF ELLIPSE_TOOL.FILLED THEN
                                        ' Draw filled ellipse using scanline algorithm
                                        CIRCLE (ecx%, ecy%), erx!, PAINT_COLOR~&, , , easp!
                                        ELLIPSE_fill_scanline ecx%, ecy%, erx!, ery!, PAINT_COLOR~&, SCRN.PAINTING&
                                    ELSE
                                        ' Draw ellipse outline
                                        CIRCLE (ecx%, ecy%), erx!, PAINT_COLOR~&, , , easp!
                                    END IF
                                END IF
                            END IF
                            _DEST SCRN.CANVAS&
                            ELLIPSE_TOOL.DRAGGING = FALSE
                            CANVAS_DIRTY% = TRUE
                            UNDO_save_state ' Save state after drawing ellipse
                            UNDO_saved_this_frame% = TRUE
                        END IF
                    CASE TOOL_BRUSH, TOOL_DOT
                        ' Draw collected pixel perfect stroke if enabled
                        IF BRUSH_SIZE.PIXEL_PERFECT AND PP_STROKE_COUNT% > 0 THEN
                            PAINT_draw_pixel_perfect
                        END IF
                        CANVAS_DIRTY% = TRUE
                        PP_STROKE_COUNT% = 0
                        UNDO_save_state
                        UNDO_saved_this_frame% = TRUE
                    CASE TOOL_TEXT
                        ' TEXT tool applies via ESC key or clicking elsewhere
                        ' TEXT_apply() saves undo, so just set flag to prevent double-save
                        ' Note: This case only triggers if mouse was released after TEXT.ACTIVE
                        _LOGINFO "MOUSE release TOOL_TEXT: TEXT.ACTIVE=" + STR$(TEXT.ACTIVE) + " flag=" + STR$(UNDO_saved_this_frame%)
                        IF TEXT.ACTIVE THEN
                            UNDO_saved_this_frame% = TRUE
                        END IF
                END SELECT
            END IF
            MOUSE.DRAG$ = ""
            MOUSE.CON_X% = 0 : MOUSE.CON_Y% = 0
            CONSTRAIN_X% = FALSE : CONSTRAIN_Y% = FALSE
        END IF
        
        ' Right Click handling for different tools
        IF MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
            ' SHIFT + Right Click: Draw line from last dot to current position (DOT tool only)
            IF CURRENT_TOOL% = TOOL_DOT AND (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&)) THEN
                IF DOT.HAS_LAST THEN
                    ' Undo the origin dot first (so the line replaces it, not adds to it)
                    UNDO_undo
                    ' Draw line from last position to current position
                    _DEST SCRN.PAINTING&
                    LINE (DOT.LAST_X, DOT.LAST_Y)-(MOUSE.X%, MOUSE.Y%), PAINT_COLOR~&
                    _DEST SCRN.CANVAS&
                    ' Update last position to current position
                    DOT.LAST_X = MOUSE.X%
                    DOT.LAST_Y = MOUSE.Y%
                    ' Save undo state (captures just the line, not the origin dot)
                    UNDO_save_state
                    UNDO_saved_this_frame% = TRUE
                    CANVAS_DIRTY% = TRUE
                END IF
            ' Right Click on POLY_LINE tool: finish poly line (stop drawing)
            ELSEIF CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED THEN
                ' Close the shape if filled polygon
                IF CURRENT_TOOL% = TOOL_POLYGON_FILLED AND POLY_LINE.HAS_LAST AND POLY_LINE.POINT_COUNT >= 3 THEN
                    ' Draw closing line
                    _DEST SCRN.PAINTING&
                    IF CUSTOM_BRUSH_is_active% THEN
                        ' Use custom brush stamps for closing line
                        CUSTOM_BRUSH_stamp_line POLY_LINE.LAST_X, POLY_LINE.LAST_Y, POLY_LINE.FIRST_X, POLY_LINE.FIRST_Y
                    ELSE
                        ' Normal line drawing
                        LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y)-(POLY_LINE.FIRST_X, POLY_LINE.FIRST_Y), PAINT_COLOR~&
                    END IF
                    ' Use scanline fill algorithm for proper polygon filling (only if not using custom brush)
                    IF NOT CUSTOM_BRUSH_is_active% THEN
                        POLY_FILL_scanline POLY_POINTS_X(), POLY_POINTS_Y(), POLY_LINE.POINT_COUNT, PAINT_COLOR~&, SCRN.PAINTING&
                    END IF
                    _DEST SCRN.CANVAS&
                    CANVAS_DIRTY% = TRUE
                END IF
                POLY_LINE_reset
            END IF
        END IF
        
        ' Right button handlers (B2)
        IF MOUSE.B2% THEN
            ' Right click with picker: pick background color
            IF CURRENT_TOOL% = TOOL_PICKER AND PICKER.ACTIVE% AND NOT MOUSE.OLD_B2% THEN
                PICKER_pick_color MOUSE.X%, MOUSE.Y%, 2  ' 2 = right button/background
            END IF
        END IF

        IF (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&)) AND NOT CONSTRAIN_X% AND NOT CONSTRAIN_Y% THEN
            IF MOUSE.DRAG$ = "L" OR MOUSE.DRAG$ = "R" THEN
                MOUSE.CON_Y% = MOUSE.Y%
                CONSTRAIN_X% = FALSE
                CONSTRAIN_Y% = TRUE
            ELSEIF MOUSE.DRAG$ = "U" OR MOUSE.DRAG$ = "D" THEN
                MOUSE.CON_X% = MOUSE.X%
                CONSTRAIN_X% = TRUE
                CONSTRAIN_Y% = FALSE
            END IF
        END IF
    END IF ' End drain-then-process block
    
    ' Process accumulated wheel delta for zoom/brush size (outside event loop)
    IF wheel_delta% <> 0 THEN
        MOUSE.SW% = wheel_delta%
        
        ' Check if over palette strip or menu first
        IF PALETTE_STRIP_in_bounds%(MOUSE.X%, MOUSE.Y%) OR PALETTE_MENU_in_bounds%(MOUSE.X%, MOUSE.Y%) THEN
            PALETTE_STRIP_handle_wheel MOUSE.SW%
        ' Check if CTRL is held for brush size adjustment
        ELSEIF (_KEYDOWN(100305) OR _KEYDOWN(100306)) THEN ' Right or Left CTRL
            ' CTRL+Wheel adjusts brush size
            ' Wheel up (negative) should increase, wheel down (positive) should decrease
            IF MOUSE.SW% < 0 THEN
                BRUSH_SIZE_increase
            ELSEIF MOUSE.SW% > 0 THEN
                BRUSH_SIZE_decrease
            END IF
        ELSE
            ' Mouse wheel without CTRL: zoom in/out
            ' Above 100%: Always use 100% increments (both in and out)
            ' At/below 100%: Zoom IN snaps to 100%, Zoom OUT uses 25%
            ' Zoom centered on mouse cursor position
            DIM oldZoom AS SINGLE
            DIM mouseScreenX AS INTEGER, mouseScreenY AS INTEGER
            oldZoom! = SCRN.zoom!
            
            ' Get mouse screen position BEFORE zoom changes
            mouseScreenX% = _MOUSEX
            mouseScreenY% = _MOUSEY
            
            IF MOUSE.SW% < 0 THEN
                ' Wheel down = zoom in
                IF SCRN.zoom! < 1.0 THEN
                    SCRN.zoom! = 1.0  ' Snap to 100% from any fractional zoom
                ELSE
                    SCRN.zoom! = INT(SCRN.zoom!) + 1.0  ' Next whole 100% (200%, 300%, etc.)
                END IF
                IF SCRN.zoom! > SCRN.zoomMax! THEN SCRN.zoom! = SCRN.zoomMax!
            ELSEIF MOUSE.SW% > 0 THEN
                ' Wheel up = zoom out
                IF SCRN.zoom! > 1.0 THEN
                    ' Above 100%: zoom out by whole 100% (200% → 100%, 300% → 200%)
                    SCRN.zoom! = INT(SCRN.zoom!) - 1.0
                ELSE
                    ' At/below 100%: zoom out by 25% (100% → 75% → 50% → 25%)
                    SCRN.zoom! = SCRN.zoom! - 0.25
                END IF
                IF SCRN.zoom! < SCRN.zoomMin! THEN SCRN.zoom! = SCRN.zoomMin!
            END IF
            
            ' Adjust offset to keep mouse over same canvas point
            IF SCRN.zoom! <> oldZoom! THEN
                ' Calculate canvas center offset at old zoom
                DIM old_zw AS LONG, old_zh AS LONG
                old_zw& = SCRN.w& * oldZoom!
                old_zh& = SCRN.h& * oldZoom!
                DIM old_center_x AS INTEGER, old_center_y AS INTEGER
                old_center_x% = (_WIDTH - old_zw&) \ 2
                old_center_y% = (_HEIGHT - old_zh&) \ 2
                
                ' Canvas position under mouse at old zoom
                DIM canvasX AS SINGLE, canvasY AS SINGLE
                canvasX! = (mouseScreenX% - old_center_x% - SCRN.offsetX%) / oldZoom!
                canvasY! = (mouseScreenY% - old_center_y% - SCRN.offsetY%) / oldZoom!
                
                ' Calculate new canvas center offset at new zoom
                DIM new_zw AS LONG, new_zh AS LONG
                new_zw& = SCRN.w& * SCRN.zoom!
                new_zh& = SCRN.h& * SCRN.zoom!
                DIM new_center_x AS INTEGER, new_center_y AS INTEGER
                new_center_x% = (_WIDTH - new_zw&) \ 2
                new_center_y% = (_HEIGHT - new_zh&) \ 2
                
                ' Calculate new offset to keep canvas point at mouse screen position
                SCRN.offsetX% = mouseScreenX% - new_center_x% - (canvasX! * SCRN.zoom!)
                SCRN.offsetY% = mouseScreenY% - new_center_y% - (canvasY! * SCRN.zoom!)
            END IF
        END IF
        MOUSE.OSW% = MOUSE.SW%
    END IF
    
    ' Update marquee every frame for keyboard controls and handle hover detection
    IF CURRENT_TOOL% = TOOL_MARQUEE AND MARQUEE.ACTIVE% THEN
        MARQUEE_update MOUSE.X%, MOUSE.Y%
    END IF
END SUB


''
' Finishing stuff in the mouse input loop
' 
SUB MOUSE_input_handler_loop ()
    MOUSE.OLD_X% = MOUSE.X% : MOUSE.OLD_Y% = MOUSE.Y%
    MOUSE.OLD_B1% = MOUSE.B1%
    MOUSE.OLD_B2% = MOUSE.B2%
    MOUSE.OLD_B3% = MOUSE.B3%
    
    ' Process deferred actions (file dialogs) after all mouse processing is complete
    IF MOUSE.DEFERRED_ACTION% = 1 THEN
        ' Save action
        SAVE_image
        MOUSE.DEFERRED_ACTION% = 0
    ELSEIF MOUSE.DEFERRED_ACTION% = 2 THEN
        ' Load action
        LOAD_image
        MOUSE.DEFERRED_ACTION% = 0
    END IF
END SUB
