''
' DRAW - INPUT/MOUSE.BM
' =============================================================================
' Mouse input handling subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initializes the mouse
' 
SUB MOUSE_init ()
    MOUSE.X%     = 1
    MOUSE.Y%     = 1
    MOUSE.OLD_X% = 1
    MOUSE.OLD_Y% = 1
    MOUSE.CON_X% = 0
    MOUSE.CON_Y% = 0
    MOUSE.OSW%   = 0
    MOUSE.B1%    = FALSE
    MOUSE.B2%    = FALSE
    MOUSE.B3%    = FALSE
    MOUSE.OLD_B1% = FALSE
    MOUSE.OLD_B3% = FALSE
    MOUSE.DRAG$  = ""
    MOUSE.B3_CLICK_TIME# = 0
    MOUSE.DEFERRED_ACTION% = 0
END SUB


''
' Reset mouse button states (call after dialogs to prevent button state desync)
' Syncs current and old states to actual hardware state to prevent false clicks
'
SUB MOUSE_reset_buttons ()
    ' Clear any pending mouse input first
    DO WHILE _MOUSEINPUT : LOOP
    
    ' Read actual current button states from hardware
    DIM current_b1 AS INTEGER
    DIM current_b2 AS INTEGER
    DIM current_b3 AS INTEGER
    current_b1% = _MOUSEBUTTON(1)
    current_b2% = _MOUSEBUTTON(2)
    current_b3% = _MOUSEBUTTON(3)
    
    ' Set both current AND old to same values (no transition = no click detection)
    MOUSE.B1% = current_b1%
    MOUSE.B2% = current_b2%
    MOUSE.B3% = current_b3%
    MOUSE.OLD_B1% = current_b1%
    MOUSE.OLD_B2% = current_b2%
    MOUSE.OLD_B3% = current_b3%
    MOUSE.TOOLBAR_CLICKED% = FALSE
END SUB


''
' Forces all mouse buttons to UP state (used after dialogs to prevent phantom clicks)
'
SUB MOUSE_force_buttons_up ()
    ' Clear any pending mouse input first
    DO WHILE _MOUSEINPUT : LOOP
    
    ' Force all buttons to UP (FALSE) state
    MOUSE.B1% = FALSE
    MOUSE.B2% = FALSE
    MOUSE.B3% = FALSE
    MOUSE.OLD_B1% = FALSE
    MOUSE.OLD_B2% = FALSE
    MOUSE.OLD_B3% = FALSE
    MOUSE.TOOLBAR_CLICKED% = FALSE
END SUB


''
' Handles mouse input
' 
SUB MOUSE_input_handler ()
    ' ==== IMAGE IMPORT MODE - PROCESS OUTSIDE LOOP FOR PERFORMANCE ====
    ' When in image import mode, skip the normal buffered mouse processing
    ' and use direct polling for responsive interaction
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        ' Accumulate wheel delta while clearing buffered input
        DIM wheel_delta AS INTEGER
        wheel_delta% = 0
        DO WHILE _MOUSEINPUT
            wheel_delta% = wheel_delta% + _MOUSEWHEEL
        LOOP
        
        ' Get current mouse state directly (not buffered)
        DIM imp_rawX AS INTEGER, imp_rawY AS INTEGER
        DIM imp_zw AS LONG, imp_zh AS LONG, imp_dx AS INTEGER, imp_dy AS INTEGER
        
        ' Get window coordinates and scale down by display scale
        imp_rawX% = _MOUSEX \ SCRN.displayScale%
        imp_rawY% = _MOUSEY \ SCRN.displayScale%
        
        ' Store raw screen coordinates
        MOUSE.RAW_X% = imp_rawX%
        MOUSE.RAW_Y% = imp_rawY%
        
        ' Calculate zoomed canvas position on screen (using logical canvas dimensions)
        imp_zw& = SCRN.w& * SCRN.zoom!
        imp_zh& = SCRN.h& * SCRN.zoom!
        imp_dx% = (SCRN.w& - imp_zw&) \ 2 + SCRN.offsetX%
        imp_dy% = (SCRN.h& - imp_zh&) \ 2 + SCRN.offsetY%
        
        ' Offset for layer panel when visible (must match SCREEN_render)
        IF LAYER_PANEL.visible% THEN imp_dx% = imp_dx% + CFG.LAYER_PANEL_WIDTH%
        
        ' Convert screen coords to canvas coords
        MOUSE.X% = INT((imp_rawX% - imp_dx%) / SCRN.zoom!)
        MOUSE.Y% = INT((imp_rawY% - imp_dy%) / SCRN.zoom!)
        
        ' Clamp to canvas bounds
        IF MOUSE.X% < 0 THEN MOUSE.X% = 0
        IF MOUSE.Y% < 0 THEN MOUSE.Y% = 0
        IF MOUSE.X% >= SCRN.w& THEN MOUSE.X% = SCRN.w& - 1
        IF MOUSE.Y% >= SCRN.h& THEN MOUSE.Y% = SCRN.h& - 1
        
        ' Get button states
        MOUSE.B1% = _MOUSEBUTTON(1)
        MOUSE.B2% = _MOUSEBUTTON(2)
        MOUSE.B3% = _MOUSEBUTTON(3)
        
        ' Handle mouse wheel for zoom (accumulated from buffer)
        IF wheel_delta% <> 0 THEN
            IMAGE_IMPORT_zoom -wheel_delta%  ' Negative: wheel up = zoom in
        END IF
        
        ' Track hover handle for visual feedback
        IF IMG_IMPORT.STATE >= IMPORT_STATE_PLACING AND NOT IMG_IMPORT.RESIZING THEN
            IMG_IMPORT.HOVER_HANDLE = IMAGE_IMPORT_get_handle_at%(MOUSE.X%, MOUSE.Y%)
        ELSE
            IMG_IMPORT.HOVER_HANDLE = 0
        END IF
        
        ' Handle mouse button interactions
        IF MOUSE.B1% THEN
            IF NOT MOUSE.OLD_B1% THEN
                ' Button just pressed - determine action based on state
                IF IMG_IMPORT.STATE = IMPORT_STATE_LOADED THEN
                    ' No marquee yet - start drawing one
                    IMAGE_IMPORT_start_placement MOUSE.X%, MOUSE.Y%
                ELSEIF IMG_IMPORT.STATE >= IMPORT_STATE_PLACING THEN
                    ' Have a placement - check for handle/pan/new marquee
                    DIM import_handle AS INTEGER
                    import_handle% = IMAGE_IMPORT_get_handle_at%(MOUSE.X%, MOUSE.Y%)
                    IF import_handle% > 0 THEN
                        IMAGE_IMPORT_start_resize import_handle%, MOUSE.X%, MOUSE.Y%
                    ELSEIF IMAGE_IMPORT_is_point_inside%(MOUSE.X%, MOUSE.Y%) THEN
                        IMAGE_IMPORT_start_pan MOUSE.X%, MOUSE.Y%
                    ELSE
                        ' Click outside - start new marquee
                        IMG_IMPORT.STATE = IMPORT_STATE_LOADED
                        IMAGE_IMPORT_start_placement MOUSE.X%, MOUSE.Y%
                    END IF
                END IF
            ELSE
                ' Button held - update current operation
                IF IMG_IMPORT.DRAGGING THEN
                    IMAGE_IMPORT_update_placement MOUSE.X%, MOUSE.Y%
                ELSEIF IMG_IMPORT.RESIZING THEN
                    IMAGE_IMPORT_update_resize MOUSE.X%, MOUSE.Y%
                ELSEIF IMG_IMPORT.PANNING THEN
                    IMAGE_IMPORT_update_pan MOUSE.X%, MOUSE.Y%
                END IF
            END IF
        ELSE
            ' Button released - finish current operation
            IF IMG_IMPORT.DRAGGING THEN
                IMAGE_IMPORT_finish_placement
            ELSEIF IMG_IMPORT.RESIZING THEN
                IMAGE_IMPORT_finish_resize
            ELSEIF IMG_IMPORT.PANNING THEN
                IMAGE_IMPORT_finish_pan
            END IF
        END IF
        
        ' Update old mouse state
        MOUSE.OLD_B1% = MOUSE.B1%
        MOUSE.OLD_B2% = MOUSE.B2%
        MOUSE.OLD_B3% = MOUSE.B3%
        MOUSE.OLD_X% = MOUSE.X%
        MOUSE.OLD_Y% = MOUSE.Y%
        
        ' Exit early - don't process normal mouse handling during import
        EXIT SUB
    END IF
    ' ==== END IMAGE IMPORT MODE ====
    
    ' ==== DRAIN-THEN-PROCESS PATTERN FOR PERFORMANCE ====
    ' Drain all buffered mouse events and accumulate wheel delta
    wheel_delta% = 0
    DO WHILE _MOUSEINPUT
        wheel_delta% = wheel_delta% + _MOUSEWHEEL
    LOOP
    
    ' Now process ONCE with final mouse state (not per-event)
    IF TRUE THEN ' Block for consistent indentation
        ' Get raw screen coordinates and convert to canvas coordinates
        DIM rawX AS INTEGER, rawY AS INTEGER
        DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
        DIM AS INTEGER TB_RIGHT, TB_LEFT
        
        ' Calculate toolbar position dynamically to align to right edge of screen
        TB_RIGHT = SCRN.w& - TB_BTN_W - 1  ' Right column: 1px from right edge
        TB_LEFT = TB_RIGHT - TB_BTN_W - TB_BTN_PADDING  ' Left column: to the left of right column
        
        ' Get window coordinates and scale down by display scale
        rawX% = _MOUSEX \ SCRN.displayScale%
        rawY% = _MOUSEY \ SCRN.displayScale%
        
        ' Store raw screen coordinates for GUI hover detection
        MOUSE.RAW_X% = rawX%
        MOUSE.RAW_Y% = rawY%
        
        ' Calculate zoomed canvas position on screen (using logical canvas dimensions)
        zw& = SCRN.w& * SCRN.zoom!
        zh& = SCRN.h& * SCRN.zoom!
        dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
        dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%
        
        ' Offset canvas X when layer panel is visible
        IF LAYER_PANEL.visible% THEN dx% = dx% + CFG.LAYER_PANEL_WIDTH%
        
        ' Convert screen coords to canvas coords
        MOUSE.X% = INT((rawX% - dx%) / SCRN.zoom!)
        MOUSE.Y% = INT((rawY% - dy%) / SCRN.zoom!)
        
        ' Apply snap-to-grid if enabled
        IF GRID.SNAP% THEN
            MOUSE.X% = GRID_snap%(MOUSE.X%)
            MOUSE.Y% = GRID_snap%(MOUSE.Y%)
        END IF
        
        ' Clamp to canvas bounds
        IF MOUSE.X% < 0 THEN MOUSE.X% = 0
        IF MOUSE.Y% < 0 THEN MOUSE.Y% = 0
        IF MOUSE.X% >= SCRN.w& THEN MOUSE.X% = SCRN.w& - 1
        IF MOUSE.Y% >= SCRN.h& THEN MOUSE.Y% = SCRN.h& - 1
        
        ' Update button states from hardware
        MOUSE.B1% = _MOUSEBUTTON(1)
        MOUSE.B2% = _MOUSEBUTTON(2)
        MOUSE.B3% = _MOUSEBUTTON(3)
        
        ' Close palette menu when clicking outside its bounds
        IF PALETTE_MENU_VISIBLE% AND MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
            IF NOT PALETTE_MENU_in_bounds%(rawX%, rawY%) THEN
                ' Check if click is NOT on the palette name trigger area (to prevent reopening)
                IF NOT PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN
                    PALETTE_MENU_hide
                    GUI_NEEDS_REDRAW% = TRUE
                END IF
            END IF
        END IF
        
        ' Check for CTRL+click to set symmetry center (before other button processing)
        IF (_KEYDOWN(KEY_LCTRL&) OR _KEYDOWN(KEY_RCTRL&)) AND MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
            ' CTRL+Left click - set symmetry center
            SYMMETRY_set_center MOUSE.X%, MOUSE.Y%
            ' Mark as toolbar clicked to prevent drawing action
            MOUSE.TOOLBAR_CLICKED% = TRUE
        END IF
        
        ' Set drawing color based on active mouse button
        ' Left button (B1) uses foreground, Right button (B2) uses background
        DIM draw_button AS INTEGER
        draw_button% = MOUSE.B1% OR MOUSE.B2%
        IF MOUSE.B2% THEN
            DRAW_COLOR~& = PAINT_BG_COLOR~&
        ELSE
            DRAW_COLOR~& = PAINT_COLOR~&
        END IF
        
        ' Reset toolbar clicked flag only when mouse button is released
        IF NOT MOUSE.B1% AND NOT MOUSE.B2% THEN
            MOUSE.TOOLBAR_CLICKED% = FALSE
        END IF
        
        ' Check for layer panel clicks (only when not panning)
        IF NOT SCRN.panning% AND LAYER_PANEL.visible% THEN
            IF LAYER_PANEL_in_bounds%(rawX%, rawY%) THEN
                ' Handle left-click on layer panel
                IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                    IF LAYER_PANEL_handle_click%(rawX%, rawY%, 1) THEN
                        MOUSE.TOOLBAR_CLICKED% = TRUE  ' Block canvas action
                    END IF
                END IF
                ' Handle right-click on layer panel
                IF MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
                    IF LAYER_PANEL_handle_click%(rawX%, rawY%, 2) THEN
                        MOUSE.TOOLBAR_CLICKED% = TRUE  ' Block canvas action
                    END IF
                END IF
                ' Handle mouse wheel for scrolling layer list or adjusting opacity
                IF wheel_delta% <> 0 THEN
                    LAYER_PANEL_handle_wheel rawX%, rawY%, wheel_delta%
                    wheel_delta% = 0  ' Consume wheel event - don't zoom canvas
                END IF
            END IF
        END IF
        
        ' Check for toolbar clicks (only when not panning)
        IF NOT SCRN.panning% AND MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
            ' Check if clicking on toolbar area (raw screen coordinates)
            IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN
                ' Only set TOOLBAR_CLICKED if an actual button was hit
                IF TOOLBAR_handle_click%(rawX%, rawY%) THEN
                    MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
                END IF
            END IF
            ' Check if clicking on status bar area (bottom of screen)
            IF SCRN.showStatus% AND rawY% >= (SCRN.h& - 10) THEN
                STATUS_handle_click rawX%, rawY%
                MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
            END IF
            ' Check if clicking on palette strip area (above status bar) or menu
            IF SCRN.showStatus% AND (PALETTE_STRIP_in_bounds%(rawX%, rawY%) OR PALETTE_MENU_in_bounds%(rawX%, rawY%)) THEN
                PALETTE_STRIP_handle_click rawX%, rawY%
                MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
            END IF
        END IF
        
        ' Check for right-click on palette strip (for background color)
        IF NOT SCRN.panning% AND MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
            IF SCRN.showStatus% AND PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN
                PALETTE_STRIP_handle_click rawX%, rawY%
                MOUSE.TOOLBAR_CLICKED% = TRUE
            END IF
        END IF
        
        ' Check for right-click on toolbar (for alternate tool modes)
        IF NOT SCRN.panning% AND MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
            IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN
                TOOLBAR_handle_right_click rawX%, rawY%
            END IF
        END IF
        
        ' Check for middle-click on toolbar (for custom font loading on text tool)
        IF NOT SCRN.panning% AND MOUSE.B3% AND NOT MOUSE.OLD_B3% THEN
            IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN
                TOOLBAR_handle_middle_click rawX%, rawY%
            END IF
        END IF
        
        ' Check for ALT key press to activate temporary color picker
        ' Only for drawing tools - NOT for MOVE (ALT=clone), MARQUEE, IMAGE_IMPORT, NULL, etc.
        ' Also skip if CTRL or SHIFT are held (likely a hotkey combo like CTRL+ALT+SHIFT)
        DIM isDrawingTool%
        DIM isCtrlOrShiftHeld%
        DIM altHeld%
        STATIC altWasHeld%  ' Track ALT state from previous frame
        STATIC pickerFromAlt%  ' Track if we entered picker via ALT key
        
        isCtrlOrShiftHeld% = (_KEYDOWN(100305) OR _KEYDOWN(100306) OR _KEYDOWN(100304) OR _KEYDOWN(100303))
        altHeld% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
        
        ' Check if current tool (or previous tool if in picker mode) is a drawing tool
        IF CURRENT_TOOL% = TOOL_PICKER AND pickerFromAlt% THEN
            ' When in ALT-triggered picker mode, check PREVIOUS_TOOL to know if we came from a drawing tool
            isDrawingTool% = (PREVIOUS_TOOL% = TOOL_DOT OR PREVIOUS_TOOL% = TOOL_BRUSH OR _
                             PREVIOUS_TOOL% = TOOL_LINE OR PREVIOUS_TOOL% = TOOL_RECT OR _
                             PREVIOUS_TOOL% = TOOL_RECT_FILLED OR PREVIOUS_TOOL% = TOOL_ELLIPSE OR _
                             PREVIOUS_TOOL% = TOOL_ELLIPSE_FILLED OR PREVIOUS_TOOL% = TOOL_FILL OR _
                             PREVIOUS_TOOL% = TOOL_POLYGON OR PREVIOUS_TOOL% = TOOL_POLYGON_FILLED OR _
                             PREVIOUS_TOOL% = TOOL_TEXT)
        ELSE
            isDrawingTool% = (CURRENT_TOOL% = TOOL_DOT OR CURRENT_TOOL% = TOOL_BRUSH OR _
                             CURRENT_TOOL% = TOOL_LINE OR CURRENT_TOOL% = TOOL_RECT OR _
                             CURRENT_TOOL% = TOOL_RECT_FILLED OR CURRENT_TOOL% = TOOL_ELLIPSE OR _
                             CURRENT_TOOL% = TOOL_ELLIPSE_FILLED OR CURRENT_TOOL% = TOOL_FILL OR _
                             CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED OR _
                             CURRENT_TOOL% = TOOL_TEXT)
        END IF
        
        ' Only ENTER picker mode when ALT is FIRST pressed (transition), not just held
        ' This prevents re-entering picker when releasing other modifiers while ALT is still held
        DIM altJustPressed%
        altJustPressed% = (altHeld% AND NOT altWasHeld%)
        
        IF altJustPressed% AND isDrawingTool% AND NOT isCtrlOrShiftHeld% THEN
            ' ALT just pressed alone with a drawing tool - enter picker mode
            IF CURRENT_TOOL% <> TOOL_PICKER THEN
                PREVIOUS_TOOL% = CURRENT_TOOL%
                CURRENT_TOOL% = TOOL_PICKER
                GUI_NEEDS_REDRAW% = TRUE
                PICKER_activate
                FILL_deactivate
                pickerFromAlt% = TRUE
            END IF
        ELSEIF pickerFromAlt% THEN
            ' We're in ALT-triggered picker mode - check if we should exit
            IF NOT altHeld% OR isCtrlOrShiftHeld% THEN
                ' Exit picker mode: ALT released OR other modifiers added
                IF CURRENT_TOOL% = TOOL_PICKER AND PREVIOUS_TOOL% <> TOOL_PICKER THEN
                    CURRENT_TOOL% = PREVIOUS_TOOL%
                    GUI_NEEDS_REDRAW% = TRUE
                    PICKER_deactivate
                    IF CURRENT_TOOL% = TOOL_FILL THEN
                        FILL_activate
                    END IF
                END IF
                pickerFromAlt% = FALSE
            END IF
        END IF
        
        ' Pick color on left click while in ALT-picker mode
        IF pickerFromAlt% AND CURRENT_TOOL% = TOOL_PICKER THEN
            IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                PICKER_pick_color MOUSE.X%, MOUSE.Y%, 1
            END IF
        END IF
        
        ' Update ALT state for next frame
        altWasHeld% = altHeld%
        
        ' Check for double middle-click to reset zoom and position
        IF MOUSE.B3% AND NOT MOUSE.OLD_B3% THEN
            DIM clickTime AS DOUBLE
            clickTime# = TIMER
            IF clickTime# - MOUSE.B3_CLICK_TIME# < 0.3 THEN ' 300ms double-click threshold
                ' Double-click detected - reset zoom and position
                SCRN.zoom! = 1.0
                SCRN.offsetX% = 0
                SCRN.offsetY% = 0
                MOUSE.B3_CLICK_TIME# = 0 ' Reset to prevent triple-click triggering
            ELSE
                MOUSE.B3_CLICK_TIME# = clickTime#
            END IF
        END IF
        
        ' Auto-hide UI when actively dragging with a tool (not when clicking toolbar)
        ' Only hide when button was already down (OLD_B1%) and we're not clicking on UI
        ' Skip auto-hide for NULL tool - let user freely access toolbar/status
        ' Also check shape tools that are in "drawing" state (LINE, RECT, ELLIPSE, POLY_LINE)
        DIM shapeToolDrawing%
        shapeToolDrawing% = LINE_TOOL.DRAGGING OR RECT_TOOL.DRAGGING OR ELLIPSE_TOOL.DRAGGING OR POLY_LINE.HAS_LAST
        
        DIM activelyDrawing%
        activelyDrawing% = (MOUSE.B1% AND MOUSE.OLD_B1%) OR shapeToolDrawing%
        
        IF CURRENT_TOOL% <> TOOL_NULL AND activelyDrawing% AND NOT SCRN.panning% AND NOT MOUSE.TOOLBAR_CLICKED% THEN
            ' Check if mouse is over an actual toolbar button (not empty toolbar area)
            IF SCRN.showToolbar% AND TOOLBAR_is_over_button%(rawX%, rawY%) THEN
                SCRN.showToolbar% = FALSE
                SCRN.toolbarManuallyHidden% = FALSE ' This is auto-hide, not manual
            END IF
            ' Check if mouse is over status bar while drawing
            IF SCRN.showStatus% AND rawY% >= (SCRN.h& - 10) THEN
                SCRN.showStatus% = FALSE
                SCRN.statusManuallyHidden% = FALSE ' This is auto-hide, not manual
            END IF
        END IF
        
        ' Restore UI when mouse is released (only if auto-hidden, not manually hidden)
        ' For shape tools, also check that they're no longer in drawing state
        DIM canRestoreUI%
        canRestoreUI% = NOT MOUSE.B1% AND NOT shapeToolDrawing%
        
        IF canRestoreUI% THEN
            ' Restore toolbar if it was auto-hidden (not manually hidden by user)
            IF NOT SCRN.showToolbar% AND NOT SCRN.toolbarManuallyHidden% THEN
                SCRN.showToolbar% = TRUE
            END IF
            ' Restore status bar if it was auto-hidden (not manually hidden by user)
            IF NOT SCRN.showStatus% AND NOT SCRN.statusManuallyHidden% THEN
                SCRN.showStatus% = TRUE
            END IF
        END IF
        
        ' Check for pan mode (spacebar + left button OR middle mouse button)
        ' Block spacebar pan when text tool is active (SPACE needed for typing)
        DIM allowSpacePan AS INTEGER
        allowSpacePan% = NOT (CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE)
        
        IF ((_KEYDOWN(32) AND allowSpacePan%) AND MOUSE.B1%) OR MOUSE.B3% THEN ' Spacebar+LMB or MMB (blocked during text input)
            IF NOT SCRN.panning% THEN
                ' Start panning
                SCRN.panning% = TRUE
                SCRN.panStartX% = rawX%
                SCRN.panStartY% = rawY%
                SCRN.panOrigOffsetX% = SCRN.offsetX%
                SCRN.panOrigOffsetY% = SCRN.offsetY%
            ELSE
                ' Continue dragging
                SCRN.offsetX% = SCRN.panOrigOffsetX% + (rawX% - SCRN.panStartX%)
                SCRN.offsetY% = SCRN.panOrigOffsetY% + (rawY% - SCRN.panStartY%)
                
                ' If spacebar mode: reset on new button press
                IF _KEYDOWN(32) AND MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                    SCRN.panStartX% = rawX%
                    SCRN.panStartY% = rawY%
                    SCRN.panOrigOffsetX% = SCRN.offsetX%
                    SCRN.panOrigOffsetY% = SCRN.offsetY%
                END IF
            END IF
        ELSE
            ' Exit pan mode when both methods released
            IF SCRN.panning% THEN SCRN.panning% = FALSE
        END IF
        
        ' Skip tool actions if we just clicked on the toolbar
        IF MOUSE.TOOLBAR_CLICKED% THEN
            MOUSE.OLD_B1% = MOUSE.B1%
            MOUSE.OLD_B2% = MOUSE.B2%
            MOUSE.OLD_B3% = MOUSE.B3%
            MOUSE.OLD_X% = MOUSE.X%
            MOUSE.OLD_Y% = MOUSE.Y%
            EXIT SUB
        END IF
        
        ' Skip normal tool behavior if panning
        IF SCRN.panning% THEN
            ' Don't process tools while panning
        ELSEIF MOUSE.B1% OR MOUSE.B2% THEN
            ' Handle different tools based on CURRENT_TOOL (B1=left=FG, B2=right=BG)
            SELECT CASE CURRENT_TOOL%
                CASE TOOL_NULL
                    ' Null tool - does nothing (used during dialogs to prevent phantom events)
                    ' Intentionally empty
                CASE TOOL_MARQUEE
                    ' Start marquee selection, resize, or move on first click
                    IF NOT MOUSE.OLD_B1% THEN
                        ' Check if clicking on a handle
                        DIM handle AS INTEGER
                        handle% = MARQUEE_get_handle_at%(MOUSE.X%, MOUSE.Y%)
                        IF handle% > 0 THEN
                            ' Start resizing from this handle
                            MARQUEE_start_resize handle%, MOUSE.X%, MOUSE.Y%
                        ELSEIF MARQUEE_is_point_inside%(MOUSE.X%, MOUSE.Y%) THEN
                            ' Start moving the box
                            MARQUEE_start_move MOUSE.X%, MOUSE.Y%
                        ELSE
                            ' Start new marquee selection (clicking outside)
                            MARQUEE_start MOUSE.X%, MOUSE.Y%
                        END IF
                    END IF
                    ' Update resize, move, or drag position while button is held
                    IF MARQUEE.RESIZING% THEN
                        MARQUEE_update_resize MOUSE.X%, MOUSE.Y%
                    ELSEIF MARQUEE.MOVING% THEN
                        MARQUEE_update_move MOUSE.X%, MOUSE.Y%
                    ELSE
                        MARQUEE_update MOUSE.X%, MOUSE.Y%
                    END IF
                CASE TOOL_MOVE
                    ' MOVE tool: Transform the selected pixels
                    IF MOVE.ACTIVE THEN
                        ' Check ALT state for clone mode
                        DIM moveIsAlt%
                        moveIsAlt% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
                        MOVE.CLONING = moveIsAlt%
                        
                        IF NOT MOUSE.OLD_B1% THEN
                            ' Fresh click - start a drag/transform
                            ' Check if clicking on a handle or inside selection
                            DIM move_handle AS INTEGER
                            DIM marquee_handle AS INTEGER
                            marquee_handle% = MARQUEE_get_handle_at%(MOUSE.X%, MOUSE.Y%)
                            IF marquee_handle% > 0 THEN
                                ' Remap MARQUEE handle to MOVE handle numbering:
                                ' MARQUEE: 1=TL, 2=T, 3=TR, 4=L, 5=R, 6=BL, 7=B, 8=BR
                                ' MOVE:    1=TL, 2=TR, 3=BR, 4=BL, 5=T, 6=R, 7=B, 8=L
                                SELECT CASE marquee_handle%
                                    CASE 1: move_handle% = 1 ' TL corner
                                    CASE 3: move_handle% = 2 ' TR corner
                                    CASE 8: move_handle% = 3 ' BR corner
                                    CASE 6: move_handle% = 4 ' BL corner
                                    CASE 2: move_handle% = 5 ' T edge
                                    CASE 5: move_handle% = 6 ' R edge
                                    CASE 7: move_handle% = 7 ' B edge
                                    CASE 4: move_handle% = 8 ' L edge
                                END SELECT
                                ' Start resizing/scaling from this handle
                                MOVE_start_transform move_handle%, MOUSE.X%, MOUSE.Y%
                            ELSEIF MARQUEE_is_point_inside%(MOUSE.X%, MOUSE.Y%) THEN
                                ' Start moving from center (handle 0)
                                MOVE_start_transform 0, MOUSE.X%, MOUSE.Y%
                            END IF
                        ELSE
                            ' Update transform while dragging
                            IF MOVE.TRANSFORMING THEN
                                MOVE_update_transform MOUSE.X%, MOUSE.Y%
                            END IF
                        END IF
                    ELSE
                        ' MOVE tool is selected but not active - capture selection on click
                        IF NOT MOUSE.OLD_B1% THEN
                            ' Fresh click - capture the layer (or marquee if active) and start move
                            MOVE_capture_selection
                            ' Immediately start a move transform from this click position
                            MOVE_start_transform 0, MOUSE.X%, MOUSE.Y%
                        END IF
                    END IF
                CASE TOOL_FILL
                    ' Flood fill on click (only on button press, not while held)
                    IF FILL.ACTIVE% AND NOT MOUSE.OLD_B1% AND NOT UNDO_saved_this_frame% THEN
                        UNDO_saved_this_frame% = TRUE
                        FILL.COLOR~& = PAINT_COLOR~&
                        FILL_flood MOUSE.X%, MOUSE.Y%
                        UNDO_save_state ' Save state after fill
                    END IF
                CASE TOOL_PICKER
                    ' Pick color on click (only on button press, not while held)
                    IF PICKER.ACTIVE% AND NOT MOUSE.OLD_B1% THEN
                        PICKER_pick_color MOUSE.X%, MOUSE.Y%, 1  ' 1 = left button/foreground
                    END IF
                CASE TOOL_SAVE
                    ' SAVE tool: Defer save dialog to avoid calling from within mouse loop
                    IF NOT MOUSE.OLD_B1% THEN
                        MOUSE.DEFERRED_ACTION% = 1  ' 1 = save
                        ' Return to previous tool after save is triggered
                        CURRENT_TOOL% = PREVIOUS_TOOL%
                        GUI_NEEDS_REDRAW% = TRUE
                    END IF
                CASE TOOL_OPEN
                    ' LOAD tool: Defer load dialog to avoid calling from within mouse loop
                    IF NOT MOUSE.OLD_B1% THEN
                        MOUSE.DEFERRED_ACTION% = 2  ' 2 = load
                        ' Return to previous tool after load is triggered
                        CURRENT_TOOL% = PREVIOUS_TOOL%
                        GUI_NEEDS_REDRAW% = TRUE
                    END IF
                CASE TOOL_TEXT
                    ' TEXT tool: Click to start or reposition text entry
                    IF NOT MOUSE.OLD_B1% THEN
                        TEXT_start MOUSE.X%, MOUSE.Y%
                    END IF
                CASE TOOL_LINE
                    ' LINE tool: Click and drag with preview
                    IF NOT MOUSE.OLD_B1% THEN
                        ' Start dragging on first click
                        LINE_TOOL.DRAGGING = TRUE
                        LINE_TOOL.START_X = MOUSE.X%
                        LINE_TOOL.START_Y = MOUSE.Y%
                        LINE_TOOL.END_X = MOUSE.X%
                        LINE_TOOL.END_Y = MOUSE.Y%
                    ELSE
                        ' Update end position while dragging
                        LINE_TOOL.END_X = MOUSE.X%
                        LINE_TOOL.END_Y = MOUSE.Y%
                        
                        ' Apply angle snapping if Ctrl+Shift are both held
                        IF (_KEYDOWN(KEY_LCTRL&) OR _KEYDOWN(KEY_RCTRL&)) AND (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&)) THEN
                            SNAP_to_angle LINE_TOOL.START_X, LINE_TOOL.START_Y, LINE_TOOL.END_X, LINE_TOOL.END_Y, CFG.ANGLE_SNAP_DEGREES%
                        END IF
                    END IF
                CASE TOOL_POLYGON, TOOL_POLYGON_FILLED
                    ' POLY_LINE tool: Click to click connected lines
                    IF NOT MOUSE.OLD_B1% THEN
                        DIM poly_x AS INTEGER, poly_y AS INTEGER
                        poly_x% = MOUSE.X%
                        poly_y% = MOUSE.Y%
                        
                        ' Apply angle snapping if Ctrl+Shift are both held and we have a previous point
                        IF POLY_LINE.HAS_LAST AND (_KEYDOWN(KEY_LCTRL&) OR _KEYDOWN(KEY_RCTRL&)) AND (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&)) THEN
                            SNAP_to_angle POLY_LINE.LAST_X, POLY_LINE.LAST_Y, poly_x%, poly_y%, CFG.ANGLE_SNAP_DEGREES%
                        END IF
                        
                        IF POLY_LINE.HAS_LAST THEN
                            ' Draw line from last position to current (snapped) position
                            ' Note: Undo is saved only when starting the polygon, not for each segment
                            _DEST LAYER_current_image&
                            IF CUSTOM_BRUSH_is_active% THEN
                                ' Use custom brush stamps along polygon edges
                                CUSTOM_BRUSH_stamp_line POLY_LINE.LAST_X, POLY_LINE.LAST_Y, poly_x%, poly_y%
                            ELSE
                                ' Normal line drawing
                                LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y)-(poly_x%, poly_y%), PAINT_COLOR~&
                            END IF
                            _DEST SCRN.CANVAS&
                            CANVAS_DIRTY% = TRUE
                        ELSE
                            ' First point - just initialize, don't save undo yet
                            POLY_LINE.FIRST_X = poly_x%
                            POLY_LINE.FIRST_Y = poly_y%
                            POLY_LINE.POINT_COUNT = 0
                        END IF
                        ' Store this point in the array
                        IF POLY_LINE.POINT_COUNT < 1000 THEN
                            POLY_POINTS_X(POLY_LINE.POINT_COUNT) = poly_x%
                            POLY_POINTS_Y(POLY_LINE.POINT_COUNT) = poly_y%
                            POLY_LINE.POINT_COUNT = POLY_LINE.POINT_COUNT + 1
                        END IF
                        ' Update last position to current (snapped) click
                        POLY_LINE.LAST_X = poly_x%
                        POLY_LINE.LAST_Y = poly_y%
                        POLY_LINE.HAS_LAST = TRUE
                    END IF
                CASE TOOL_RECT, TOOL_RECT_FILLED
                    ' RECT tool: Click and drag with preview
                    IF NOT MOUSE.OLD_B1% THEN
                        ' Start dragging on first click
                        RECT_TOOL.DRAGGING = TRUE
                        RECT_TOOL.START_X = MOUSE.X%
                        RECT_TOOL.START_Y = MOUSE.Y%
                        RECT_TOOL.CENTER_X = MOUSE.X%
                        RECT_TOOL.CENTER_Y = MOUSE.Y%
                        RECT_TOOL.END_X = MOUSE.X%
                        RECT_TOOL.END_Y = MOUSE.Y%
                        RECT_TOOL.FILLED = (CURRENT_TOOL% = TOOL_RECT_FILLED)
                    ELSE
                        ' Update end position while dragging
                        DIM temp_end_x AS INTEGER, temp_end_y AS INTEGER
                        temp_end_x% = MOUSE.X%
                        temp_end_y% = MOUSE.Y%
                        
                        ' SHIFT: Constrain to square (calculate from center)
                        IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                            DIM size AS INTEGER
                            size% = INT(SQR((temp_end_x% - RECT_TOOL.CENTER_X) ^ 2 + (temp_end_y% - RECT_TOOL.CENTER_Y) ^ 2))
                            IF temp_end_x% < RECT_TOOL.CENTER_X THEN size% = -size%
                            temp_end_x% = RECT_TOOL.CENTER_X + size%
                            temp_end_y% = RECT_TOOL.CENTER_Y + size%
                        END IF
                        
                        ' CTRL: Draw from center
                        IF _KEYDOWN(KEY_LCTRL&) OR _KEYDOWN(KEY_RCTRL&) THEN
                            DIM offset_x AS INTEGER, offset_y AS INTEGER
                            ' Calculate offset from center to mouse
                            offset_x% = temp_end_x% - RECT_TOOL.CENTER_X
                            offset_y% = temp_end_y% - RECT_TOOL.CENTER_Y
                            ' Set corners mirrored around center
                            RECT_TOOL.START_X = RECT_TOOL.CENTER_X - offset_x%
                            RECT_TOOL.START_Y = RECT_TOOL.CENTER_Y - offset_y%
                            RECT_TOOL.END_X = RECT_TOOL.CENTER_X + offset_x%
                            RECT_TOOL.END_Y = RECT_TOOL.CENTER_Y + offset_y%
                        ELSE
                            ' Normal mode: draw from corner
                            RECT_TOOL.START_X = RECT_TOOL.CENTER_X
                            RECT_TOOL.START_Y = RECT_TOOL.CENTER_Y
                            RECT_TOOL.END_X = temp_end_x%
                            RECT_TOOL.END_Y = temp_end_y%
                        END IF
                    END IF
                CASE TOOL_ELLIPSE, TOOL_ELLIPSE_FILLED
                    ' ELLIPSE tool: Click and drag with preview
                    IF NOT MOUSE.OLD_B1% THEN
                        ' Start dragging on first click
                        ELLIPSE_TOOL.DRAGGING = TRUE
                        ELLIPSE_TOOL.START_X = MOUSE.X%
                        ELLIPSE_TOOL.START_Y = MOUSE.Y%
                        ELLIPSE_TOOL.CENTER_X = MOUSE.X%
                        ELLIPSE_TOOL.CENTER_Y = MOUSE.Y%
                        ELLIPSE_TOOL.END_X = MOUSE.X%
                        ELLIPSE_TOOL.END_Y = MOUSE.Y%
                        ELLIPSE_TOOL.FILLED = (CURRENT_TOOL% = TOOL_ELLIPSE_FILLED)
                    ELSE
                        ' Update end position while dragging
                        DIM temp_ex AS INTEGER, temp_ey AS INTEGER
                        temp_ex% = MOUSE.X%
                        temp_ey% = MOUSE.Y%
                        
                        ' SHIFT: Constrain to circle (calculate from center)
                        IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                            DIM esize AS INTEGER
                            esize% = INT(SQR((temp_ex% - ELLIPSE_TOOL.CENTER_X) ^ 2 + (temp_ey% - ELLIPSE_TOOL.CENTER_Y) ^ 2))
                            IF temp_ex% < ELLIPSE_TOOL.CENTER_X THEN esize% = -esize%
                            temp_ex% = ELLIPSE_TOOL.CENTER_X + esize%
                            temp_ey% = ELLIPSE_TOOL.CENTER_Y + esize%
                        END IF
                        
                        ' CTRL: Draw from center
                        IF _KEYDOWN(KEY_LCTRL&) OR _KEYDOWN(KEY_RCTRL&) THEN
                            DIM eoffset_x AS INTEGER, eoffset_y AS INTEGER
                            ' Calculate offset from center to mouse
                            eoffset_x% = temp_ex% - ELLIPSE_TOOL.CENTER_X
                            eoffset_y% = temp_ey% - ELLIPSE_TOOL.CENTER_Y
                            ' Set corners mirrored around center
                            ELLIPSE_TOOL.START_X = ELLIPSE_TOOL.CENTER_X - eoffset_x%
                            ELLIPSE_TOOL.START_Y = ELLIPSE_TOOL.CENTER_Y - eoffset_y%
                            ELLIPSE_TOOL.END_X = ELLIPSE_TOOL.CENTER_X + eoffset_x%
                            ELLIPSE_TOOL.END_Y = ELLIPSE_TOOL.CENTER_Y + eoffset_y%
                        ELSE
                            ' Normal mode: draw from corner
                            ELLIPSE_TOOL.START_X = ELLIPSE_TOOL.CENTER_X
                            ELLIPSE_TOOL.START_Y = ELLIPSE_TOOL.CENTER_Y
                            ELLIPSE_TOOL.END_X = temp_ex%
                            ELLIPSE_TOOL.END_Y = temp_ey%
                        END IF
                    END IF
                CASE TOOL_BRUSH, TOOL_DOT
                    ' Reset pixel-perfect stroke on first mouse down
                    IF NOT MOUSE.OLD_B1% THEN
                        PP_STROKE_COUNT% = 0
                    END IF
                    ' Only draw while LEFT button is held (not right-click)
                    ' Right-click with SHIFT is for connecting lines, handled separately
                    IF MOUSE.B1% THEN
                        IF MOUSE.X% < MOUSE.OLD_X% THEN MOUSE.DRAG$ = "L"
                        IF MOUSE.X% > MOUSE.OLD_X% THEN MOUSE.DRAG$ = "R"
                        IF MOUSE.Y% < MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "U"
                        IF MOUSE.Y% > MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "D"
                        PAINT_on
                    END IF
            END SELECT
        ELSEIF NOT MOUSE.B1% THEN
            ' Button released - save undo state if we were drawing
            IF MOUSE.OLD_B1% AND NOT UNDO_saved_this_frame% THEN
                SELECT CASE CURRENT_TOOL%
                    CASE TOOL_MARQUEE
                        ' Finish the marquee drag, resize, or move
                        IF MARQUEE.DRAGGING% THEN
                            MARQUEE_finish_drag
                        ELSEIF MARQUEE.RESIZING% THEN
                            MARQUEE_finish_resize
                        ELSEIF MARQUEE.MOVING% THEN
                            MARQUEE_finish_move
                        END IF
                    CASE TOOL_MOVE
                        ' Mouse released - check for clone/stamp mode
                        IF MOVE.ACTIVE AND MOVE.TRANSFORMING THEN
                            DIM moveReleaseAlt%
                            moveReleaseAlt% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
                            
                            IF moveReleaseAlt% THEN
                                ' ALT held on release = stamp a copy and stay in clone mode
                                MOVE_stamp
                                ' Keep MOVE.TRANSFORMING = FALSE so next click starts fresh drag
                            END IF
                            
                            ' Update base selection to current position for next transform
                            MOVE.SELECTION_X = MOVE.CURRENT_X
                            MOVE.SELECTION_Y = MOVE.CURRENT_Y
                            MOVE.SELECTION_W = MOVE.CURRENT_W
                            MOVE.SELECTION_H = MOVE.CURRENT_H
                            MOVE.TRANSFORMING = FALSE
                        END IF
                    CASE TOOL_LINE
                        ' Draw the final line on mouse release
                        IF LINE_TOOL.DRAGGING THEN
                            DIM line_mx(0 TO 7) AS INTEGER
                            DIM line_my(0 TO 7) AS INTEGER
                            DIM line_sx(0 TO 7) AS INTEGER
                            DIM line_sy(0 TO 7) AS INTEGER
                            DIM line_count AS INTEGER
                            DIM line_i AS INTEGER
                            
                            _DEST LAYER_current_image&
                            IF CUSTOM_BRUSH_is_active% THEN
                                ' Use custom brush stamps along the line
                                CUSTOM_BRUSH_stamp_line LINE_TOOL.START_X, LINE_TOOL.START_Y, LINE_TOOL.END_X, LINE_TOOL.END_Y
                                ' TODO: Add symmetry support for custom brush lines
                            ELSE
                                ' Draw master line at full opacity
                                LINE (LINE_TOOL.START_X, LINE_TOOL.START_Y)-(LINE_TOOL.END_X, LINE_TOOL.END_Y), PAINT_COLOR~&
                                
                                ' Draw symmetry lines at full opacity
                                IF SYMMETRY.MODE > 0 THEN
                                    SYMMETRY_get_mirrored_points LINE_TOOL.START_X, LINE_TOOL.START_Y, line_sx%(), line_sy%(), line_count%
                                    SYMMETRY_get_mirrored_points LINE_TOOL.END_X, LINE_TOOL.END_Y, line_mx%(), line_my%(), line_count%
                                    
                                    FOR line_i% = 0 TO line_count% - 1
                                        LINE (line_sx%(line_i%), line_sy%(line_i%))-(line_mx%(line_i%), line_my%(line_i%)), PAINT_COLOR~&
                                    NEXT line_i%
                                END IF
                            END IF
                            _DEST SCRN.CANVAS&
                            LINE_TOOL.DRAGGING = FALSE
                            CANVAS_DIRTY% = TRUE
                            UNDO_save_state ' Save state after drawing line
                            UNDO_saved_this_frame% = TRUE
                        END IF
                    CASE TOOL_RECT, TOOL_RECT_FILLED
                        ' Draw the final rectangle on mouse release
                        IF RECT_TOOL.DRAGGING THEN
                            DIM rect_fsx(0 TO 7) AS INTEGER, rect_fsy(0 TO 7) AS INTEGER
                            DIM rect_fex(0 TO 7) AS INTEGER, rect_fey(0 TO 7) AS INTEGER
                            DIM rect_fcount AS INTEGER, rect_fi AS INTEGER
                            
                            _DEST LAYER_current_image&
                            IF CUSTOM_BRUSH_is_active% AND NOT RECT_TOOL.FILLED THEN
                                ' Use custom brush stamps for outline only
                                CUSTOM_BRUSH_stamp_line RECT_TOOL.START_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.START_Y ' Top
                                CUSTOM_BRUSH_stamp_line RECT_TOOL.END_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.END_Y     ' Right
                                CUSTOM_BRUSH_stamp_line RECT_TOOL.END_X, RECT_TOOL.END_Y, RECT_TOOL.START_X, RECT_TOOL.END_Y     ' Bottom
                                CUSTOM_BRUSH_stamp_line RECT_TOOL.START_X, RECT_TOOL.END_Y, RECT_TOOL.START_X, RECT_TOOL.START_Y ' Left
                                ' TODO: Add symmetry support for custom brush rectangles
                            ELSE
                                ' Normal rectangle drawing
                                IF RECT_TOOL.FILLED THEN
                                    ' Check if NumLock is OFF and dither pattern is active
                                    IF NOT _NUMLOCK AND BRUSH_DITHER_ACTIVE > 0 THEN
                                        ' Use dither pattern fill (PAINT_pset_with_symmetry already handles symmetry)
                                        DIM rx AS INTEGER, ry AS INTEGER
                                        DIM min_x AS INTEGER, max_x AS INTEGER, min_y AS INTEGER, max_y AS INTEGER
                                        min_x% = RECT_TOOL.START_X: max_x% = RECT_TOOL.END_X
                                        IF min_x% > max_x% THEN SWAP min_x%, max_x%
                                        min_y% = RECT_TOOL.START_Y: max_y% = RECT_TOOL.END_Y
                                        IF min_y% > max_y% THEN SWAP min_y%, max_y%
                                        FOR ry% = min_y% TO max_y%
                                            FOR rx% = min_x% TO max_x%
                                                IF BRUSH_DITHERS_should_draw%(rx%, ry%) THEN
                                                    PAINT_pset_with_symmetry rx%, ry%, PAINT_COLOR~&, TRUE
                                                END IF
                                            NEXT rx%
                                        NEXT ry%
                                    ELSE
                                        ' Solid fill - draw master rectangle
                                        LINE (RECT_TOOL.START_X, RECT_TOOL.START_Y)-(RECT_TOOL.END_X, RECT_TOOL.END_Y), PAINT_COLOR~&, BF
                                        
                                        ' Draw symmetry rectangles at full opacity
                                        IF SYMMETRY.MODE > 0 THEN
                                            SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_fsx%(), rect_fsy%(), rect_fcount%
                                            SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_fex%(), rect_fey%(), rect_fcount%
                                            
                                            FOR rect_fi% = 0 TO rect_fcount% - 1
                                                LINE (rect_fsx%(rect_fi%), rect_fsy%(rect_fi%))-(rect_fex%(rect_fi%), rect_fey%(rect_fi%)), PAINT_COLOR~&, BF
                                            NEXT rect_fi%
                                        END IF
                                    END IF
                                ELSE
                                    ' Outline - draw master rectangle
                                    LINE (RECT_TOOL.START_X, RECT_TOOL.START_Y)-(RECT_TOOL.END_X, RECT_TOOL.END_Y), PAINT_COLOR~&, B
                                    
                                    ' Draw symmetry rectangles at full opacity
                                    IF SYMMETRY.MODE > 0 THEN
                                        SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_fsx%(), rect_fsy%(), rect_fcount%
                                        SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_fex%(), rect_fey%(), rect_fcount%
                                        
                                        FOR rect_fi% = 0 TO rect_fcount% - 1
                                            LINE (rect_fsx%(rect_fi%), rect_fsy%(rect_fi%))-(rect_fex%(rect_fi%), rect_fey%(rect_fi%)), PAINT_COLOR~&, B
                                        NEXT rect_fi%
                                    END IF
                                END IF
                            END IF
                            _DEST SCRN.CANVAS&
                            RECT_TOOL.DRAGGING = FALSE
                            CANVAS_DIRTY% = TRUE
                            UNDO_save_state ' Save state after drawing rectangle
                            UNDO_saved_this_frame% = TRUE
                        END IF
                    CASE TOOL_ELLIPSE, TOOL_ELLIPSE_FILLED
                        ' Draw the final ellipse on mouse release
                        IF ELLIPSE_TOOL.DRAGGING THEN
                            DIM ecx AS INTEGER, ecy AS INTEGER, erx AS SINGLE, ery AS SINGLE, easp AS SINGLE
                            ecx% = (ELLIPSE_TOOL.START_X + ELLIPSE_TOOL.END_X) \ 2
                            ecy% = (ELLIPSE_TOOL.START_Y + ELLIPSE_TOOL.END_Y) \ 2
                            erx! = ABS(ELLIPSE_TOOL.END_X - ELLIPSE_TOOL.START_X) / 2
                            ery! = ABS(ELLIPSE_TOOL.END_Y - ELLIPSE_TOOL.START_Y) / 2
                            IF erx! > 0 THEN easp! = ery! / erx! ELSE easp! = 1
                            
                            DIM ell_fcsx(0 TO 7) AS INTEGER, ell_fcsy(0 TO 7) AS INTEGER
                            DIM ell_fcount AS INTEGER, ell_fi AS INTEGER
                            
                            _DEST LAYER_current_image&
                            IF erx! > 0 THEN
                                IF CUSTOM_BRUSH_is_active% AND NOT ELLIPSE_TOOL.FILLED THEN
                                    ' Use custom brush stamps for outline only
                                    CUSTOM_BRUSH_stamp_ellipse ecx%, ecy%, erx!, ery!
                                    ' TODO: Add symmetry support for custom brush ellipses
                                ELSE
                                    ' Normal ellipse drawing
                                    IF ELLIPSE_TOOL.FILLED THEN
                                        ' Draw filled ellipse using scanline algorithm
                                        CIRCLE (ecx%, ecy%), erx!, PAINT_COLOR~&, , , easp!
                                        ELLIPSE_fill_scanline ecx%, ecy%, erx!, ery!, PAINT_COLOR~&, LAYER_current_image&
                                        
                                        ' Draw symmetry ellipses at full opacity
                                        IF SYMMETRY.MODE > 0 THEN
                                            SYMMETRY_get_mirrored_points ecx%, ecy%, ell_fcsx%(), ell_fcsy%(), ell_fcount%
                                            
                                            FOR ell_fi% = 0 TO ell_fcount% - 1
                                                CIRCLE (ell_fcsx%(ell_fi%), ell_fcsy%(ell_fi%)), erx!, PAINT_COLOR~&, , , easp!
                                                ELLIPSE_fill_scanline ell_fcsx%(ell_fi%), ell_fcsy%(ell_fi%), erx!, ery!, PAINT_COLOR~&, LAYER_current_image&
                                            NEXT ell_fi%
                                        END IF
                                    ELSE
                                        ' Draw ellipse outline
                                        CIRCLE (ecx%, ecy%), erx!, PAINT_COLOR~&, , , easp!
                                        
                                        ' Draw symmetry ellipses at full opacity
                                        IF SYMMETRY.MODE > 0 THEN
                                            SYMMETRY_get_mirrored_points ecx%, ecy%, ell_fcsx%(), ell_fcsy%(), ell_fcount%
                                            
                                            FOR ell_fi% = 0 TO ell_fcount% - 1
                                                CIRCLE (ell_fcsx%(ell_fi%), ell_fcsy%(ell_fi%)), erx!, PAINT_COLOR~&, , , easp!
                                            NEXT ell_fi%
                                        END IF
                                    END IF
                                END IF
                            END IF
                            _DEST SCRN.CANVAS&
                            ELLIPSE_TOOL.DRAGGING = FALSE
                            CANVAS_DIRTY% = TRUE
                            UNDO_save_state ' Save state after drawing ellipse
                            UNDO_saved_this_frame% = TRUE
                        END IF
                    CASE TOOL_BRUSH, TOOL_DOT
                        ' Draw collected pixel perfect stroke if enabled
                        IF BRUSH_SIZE.PIXEL_PERFECT AND PP_STROKE_COUNT% > 0 THEN
                            PAINT_draw_pixel_perfect
                        END IF
                        CANVAS_DIRTY% = TRUE
                        PP_STROKE_COUNT% = 0
                        UNDO_save_state
                        UNDO_saved_this_frame% = TRUE
                        ' Update DOT.LAST position for SHIFT+RightClick dynamic lines
                        ' This captures the final position after any mouse movement
                        DOT.LAST_X = MOUSE.X%
                        DOT.LAST_Y = MOUSE.Y%
                        DOT.HAS_LAST = TRUE
                    CASE TOOL_TEXT
                        ' TEXT tool applies via ESC key or clicking elsewhere
                        ' TEXT_apply() saves undo, so just set flag to prevent double-save
                        ' Note: This case only triggers if mouse was released after TEXT.ACTIVE
                        _LOGINFO "MOUSE release TOOL_TEXT: TEXT.ACTIVE=" + STR$(TEXT.ACTIVE) + " flag=" + STR$(UNDO_saved_this_frame%)
                        IF TEXT.ACTIVE THEN
                            UNDO_saved_this_frame% = TRUE
                        END IF
                END SELECT
            END IF
            MOUSE.DRAG$ = ""
            MOUSE.CON_X% = 0 : MOUSE.CON_Y% = 0
            CONSTRAIN_X% = FALSE : CONSTRAIN_Y% = FALSE
        END IF
        
        ' Right Click handling for different tools
        IF MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
            _LOGINFO "Right-click detected: B2=" + STR$(MOUSE.B2%) + " OLD_B2=" + STR$(MOUSE.OLD_B2%)
            _LOGINFO "Current tool=" + STR$(CURRENT_TOOL%) + " (DOT=3, BRUSH=1)"
            _LOGINFO "SHIFT held: LSHIFT=" + STR$(_KEYDOWN(KEY_LSHIFT&)) + " RSHIFT=" + STR$(_KEYDOWN(KEY_RSHIFT&))
            _LOGINFO "MOUSE position at right-click: X=" + STR$(MOUSE.X%) + " Y=" + STR$(MOUSE.Y%)
            _LOGINFO "RAW mouse position: _MOUSEX=" + STR$(_MOUSEX) + " _MOUSEY=" + STR$(_MOUSEY)
            
            ' SHIFT + Right Click: Draw line from last dot/brush to current position
            IF (CURRENT_TOOL% = TOOL_DOT OR CURRENT_TOOL% = TOOL_BRUSH) AND (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&)) THEN
                _LOGINFO "SHIFT+Right-click on BRUSH/DOT tool - checking DOT.HAS_LAST=" + STR$(DOT.HAS_LAST)
                _LOGINFO "BEFORE drawing: DOT.LAST_X=" + STR$(DOT.LAST_X) + " DOT.LAST_Y=" + STR$(DOT.LAST_Y)
                _LOGINFO "BEFORE drawing: MOUSE.X%=" + STR$(MOUSE.X%) + " MOUSE.Y%=" + STR$(MOUSE.Y%)
                IF DOT.HAS_LAST THEN
                    _LOGINFO "Drawing dynamic line from (" + STR$(DOT.LAST_X) + "," + STR$(DOT.LAST_Y) + ") to (" + STR$(MOUSE.X%) + "," + STR$(MOUSE.Y%) + ")"
                    _LOGINFO "Using PAINT_COLOR=" + STR$(PAINT_COLOR~&) + " (not PAINT_BG_COLOR=" + STR$(PAINT_BG_COLOR~&) + ")"
                    ' Draw line from last position to current position using FOREGROUND color
                    ' Note: Don't undo the origin point - keep it and draw line from it
                    _DEST LAYER_current_image&
                    IF CUSTOM_BRUSH_is_active% THEN
                        ' Use custom brush stamps along the line
                        CUSTOM_BRUSH_stamp_line DOT.LAST_X, DOT.LAST_Y, MOUSE.X%, MOUSE.Y%
                    ELSE
                        ' Normal line drawing with foreground color (not background)
                        LINE (DOT.LAST_X, DOT.LAST_Y)-(MOUSE.X%, MOUSE.Y%), PAINT_COLOR~&
                    END IF
                    _DEST SCRN.CANVAS&
                    ' Update last position to current position
                    DOT.LAST_X = MOUSE.X%
                    DOT.LAST_Y = MOUSE.Y%
                    ' Save undo state
                    UNDO_save_state
                    UNDO_saved_this_frame% = TRUE
                    CANVAS_DIRTY% = TRUE
                ELSE
                    _LOGINFO "DOT.HAS_LAST is FALSE - no previous point to draw from"
                END IF
            ' Right Click on POLY_LINE tool: finish poly line (stop drawing)
            ELSEIF CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED THEN
                ' Close the shape if filled polygon
                IF CURRENT_TOOL% = TOOL_POLYGON_FILLED AND POLY_LINE.HAS_LAST AND POLY_LINE.POINT_COUNT >= 3 THEN
                    ' Draw closing line
                    _DEST LAYER_current_image&
                    IF CUSTOM_BRUSH_is_active% THEN
                        ' Use custom brush stamps for closing line
                        CUSTOM_BRUSH_stamp_line POLY_LINE.LAST_X, POLY_LINE.LAST_Y, POLY_LINE.FIRST_X, POLY_LINE.FIRST_Y
                    ELSE
                        ' Normal line drawing
                        LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y)-(POLY_LINE.FIRST_X, POLY_LINE.FIRST_Y), PAINT_COLOR~&
                    END IF
                    ' Use scanline fill algorithm for proper polygon filling (only if not using custom brush)
                    IF NOT CUSTOM_BRUSH_is_active% THEN
                        POLY_FILL_scanline POLY_POINTS_X(), POLY_POINTS_Y(), POLY_LINE.POINT_COUNT, PAINT_COLOR~&, LAYER_current_image&
                    END IF
                    _DEST SCRN.CANVAS&
                    CANVAS_DIRTY% = TRUE
                END IF
                ' Save undo AFTER polygon is complete (like LINE tool)
                UNDO_save_state
                UNDO_saved_this_frame% = TRUE
                POLY_LINE_reset
                ' Switch to NULL tool to prevent accidental clicks from starting new polygons
                CURRENT_TOOL% = TOOL_NULL
                GUI_NEEDS_REDRAW% = TRUE
            END IF
        END IF
        
        ' Right button handlers (B2)
        IF MOUSE.B2% THEN
            ' Right click with picker: pick background color
            IF CURRENT_TOOL% = TOOL_PICKER AND PICKER.ACTIVE% AND NOT MOUSE.OLD_B2% THEN
                PICKER_pick_color MOUSE.X%, MOUSE.Y%, 2  ' 2 = right button/background
            END IF
        END IF

        IF (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&)) AND NOT CONSTRAIN_X% AND NOT CONSTRAIN_Y% THEN
            IF MOUSE.DRAG$ = "L" OR MOUSE.DRAG$ = "R" THEN
                MOUSE.CON_Y% = MOUSE.Y%
                CONSTRAIN_X% = FALSE
                CONSTRAIN_Y% = TRUE
            ELSEIF MOUSE.DRAG$ = "U" OR MOUSE.DRAG$ = "D" THEN
                MOUSE.CON_X% = MOUSE.X%
                CONSTRAIN_X% = TRUE
                CONSTRAIN_Y% = FALSE
            END IF
        END IF
    END IF ' End drain-then-process block
    
    ' Trigger redraw when palette menu is visible (for continuous hover highlighting)
    IF PALETTE_MENU_VISIBLE% THEN
        GUI_NEEDS_REDRAW% = TRUE
    END IF
    
    ' Process accumulated wheel delta for zoom/brush size (outside event loop)
    IF wheel_delta% <> 0 THEN
        MOUSE.SW% = wheel_delta%
        
        ' Check if palette menu is visible - always handle wheel for menu scrolling, never zoom
        IF PALETTE_MENU_VISIBLE% THEN
            PALETTE_STRIP_handle_wheel MOUSE.SW%
        ' Check if over layer panel first - use RAW screen coords for GUI bounds checks!
        ELSEIF LAYER_PANEL.visible% AND LAYER_PANEL_in_bounds%(rawX%, rawY%) THEN
            LAYER_PANEL_handle_wheel rawX%, rawY%, MOUSE.SW%
        ' Check if over palette dropdown button (closed menu) - ignore wheel
        ELSEIF PALETTE_STRIP_dropdown_in_bounds%(rawX%, rawY%) THEN
            ' Ignore wheel over dropdown button when menu is closed
        ' Check if over palette strip (excluding dropdown) - use RAW screen coords
        ELSEIF PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN
            PALETTE_STRIP_handle_wheel MOUSE.SW%
        ' Check if over toolbar (don't zoom when over toolbar) - use RAW screen coords
        ELSEIF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN
            ' Ignore wheel over toolbar
        ' Check if over status bar area (don't zoom when over status bar) - use RAW screen coords
        ELSEIF SCRN.showStatus% AND rawY% >= SCRN.h& - THEME.STATUS_height% - PALETTE_STRIP_get_height% THEN
            ' Ignore wheel over status bar / palette strip area (palette strip already handled above)
        ' Check if CTRL is held for brush size adjustment
        ELSEIF (_KEYDOWN(100305) OR _KEYDOWN(100306)) THEN ' Right or Left CTRL
            ' CTRL+Wheel adjusts brush size
            ' Wheel up (negative) should increase, wheel down (positive) should decrease
            IF MOUSE.SW% < 0 THEN
                BRUSH_SIZE_increase
            ELSEIF MOUSE.SW% > 0 THEN
                BRUSH_SIZE_decrease
            END IF
        ELSE
            ' Mouse wheel without CTRL: zoom in/out (only when over canvas)
            ' Above 100%: Always use 100% increments (both in and out)
            ' At/below 100%: Zoom IN snaps to 100%, Zoom OUT uses 25%
            ' Zoom centered on mouse cursor position
            DIM oldZoom AS SINGLE
            DIM mouseScreenX AS INTEGER, mouseScreenY AS INTEGER
            oldZoom! = SCRN.zoom!
            
            ' Get mouse screen position BEFORE zoom changes (scaled to logical coords)
            mouseScreenX% = _MOUSEX \ SCRN.displayScale%
            mouseScreenY% = _MOUSEY \ SCRN.displayScale%
            
            IF MOUSE.SW% < 0 THEN
                ' Wheel down = zoom in
                IF SCRN.zoom! < 1.0 THEN
                    SCRN.zoom! = 1.0  ' Snap to 100% from any fractional zoom
                ELSE
                    SCRN.zoom! = INT(SCRN.zoom!) + 1.0  ' Next whole 100% (200%, 300%, etc.)
                END IF
                IF SCRN.zoom! > SCRN.zoomMax! THEN SCRN.zoom! = SCRN.zoomMax!
            ELSEIF MOUSE.SW% > 0 THEN
                ' Wheel up = zoom out
                IF SCRN.zoom! > 1.0 THEN
                    ' Above 100%: zoom out by whole 100% (200%  100%, 300%  200%)
                    SCRN.zoom! = INT(SCRN.zoom!) - 1.0
                ELSE
                    ' At/below 100%: zoom out by 25% (100%  75%  50%  25%)
                    SCRN.zoom! = SCRN.zoom! - 0.25
                END IF
                IF SCRN.zoom! < SCRN.zoomMin! THEN SCRN.zoom! = SCRN.zoomMin!
            END IF
            
            ' Adjust offset to keep mouse over same canvas point
            IF SCRN.zoom! <> oldZoom! THEN
                ' Calculate canvas center offset at old zoom (using logical canvas dimensions)
                DIM old_zw AS LONG, old_zh AS LONG
                old_zw& = SCRN.w& * oldZoom!
                old_zh& = SCRN.h& * oldZoom!
                DIM old_center_x AS INTEGER, old_center_y AS INTEGER
                old_center_x% = (SCRN.w& - old_zw&) \ 2
                old_center_y% = (SCRN.h& - old_zh&) \ 2
                
                ' Account for layer panel offset when visible
                DIM layerPanelOffset AS INTEGER
                layerPanelOffset% = 0
                IF LAYER_PANEL.visible% THEN layerPanelOffset% = CFG.LAYER_PANEL_WIDTH%
                
                ' Canvas position under mouse at old zoom
                DIM canvasX AS SINGLE, canvasY AS SINGLE
                canvasX! = (mouseScreenX% - old_center_x% - SCRN.offsetX% - layerPanelOffset%) / oldZoom!
                canvasY! = (mouseScreenY% - old_center_y% - SCRN.offsetY%) / oldZoom!
                
                ' Calculate new canvas center offset at new zoom
                DIM new_zw AS LONG, new_zh AS LONG
                new_zw& = SCRN.w& * SCRN.zoom!
                new_zh& = SCRN.h& * SCRN.zoom!
                DIM new_center_x AS INTEGER, new_center_y AS INTEGER
                new_center_x% = (SCRN.w& - new_zw&) \ 2
                new_center_y% = (SCRN.h& - new_zh&) \ 2
                
                ' Calculate new offset to keep canvas point at mouse screen position
                SCRN.offsetX% = mouseScreenX% - new_center_x% - (canvasX! * SCRN.zoom!) - layerPanelOffset%
                SCRN.offsetY% = mouseScreenY% - new_center_y% - (canvasY! * SCRN.zoom!)
            END IF
        END IF
        MOUSE.OSW% = MOUSE.SW%
    END IF
    
    ' Update marquee every frame for keyboard controls and handle hover detection
    IF CURRENT_TOOL% = TOOL_MARQUEE AND MARQUEE.ACTIVE% THEN
        MARQUEE_update MOUSE.X%, MOUSE.Y%
    END IF
END SUB


''
' Finishing stuff in the mouse input loop
' 
SUB MOUSE_input_handler_loop ()
    MOUSE.OLD_X% = MOUSE.X% : MOUSE.OLD_Y% = MOUSE.Y%
    MOUSE.OLD_B1% = MOUSE.B1%
    MOUSE.OLD_B2% = MOUSE.B2%
    MOUSE.OLD_B3% = MOUSE.B3%
    
    ' Process deferred actions (file dialogs) after all mouse processing is complete
    ' Actions: 1=save, 2=import image (to active layer), 3=open DRW project
    IF MOUSE.DEFERRED_ACTION% = 1 THEN
        ' Save action
        SAVE_image
        MOUSE.DEFERRED_ACTION% = 0
    ELSEIF MOUSE.DEFERRED_ACTION% = 2 THEN
        ' Import image action (right-click on open) - imports to active layer
        IMPORT_image
        MOUSE.DEFERRED_ACTION% = 0
    ELSEIF MOUSE.DEFERRED_ACTION% = 3 THEN
        ' Open DRW project action (left-click on open)
        DRW_open_dialog
        MOUSE.DEFERRED_ACTION% = 0
    END IF
END SUB
