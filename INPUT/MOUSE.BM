''
' DRAW - INPUT/MOUSE.BM
' =============================================================================
' Mouse input handling subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

DECLARE FUNCTION MOUSE_handle_image_import% ()
DECLARE FUNCTION MOUSE_handle_command_palette_click% (rawX AS INTEGER, rawY AS INTEGER)
DECLARE FUNCTION MOUSE_handle_menubar_click% (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_menubar_mouse_move (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_autocommit_move_if_click_on_gui (rawX AS INTEGER, rawY AS INTEGER)
DECLARE FUNCTION MOUSE_handle_palette_menu_close% (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_layer_panel (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
DECLARE SUB MOUSE_handle_toolbar_status_palette (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_b3_dblclick_reset_zoom ()
DECLARE SUB MOUSE_handle_ui_autohide_restore (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_handle_panning (rawX AS INTEGER, rawY AS INTEGER)
DECLARE SUB MOUSE_tool_marquee ()
DECLARE SUB MOUSE_tool_move ()
DECLARE SUB MOUSE_tool_line ()
DECLARE SUB MOUSE_tool_poly ()
DECLARE SUB MOUSE_tool_rect ()
DECLARE SUB MOUSE_tool_ellip ()

''
' Drain all buffered mouse events and update MOUSE state ONCE with final values.
' - Accumulates wheel delta (returned via wheel_delta%)
' - Updates MOUSE.RAW_X/Y, MOUSE.X/Y (with grid snap + clamp)
' - Updates MOUSE.B1/B2/B3 (with macOS trackpad tap-to-click workaround)
'
SUB MOUSE_drain_update_state (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
    wheel_delta% = 0

    $IF MAC THEN
        ' macOS: Capture button states during drain to fix trackpad tap-to-click
        ' SDL2 on macOS doesn't always preserve button state after _MOUSEINPUT drain
        DIM mac_b1 AS INTEGER, mac_b2 AS INTEGER, mac_b3 AS INTEGER
        mac_b1% = FALSE: mac_b2% = FALSE: mac_b3% = FALSE
        DO WHILE _MOUSEINPUT
            wheel_delta% = wheel_delta% + _MOUSEWHEEL
            ' Capture any button presses during the drain
            IF _MOUSEBUTTON(1) THEN mac_b1% = TRUE
            IF _MOUSEBUTTON(2) THEN mac_b2% = TRUE
            IF _MOUSEBUTTON(3) THEN mac_b3% = TRUE
        LOOP
    $ELSE
        DO WHILE _MOUSEINPUT
            wheel_delta% = wheel_delta% + _MOUSEWHEEL
        LOOP
    $END IF

    ' Get window coordinates and scale down by display scale
    rawX% = _MOUSEX
    rawY% = _MOUSEY

    ' Store raw screen coordinates for GUI hover detection
    MOUSE.RAW_X% = rawX%
    MOUSE.RAW_Y% = rawY%

    ' Calculate zoomed canvas position on screen (using logical canvas dimensions)
    DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
    zw& = SCRN.w& * SCRN.zoom!
    zh& = SCRN.h& * SCRN.zoom!
    dx% = (SCRN.w& - zw&) \ 2 + SCRN.offsetX%
    dy% = (SCRN.h& - zh&) \ 2 + SCRN.offsetY%

    ' Offset canvas X when layer panel is visible
    IF LAYER_PANEL.visible% THEN dx% = dx% + CFG.LAYER_PANEL_WIDTH%

    ' Offset canvas Y when menu bar is visible
    IF SCRN.showMenubar% AND MENU_BAR.visible% THEN dy% = dy% + MENU_BAR_HEIGHT

    ' Convert screen coords to canvas coords
    MOUSE.X% = INT((rawX% - dx%) / SCRN.zoom!)
    MOUSE.Y% = INT((rawY% - dy%) / SCRN.zoom!)

    ' Apply snap-to-grid if enabled
    IF GRID.SNAP% THEN
        MOUSE.X% = GRID_snap%(MOUSE.X%)
        MOUSE.Y% = GRID_snap%(MOUSE.Y%)
    END IF

    ' Clamp to canvas bounds
    IF MOUSE.X% < 0 THEN MOUSE.X% = 0
    IF MOUSE.Y% < 0 THEN MOUSE.Y% = 0
    IF MOUSE.X% >= SCRN.w& THEN MOUSE.X% = SCRN.w& - 1
    IF MOUSE.Y% >= SCRN.h& THEN MOUSE.Y% = SCRN.h& - 1

    ' Update button states from hardware
    $IF MAC THEN
        ' macOS: Use captured states OR current hardware state (whichever shows pressed)
        MOUSE.B1% = mac_b1% OR _MOUSEBUTTON(1)
        MOUSE.B2% = mac_b2% OR _MOUSEBUTTON(2)
        MOUSE.B3% = mac_b3% OR _MOUSEBUTTON(3)
    $ELSE
        MOUSE.B1% = _MOUSEBUTTON(1)
        MOUSE.B2% = _MOUSEBUTTON(2)
        MOUSE.B3% = _MOUSEBUTTON(3)
    $END IF
END SUB

''
' Initializes the mouse
' 
SUB MOUSE_init ()
    MOUSE.X%     = 1
    MOUSE.Y%     = 1
    MOUSE.OLD_X% = 1
    MOUSE.OLD_Y% = 1
    MOUSE.CON_X% = 0
    MOUSE.CON_Y% = 0
    MOUSE.OSW%   = 0
    MOUSE.B1%    = FALSE
    MOUSE.B2%    = FALSE
    MOUSE.B3%    = FALSE
    MOUSE.OLD_B1% = FALSE
    MOUSE.OLD_B3% = FALSE
    MOUSE.DRAG$  = ""
    MOUSE.B3_CLICK_TIME# = 0
    MOUSE.DEFERRED_ACTION% = 0
END SUB


''
' Reset mouse button states (call after dialogs to prevent button state desync)
' Syncs current and old states to actual hardware state to prevent false clicks
'
SUB MOUSE_reset_buttons ()
    ' Clear any pending mouse input first
    DO WHILE _MOUSEINPUT : LOOP
    
    ' Read actual current button states from hardware
    DIM current_b1 AS INTEGER
    DIM current_b2 AS INTEGER
    DIM current_b3 AS INTEGER
    current_b1% = _MOUSEBUTTON(1)
    current_b2% = _MOUSEBUTTON(2)
    current_b3% = _MOUSEBUTTON(3)
    
    ' Set both current AND old to same values (no transition = no click detection)
    MOUSE.B1% = current_b1%
    MOUSE.B2% = current_b2%
    MOUSE.B3% = current_b3%
    MOUSE.OLD_B1% = current_b1%
    MOUSE.OLD_B2% = current_b2%
    MOUSE.OLD_B3% = current_b3%
    MOUSE.TOOLBAR_CLICKED% = FALSE
END SUB


''
' Forces all mouse buttons to UP state (used after dialogs to prevent phantom clicks)
'
SUB MOUSE_force_buttons_up ()
    ' Clear any pending mouse input first
    DO WHILE _MOUSEINPUT : LOOP
    
    ' Force all buttons to UP (FALSE) state
    MOUSE.B1% = FALSE
    MOUSE.B2% = FALSE
    MOUSE.B3% = FALSE
    MOUSE.OLD_B1% = FALSE
    MOUSE.OLD_B2% = FALSE
    MOUSE.OLD_B3% = FALSE
    MOUSE.TOOLBAR_CLICKED% = FALSE

    ' Suppress button input for next 2 frames to catch late-arriving SDL events
    ' after native dialogs (file open/save, message boxes) close
    MOUSE.SUPPRESS_FRAMES% = 2
END SUB


''
' Image import mode mouse handling.
' Returns TRUE when IMG_IMPORT is active and input was handled (caller should EXIT SUB).
'
FUNCTION MOUSE_handle_image_import% ()
    MOUSE_handle_image_import% = FALSE
    IF IMG_IMPORT.STATE <= IMPORT_STATE_IDLE THEN EXIT FUNCTION

    ' Accumulate wheel delta while clearing buffered input
    DIM wheel_delta AS INTEGER
    wheel_delta% = 0
    $IF MAC THEN
        ' macOS: Capture button states during drain to fix trackpad tap-to-click
        ' SDL2 on macOS doesn't always preserve button state after _MOUSEINPUT drain
        DIM mac_b1 AS INTEGER, mac_b2 AS INTEGER, mac_b3 AS INTEGER
        mac_b1% = FALSE: mac_b2% = FALSE: mac_b3% = FALSE
        DO WHILE _MOUSEINPUT
            wheel_delta% = wheel_delta% + _MOUSEWHEEL
            ' Capture any button presses during the drain
            IF _MOUSEBUTTON(1) THEN mac_b1% = TRUE
            IF _MOUSEBUTTON(2) THEN mac_b2% = TRUE
            IF _MOUSEBUTTON(3) THEN mac_b3% = TRUE
        LOOP
    $ELSE
        DO WHILE _MOUSEINPUT
            wheel_delta% = wheel_delta% + _MOUSEWHEEL
        LOOP
    $END IF

    ' Get current mouse state directly (not buffered)
    DIM imp_rawX AS INTEGER, imp_rawY AS INTEGER
    DIM imp_zw AS LONG, imp_zh AS LONG, imp_dx AS INTEGER, imp_dy AS INTEGER

    ' Get window coordinates and scale down by display scale
    imp_rawX% = _MOUSEX
    imp_rawY% = _MOUSEY

    ' Store raw screen coordinates
    MOUSE.RAW_X% = imp_rawX%
    MOUSE.RAW_Y% = imp_rawY%

    ' Calculate zoomed canvas position on screen (using logical canvas dimensions)
    imp_zw& = SCRN.w& * SCRN.zoom!
    imp_zh& = SCRN.h& * SCRN.zoom!
    imp_dx% = (SCRN.w& - imp_zw&) \ 2 + SCRN.offsetX%
    imp_dy% = (SCRN.h& - imp_zh&) \ 2 + SCRN.offsetY%

    ' Offset for layer panel when visible (must match SCREEN_render)
    IF LAYER_PANEL.visible% THEN imp_dx% = imp_dx% + CFG.LAYER_PANEL_WIDTH%

    ' Offset canvas Y when menu bar is visible
    IF SCRN.showMenubar% AND MENU_BAR.visible% THEN imp_dy% = imp_dy% + MENU_BAR_HEIGHT

    ' Convert screen coords to canvas coords
    MOUSE.X% = INT((imp_rawX% - imp_dx%) / SCRN.zoom!)
    MOUSE.Y% = INT((imp_rawY% - imp_dy%) / SCRN.zoom!)

    ' Clamp to canvas bounds
    IF MOUSE.X% < 0 THEN MOUSE.X% = 0
    IF MOUSE.Y% < 0 THEN MOUSE.Y% = 0
    IF MOUSE.X% >= SCRN.w& THEN MOUSE.X% = SCRN.w& - 1
    IF MOUSE.Y% >= SCRN.h& THEN MOUSE.Y% = SCRN.h& - 1

    ' Get button states
    $IF MAC THEN
        ' macOS: Use captured states OR current hardware state (whichever shows pressed)
        MOUSE.B1% = mac_b1% OR _MOUSEBUTTON(1)
        MOUSE.B2% = mac_b2% OR _MOUSEBUTTON(2)
        MOUSE.B3% = mac_b3% OR _MOUSEBUTTON(3)
    $ELSE
        MOUSE.B1% = _MOUSEBUTTON(1)
        MOUSE.B2% = _MOUSEBUTTON(2)
        MOUSE.B3% = _MOUSEBUTTON(3)
    $END IF

    ' Suppress button input after native dialogs (same as normal mode)
    IF MOUSE.SUPPRESS_FRAMES% > 0 THEN
        DO WHILE _MOUSEINPUT: LOOP
        MOUSE.B1% = FALSE
        MOUSE.B2% = FALSE
        MOUSE.B3% = FALSE
        MOUSE.OLD_B1% = FALSE
        MOUSE.OLD_B2% = FALSE
        MOUSE.OLD_B3% = FALSE
        MOUSE.SUPPRESS_FRAMES% = MOUSE.SUPPRESS_FRAMES% - 1
        MOUSE.OLD_X% = MOUSE.X%
        MOUSE.OLD_Y% = MOUSE.Y%
        MOUSE_handle_image_import% = TRUE
        EXIT FUNCTION
    END IF

    ' Handle mouse wheel for zoom (accumulated from buffer)
    IF wheel_delta% <> 0 THEN
        IMAGE_IMPORT_zoom -wheel_delta%  ' Negative: wheel up = zoom in
    END IF

    ' Track hover handle for visual feedback
    IF IMG_IMPORT.STATE >= IMPORT_STATE_PLACING AND NOT IMG_IMPORT.RESIZING THEN
        IMG_IMPORT.HOVER_HANDLE = IMAGE_IMPORT_get_handle_at%(MOUSE.X%, MOUSE.Y%)
    ELSE
        IMG_IMPORT.HOVER_HANDLE = 0
    END IF

    ' Handle mouse button interactions
    IF MOUSE.B1% THEN
        IF NOT MOUSE.OLD_B1% THEN
            ' Button just pressed - determine action based on state
            IF IMG_IMPORT.STATE = IMPORT_STATE_LOADED THEN
                ' No marquee yet - start drawing one
                IMAGE_IMPORT_start_placement MOUSE.X%, MOUSE.Y%
            ELSEIF IMG_IMPORT.STATE >= IMPORT_STATE_PLACING THEN
                ' Have a placement - check for handle/pan/new marquee
                DIM import_handle AS INTEGER
                import_handle% = IMAGE_IMPORT_get_handle_at%(MOUSE.X%, MOUSE.Y%)
                IF import_handle% > 0 THEN
                    IMAGE_IMPORT_start_resize import_handle%, MOUSE.X%, MOUSE.Y%
                ELSEIF IMAGE_IMPORT_is_point_inside%(MOUSE.X%, MOUSE.Y%) THEN
                    IMAGE_IMPORT_start_pan MOUSE.X%, MOUSE.Y%
                ELSE
                    ' Click outside - start new marquee
                    IMG_IMPORT.STATE = IMPORT_STATE_LOADED
                    IMAGE_IMPORT_start_placement MOUSE.X%, MOUSE.Y%
                END IF
            END IF
        ELSE
            ' Button held - update current operation
            IF IMG_IMPORT.DRAGGING THEN
                IMAGE_IMPORT_update_placement MOUSE.X%, MOUSE.Y%
            ELSEIF IMG_IMPORT.RESIZING THEN
                IMAGE_IMPORT_update_resize MOUSE.X%, MOUSE.Y%
            ELSEIF IMG_IMPORT.PANNING THEN
                IMAGE_IMPORT_update_pan MOUSE.X%, MOUSE.Y%
            END IF
        END IF
    ELSE
        ' Button released - finish current operation
        IF IMG_IMPORT.DRAGGING THEN
            IMAGE_IMPORT_finish_placement
        ELSEIF IMG_IMPORT.RESIZING THEN
            IMAGE_IMPORT_finish_resize
        ELSEIF IMG_IMPORT.PANNING THEN
            IMAGE_IMPORT_finish_pan
        END IF
    END IF

    ' Update old mouse state
    MOUSE.OLD_B1% = MOUSE.B1%
    MOUSE.OLD_B2% = MOUSE.B2%
    MOUSE.OLD_B3% = MOUSE.B3%
    MOUSE.OLD_X% = MOUSE.X%
    MOUSE.OLD_Y% = MOUSE.Y%

    MOUSE_handle_image_import% = TRUE
END FUNCTION


''
' Command palette click handling.
' Returns TRUE if click was consumed (caller should EXIT SUB).
'
FUNCTION MOUSE_handle_command_palette_click% (rawX AS INTEGER, rawY AS INTEGER)
    MOUSE_handle_command_palette_click% = FALSE
    IF NOT CMD_PALETTE.visible THEN EXIT FUNCTION
    IF NOT (MOUSE.B1% AND NOT MOUSE.OLD_B1%) THEN EXIT FUNCTION

    CMD_handle_click rawX%, rawY%

    ' Don't process other clicks when palette is visible
    MOUSE.OLD_B1% = MOUSE.B1%
    MOUSE.OLD_B2% = MOUSE.B2%
    MOUSE.OLD_B3% = MOUSE.B3%
    MOUSE.OLD_X% = MOUSE.X%
    MOUSE.OLD_Y% = MOUSE.Y%
    MOUSE_handle_command_palette_click% = TRUE
END FUNCTION


''
' Menu bar click handling.
' Returns TRUE if click was consumed (caller should EXIT SUB).
'
FUNCTION MOUSE_handle_menubar_click% (rawX AS INTEGER, rawY AS INTEGER)
    MOUSE_handle_menubar_click% = FALSE
    IF NOT (SCRN.showMenubar% AND MENU_BAR.visible%) THEN EXIT FUNCTION
    IF NOT (MOUSE.B1% AND NOT MOUSE.OLD_B1%) THEN EXIT FUNCTION

    IF MENUBAR_in_bounds%(rawX%, rawY%) OR MENUBAR_submenu_in_bounds%(rawX%, rawY%) THEN
        MENUBAR_handle_click rawX%, rawY%
        MOUSE.TOOLBAR_CLICKED% = TRUE
        MOUSE.OLD_B1% = MOUSE.B1%
        MOUSE.OLD_B2% = MOUSE.B2%
        MOUSE.OLD_B3% = MOUSE.B3%
        MOUSE.OLD_X% = MOUSE.X%
        MOUSE.OLD_Y% = MOUSE.Y%
        MOUSE_handle_menubar_click% = TRUE
    ELSEIF MENUBAR_is_open% THEN
        ' Clicked outside menu bar while submenu is open â€” close it
        MENUBAR_close_all
        GUI_NEEDS_REDRAW% = TRUE
    END IF
END FUNCTION


''
' Menu bar hover tracking (menu switching on mouse move).
'
SUB MOUSE_handle_menubar_mouse_move (rawX AS INTEGER, rawY AS INTEGER)
    IF SCRN.showMenubar% AND MENU_BAR.visible% THEN
        MENUBAR_handle_mouse_move rawX%, rawY%
    END IF
END SUB


''
' Auto-apply move transform when clicking GUI controls (without marquee selection).
'
SUB MOUSE_autocommit_move_if_click_on_gui (rawX AS INTEGER, rawY AS INTEGER)
    IF NOT (MOUSE.B1% AND NOT MOUSE.OLD_B1%) THEN EXIT SUB
    IF NOT MOVE.ACTIVE THEN EXIT SUB
    IF MOVE.SELECTION_IMAGE >= -1 THEN EXIT SUB
    IF MARQUEE.ACTIVE% AND MARQUEE.INITIALIZED% THEN EXIT SUB

    ' Check if click is on any GUI element (not canvas)
    DIM clickOnGUI AS INTEGER
    clickOnGUI% = FALSE
    IF LAYER_PANEL.visible% AND LAYER_PANEL_in_bounds%(rawX%, rawY%) THEN clickOnGUI% = TRUE
    IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN clickOnGUI% = TRUE
    IF SCRN.showStatus% AND rawY% >= (SCRN.h& - 10) THEN clickOnGUI% = TRUE
    IF SCRN.showStatus% AND PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN clickOnGUI% = TRUE
    IF SCRN.showMenubar% AND MENU_BAR.visible% AND MENUBAR_in_bounds%(rawX%, rawY%) THEN clickOnGUI% = TRUE

    IF clickOnGUI% THEN
        MOVE_apply_transform
        MOVE_reset
    END IF
END SUB


''
' Close palette menu when clicking outside its bounds.
' Returns TRUE if palette menu was closed.
'
FUNCTION MOUSE_handle_palette_menu_close% (rawX AS INTEGER, rawY AS INTEGER)
    MOUSE_handle_palette_menu_close% = FALSE
    IF NOT PALETTE_MENU_VISIBLE% THEN EXIT FUNCTION
    IF NOT (MOUSE.B1% AND NOT MOUSE.OLD_B1%) THEN EXIT FUNCTION

    IF NOT PALETTE_MENU_in_bounds%(rawX%, rawY%) THEN
        ' Check if click is NOT on the palette name trigger area (to prevent reopening)
        IF NOT PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN
            PALETTE_MENU_hide
            GUI_NEEDS_REDRAW% = TRUE
            MOUSE_handle_palette_menu_close% = TRUE
        END IF
    END IF
END FUNCTION


''
' Layer panel input handling.
' May consume wheel_delta% (sets to 0) so it doesn't propagate to canvas zoom.
'
SUB MOUSE_handle_layer_panel (rawX AS INTEGER, rawY AS INTEGER, wheel_delta AS INTEGER)
    ' Check for layer panel clicks (only when not panning)
    IF NOT SCRN.panning% AND LAYER_PANEL.visible% THEN
        IF LAYER_PANEL_in_bounds%(rawX%, rawY%) THEN
            ' Handle left-click on layer panel
            IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                IF LAYER_PANEL_handle_click%(rawX%, rawY%, 1) THEN
                    MOUSE.TOOLBAR_CLICKED% = TRUE  ' Block canvas action
                END IF
            END IF
            ' Handle right-click on layer panel
            IF MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
                IF LAYER_PANEL_handle_click%(rawX%, rawY%, 2) THEN
                    MOUSE.TOOLBAR_CLICKED% = TRUE  ' Block canvas action
                END IF
            END IF
            ' Handle mouse wheel for scrolling layer list or adjusting opacity
            IF wheel_delta% <> 0 THEN
                LAYER_PANEL_handle_wheel rawX%, rawY%, wheel_delta%
                wheel_delta% = 0  ' Consume wheel event - don't zoom canvas
            END IF
        END IF

        ' Handle visibility swipe (takes priority over drag-reorder)
        IF LAYER_PANEL.visSwiping% THEN
            IF MOUSE.B1% THEN
                LAYER_PANEL_handle_vis_swipe rawX%, rawY%
                MOUSE.TOOLBAR_CLICKED% = TRUE
            ELSE
                LAYER_PANEL_end_vis_swipe
            END IF
        ' Handle layer drag movement (even if outside panel bounds)
        ELSEIF LAYER_PANEL_is_dragging% THEN
            IF MOUSE.B1% THEN
                ' Continue dragging - update drop target
                LAYER_PANEL_handle_drag rawX%, rawY%
                MOUSE.TOOLBAR_CLICKED% = TRUE  ' Block canvas action
            ELSE
                ' Mouse button released - complete the drop
                LAYER_PANEL_handle_drop
            END IF
        END IF
    ELSEIF LAYER_PANEL.visSwiping% THEN
        ' Swipe may have moved outside panel
        IF MOUSE.B1% THEN
            LAYER_PANEL_handle_vis_swipe rawX%, rawY%
            MOUSE.TOOLBAR_CLICKED% = TRUE
        ELSE
            LAYER_PANEL_end_vis_swipe
        END IF
    ELSEIF LAYER_PANEL_is_dragging% THEN
        ' Layer drag may have moved outside panel - still need to handle
        IF MOUSE.B1% THEN
            LAYER_PANEL_handle_drag rawX%, rawY%
            MOUSE.TOOLBAR_CLICKED% = TRUE
        ELSE
            LAYER_PANEL_handle_drop
        END IF
    END IF
END SUB


''
' Toolbar/status/palette click handling.
'
SUB MOUSE_handle_toolbar_status_palette (rawX AS INTEGER, rawY AS INTEGER)
    ' Check for toolbar clicks (only when not panning)
    IF NOT SCRN.panning% AND MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
        ' Check if clicking on toolbar area (raw screen coordinates)
        IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN
            ' Only set TOOLBAR_CLICKED if an actual button was hit
            IF TOOLBAR_handle_click%(rawX%, rawY%) THEN
                MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
            END IF
        END IF
        ' Check if clicking on status bar area (bottom of screen)
        IF SCRN.showStatus% AND rawY% >= (SCRN.h& - 10) THEN
            STATUS_handle_click rawX%, rawY%
            MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
        END IF
        ' Check if clicking on palette strip area (above status bar) or menu
        IF SCRN.showStatus% AND (PALETTE_STRIP_in_bounds%(rawX%, rawY%) OR PALETTE_MENU_in_bounds%(rawX%, rawY%)) THEN
            PALETTE_STRIP_handle_click rawX%, rawY%
            MOUSE.TOOLBAR_CLICKED% = TRUE  ' Flag to prevent canvas action
        END IF
    END IF

    ' Check for right-click on palette strip (for background color)
    IF NOT SCRN.panning% AND MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
        IF SCRN.showStatus% AND PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN
            PALETTE_STRIP_handle_click rawX%, rawY%
            MOUSE.TOOLBAR_CLICKED% = TRUE
        END IF
    END IF

    ' Check for right-click on toolbar (for alternate tool modes)
    IF NOT SCRN.panning% AND MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
        IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN
            TOOLBAR_handle_right_click rawX%, rawY%
        END IF
    END IF

    ' Check for middle-click on toolbar (for custom font loading on text tool)
    IF NOT SCRN.panning% AND MOUSE.B3% AND NOT MOUSE.OLD_B3% THEN
        IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN
            TOOLBAR_handle_middle_click rawX%, rawY%
        END IF
    END IF
END SUB


''
' Double middle-click (B3) to reset zoom and position.
'
SUB MOUSE_handle_b3_dblclick_reset_zoom ()
    IF MOUSE.B3% AND NOT MOUSE.OLD_B3% THEN
        DIM clickTime AS DOUBLE
        clickTime# = TIMER
        IF clickTime# - MOUSE.B3_CLICK_TIME# < 0.3 THEN ' 300ms double-click threshold
            ' Double-click detected - reset zoom and position
            SCRN.zoom! = 1.0
            SCRN.offsetX% = 0
            SCRN.offsetY% = 0
            MOUSE.B3_CLICK_TIME# = 0 ' Reset to prevent triple-click triggering
        ELSE
            MOUSE.B3_CLICK_TIME# = clickTime#
        END IF
    END IF
END SUB


''
' Auto-hide UI while actively drawing; restore after release.
'
SUB MOUSE_handle_ui_autohide_restore (rawX AS INTEGER, rawY AS INTEGER)
    ' Auto-hide UI when actively dragging with a tool (not when clicking toolbar)
    ' Only hide when button was already down (OLD_B1%) and we're not clicking on UI
    ' Skip auto-hide for NULL tool - let user freely access toolbar/status
    ' Also check shape tools that are in "drawing" state (LINE, RECT, ELLIPSE, POLY_LINE)
    DIM shapeToolDrawing AS INTEGER
    shapeToolDrawing% = LINE_TOOL.DRAGGING OR RECT_TOOL.DRAGGING OR ELLIPSE_TOOL.DRAGGING OR POLY_LINE.HAS_LAST

    DIM activelyDrawing AS INTEGER
    activelyDrawing% = (MOUSE.B1% AND MOUSE.OLD_B1%) OR shapeToolDrawing%

    IF CURRENT_TOOL% <> TOOL_NULL AND activelyDrawing% AND NOT SCRN.panning% AND NOT MOUSE.TOOLBAR_CLICKED% THEN
        ' Check if mouse is over an actual toolbar button (not empty toolbar area)
        IF SCRN.showToolbar% AND TOOLBAR_is_over_button%(rawX%, rawY%) THEN
            SCRN.showToolbar% = FALSE
            SCRN.toolbarManuallyHidden% = FALSE ' This is auto-hide, not manual
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
        END IF
        ' Check if mouse is over status bar/palette strip while drawing
        IF SCRN.showStatus% THEN
            DIM autoHideStripTop AS INTEGER
            autoHideStripTop% = SCRN.h& - THEME.STATUS_height% - PALETTE_STRIP_get_height%
            IF rawY% >= autoHideStripTop% THEN
                SCRN.showStatus% = FALSE
                SCRN.statusManuallyHidden% = FALSE ' This is auto-hide, not manual
                GUI_NEEDS_REDRAW% = TRUE
                SCENE_DIRTY% = TRUE
            END IF
        END IF
        ' Check if mouse is over menu bar while drawing
        IF SCRN.showMenubar% AND MENU_BAR.visible% THEN
            IF rawY% < MENU_BAR_HEIGHT AND rawX% >= MENU_BAR.barX% THEN
                SCRN.showMenubar% = FALSE
                MENU_BAR.visible% = FALSE
                SCRN.menubarManuallyHidden% = FALSE
                MENUBAR_close_all
                GUI_NEEDS_REDRAW% = TRUE
                SCENE_DIRTY% = TRUE
            END IF
        END IF
        ' Check if mouse is over layer panel while drawing
        IF LAYER_PANEL.visible% THEN
            IF rawX% < CFG.LAYER_PANEL_WIDTH% THEN
                LAYER_PANEL.visible% = FALSE
                SCRN.layerPanelManuallyHidden% = FALSE ' This is auto-hide, not manual
                GUI_NEEDS_REDRAW% = TRUE
                SCENE_DIRTY% = TRUE
            END IF
        END IF
    END IF

    ' Restore UI when mouse is released (only if auto-hidden, not manually hidden)
    ' For shape tools, also check that they're no longer in drawing state
    DIM canRestoreUI AS INTEGER
    canRestoreUI% = NOT MOUSE.B1% AND NOT shapeToolDrawing%

    IF canRestoreUI% THEN
        DIM uiRestored AS INTEGER
        uiRestored% = FALSE
        ' Restore toolbar if it was auto-hidden (not manually hidden by user)
        IF NOT SCRN.showToolbar% AND NOT SCRN.toolbarManuallyHidden% THEN
            SCRN.showToolbar% = TRUE
            uiRestored% = TRUE
        END IF
        ' Restore status bar if it was auto-hidden (not manually hidden by user)
        IF NOT SCRN.showStatus% AND NOT SCRN.statusManuallyHidden% THEN
            SCRN.showStatus% = TRUE
            uiRestored% = TRUE
        END IF
        ' Restore menu bar if it was auto-hidden (not manually hidden by user)
        IF NOT SCRN.showMenubar% AND NOT SCRN.menubarManuallyHidden% THEN
            SCRN.showMenubar% = TRUE
            MENU_BAR.visible% = TRUE
            uiRestored% = TRUE
        END IF
        ' Restore layer panel if it was auto-hidden (not manually hidden by user)
        IF NOT LAYER_PANEL.visible% AND NOT SCRN.layerPanelManuallyHidden% THEN
            LAYER_PANEL.visible% = TRUE
            uiRestored% = TRUE
        END IF
        IF uiRestored% THEN
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
        END IF
    END IF
END SUB


''
' Pan mode (spacebar + LMB OR MMB OR PAN tool + LMB).
'
SUB MOUSE_handle_panning (rawX AS INTEGER, rawY AS INTEGER)
    ' Block spacebar pan when text tool is active (SPACE needed for typing)
    DIM allowSpacePan AS INTEGER
    allowSpacePan% = NOT (CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE)

    DIM panToolActive AS INTEGER
    panToolActive% = (CURRENT_TOOL% = TOOL_PAN AND MOUSE.B1%)

    IF ((_KEYDOWN(32) AND allowSpacePan%) AND MOUSE.B1%) OR MOUSE.B3% OR panToolActive% THEN ' Spacebar+LMB or MMB or PAN tool+LMB
        IF NOT SCRN.panning% THEN
            ' Start panning
            SCRN.panning% = TRUE
            SCRN.panStartX% = rawX%
            SCRN.panStartY% = rawY%
            SCRN.panOrigOffsetX% = SCRN.offsetX%
            SCRN.panOrigOffsetY% = SCRN.offsetY%
        ELSE
            ' Continue dragging
            SCRN.offsetX% = SCRN.panOrigOffsetX% + (rawX% - SCRN.panStartX%)
            SCRN.offsetY% = SCRN.panOrigOffsetY% + (rawY% - SCRN.panStartY%)

            ' If spacebar mode: reset on new button press
            IF _KEYDOWN(32) AND MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                SCRN.panStartX% = rawX%
                SCRN.panStartY% = rawY%
                SCRN.panOrigOffsetX% = SCRN.offsetX%
                SCRN.panOrigOffsetY% = SCRN.offsetY%
            END IF
        END IF
    ELSE
        ' Exit pan mode when both methods released
        IF SCRN.panning% THEN SCRN.panning% = FALSE
    END IF
END SUB


''
' Tool handler: Marquee (includes Magic Wand mode).
'
SUB MOUSE_tool_marquee ()
    ' Magic Wand mode: select contiguous pixels of same color
    IF MARQUEE.MAGIC_WAND_MODE THEN
        IF NOT MOUSE.OLD_B1% THEN
            ' Determine selection mode based on modifiers
            DIM wandSelMode AS INTEGER
            DIM wandIsShift AS INTEGER, wandIsAlt AS INTEGER
            wandIsShift% = MODIFIERS.shift%
            wandIsAlt% = MODIFIERS.alt%
            IF wandIsShift% THEN
                wandSelMode% = SEL_MODE_ADD
            ELSEIF wandIsAlt% THEN
                wandSelMode% = SEL_MODE_SUBTRACT
            ELSE
                wandSelMode% = SEL_MODE_REPLACE
            END IF
            ' Fresh click - select contiguous color at this position
            MAGIC_WAND_select_with_mode MOUSE.X%, MOUSE.Y%, wandSelMode%
            GUI_NEEDS_REDRAW% = TRUE
        END IF
    ELSE
        ' Normal marquee mode: Start marquee selection, resize, or move on first click
        IF NOT MOUSE.OLD_B1% THEN
            ' Store selection mode for marquee based on modifiers
            DIM marqIsShift AS INTEGER, marqIsAlt AS INTEGER
            marqIsShift% = MODIFIERS.shift%
            marqIsAlt% = MODIFIERS.alt%
            IF marqIsShift% THEN
                MARQUEE.SELECTION_MODE = SEL_MODE_ADD
            ELSEIF marqIsAlt% THEN
                MARQUEE.SELECTION_MODE = SEL_MODE_SUBTRACT
            ELSE
                MARQUEE.SELECTION_MODE = SEL_MODE_REPLACE
            END IF

            ' In add/subtract mode, always start a new marquee drag
            ' (don't allow move/resize - those only work in replace mode)
            IF MARQUEE.SELECTION_MODE <> SEL_MODE_REPLACE THEN
                MARQUEE_start MOUSE.X%, MOUSE.Y%
            ELSE
                ' Replace mode: Check if clicking on a handle or inside selection
                DIM handle AS INTEGER
                handle% = MARQUEE_get_handle_at%(MOUSE.X%, MOUSE.Y%)
                IF handle% > 0 THEN
                    ' Start resizing from this handle
                    MARQUEE_start_resize handle%, MOUSE.X%, MOUSE.Y%
                ELSEIF MARQUEE_is_point_inside%(MOUSE.X%, MOUSE.Y%) THEN
                    ' Start moving the box
                    MARQUEE_start_move MOUSE.X%, MOUSE.Y%
                ELSE
                    ' Start new marquee selection (clicking outside)
                    MARQUEE_start MOUSE.X%, MOUSE.Y%
                END IF
            END IF
        END IF
        ' Update resize, move, or drag position while button is held
        IF MARQUEE.RESIZING% THEN
            MARQUEE_update_resize MOUSE.X%, MOUSE.Y%
        ELSEIF MARQUEE.MOVING% THEN
            MARQUEE_update_move MOUSE.X%, MOUSE.Y%
        ELSE
            MARQUEE_update MOUSE.X%, MOUSE.Y%
        END IF
    END IF
END SUB


''
' Tool handler: Move.
'
SUB MOUSE_tool_move ()
    ' MOVE tool: Transform the selected pixels
    IF MOVE.ACTIVE THEN
        ' Check ALT state for clone mode
        DIM moveIsAlt AS INTEGER
        moveIsAlt% = MODIFIERS.alt%
        MOVE.CLONING = moveIsAlt%

        IF NOT MOUSE.OLD_B1% THEN
            ' Fresh click - start a drag/transform
            ' Check if clicking on a handle or inside selection
            DIM move_handle AS INTEGER
            DIM marquee_handle AS INTEGER
            marquee_handle% = MARQUEE_get_handle_at%(MOUSE.X%, MOUSE.Y%)
            IF marquee_handle% > 0 THEN
                ' Remap MARQUEE handle to MOVE handle numbering:
                ' MARQUEE: 1=TL, 2=T, 3=TR, 4=L, 5=R, 6=BL, 7=B, 8=BR
                ' MOVE:    1=TL, 2=TR, 3=BR, 4=BL, 5=T, 6=R, 7=B, 8=L
                SELECT CASE marquee_handle%
                    CASE 1: move_handle% = 1 ' TL corner
                    CASE 3: move_handle% = 2 ' TR corner
                    CASE 8: move_handle% = 3 ' BR corner
                    CASE 6: move_handle% = 4 ' BL corner
                    CASE 2: move_handle% = 5 ' T edge
                    CASE 5: move_handle% = 6 ' R edge
                    CASE 7: move_handle% = 7 ' B edge
                    CASE 4: move_handle% = 8 ' L edge
                END SELECT
                ' Start resizing/scaling from this handle
                MOVE_start_transform move_handle%, MOUSE.X%, MOUSE.Y%
            ELSEIF MARQUEE_is_point_inside%(MOUSE.X%, MOUSE.Y%) THEN
                ' Start moving from center (handle 0)
                MOVE_start_transform 0, MOUSE.X%, MOUSE.Y%
            END IF
        ELSE
            ' Update transform while dragging
            IF MOVE.TRANSFORMING THEN
                MOVE_update_transform MOUSE.X%, MOUSE.Y%
            END IF
        END IF
    ELSE
        ' MOVE tool is selected but not active - capture selection on click
        IF NOT MOUSE.OLD_B1% THEN
            ' Fresh click - capture the layer (or marquee if active) and start move
            MOVE_capture_selection
            ' Immediately start a move transform from this click position
            MOVE_start_transform 0, MOUSE.X%, MOUSE.Y%
        END IF
    END IF
END SUB


''
' Tool handler: Line.
'
SUB MOUSE_tool_line ()
    ' LINE tool: Click and drag with preview
    IF NOT MOUSE.OLD_B1% THEN
        ' Start dragging on first click
        LINE_TOOL.DRAGGING = TRUE
        LINE_TOOL.START_X = MOUSE.X%
        LINE_TOOL.START_Y = MOUSE.Y%
        LINE_TOOL.END_X = MOUSE.X%
        LINE_TOOL.END_Y = MOUSE.Y%
    ELSE
        ' Update end position while dragging
        LINE_TOOL.END_X = MOUSE.X%
        LINE_TOOL.END_Y = MOUSE.Y%

        ' Apply angle snapping if Ctrl+Shift are both held
        IF MODIFIERS.ctrlShift% THEN
            SNAP_to_angle LINE_TOOL.START_X, LINE_TOOL.START_Y, LINE_TOOL.END_X, LINE_TOOL.END_Y, CFG.ANGLE_SNAP_DEGREES%
        END IF
    END IF
END SUB


''
' Tool handler: Polygon/Polygon filled.
'
SUB MOUSE_tool_poly ()
    ' POLY_LINE tool: Click to click connected lines
    IF NOT MOUSE.OLD_B1% THEN
        DIM poly_x AS INTEGER, poly_y AS INTEGER
        poly_x% = MOUSE.X%
        poly_y% = MOUSE.Y%

        ' Apply angle snapping if Ctrl+Shift are both held and we have a previous point
        IF POLY_LINE.HAS_LAST AND MODIFIERS.ctrlShift% THEN
            SNAP_to_angle POLY_LINE.LAST_X, POLY_LINE.LAST_Y, poly_x%, poly_y%, CFG.ANGLE_SNAP_DEGREES%
        END IF

        IF POLY_LINE.HAS_LAST THEN
            ' Draw line from last position to current (snapped) position
            ' Note: Undo is saved only when starting the polygon, not for each segment
            DIM poly_target AS LONG
            DIM poly_is_transparent AS INTEGER
            poly_target& = LAYER_current_image&
            _DEST poly_target&

            ' Check if drawing with transparent color
            poly_is_transparent% = (_ALPHA32(PAINT_COLOR~&) = 0)
            IF poly_is_transparent% THEN _DONTBLEND poly_target&

            IF CUSTOM_BRUSH_is_active% THEN
                ' Use custom brush stamps along polygon edges
                CUSTOM_BRUSH_stamp_line POLY_LINE.LAST_X, POLY_LINE.LAST_Y, poly_x%, poly_y%
            ELSEIF SELECTION_has_active% THEN
                ' Use clipped line drawing when selection is active
                LINE_draw_clipped POLY_LINE.LAST_X, POLY_LINE.LAST_Y, poly_x%, poly_y%, PAINT_COLOR~&
            ELSE
                ' Normal line drawing
                LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y)-(poly_x%, poly_y%), PAINT_COLOR~&
            END IF

            IF poly_is_transparent% THEN _BLEND poly_target&
            _DEST SCRN.CANVAS&
            CANVAS_DIRTY% = TRUE
        ELSE
            ' First point - just initialize, don't save undo yet
            POLY_LINE.FIRST_X = poly_x%
            POLY_LINE.FIRST_Y = poly_y%
            POLY_LINE.POINT_COUNT = 0
        END IF
        ' Store this point in the array
        IF POLY_LINE.POINT_COUNT < 1000 THEN
            POLY_POINTS_X(POLY_LINE.POINT_COUNT) = poly_x%
            POLY_POINTS_Y(POLY_LINE.POINT_COUNT) = poly_y%
            POLY_LINE.POINT_COUNT = POLY_LINE.POINT_COUNT + 1
        END IF
        ' Update last position to current (snapped) click
        POLY_LINE.LAST_X = poly_x%
        POLY_LINE.LAST_Y = poly_y%
        POLY_LINE.HAS_LAST = TRUE
    END IF
END SUB


''
' Tool handler: Rect/Rect filled.
'
SUB MOUSE_tool_rect ()
    ' RECT tool: Click and drag with preview
    IF NOT MOUSE.OLD_B1% THEN
        ' Start dragging on first click
        RECT_TOOL.DRAGGING = TRUE
        RECT_TOOL.START_X = MOUSE.X%
        RECT_TOOL.START_Y = MOUSE.Y%
        RECT_TOOL.CENTER_X = MOUSE.X%
        RECT_TOOL.CENTER_Y = MOUSE.Y%
        RECT_TOOL.END_X = MOUSE.X%
        RECT_TOOL.END_Y = MOUSE.Y%
        RECT_TOOL.FILLED = (CURRENT_TOOL% = TOOL_RECT_FILLED)
    ELSE
        ' Update end position while dragging
        DIM temp_end_x AS INTEGER, temp_end_y AS INTEGER
        temp_end_x% = MOUSE.X%
        temp_end_y% = MOUSE.Y%

        ' SHIFT: Constrain to square (calculate from center)
        IF MODIFIERS.shift% THEN
            DIM size AS INTEGER
            size% = INT(SQR((temp_end_x% - RECT_TOOL.CENTER_X) ^ 2 + (temp_end_y% - RECT_TOOL.CENTER_Y) ^ 2))
            IF temp_end_x% < RECT_TOOL.CENTER_X THEN size% = -size%
            temp_end_x% = RECT_TOOL.CENTER_X + size%
            temp_end_y% = RECT_TOOL.CENTER_Y + size%
        END IF

        ' CTRL: Draw from center
        IF MODIFIERS.ctrl% THEN
            DIM offset_x AS INTEGER, offset_y AS INTEGER
            ' Calculate offset from center to mouse
            offset_x% = temp_end_x% - RECT_TOOL.CENTER_X
            offset_y% = temp_end_y% - RECT_TOOL.CENTER_Y
            ' Set corners mirrored around center
            RECT_TOOL.START_X = RECT_TOOL.CENTER_X - offset_x%
            RECT_TOOL.START_Y = RECT_TOOL.CENTER_Y - offset_y%
            RECT_TOOL.END_X = RECT_TOOL.CENTER_X + offset_x%
            RECT_TOOL.END_Y = RECT_TOOL.CENTER_Y + offset_y%
        ELSE
            ' Normal mode: draw from corner
            RECT_TOOL.START_X = RECT_TOOL.CENTER_X
            RECT_TOOL.START_Y = RECT_TOOL.CENTER_Y
            RECT_TOOL.END_X = temp_end_x%
            RECT_TOOL.END_Y = temp_end_y%
        END IF
    END IF
END SUB


''
' Tool handler: Ellipse/Ellipse filled.
'
SUB MOUSE_tool_ellip ()
    ' ELLIPSE tool: Click and drag with preview
    IF NOT MOUSE.OLD_B1% THEN
        ' Start dragging on first click
        ELLIPSE_TOOL.DRAGGING = TRUE
        ELLIPSE_TOOL.START_X = MOUSE.X%
        ELLIPSE_TOOL.START_Y = MOUSE.Y%
        ELLIPSE_TOOL.CENTER_X = MOUSE.X%
        ELLIPSE_TOOL.CENTER_Y = MOUSE.Y%
        ELLIPSE_TOOL.END_X = MOUSE.X%
        ELLIPSE_TOOL.END_Y = MOUSE.Y%
        ELLIPSE_TOOL.FILLED = (CURRENT_TOOL% = TOOL_ELLIPSE_FILLED)
    ELSE
        ' Update end position while dragging
        DIM temp_ex AS INTEGER, temp_ey AS INTEGER
        temp_ex% = MOUSE.X%
        temp_ey% = MOUSE.Y%

        ' SHIFT: Constrain to circle (calculate from center)
        IF MODIFIERS.shift% THEN
            DIM esize AS INTEGER
            esize% = INT(SQR((temp_ex% - ELLIPSE_TOOL.CENTER_X) ^ 2 + (temp_ey% - ELLIPSE_TOOL.CENTER_Y) ^ 2))
            IF temp_ex% < ELLIPSE_TOOL.CENTER_X THEN esize% = -esize%
            temp_ex% = ELLIPSE_TOOL.CENTER_X + esize%
            temp_ey% = ELLIPSE_TOOL.CENTER_Y + esize%
        END IF

        ' CTRL: Draw from center
        IF MODIFIERS.ctrl% THEN
            DIM eoffset_x AS INTEGER, eoffset_y AS INTEGER
            ' Calculate offset from center to mouse
            eoffset_x% = temp_ex% - ELLIPSE_TOOL.CENTER_X
            eoffset_y% = temp_ey% - ELLIPSE_TOOL.CENTER_Y
            ' Set corners mirrored around center
            ELLIPSE_TOOL.START_X = ELLIPSE_TOOL.CENTER_X - eoffset_x%
            ELLIPSE_TOOL.START_Y = ELLIPSE_TOOL.CENTER_Y - eoffset_y%
            ELLIPSE_TOOL.END_X = ELLIPSE_TOOL.CENTER_X + eoffset_x%
            ELLIPSE_TOOL.END_Y = ELLIPSE_TOOL.CENTER_Y + eoffset_y%
        ELSE
            ' Normal mode: draw from corner
            ELLIPSE_TOOL.START_X = ELLIPSE_TOOL.CENTER_X
            ELLIPSE_TOOL.START_Y = ELLIPSE_TOOL.CENTER_Y
            ELLIPSE_TOOL.END_X = temp_ex%
            ELLIPSE_TOOL.END_Y = temp_ey%
        END IF
    END IF
END SUB


''
' Handles mouse input
' 
SUB MOUSE_input_handler ()
    ' ==== IMAGE IMPORT MODE - PROCESS OUTSIDE LOOP FOR PERFORMANCE ====
    ' When in image import mode, skip the normal buffered mouse processing
    ' and use direct polling for responsive interaction
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        IF MOUSE_handle_image_import% THEN EXIT SUB
    END IF
    ' ==== END IMAGE IMPORT MODE ====

    DIM wheel_delta AS INTEGER
    
    ' ==== DRAIN-THEN-PROCESS PATTERN FOR PERFORMANCE ====
    ' Now process ONCE with final mouse state (not per-event)
    IF TRUE THEN ' Block for consistent indentation
        DIM rawX AS INTEGER, rawY AS INTEGER
        DIM AS INTEGER TB_RIGHT, TB_LEFT

        MOUSE_drain_update_state rawX%, rawY%, wheel_delta%

        ' Calculate toolbar position dynamically to align to right edge of screen
        TB_RIGHT = SCRN.w& - TB_BTN_W - 1  ' Right column: 1px from right edge
        TB_LEFT = TB_RIGHT - TB_BTN_W - TB_BTN_PADDING  ' Left column: to the left of right column
        
        ' Suppress button input after native dialogs to prevent phantom clicks
        ' SDL can produce spurious button events when the window regains focus
        ' after a GTK/native dialog closes, arriving after MOUSE_force_buttons_up
        IF MOUSE.SUPPRESS_FRAMES% > 0 THEN
            DO WHILE _MOUSEINPUT : LOOP  ' Drain any late-arriving events
            MOUSE.B1% = FALSE
            MOUSE.B2% = FALSE
            MOUSE.B3% = FALSE
            MOUSE.OLD_B1% = FALSE
            MOUSE.OLD_B2% = FALSE
            MOUSE.OLD_B3% = FALSE
            MOUSE.SUPPRESS_FRAMES% = MOUSE.SUPPRESS_FRAMES% - 1
            MOUSE.OLD_X% = MOUSE.X%
            MOUSE.OLD_Y% = MOUSE.Y%
            EXIT SUB
        END IF
        
        ' Auto-apply move transform when clicking GUI controls (without marquee selection)
        ' This ensures moving an entire layer is committed when user clicks elsewhere
        MOUSE_autocommit_move_if_click_on_gui rawX%, rawY%
        
        ' Handle command palette clicks first (takes priority)
        IF MOUSE_handle_command_palette_click%(rawX%, rawY%) THEN EXIT SUB
        
        ' Handle menu bar mouse move (hover tracking with menu switching)
        MOUSE_handle_menubar_mouse_move rawX%, rawY%

        ' Handle menu bar clicks (after command palette, before other GUI)
        IF MOUSE_handle_menubar_click%(rawX%, rawY%) THEN EXIT SUB

        ' Close palette menu when clicking outside its bounds
        DIM paletteClosed AS INTEGER
        paletteClosed% = MOUSE_handle_palette_menu_close%(rawX%, rawY%)
        
        ' Check for CTRL+click to set symmetry center (before other button processing)
        ' On macOS, CTRL+left-click is converted to right-click (B2) by the OS,
        ' so we also check CTRL+B2 to handle that platform quirk.
        DIM ctrlHeld AS INTEGER
        ctrlHeld% = MODIFIERS.ctrl%
        DIM ctrlClicked AS INTEGER
        ctrlClicked% = FALSE
        IF ctrlHeld% THEN
            IF (MOUSE.B1% AND NOT MOUSE.OLD_B1%) OR (MOUSE.B2% AND NOT MOUSE.OLD_B2%) THEN
                ctrlClicked% = TRUE
            END IF
        END IF
        IF ctrlClicked% THEN
            ' CTRL+click - set symmetry center
            SYMMETRY_set_center MOUSE.X%, MOUSE.Y%
            ' Mark as toolbar clicked to prevent drawing action
            MOUSE.TOOLBAR_CLICKED% = TRUE
        END IF
        
        ' Set drawing color based on active mouse button
        ' Left button (B1) uses foreground, Right button (B2) uses background
        DIM draw_button AS INTEGER
        draw_button% = MOUSE.B1% OR MOUSE.B2%
        IF MOUSE.B2% THEN
            DRAW_COLOR~& = PAINT_BG_COLOR~&
        ELSE
            DRAW_COLOR~& = PAINT_COLOR~&
        END IF
        
        ' Reset toolbar clicked flag only when mouse button is released
        IF NOT MOUSE.B1% AND NOT MOUSE.B2% THEN
            MOUSE.TOOLBAR_CLICKED% = FALSE
        END IF
        
        ' Layer panel
        MOUSE_handle_layer_panel rawX%, rawY%, wheel_delta%
        
        ' Toolbar/status/palette
        MOUSE_handle_toolbar_status_palette rawX%, rawY%
        
        ' Check for ALT key press to activate temporary color picker
        ' Only for drawing tools - NOT for MOVE (ALT=clone), MARQUEE, IMAGE_IMPORT, NULL, etc.
        ' Also skip if CTRL or SHIFT are held (likely a hotkey combo like CTRL+ALT+SHIFT)
        DIM isDrawingTool%
        DIM isCtrlOrShiftHeld%
        DIM altHeld%
        STATIC altWasHeld%  ' Track ALT state from previous frame
        STATIC pickerFromAlt%  ' Track if we entered picker via ALT key
        
        isCtrlOrShiftHeld% = (MODIFIERS.ctrl% OR MODIFIERS.shift%)
        altHeld% = MODIFIERS.alt%
        
        ' Check if current tool (or previous tool if in picker mode) is a drawing tool
        IF CURRENT_TOOL% = TOOL_PICKER AND pickerFromAlt% THEN
            ' When in ALT-triggered picker mode, check PREVIOUS_TOOL to know if we came from a drawing tool
            isDrawingTool% = (PREVIOUS_TOOL% = TOOL_DOT OR PREVIOUS_TOOL% = TOOL_BRUSH OR _
                             PREVIOUS_TOOL% = TOOL_LINE OR PREVIOUS_TOOL% = TOOL_RECT OR _
                             PREVIOUS_TOOL% = TOOL_RECT_FILLED OR PREVIOUS_TOOL% = TOOL_ELLIPSE OR _
                             PREVIOUS_TOOL% = TOOL_ELLIPSE_FILLED OR PREVIOUS_TOOL% = TOOL_FILL OR _
                             PREVIOUS_TOOL% = TOOL_POLYGON OR PREVIOUS_TOOL% = TOOL_POLYGON_FILLED OR _
                             PREVIOUS_TOOL% = TOOL_TEXT OR PREVIOUS_TOOL% = TOOL_SPRAY)
        ELSE
            isDrawingTool% = (CURRENT_TOOL% = TOOL_DOT OR CURRENT_TOOL% = TOOL_BRUSH OR _
                             CURRENT_TOOL% = TOOL_LINE OR CURRENT_TOOL% = TOOL_RECT OR _
                             CURRENT_TOOL% = TOOL_RECT_FILLED OR CURRENT_TOOL% = TOOL_ELLIPSE OR _
                             CURRENT_TOOL% = TOOL_ELLIPSE_FILLED OR CURRENT_TOOL% = TOOL_FILL OR _
                             CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED OR _
                             CURRENT_TOOL% = TOOL_TEXT OR CURRENT_TOOL% = TOOL_SPRAY)
        END IF
        
        ' Only ENTER picker mode when ALT is FIRST pressed (transition), not just held
        ' This prevents re-entering picker when releasing other modifiers while ALT is still held
        DIM altJustPressed%
        altJustPressed% = (altHeld% AND NOT altWasHeld%)
        
        ' Skip ALT picker when mouse is over menu bar
        DIM overMenuBar%
        overMenuBar% = FALSE
        IF SCRN.showMenubar% AND MENU_BAR.visible% THEN
            overMenuBar% = MENUBAR_in_bounds%(rawX%, rawY%) OR MENUBAR_submenu_in_bounds%(rawX%, rawY%) OR MENUBAR_is_open%
        END IF

        IF altJustPressed% AND isDrawingTool% AND NOT isCtrlOrShiftHeld% AND NOT overMenuBar% THEN
            ' ALT just pressed alone with a drawing tool - enter picker mode
            IF CURRENT_TOOL% <> TOOL_PICKER THEN
                PREVIOUS_TOOL% = CURRENT_TOOL%
                CURRENT_TOOL% = TOOL_PICKER
                GUI_NEEDS_REDRAW% = TRUE
                PICKER_activate
                FILL_deactivate
                pickerFromAlt% = TRUE
            END IF
        ELSEIF pickerFromAlt% THEN
            ' We're in ALT-triggered picker mode - check if we should exit
            IF NOT altHeld% OR isCtrlOrShiftHeld% THEN
                ' Exit picker mode: ALT released OR other modifiers added
                IF CURRENT_TOOL% = TOOL_PICKER AND PREVIOUS_TOOL% <> TOOL_PICKER THEN
                    CURRENT_TOOL% = PREVIOUS_TOOL%
                    GUI_NEEDS_REDRAW% = TRUE
                    PICKER_deactivate
                    IF CURRENT_TOOL% = TOOL_FILL THEN
                        FILL_activate
                    END IF
                END IF
                pickerFromAlt% = FALSE
            END IF
        END IF
        
        ' Pick color on left click while in ALT-picker mode
        IF pickerFromAlt% AND CURRENT_TOOL% = TOOL_PICKER THEN
            IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                PICKER_pick_color MOUSE.X%, MOUSE.Y%, 1
            END IF
        END IF
        
        ' Update ALT state for next frame
        altWasHeld% = altHeld%
        
        ' Double middle-click reset + UI auto-hide/restore
        MOUSE_handle_b3_dblclick_reset_zoom
        MOUSE_handle_ui_autohide_restore rawX%, rawY%
        
        ' Pan mode (spacebar + LMB OR MMB OR PAN tool + LMB)
        MOUSE_handle_panning rawX%, rawY%
        
        ' Skip tool actions if we just clicked on the toolbar
        IF MOUSE.TOOLBAR_CLICKED% THEN
            MOUSE.OLD_B1% = MOUSE.B1%
            MOUSE.OLD_B2% = MOUSE.B2%
            MOUSE.OLD_B3% = MOUSE.B3%
            MOUSE.OLD_X% = MOUSE.X%
            MOUSE.OLD_Y% = MOUSE.Y%
            EXIT SUB
        END IF
        
        ' Skip normal tool behavior if panning
        IF SCRN.panning% THEN
            ' Don't process tools while panning
        ELSEIF MOUSE.B1% OR MOUSE.B2% THEN
            ' Handle different tools based on CURRENT_TOOL (B1=left=FG, B2=right=BG)
            SELECT CASE CURRENT_TOOL%
                CASE TOOL_NULL
                    ' Null tool - does nothing (used during dialogs to prevent phantom events)
                    ' Intentionally empty
                CASE TOOL_MARQUEE
                    MOUSE_tool_marquee
                CASE TOOL_MOVE
                    MOUSE_tool_move
                CASE TOOL_FILL
                    ' Flood fill on click (only on button press, not while held)
                    IF FILL.ACTIVE% AND NOT MOUSE.OLD_B1% AND NOT UNDO_saved_this_frame% THEN
                        UNDO_saved_this_frame% = TRUE
                        FILL.COLOR~& = PAINT_COLOR~&
                        FILL_flood MOUSE.X%, MOUSE.Y%
                        UNDO_save_state ' Save state after fill
                    END IF
                CASE TOOL_PICKER
                    ' Pick color on click (only on button press, not while held)
                    IF PICKER.ACTIVE% AND NOT MOUSE.OLD_B1% THEN
                        PICKER_pick_color MOUSE.X%, MOUSE.Y%, 1  ' 1 = left button/foreground
                    END IF
                CASE TOOL_SAVE
                    ' SAVE tool: Defer save dialog to avoid calling from within mouse loop
                    IF NOT MOUSE.OLD_B1% THEN
                        MOUSE.DEFERRED_ACTION% = 1  ' 1 = save
                        ' Return to previous tool after save is triggered
                        CURRENT_TOOL% = PREVIOUS_TOOL%
                        GUI_NEEDS_REDRAW% = TRUE
                    END IF
                CASE TOOL_OPEN
                    ' LOAD tool: Defer load dialog to avoid calling from within mouse loop
                    IF NOT MOUSE.OLD_B1% THEN
                        MOUSE.DEFERRED_ACTION% = 2  ' 2 = load
                        ' Return to previous tool after load is triggered
                        CURRENT_TOOL% = PREVIOUS_TOOL%
                        GUI_NEEDS_REDRAW% = TRUE
                    END IF
                CASE TOOL_TEXT
                    ' TEXT tool: Click to start or reposition text entry
                    IF NOT MOUSE.OLD_B1% THEN
                        TEXT_start MOUSE.X%, MOUSE.Y%
                    END IF
                CASE TOOL_LINE
                    MOUSE_tool_line
                CASE TOOL_POLYGON, TOOL_POLYGON_FILLED
                    MOUSE_tool_poly
                CASE TOOL_RECT, TOOL_RECT_FILLED
                    MOUSE_tool_rect
                CASE TOOL_ELLIPSE, TOOL_ELLIPSE_FILLED
                    MOUSE_tool_ellip
                CASE TOOL_BRUSH
                    ' Reset pixel-perfect stroke on first mouse down
                    IF NOT MOUSE.OLD_B1% THEN
                        PP_STROKE_COUNT% = 0
                    END IF
                    ' Only draw while LEFT button is held (not right-click)
                    ' Right-click with SHIFT is for connecting lines, handled separately
                    IF MOUSE.B1% THEN
                        IF MOUSE.X% < MOUSE.OLD_X% THEN MOUSE.DRAG$ = "L"
                        IF MOUSE.X% > MOUSE.OLD_X% THEN MOUSE.DRAG$ = "R"
                        IF MOUSE.Y% < MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "U"
                        IF MOUSE.Y% > MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "D"
                        PAINT_on
                    END IF
                CASE TOOL_DOT
                    ' DOT stamps a single point on initial click only (no drag)
                    IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                        PP_STROKE_COUNT% = 0
                        ' Set old position to current to prevent line interpolation
                        MOUSE.OLD_X% = MOUSE.X%
                        MOUSE.OLD_Y% = MOUSE.Y%
                        PAINT_on
                    END IF
                CASE TOOL_SPRAY
                    ' Spray paint on left mouse button hold
                    IF MOUSE.B1% THEN
                        ' Save undo state on first press
                        IF NOT MOUSE.OLD_B1% AND NOT UNDO_saved_this_frame% THEN
                            UNDO_save_state
                            UNDO_saved_this_frame% = TRUE
                        END IF
                        ' Track drag direction for SHIFT axis constraint
                        IF MOUSE.X% < MOUSE.OLD_X% THEN MOUSE.DRAG$ = "L"
                        IF MOUSE.X% > MOUSE.OLD_X% THEN MOUSE.DRAG$ = "R"
                        IF MOUSE.Y% < MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "U"
                        IF MOUSE.Y% > MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "D"
                        SPRAY.ACTIVE = TRUE
                        ' Apply axis constraint if active
                        DIM sprayX AS INTEGER, sprayY AS INTEGER
                        IF CONSTRAIN_X% THEN
                            sprayX% = MOUSE.CON_X%: sprayY% = MOUSE.Y%
                        ELSEIF CONSTRAIN_Y% THEN
                            sprayX% = MOUSE.X%: sprayY% = MOUSE.CON_Y%
                        ELSE
                            sprayX% = MOUSE.X%: sprayY% = MOUSE.Y%
                        END IF
                        SPRAY_on sprayX%, sprayY%, DRAW_COLOR~&
                    ELSEIF MOUSE.B2% THEN
                        ' Right button sprays with BG color
                        IF NOT MOUSE.OLD_B2% AND NOT UNDO_saved_this_frame% THEN
                            UNDO_save_state
                            UNDO_saved_this_frame% = TRUE
                        END IF
                        ' Track drag direction for SHIFT axis constraint
                        IF MOUSE.X% < MOUSE.OLD_X% THEN MOUSE.DRAG$ = "L"
                        IF MOUSE.X% > MOUSE.OLD_X% THEN MOUSE.DRAG$ = "R"
                        IF MOUSE.Y% < MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "U"
                        IF MOUSE.Y% > MOUSE.OLD_Y% THEN MOUSE.DRAG$ = "D"
                        SPRAY.ACTIVE = TRUE
                        IF CONSTRAIN_X% THEN
                            sprayX% = MOUSE.CON_X%: sprayY% = MOUSE.Y%
                        ELSEIF CONSTRAIN_Y% THEN
                            sprayX% = MOUSE.X%: sprayY% = MOUSE.CON_Y%
                        ELSE
                            sprayX% = MOUSE.X%: sprayY% = MOUSE.Y%
                        END IF
                        SPRAY_on sprayX%, sprayY%, PAINT_BG_COLOR~&
                    END IF
                CASE TOOL_ZOOM
                    ' Zoom tool: click to zoom in at cursor, alt+click to zoom out
                    ' Drag to zoom into a region
                    IF MOUSE.B1% AND NOT MOUSE.OLD_B1% THEN
                        ' Mouse just pressed - start drag tracking
                        ZOOM.DRAGGING = TRUE
                        ZOOM.START_X = rawX%
                        ZOOM.START_Y = rawY%
                        ZOOM.END_X = rawX%
                        ZOOM.END_Y = rawY%
                    ELSEIF MOUSE.B1% AND ZOOM.DRAGGING THEN
                        ' Continue dragging - update end position
                        ZOOM.END_X = rawX%
                        ZOOM.END_Y = rawY%
                    END IF
            END SELECT
        ELSEIF NOT MOUSE.B1% THEN
            ' Button released - save undo state if we were drawing
            IF MOUSE.OLD_B1% AND NOT UNDO_saved_this_frame% THEN
                SELECT CASE CURRENT_TOOL%
                    CASE TOOL_ZOOM
                        ' Zoom tool release - check if it was a click or a drag
                        IF ZOOM.DRAGGING THEN
                            DIM zDragW AS INTEGER, zDragH AS INTEGER
                            zDragW% = ABS(ZOOM.END_X - ZOOM.START_X)
                            zDragH% = ABS(ZOOM.END_Y - ZOOM.START_Y)
                            IF zDragW% >= 8 AND zDragH% >= 8 THEN
                                ' Drag was large enough - zoom to region
                                ZOOM_to_region ZOOM.START_X, ZOOM.START_Y, ZOOM.END_X, ZOOM.END_Y
                            ELSE
                                ' Small drag or click - zoom in/out at cursor
                                DIM zScreenX AS INTEGER, zScreenY AS INTEGER
                                zScreenX% = rawX%
                                zScreenY% = rawY%
                                IF MODIFIERS.alt% THEN
                                    ZOOM_out_at zScreenX%, zScreenY%
                                ELSE
                                    ZOOM_in_at zScreenX%, zScreenY%
                                END IF
                            END IF
                            ZOOM_drag_reset
                        END IF
                    CASE TOOL_MARQUEE
                        ' Finish the marquee drag, resize, or move
                        IF MARQUEE.DRAGGING% THEN
                            MARQUEE_finish_drag
                        ELSEIF MARQUEE.RESIZING% THEN
                            MARQUEE_finish_resize
                        ELSEIF MARQUEE.MOVING% THEN
                            MARQUEE_finish_move
                        END IF
                    CASE TOOL_MOVE
                        ' Mouse released - check for clone/stamp mode
                        IF MOVE.ACTIVE AND MOVE.TRANSFORMING THEN
                            DIM moveReleaseAlt%
                            moveReleaseAlt% = MODIFIERS.alt%
                            
                            IF moveReleaseAlt% THEN
                                ' ALT held on release = stamp a copy and stay in clone mode
                                MOVE_stamp
                                ' Keep MOVE.TRANSFORMING = FALSE so next click starts fresh drag
                            END IF
                            
                            ' Update base selection to current position for next transform
                            MOVE.SELECTION_X = MOVE.CURRENT_X
                            MOVE.SELECTION_Y = MOVE.CURRENT_Y
                            MOVE.SELECTION_W = MOVE.CURRENT_W
                            MOVE.SELECTION_H = MOVE.CURRENT_H
                            MOVE.TRANSFORMING = FALSE
                        END IF
                    CASE TOOL_LINE
                        ' Draw the final line on mouse release
                        IF LINE_TOOL.DRAGGING THEN
                            DIM line_mx(0 TO 7) AS INTEGER
                            DIM line_my(0 TO 7) AS INTEGER
                            DIM line_sx(0 TO 7) AS INTEGER
                            DIM line_sy(0 TO 7) AS INTEGER
                            DIM line_count AS INTEGER
                            DIM line_i AS INTEGER
                            DIM line_target AS LONG
                            DIM line_is_transparent AS INTEGER
                            
                            line_target& = LAYER_current_image&
                            _DEST line_target&
                            
                            ' Check if drawing with transparent color
                            line_is_transparent% = (_ALPHA32(PAINT_COLOR~&) = 0)
                            IF line_is_transparent% THEN _DONTBLEND line_target&
                            
                            IF CUSTOM_BRUSH_is_active% THEN
                                ' Use custom brush stamps along the line
                                CUSTOM_BRUSH_stamp_line LINE_TOOL.START_X, LINE_TOOL.START_Y, LINE_TOOL.END_X, LINE_TOOL.END_Y
                                ' TODO: Add symmetry support for custom brush lines
                            ELSEIF SELECTION_has_active% THEN
                                ' Use clipped line drawing when selection is active
                                LINE_draw_clipped LINE_TOOL.START_X, LINE_TOOL.START_Y, LINE_TOOL.END_X, LINE_TOOL.END_Y, PAINT_COLOR~&
                                
                                ' Draw clipped symmetry lines
                                IF SYMMETRY.MODE > 0 THEN
                                    SYMMETRY_get_mirrored_points LINE_TOOL.START_X, LINE_TOOL.START_Y, line_sx%(), line_sy%(), line_count%
                                    SYMMETRY_get_mirrored_points LINE_TOOL.END_X, LINE_TOOL.END_Y, line_mx%(), line_my%(), line_count%
                                    
                                    FOR line_i% = 0 TO line_count% - 1
                                        LINE_draw_clipped line_sx%(line_i%), line_sy%(line_i%), line_mx%(line_i%), line_my%(line_i%), PAINT_COLOR~&
                                    NEXT line_i%
                                END IF
                            ELSE
                                ' Draw master line at full opacity
                                LINE (LINE_TOOL.START_X, LINE_TOOL.START_Y)-(LINE_TOOL.END_X, LINE_TOOL.END_Y), PAINT_COLOR~&
                                
                                ' Draw symmetry lines at full opacity
                                IF SYMMETRY.MODE > 0 THEN
                                    SYMMETRY_get_mirrored_points LINE_TOOL.START_X, LINE_TOOL.START_Y, line_sx%(), line_sy%(), line_count%
                                    SYMMETRY_get_mirrored_points LINE_TOOL.END_X, LINE_TOOL.END_Y, line_mx%(), line_my%(), line_count%
                                    
                                    FOR line_i% = 0 TO line_count% - 1
                                        LINE (line_sx%(line_i%), line_sy%(line_i%))-(line_mx%(line_i%), line_my%(line_i%)), PAINT_COLOR~&
                                    NEXT line_i%
                                END IF
                            END IF
                            
                            IF line_is_transparent% THEN _BLEND line_target&
                            _DEST SCRN.CANVAS&
                            LINE_TOOL.DRAGGING = FALSE
                            CANVAS_DIRTY% = TRUE
                            UNDO_save_state ' Save state after drawing line
                            UNDO_saved_this_frame% = TRUE
                        END IF
                    CASE TOOL_RECT, TOOL_RECT_FILLED
                        ' Draw the final rectangle on mouse release
                        IF RECT_TOOL.DRAGGING THEN
                            DIM rect_fsx(0 TO 7) AS INTEGER, rect_fsy(0 TO 7) AS INTEGER
                            DIM rect_fex(0 TO 7) AS INTEGER, rect_fey(0 TO 7) AS INTEGER
                            DIM rect_fcount AS INTEGER, rect_fi AS INTEGER
                            DIM rect_target AS LONG
                            DIM rect_is_transparent AS INTEGER
                            DIM rect_has_selection AS INTEGER
                            
                            rect_target& = LAYER_current_image&
                            _DEST rect_target&
                            
                            ' Check if there's an active selection for clipping
                            rect_has_selection% = SELECTION_has_active%
                            
                            ' Check if drawing with transparent color
                            rect_is_transparent% = (_ALPHA32(PAINT_COLOR~&) = 0)
                            IF rect_is_transparent% THEN _DONTBLEND rect_target&
                            
                            IF CUSTOM_BRUSH_is_active% AND NOT RECT_TOOL.FILLED THEN
                                ' Use custom brush stamps for outline only
                                CUSTOM_BRUSH_stamp_line RECT_TOOL.START_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.START_Y ' Top
                                CUSTOM_BRUSH_stamp_line RECT_TOOL.END_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.END_Y     ' Right
                                CUSTOM_BRUSH_stamp_line RECT_TOOL.END_X, RECT_TOOL.END_Y, RECT_TOOL.START_X, RECT_TOOL.END_Y     ' Bottom
                                CUSTOM_BRUSH_stamp_line RECT_TOOL.START_X, RECT_TOOL.END_Y, RECT_TOOL.START_X, RECT_TOOL.START_Y ' Left
                                ' TODO: Add symmetry support for custom brush rectangles
                            ELSE
                                ' Normal rectangle drawing
                                IF RECT_TOOL.FILLED THEN
                                    ' Check if NumLock is OFF and dither pattern is active
                                    IF NOT _NUMLOCK AND BRUSH_DITHER_ACTIVE > 0 THEN
                                        ' Use dither pattern fill (PAINT_pset_with_symmetry already handles symmetry and selection)
                                        DIM rx AS INTEGER, ry AS INTEGER
                                        DIM min_x AS INTEGER, max_x AS INTEGER, min_y AS INTEGER, max_y AS INTEGER
                                        min_x% = RECT_TOOL.START_X: max_x% = RECT_TOOL.END_X
                                        IF min_x% > max_x% THEN SWAP min_x%, max_x%
                                        min_y% = RECT_TOOL.START_Y: max_y% = RECT_TOOL.END_Y
                                        IF min_y% > max_y% THEN SWAP min_y%, max_y%
                                        FOR ry% = min_y% TO max_y%
                                            FOR rx% = min_x% TO max_x%
                                                IF BRUSH_DITHERS_should_draw%(rx%, ry%) THEN
                                                    PAINT_pset_with_symmetry rx%, ry%, PAINT_COLOR~&, TRUE
                                                END IF
                                            NEXT rx%
                                        NEXT ry%
                                    ELSEIF rect_has_selection% THEN
                                        ' Use clipped filled rect when selection is active
                                        RECT_draw_clipped_filled RECT_TOOL.START_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.END_Y, PAINT_COLOR~&
                                        
                                        ' Draw clipped symmetry rectangles
                                        IF SYMMETRY.MODE > 0 THEN
                                            SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_fsx%(), rect_fsy%(), rect_fcount%
                                            SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_fex%(), rect_fey%(), rect_fcount%
                                            
                                            FOR rect_fi% = 0 TO rect_fcount% - 1
                                                RECT_draw_clipped_filled rect_fsx%(rect_fi%), rect_fsy%(rect_fi%), rect_fex%(rect_fi%), rect_fey%(rect_fi%), PAINT_COLOR~&
                                            NEXT rect_fi%
                                        END IF
                                    ELSE
                                        ' Solid fill - draw master rectangle
                                        LINE (RECT_TOOL.START_X, RECT_TOOL.START_Y)-(RECT_TOOL.END_X, RECT_TOOL.END_Y), PAINT_COLOR~&, BF
                                        
                                        ' Draw symmetry rectangles at full opacity
                                        IF SYMMETRY.MODE > 0 THEN
                                            SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_fsx%(), rect_fsy%(), rect_fcount%
                                            SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_fex%(), rect_fey%(), rect_fcount%
                                            
                                            FOR rect_fi% = 0 TO rect_fcount% - 1
                                                LINE (rect_fsx%(rect_fi%), rect_fsy%(rect_fi%))-(rect_fex%(rect_fi%), rect_fey%(rect_fi%)), PAINT_COLOR~&, BF
                                            NEXT rect_fi%
                                        END IF
                                    END IF
                                ELSEIF rect_has_selection% THEN
                                    ' Use clipped outline when selection is active
                                    RECT_draw_clipped_outline RECT_TOOL.START_X, RECT_TOOL.START_Y, RECT_TOOL.END_X, RECT_TOOL.END_Y, PAINT_COLOR~&
                                    
                                    ' Draw clipped symmetry rectangles
                                    IF SYMMETRY.MODE > 0 THEN
                                        SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_fsx%(), rect_fsy%(), rect_fcount%
                                        SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_fex%(), rect_fey%(), rect_fcount%
                                        
                                        FOR rect_fi% = 0 TO rect_fcount% - 1
                                            RECT_draw_clipped_outline rect_fsx%(rect_fi%), rect_fsy%(rect_fi%), rect_fex%(rect_fi%), rect_fey%(rect_fi%), PAINT_COLOR~&
                                        NEXT rect_fi%
                                    END IF
                                ELSE
                                    ' Outline - draw master rectangle
                                    LINE (RECT_TOOL.START_X, RECT_TOOL.START_Y)-(RECT_TOOL.END_X, RECT_TOOL.END_Y), PAINT_COLOR~&, B
                                    
                                    ' Draw symmetry rectangles at full opacity
                                    IF SYMMETRY.MODE > 0 THEN
                                        SYMMETRY_get_mirrored_points RECT_TOOL.START_X, RECT_TOOL.START_Y, rect_fsx%(), rect_fsy%(), rect_fcount%
                                        SYMMETRY_get_mirrored_points RECT_TOOL.END_X, RECT_TOOL.END_Y, rect_fex%(), rect_fey%(), rect_fcount%
                                        
                                        FOR rect_fi% = 0 TO rect_fcount% - 1
                                            LINE (rect_fsx%(rect_fi%), rect_fsy%(rect_fi%))-(rect_fex%(rect_fi%), rect_fey%(rect_fi%)), PAINT_COLOR~&, B
                                        NEXT rect_fi%
                                    END IF
                                END IF
                            END IF
                            
                            IF rect_is_transparent% THEN _BLEND rect_target&
                            _DEST SCRN.CANVAS&
                            RECT_TOOL.DRAGGING = FALSE
                            CANVAS_DIRTY% = TRUE
                            UNDO_save_state ' Save state after drawing rectangle
                            UNDO_saved_this_frame% = TRUE
                        END IF
                    CASE TOOL_ELLIPSE, TOOL_ELLIPSE_FILLED
                        ' Draw the final ellipse on mouse release
                        IF ELLIPSE_TOOL.DRAGGING THEN
                            DIM ecx AS INTEGER, ecy AS INTEGER, erx AS SINGLE, ery AS SINGLE, easp AS SINGLE
                            ecx% = (ELLIPSE_TOOL.START_X + ELLIPSE_TOOL.END_X) \ 2
                            ecy% = (ELLIPSE_TOOL.START_Y + ELLIPSE_TOOL.END_Y) \ 2
                            erx! = ABS(ELLIPSE_TOOL.END_X - ELLIPSE_TOOL.START_X) / 2
                            ery! = ABS(ELLIPSE_TOOL.END_Y - ELLIPSE_TOOL.START_Y) / 2
                            IF erx! > 0 THEN easp! = ery! / erx! ELSE easp! = 1
                            
                            DIM ell_fcsx(0 TO 7) AS INTEGER, ell_fcsy(0 TO 7) AS INTEGER
                            DIM ell_fcount AS INTEGER, ell_fi AS INTEGER
                            DIM ell_target AS LONG
                            DIM ell_is_transparent AS INTEGER
                            DIM ell_has_selection AS INTEGER
                            
                            ell_target& = LAYER_current_image&
                            _DEST ell_target&
                            
                            ' Check if there's an active selection for clipping
                            ell_has_selection% = SELECTION_has_active%
                            
                            ' Check if drawing with transparent color
                            ell_is_transparent% = (_ALPHA32(PAINT_COLOR~&) = 0)
                            IF ell_is_transparent% THEN _DONTBLEND ell_target&
                            
                            IF erx! > 0 THEN
                                IF CUSTOM_BRUSH_is_active% AND NOT ELLIPSE_TOOL.FILLED THEN
                                    ' Use custom brush stamps for outline only
                                    CUSTOM_BRUSH_stamp_ellipse ecx%, ecy%, erx!, ery!
                                    ' TODO: Add symmetry support for custom brush ellipses
                                ELSE
                                    ' Normal ellipse drawing
                                    IF ELLIPSE_TOOL.FILLED THEN
                                        ' Draw filled ellipse using scanline algorithm (already handles selection)
                                        IF NOT ell_has_selection% THEN
                                            CIRCLE (ecx%, ecy%), erx!, PAINT_COLOR~&, , , easp!
                                        END IF
                                        ELLIPSE_fill_scanline ecx%, ecy%, erx!, ery!, PAINT_COLOR~&, LAYER_current_image&
                                        
                                        ' Draw symmetry ellipses
                                        IF SYMMETRY.MODE > 0 THEN
                                            SYMMETRY_get_mirrored_points ecx%, ecy%, ell_fcsx%(), ell_fcsy%(), ell_fcount%
                                            
                                            FOR ell_fi% = 0 TO ell_fcount% - 1
                                                IF NOT ell_has_selection% THEN
                                                    CIRCLE (ell_fcsx%(ell_fi%), ell_fcsy%(ell_fi%)), erx!, PAINT_COLOR~&, , , easp!
                                                END IF
                                                ELLIPSE_fill_scanline ell_fcsx%(ell_fi%), ell_fcsy%(ell_fi%), erx!, ery!, PAINT_COLOR~&, LAYER_current_image&
                                            NEXT ell_fi%
                                        END IF
                                    ELSEIF ell_has_selection% THEN
                                        ' Use clipped ellipse outline when selection is active
                                        ELLIPSE_draw_clipped_outline ecx%, ecy%, erx!, ery!, PAINT_COLOR~&
                                        
                                        ' Draw clipped symmetry ellipses
                                        IF SYMMETRY.MODE > 0 THEN
                                            SYMMETRY_get_mirrored_points ecx%, ecy%, ell_fcsx%(), ell_fcsy%(), ell_fcount%
                                            
                                            FOR ell_fi% = 0 TO ell_fcount% - 1
                                                ELLIPSE_draw_clipped_outline ell_fcsx%(ell_fi%), ell_fcsy%(ell_fi%), erx!, ery!, PAINT_COLOR~&
                                            NEXT ell_fi%
                                        END IF
                                    ELSE
                                        ' Draw ellipse outline
                                        CIRCLE (ecx%, ecy%), erx!, PAINT_COLOR~&, , , easp!
                                        
                                        ' Draw symmetry ellipses at full opacity
                                        IF SYMMETRY.MODE > 0 THEN
                                            SYMMETRY_get_mirrored_points ecx%, ecy%, ell_fcsx%(), ell_fcsy%(), ell_fcount%
                                            
                                            FOR ell_fi% = 0 TO ell_fcount% - 1
                                                CIRCLE (ell_fcsx%(ell_fi%), ell_fcsy%(ell_fi%)), erx!, PAINT_COLOR~&, , , easp!
                                            NEXT ell_fi%
                                        END IF
                                    END IF
                                END IF
                            END IF
                            
                            IF ell_is_transparent% THEN _BLEND ell_target&
                            _DEST SCRN.CANVAS&
                            ELLIPSE_TOOL.DRAGGING = FALSE
                            CANVAS_DIRTY% = TRUE
                            UNDO_save_state ' Save state after drawing ellipse
                            UNDO_saved_this_frame% = TRUE
                        END IF
                    CASE TOOL_BRUSH
                        ' Draw collected pixel perfect stroke if enabled
                        IF BRUSH_SIZE.PIXEL_PERFECT AND PP_STROKE_COUNT% > 0 THEN
                            PAINT_draw_pixel_perfect
                        END IF
                        CANVAS_DIRTY% = TRUE
                        PP_STROKE_COUNT% = 0
                        UNDO_save_state
                        UNDO_saved_this_frame% = TRUE
                        ' Update DOT.LAST position for SHIFT+RightClick dynamic lines
                        ' This captures the final position after any mouse movement
                        DOT.LAST_X = MOUSE.X%
                        DOT.LAST_Y = MOUSE.Y%
                        DOT.HAS_LAST = TRUE
                    CASE TOOL_DOT
                        ' DOT stamps single pixel - just finalize
                        CANVAS_DIRTY% = TRUE
                        UNDO_save_state
                        UNDO_saved_this_frame% = TRUE
                        DOT.LAST_X = MOUSE.X%
                        DOT.LAST_Y = MOUSE.Y%
                        DOT.HAS_LAST = TRUE
                    CASE TOOL_TEXT
                        ' TEXT tool applies via ESC key or clicking elsewhere
                        ' TEXT_apply() saves undo, so just set flag to prevent double-save
                        ' Note: This case only triggers if mouse was released after TEXT.ACTIVE
                        _LOGINFO "MOUSE release TOOL_TEXT: TEXT.ACTIVE=" + STR$(TEXT.ACTIVE) + " flag=" + STR$(UNDO_saved_this_frame%)
                        IF TEXT.ACTIVE THEN
                            UNDO_saved_this_frame% = TRUE
                        END IF
                    CASE TOOL_SPRAY
                        ' Spray tool - reset active flag on release
                        SPRAY.ACTIVE = FALSE
                        CANVAS_DIRTY% = TRUE
                END SELECT
            END IF
            MOUSE.DRAG$ = ""
            MOUSE.CON_X% = 0 : MOUSE.CON_Y% = 0
            CONSTRAIN_X% = FALSE : CONSTRAIN_Y% = FALSE
        END IF
        
        ' Right Click handling for different tools
        IF MOUSE.B2% AND NOT MOUSE.OLD_B2% THEN
            _LOGINFO "Right-click detected: B2=" + STR$(MOUSE.B2%) + " OLD_B2=" + STR$(MOUSE.OLD_B2%)
            _LOGINFO "Current tool=" + STR$(CURRENT_TOOL%) + " (DOT=3, BRUSH=1)"
            _LOGINFO "SHIFT held: " + STR$(MODIFIERS.shift%)
            _LOGINFO "MOUSE position at right-click: X=" + STR$(MOUSE.X%) + " Y=" + STR$(MOUSE.Y%)
            _LOGINFO "RAW mouse position: _MOUSEX=" + STR$(_MOUSEX) + " _MOUSEY=" + STR$(_MOUSEY)
            
            ' SHIFT + Right Click: Draw line from last dot/brush to current position
            IF (CURRENT_TOOL% = TOOL_DOT OR CURRENT_TOOL% = TOOL_BRUSH) AND MODIFIERS.shift% THEN
                _LOGINFO "SHIFT+Right-click on BRUSH/DOT tool - checking DOT.HAS_LAST=" + STR$(DOT.HAS_LAST)
                _LOGINFO "BEFORE drawing: DOT.LAST_X=" + STR$(DOT.LAST_X) + " DOT.LAST_Y=" + STR$(DOT.LAST_Y)
                _LOGINFO "BEFORE drawing: MOUSE.X%=" + STR$(MOUSE.X%) + " MOUSE.Y%=" + STR$(MOUSE.Y%)
                IF DOT.HAS_LAST THEN
                    _LOGINFO "Drawing dynamic line from (" + STR$(DOT.LAST_X) + "," + STR$(DOT.LAST_Y) + ") to (" + STR$(MOUSE.X%) + "," + STR$(MOUSE.Y%) + ")"
                    _LOGINFO "Using PAINT_COLOR=" + STR$(PAINT_COLOR~&) + " (not PAINT_BG_COLOR=" + STR$(PAINT_BG_COLOR~&) + ")"
                    ' Draw line from last position to current position using FOREGROUND color
                    ' Note: Don't undo the origin point - keep it and draw line from it
                    _DEST LAYER_current_image&
                    IF CUSTOM_BRUSH_is_active% THEN
                        ' Use custom brush stamps along the line
                        CUSTOM_BRUSH_stamp_line DOT.LAST_X, DOT.LAST_Y, MOUSE.X%, MOUSE.Y%
                    ELSE
                        ' Normal line drawing with foreground color (not background)
                        LINE (DOT.LAST_X, DOT.LAST_Y)-(MOUSE.X%, MOUSE.Y%), PAINT_COLOR~&
                    END IF
                    _DEST SCRN.CANVAS&
                    ' Update last position to current position
                    DOT.LAST_X = MOUSE.X%
                    DOT.LAST_Y = MOUSE.Y%
                    ' Save undo state
                    UNDO_save_state
                    UNDO_saved_this_frame% = TRUE
                    CANVAS_DIRTY% = TRUE
                ELSE
                    _LOGINFO "DOT.HAS_LAST is FALSE - no previous point to draw from"
                END IF
            ' Right Click on POLY_LINE tool: finish poly line (stop drawing)
            ELSEIF CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED THEN
                ' Close the shape if filled polygon
                IF CURRENT_TOOL% = TOOL_POLYGON_FILLED AND POLY_LINE.HAS_LAST AND POLY_LINE.POINT_COUNT >= 3 THEN
                    ' Draw closing line
                    DIM polyfill_target AS LONG
                    DIM polyfill_is_transparent AS INTEGER
                    polyfill_target& = LAYER_current_image&
                    _DEST polyfill_target&
                    
                    ' Check if drawing with transparent color
                    polyfill_is_transparent% = (_ALPHA32(PAINT_COLOR~&) = 0)
                    IF polyfill_is_transparent% THEN _DONTBLEND polyfill_target&
                    
                    IF CUSTOM_BRUSH_is_active% THEN
                        ' Use custom brush stamps for closing line
                        CUSTOM_BRUSH_stamp_line POLY_LINE.LAST_X, POLY_LINE.LAST_Y, POLY_LINE.FIRST_X, POLY_LINE.FIRST_Y
                    ELSEIF SELECTION_has_active% THEN
                        ' Use clipped line drawing for closing line when selection is active
                        LINE_draw_clipped POLY_LINE.LAST_X, POLY_LINE.LAST_Y, POLY_LINE.FIRST_X, POLY_LINE.FIRST_Y, PAINT_COLOR~&
                    ELSE
                        ' Normal line drawing
                        LINE (POLY_LINE.LAST_X, POLY_LINE.LAST_Y)-(POLY_LINE.FIRST_X, POLY_LINE.FIRST_Y), PAINT_COLOR~&
                    END IF
                    ' Use scanline fill algorithm for proper polygon filling (only if not using custom brush)
                    IF NOT CUSTOM_BRUSH_is_active% THEN
                        POLY_FILL_scanline POLY_POINTS_X(), POLY_POINTS_Y(), POLY_LINE.POINT_COUNT, PAINT_COLOR~&, polyfill_target&
                    END IF
                    
                    IF polyfill_is_transparent% THEN _BLEND polyfill_target&
                    _DEST SCRN.CANVAS&
                    CANVAS_DIRTY% = TRUE
                END IF
                ' Save undo AFTER polygon is complete (like LINE tool)
                UNDO_save_state
                UNDO_saved_this_frame% = TRUE
                POLY_LINE_reset
                ' Switch to NULL tool to prevent accidental clicks from starting new polygons
                CURRENT_TOOL% = TOOL_NULL
                GUI_NEEDS_REDRAW% = TRUE
            END IF
        END IF
        
        ' Right button handlers (B2)
        IF MOUSE.B2% THEN
            ' Right click with picker: pick background color
            IF CURRENT_TOOL% = TOOL_PICKER AND PICKER.ACTIVE% AND NOT MOUSE.OLD_B2% THEN
                PICKER_pick_color MOUSE.X%, MOUSE.Y%, 2  ' 2 = right button/background
            END IF
        END IF

        IF MODIFIERS.shift% AND NOT CONSTRAIN_X% AND NOT CONSTRAIN_Y% THEN
            IF MOUSE.DRAG$ = "L" OR MOUSE.DRAG$ = "R" THEN
                MOUSE.CON_Y% = MOUSE.Y%
                CONSTRAIN_X% = FALSE
                CONSTRAIN_Y% = TRUE
            ELSEIF MOUSE.DRAG$ = "U" OR MOUSE.DRAG$ = "D" THEN
                MOUSE.CON_X% = MOUSE.X%
                CONSTRAIN_X% = TRUE
                CONSTRAIN_Y% = FALSE
            END IF
        END IF
    END IF ' End drain-then-process block
    
    ' Trigger redraw when palette menu is visible (for continuous hover highlighting)
    IF PALETTE_MENU_VISIBLE% THEN
        GUI_NEEDS_REDRAW% = TRUE
    END IF
    
    ' Process accumulated wheel delta for zoom/brush size (outside event loop)
    IF wheel_delta% <> 0 THEN
        MOUSE.SW% = wheel_delta%
        
        ' Check if palette menu is visible - always handle wheel for menu scrolling, never zoom
        IF PALETTE_MENU_VISIBLE% THEN
            PALETTE_STRIP_handle_wheel MOUSE.SW%
            MOUSE.SW% = 0 ' Consume â€” menu scroll doesn't change the scene
        ' Check if over layer panel first - use RAW screen coords for GUI bounds checks!
        ELSEIF LAYER_PANEL.visible% AND LAYER_PANEL_in_bounds%(rawX%, rawY%) THEN
            LAYER_PANEL_handle_wheel rawX%, rawY%, MOUSE.SW%
            MOUSE.SW% = 0 ' Consume â€” panel scroll doesn't change the scene
        ' Check if over palette dropdown button (closed menu) - ignore wheel
        ELSEIF PALETTE_STRIP_dropdown_in_bounds%(rawX%, rawY%) THEN
            MOUSE.SW% = 0 ' Consume â€” ignored
        ' Check if over palette strip (excluding dropdown) - use RAW screen coords
        ELSEIF PALETTE_STRIP_in_bounds%(rawX%, rawY%) THEN
            PALETTE_STRIP_handle_wheel MOUSE.SW%
            MOUSE.SW% = 0 ' Consume â€” palette scroll doesn't change the scene
        ' Check if over toolbar (don't zoom when over toolbar) - use RAW screen coords
        ELSEIF SCRN.showToolbar% AND TOOLBAR_is_over_area%(rawX%, rawY%) THEN
            MOUSE.SW% = 0 ' Consume â€” ignored
        ' Check if over status bar area (don't zoom when over status bar) - use RAW screen coords
        ELSEIF SCRN.showStatus% AND rawY% >= SCRN.h& - THEME.STATUS_height% - PALETTE_STRIP_get_height% THEN
            MOUSE.SW% = 0 ' Consume â€” ignored
        ' Check if CTRL is held for brush size adjustment
        ELSEIF (_KEYDOWN(100305) OR _KEYDOWN(100306)) THEN ' Right or Left CTRL
            ' CTRL+Wheel adjusts brush size
            ' Wheel up (negative) should increase, wheel down (positive) should decrease
            IF MOUSE.SW% < 0 THEN
                BRUSH_SIZE_increase
            ELSEIF MOUSE.SW% > 0 THEN
                BRUSH_SIZE_decrease
            END IF
            MOUSE.SW% = 0 ' Consume wheel â€” brush resize doesn't change the scene
        ELSE
            ' Mouse wheel without CTRL: zoom in/out (only when over canvas)
            ' Above 100%: Always use 100% increments (both in and out)
            ' At/below 100%: Zoom IN snaps to 100%, Zoom OUT uses 25%
            ' Zoom centered on mouse cursor position
            DIM oldZoom AS SINGLE
            DIM mouseScreenX AS INTEGER, mouseScreenY AS INTEGER
            oldZoom! = SCRN.zoom!
            
            ' Get mouse screen position BEFORE zoom changes (scaled to logical coords)
            mouseScreenX% = _MOUSEX
            mouseScreenY% = _MOUSEY
            
            IF MOUSE.SW% < 0 THEN
                ' Wheel down = zoom in
                IF SCRN.zoom! < 1.0 THEN
                    SCRN.zoom! = 1.0  ' Snap to 100% from any fractional zoom
                ELSE
                    SCRN.zoom! = INT(SCRN.zoom!) + 1.0  ' Next whole 100% (200%, 300%, etc.)
                END IF
                IF SCRN.zoom! > SCRN.zoomMax! THEN SCRN.zoom! = SCRN.zoomMax!
            ELSEIF MOUSE.SW% > 0 THEN
                ' Wheel up = zoom out
                IF SCRN.zoom! > 1.0 THEN
                    ' Above 100%: zoom out by whole 100% (200% â†’ 100%, 300% â†’ 200%)
                    SCRN.zoom! = INT(SCRN.zoom!) - 1.0
                ELSE
                    ' At/below 100%: zoom out by 25% (100% â†’ 75% â†’ 50% â†’ 25%)
                    SCRN.zoom! = SCRN.zoom! - 0.25
                END IF
                IF SCRN.zoom! < SCRN.zoomMin! THEN SCRN.zoom! = SCRN.zoomMin!
            END IF
            
            ' Adjust offset to keep mouse over same canvas point
            IF SCRN.zoom! <> oldZoom! THEN
                GUI_NEEDS_REDRAW% = TRUE
                ' Calculate canvas center offset at old zoom (using logical canvas dimensions)
                DIM old_zw AS LONG, old_zh AS LONG
                old_zw& = SCRN.w& * oldZoom!
                old_zh& = SCRN.h& * oldZoom!
                DIM old_center_x AS INTEGER, old_center_y AS INTEGER
                old_center_x% = (SCRN.w& - old_zw&) \ 2
                old_center_y% = (SCRN.h& - old_zh&) \ 2
                
                ' Account for layer panel offset when visible
                DIM layerPanelOffset AS INTEGER
                layerPanelOffset% = 0
                IF LAYER_PANEL.visible% THEN layerPanelOffset% = CFG.LAYER_PANEL_WIDTH%
                
                ' Canvas position under mouse at old zoom
                DIM canvasX AS SINGLE, canvasY AS SINGLE
                canvasX! = (mouseScreenX% - old_center_x% - SCRN.offsetX% - layerPanelOffset%) / oldZoom!
                canvasY! = (mouseScreenY% - old_center_y% - SCRN.offsetY%) / oldZoom!
                
                ' Calculate new canvas center offset at new zoom
                DIM new_zw AS LONG, new_zh AS LONG
                new_zw& = SCRN.w& * SCRN.zoom!
                new_zh& = SCRN.h& * SCRN.zoom!
                DIM new_center_x AS INTEGER, new_center_y AS INTEGER
                new_center_x% = (SCRN.w& - new_zw&) \ 2
                new_center_y% = (SCRN.h& - new_zh&) \ 2
                
                ' Calculate new offset to keep canvas point at mouse screen position
                SCRN.offsetX% = mouseScreenX% - new_center_x% - (canvasX! * SCRN.zoom!) - layerPanelOffset%
                SCRN.offsetY% = mouseScreenY% - new_center_y% - (canvasY! * SCRN.zoom!)
            END IF
        END IF
        MOUSE.OSW% = MOUSE.SW%
    END IF
    
    ' Update marquee every frame for keyboard controls and handle hover detection
    IF CURRENT_TOOL% = TOOL_MARQUEE AND MARQUEE.ACTIVE% THEN
        MARQUEE_update MOUSE.X%, MOUSE.Y%
    END IF
END SUB


''
' Finishing stuff in the mouse input loop
' 
SUB MOUSE_input_handler_loop ()
    MOUSE.OLD_X% = MOUSE.X% : MOUSE.OLD_Y% = MOUSE.Y%
    MOUSE.OLD_B1% = MOUSE.B1%
    MOUSE.OLD_B2% = MOUSE.B2%
    MOUSE.OLD_B3% = MOUSE.B3%
    
    ' Process deferred actions (file dialogs) after all mouse processing is complete
    ' Actions: 1=save, 2=import image (to active layer), 3=open DRW project
    IF MOUSE.DEFERRED_ACTION% = 1 THEN
        ' Save action
        SAVE_image
        MOUSE.DEFERRED_ACTION% = 0
    ELSEIF MOUSE.DEFERRED_ACTION% = 2 THEN
        ' Import image action (right-click on open) - imports to active layer
        IMPORT_image
        MOUSE.DEFERRED_ACTION% = 0
    ELSEIF MOUSE.DEFERRED_ACTION% = 3 THEN
        ' Open DRW project action (left-click on open)
        DRW_open_dialog
        MOUSE.DEFERRED_ACTION% = 0
    END IF
END SUB
