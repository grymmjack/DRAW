''
' DRAW - INPUT/KEYBOARD.BM
' =============================================================================
' Keyboard input handling subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

' Forward declarations for extracted helper functions
DECLARE FUNCTION KEYBOARD_handle_command_palette% ()
DECLARE FUNCTION KEYBOARD_handle_image_import% ()
DECLARE FUNCTION KEYBOARD_handle_crop_tool% ()
DECLARE FUNCTION KEYBOARD_handle_refimg_reposition% ()
DECLARE FUNCTION KEYBOARD_handle_menubar% ()
DECLARE FUNCTION KEYBOARD_handle_palette_menu% ()
DECLARE FUNCTION KEYBOARD_handle_text_tool% (keypress AS STRING)
DECLARE SUB KEYBOARD_handle_custom_brush ()
DECLARE SUB KEYBOARD_handle_ui_toggles ()
DECLARE SUB KEYBOARD_handle_grid_controls ()
DECLARE SUB KEYBOARD_handle_delete_backspace ()
DECLARE SUB KEYBOARD_handle_marquee_keys ()
DECLARE SUB KEYBOARD_handle_move_keys ()
DECLARE SUB KEYBOARD_handle_numpad_dithers ()

''
' Handles changing colors with keyboard
' @todo
' 
SUB KEYBOARD_colors (keypress AS STRING)
    SELECT CASE keypress$
        CASE "1": PAINT_OPACITY% = 10: GUI_NEEDS_REDRAW% = TRUE: SCENE_DIRTY% = TRUE
        CASE "2": PAINT_OPACITY% = 20: GUI_NEEDS_REDRAW% = TRUE: SCENE_DIRTY% = TRUE
        CASE "3": PAINT_OPACITY% = 30: GUI_NEEDS_REDRAW% = TRUE: SCENE_DIRTY% = TRUE
        CASE "4": PAINT_OPACITY% = 40: GUI_NEEDS_REDRAW% = TRUE: SCENE_DIRTY% = TRUE
        CASE "5": PAINT_OPACITY% = 50: GUI_NEEDS_REDRAW% = TRUE: SCENE_DIRTY% = TRUE
        CASE "6": PAINT_OPACITY% = 60: GUI_NEEDS_REDRAW% = TRUE: SCENE_DIRTY% = TRUE
        CASE "7": PAINT_OPACITY% = 70: GUI_NEEDS_REDRAW% = TRUE: SCENE_DIRTY% = TRUE
        CASE "8": PAINT_OPACITY% = 80: GUI_NEEDS_REDRAW% = TRUE: SCENE_DIRTY% = TRUE
        CASE "9": PAINT_OPACITY% = 90: GUI_NEEDS_REDRAW% = TRUE: SCENE_DIRTY% = TRUE
        CASE "0": PAINT_OPACITY% = 100: GUI_NEEDS_REDRAW% = TRUE: SCENE_DIRTY% = TRUE
        CASE "*"  ' Toggle transparent color (eraser mode)
            IF PAL_FG_IS_TRANSPARENT% THEN
                ' Restore previous foreground color
                IF PAL_FG_SAVED_VALID% THEN
                    PAINT_COLOR~& = PAL_FG_SAVED_COLOR~&
                    PAL_FG_IDX% = PAL_FG_SAVED_IDX%
                ELSE
                    ' Fallback: use palette index 0
                    PAINT_COLOR~& = PAL(0).value~&
                    PAL_FG_IDX% = 0
                END IF
                PAL_FG_IS_TRANSPARENT% = FALSE
            ELSE
                ' Save current color, switch to transparent
                PAL_FG_SAVED_COLOR~& = PAINT_COLOR~&
                PAL_FG_SAVED_IDX% = PAL_FG_IDX%
                PAL_FG_SAVED_VALID% = TRUE
                PAINT_COLOR~& = _RGBA32(0, 0, 0, 0)
                PAL_FG_IS_TRANSPARENT% = TRUE
            END IF
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
        CASE "x", "X"  ' Swap foreground and background colors
            DIM temp_color AS _UNSIGNED LONG
            DIM temp_idx AS INTEGER
            temp_color~& = PAINT_COLOR~&
            temp_idx% = PAL_FG_IDX%
            PAINT_COLOR~& = PAINT_BG_COLOR~&
            PAL_FG_IDX% = PAL_BG_IDX%
            PAINT_BG_COLOR~& = temp_color~&
            PAL_BG_IDX% = temp_idx%
            GUI_NEEDS_REDRAW% = TRUE
        EVERYCASE:
            KEY_COLOR%   = TRUE 
            WHEEL_COLOR% = FALSE
    END SELECT
END SUB


''
' Handles tool selection with keyboard
'
SUB KEYBOARD_tools (keypress AS STRING)
    ' H = Flip Horizontal (works with any tool — no tool conflict)
    IF keypress$ = "h" OR keypress$ = "H" THEN
        CMD_execute_action 315
        EXIT SUB
    END IF
    ' V = Flip Vertical only when move tool has floating selection
    ' (V is also the Move tool shortcut, so it can't be universal)
    IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
        IF keypress$ = "v" OR keypress$ = "V" THEN
            CMD_execute_action 316
            EXIT SUB
        END IF
    END IF
    
    SELECT CASE keypress$
        CASE "b", "B"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_BRUSH
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
        CASE "f", "F"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_FILL
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
            FILL_activate              ' Re-activate fill after reset
        CASE "d", "D"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_DOT
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
        CASE "l", "L"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_LINE
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
        CASE "p", "P"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            ' SHIFT+P = filled polygon, P = outline polygon
            IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                CURRENT_TOOL% = TOOL_POLYGON_FILLED
            ELSE
                CURRENT_TOOL% = TOOL_POLYGON
            END IF
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
            ' Set filled flag for polygon
            POLY_LINE.FILLED = (CURRENT_TOOL% = TOOL_POLYGON_FILLED)
        CASE "r", "R"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            ' SHIFT+R = filled rectangle, R = outline rectangle
            IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                CURRENT_TOOL% = TOOL_RECT_FILLED
            ELSE
                CURRENT_TOOL% = TOOL_RECT
            END IF
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
        CASE "e", "E"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            ' SHIFT+E = filled ellipse, E = outline ellipse
            IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                CURRENT_TOOL% = TOOL_ELLIPSE_FILLED
            ELSE
                CURRENT_TOOL% = TOOL_ELLIPSE
            END IF
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
        CASE "m", "M"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_MARQUEE
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
            ' Clear auto-created marquee from MOVE tool (preserve user-created ones)
            IF MARQUEE.ACTIVE% AND NOT MARQUEE.USER_CREATED THEN
                MARQUEE_reset
            END IF
            MARQUEE.MAGIC_WAND_MODE = FALSE  ' Regular marquee mode
        CASE "w", "W"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_MARQUEE
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
            ' Enable magic wand mode (same as right-click on marquee tool)
            MARQUEE.MAGIC_WAND_MODE = TRUE
            MAGIC_WAND_reset
            MARQUEE.ACTIVE% = FALSE
            MARQUEE.INITIALIZED% = FALSE
        CASE "v", "V"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_MOVE
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
            ' Always capture selection - handles both marquee and full-layer cases
            MOVE_capture_selection
        CASE "i", "I"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_PICKER
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
            PICKER_activate            ' Re-activate picker after reset
        CASE "k", "K"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_SPRAY
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
        CASE "z", "Z"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_ZOOM
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
        CASE "t", "T"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_TEXT
            TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
            ' SHIFT+T = Tiny5 font, T = VGA default font (CTRL+T handled separately)
            IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                TEXT.USE_CUSTOM = FALSE
                TEXT.USE_TINY5 = TRUE
                TEXT.CHAR_WIDTH = 5
                TEXT.LINE_HEIGHT = 6  ' 5px font + 1px gap
            ELSE
                TEXT.USE_CUSTOM = FALSE
                TEXT.USE_TINY5 = FALSE
                TEXT.CHAR_WIDTH = 8
                TEXT.LINE_HEIGHT = 13  ' 8px font + larger gap for readability
            END IF
            TEXT_reset       ' Reset text tool when switching to it
            GUI_NEEDS_REDRAW% = TRUE
        CASE CHR$(27)  ' ESC key - reset poly line tool, cancel move, cancel layer drag, apply text, or clear selection
            ' First check if layer drag is in progress
            IF LAYER_PANEL_is_dragging% THEN
                LAYER_PANEL_drag_cancel
            ELSEIF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
                ' Cancel the move: restore pixels to original position, discard undo states
                ' Set frame flag BEFORE reset so MOVE_apply_transform skips its undo save
                ' (the apply just restores original pixels — saving would create a phantom state
                ' identical to the pre-capture state, wasting a CTRL+Z press)
                UNDO_saved_this_frame% = TRUE
                MOVE_cancel_transform
                MOVE_reset
                ' Clear auto-created marquee but keep TOOL_MOVE selected
                IF MARQUEE.ACTIVE% AND NOT MARQUEE.USER_CREATED THEN
                    MARQUEE_reset
                END IF
                GUI_NEEDS_REDRAW% = TRUE
            ELSEIF CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE THEN
                TEXT_apply
            ELSEIF CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED THEN
                POLY_LINE_reset
            ELSEIF MARQUEE.MAGIC_WAND_MODE AND MARQUEE.WAND_HAS_SELECTION THEN
                ' Clear magic wand selection from any tool
                MAGIC_WAND_reset
                MARQUEE.ACTIVE% = FALSE
                GUI_NEEDS_REDRAW% = TRUE
            ELSEIF MARQUEE.ACTIVE% THEN
                ' Clear regular marquee selection from any tool
                MARQUEE_clear
                GUI_NEEDS_REDRAW% = TRUE
            END IF
        CASE CHR$(13)  ' ENTER key - finish poly line (keeps tool active), apply move transform, or newline in text
            IF CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE THEN
                TEXT_newline
            ELSEIF CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED THEN
                POLY_LINE_reset
                ' Keep tool selected so user can draw more polygons
                GUI_NEEDS_REDRAW% = TRUE
            ELSEIF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
                MOVE_apply_transform
                ' After applying, clear move state and return to marquee tool
                MOVE_reset
                CURRENT_TOOL% = TOOL_MARQUEE
                ' Clear marquee selection
                MARQUEE.ACTIVE = FALSE
                MARQUEE.INITIALIZED = FALSE
                GUI_NEEDS_REDRAW% = TRUE
            END IF
        CASE CHR$(26), CHR$(90), CHR$(122) ' Ctrl+Z - handled in loop handler with single-press
            ' Do nothing here - handled in KEYBOARD_input_handler_loop
        CASE CHR$(25), CHR$(89), CHR$(121) ' Ctrl+Y - handled in loop handler with single-press
            ' Do nothing here - handled in KEYBOARD_input_handler_loop
    END SELECT
END SUB


''
' Handles brush size changes with keyboard
'
SUB KEYBOARD_brush_size (keypress AS STRING)
    SELECT CASE keypress$
        CASE "[", "{"
            BRUSH_SIZE_decrease
        CASE "]", "}"
            BRUSH_SIZE_increase
    END SELECT
END SUB


''
' Handles assistant toggles with keyboard
'
SUB KEYBOARD_assistants (keypress AS STRING)
    ' Don't trigger assistants when in text edit mode
    IF CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE THEN EXIT SUB
    
    SELECT CASE keypress$
        CASE "~", "`"
            BRUSH_SIZE_toggle_preview
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
        CASE "|", "\"
            BRUSH_SIZE_toggle_shape
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
    END SELECT
END SUB


''
' Handle function keys F1-F8 using _KEYDOWN() — runs unconditionally every frame.
' F1-F4: Brush size presets, F6: Pixel perfect, F7: Symmetry cycle, F8: Symmetry clear.
' Uses _KEYDOWN() instead of INKEY$ so they work regardless of buffer state.
'
SUB KEYBOARD_handle_function_keys ()
    ' Don't trigger when text tool is active (matches KEYBOARD_assistants behavior)
    IF CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE THEN EXIT SUB

    STATIC f1Pressed AS INTEGER, f2Pressed AS INTEGER
    STATIC f3Pressed AS INTEGER, f4Pressed AS INTEGER
    STATIC f6Pressed AS INTEGER, f7Pressed AS INTEGER, f8Pressed AS INTEGER

    ' F1-F4: Brush size presets
    IF _KEYDOWN(15104) THEN ' F1
        IF NOT f1Pressed% THEN
            BRUSH_SIZE_set_preset 1
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
            f1Pressed% = TRUE
        END IF
    ELSE
        f1Pressed% = FALSE
    END IF

    IF _KEYDOWN(15360) THEN ' F2
        IF NOT f2Pressed% THEN
            BRUSH_SIZE_set_preset 2
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
            f2Pressed% = TRUE
        END IF
    ELSE
        f2Pressed% = FALSE
    END IF

    IF _KEYDOWN(15616) THEN ' F3
        IF NOT f3Pressed% THEN
            BRUSH_SIZE_set_preset 3
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
            f3Pressed% = TRUE
        END IF
    ELSE
        f3Pressed% = FALSE
    END IF

    IF _KEYDOWN(15872) THEN ' F4
        IF NOT f4Pressed% THEN
            BRUSH_SIZE_set_preset 4
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
            f4Pressed% = TRUE
        END IF
    ELSE
        f4Pressed% = FALSE
    END IF

    ' F6: Pixel perfect toggle
    IF _KEYDOWN(16384) THEN ' F6
        IF NOT f6Pressed% THEN
            BRUSH_SIZE_toggle_pixel_perfect
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
            f6Pressed% = TRUE
        END IF
    ELSE
        f6Pressed% = FALSE
    END IF

    ' F7: Symmetry cycle
    IF _KEYDOWN(16640) THEN ' F7
        IF NOT f7Pressed% THEN
            SYMMETRY_cycle_mode
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
            f7Pressed% = TRUE
        END IF
    ELSE
        f7Pressed% = FALSE
    END IF

    ' F8: Symmetry clear
    IF _KEYDOWN(16896) THEN ' F8
        IF NOT f8Pressed% THEN
            SYMMETRY_clear
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
            f8Pressed% = TRUE
        END IF
    ELSE
        f8Pressed% = FALSE
    END IF
END SUB


''
' Handle command palette keyboard input with arrow key repeat.
' Returns TRUE if command palette consumed the input (caller should EXIT SUB).
'
FUNCTION KEYBOARD_handle_command_palette% ()
    IF NOT CMD_PALETTE.visible THEN
        KEYBOARD_handle_command_palette% = FALSE
        EXIT FUNCTION
    END IF
    
    DIM cmd_keypress AS STRING
    cmd_keypress$ = INKEY$
    IF cmd_keypress$ <> "" THEN
        CMD_handle_key cmd_keypress$
    END IF
    
    ' Handle arrow key and page navigation for command palette with key repeat
    STATIC cmdArrowUp AS INTEGER, cmdArrowDown AS INTEGER
    STATIC cmdPageUp AS INTEGER, cmdPageDown AS INTEGER
    STATIC cmdRepeatTimer AS DOUBLE
    STATIC cmdRepeatDelay AS DOUBLE
    DIM cmdArrowUpNow AS INTEGER, cmdArrowDownNow AS INTEGER
    DIM cmdPageUpNow AS INTEGER, cmdPageDownNow AS INTEGER
    DIM cmdCurrentTime AS DOUBLE
    
    ' Key repeat settings (in seconds)
    CONST CMD_REPEAT_INITIAL = 0.3   ' Initial delay before repeat starts
    CONST CMD_REPEAT_RATE = 0.08     ' Delay between repeats (~12 per second)
    
    cmdArrowUpNow% = _KEYDOWN(18432)    ' Up arrow
    cmdArrowDownNow% = _KEYDOWN(20480)  ' Down arrow
    cmdPageUpNow% = _KEYDOWN(18688)     ' Page Up
    cmdPageDownNow% = _KEYDOWN(20736)   ' Page Down
    cmdCurrentTime# = TIMER(.001)
    
    ' Arrow Up with repeat
    IF cmdArrowUpNow% THEN
        IF NOT cmdArrowUp% THEN
            CMD_navigate_up
            cmdRepeatTimer# = cmdCurrentTime#
            cmdRepeatDelay# = CMD_REPEAT_INITIAL
        ELSEIF cmdCurrentTime# - cmdRepeatTimer# >= cmdRepeatDelay# THEN
            CMD_navigate_up
            cmdRepeatTimer# = cmdCurrentTime#
            cmdRepeatDelay# = CMD_REPEAT_RATE
        END IF
    END IF
    
    ' Arrow Down with repeat
    IF cmdArrowDownNow% THEN
        IF NOT cmdArrowDown% THEN
            CMD_navigate_down
            cmdRepeatTimer# = cmdCurrentTime#
            cmdRepeatDelay# = CMD_REPEAT_INITIAL
        ELSEIF cmdCurrentTime# - cmdRepeatTimer# >= cmdRepeatDelay# THEN
            CMD_navigate_down
            cmdRepeatTimer# = cmdCurrentTime#
            cmdRepeatDelay# = CMD_REPEAT_RATE
        END IF
    END IF
    
    ' Page Up with repeat
    IF cmdPageUpNow% THEN
        IF NOT cmdPageUp% THEN
            CMD_navigate_page_up
            cmdRepeatTimer# = cmdCurrentTime#
            cmdRepeatDelay# = CMD_REPEAT_INITIAL
        ELSEIF cmdCurrentTime# - cmdRepeatTimer# >= cmdRepeatDelay# THEN
            CMD_navigate_page_up
            cmdRepeatTimer# = cmdCurrentTime#
            cmdRepeatDelay# = CMD_REPEAT_RATE
        END IF
    END IF
    
    ' Page Down with repeat
    IF cmdPageDownNow% THEN
        IF NOT cmdPageDown% THEN
            CMD_navigate_page_down
            cmdRepeatTimer# = cmdCurrentTime#
            cmdRepeatDelay# = CMD_REPEAT_INITIAL
        ELSEIF cmdCurrentTime# - cmdRepeatTimer# >= cmdRepeatDelay# THEN
            CMD_navigate_page_down
            cmdRepeatTimer# = cmdCurrentTime#
            cmdRepeatDelay# = CMD_REPEAT_RATE
        END IF
    END IF
    
    cmdArrowUp% = cmdArrowUpNow%
    cmdArrowDown% = cmdArrowDownNow%
    cmdPageUp% = cmdPageUpNow%
    cmdPageDown% = cmdPageDownNow%
    
    KEYBOARD_handle_command_palette% = TRUE  ' Consumed
END FUNCTION


''
' Handle image import mode keyboard input (Enter, ESC, arrow keys).
' Returns TRUE if import mode consumed the input (caller should EXIT SUB).
'
FUNCTION KEYBOARD_handle_image_import% ()
    IF IMG_IMPORT.STATE <= IMPORT_STATE_IDLE THEN
        KEYBOARD_handle_image_import% = FALSE
        EXIT FUNCTION
    END IF
    
    DIM keypress AS STRING
    keypress$ = INKEY$
    IF keypress$ <> "" THEN
        DIM import_key_code AS INTEGER
        import_key_code% = ASC(keypress$)
        
        SELECT CASE import_key_code%
            CASE 27  ' ESC - cancel import
                IMAGE_IMPORT_cancel
            CASE 13  ' ENTER - apply import
                IF IMG_IMPORT.STATE = IMPORT_STATE_LOADED THEN
                    ' Use dimensions already set during loading
                    ' (centered at original size for small images, fitted for large)
                    IMAGE_IMPORT_update_crop_from_zoom
                    IMG_IMPORT.STATE = IMPORT_STATE_PLACING
                END IF
                IMAGE_IMPORT_apply
        END SELECT
    END IF
    
    ' Arrow key handling for import mode (works in LOADED or PLACING state)
    IF IMG_IMPORT.STATE >= IMPORT_STATE_LOADED THEN
        DIM impIsCtrl AS INTEGER, impIsShift AS INTEGER, impIsAlt AS INTEGER
        DIM impMoveStep AS INTEGER
        
        impIsCtrl% = MODIFIERS.ctrl%
        impIsShift% = MODIFIERS.shift%
        impIsAlt% = MODIFIERS.alt%
        impMoveStep% = 1
        IF impIsShift% THEN impMoveStep% = CFG.NUDGE_N%
        
        ' Single-press detection for arrow keys
        STATIC impKeyUpLast AS INTEGER, impKeyDownLast AS INTEGER
        STATIC impKeyLeftLast AS INTEGER, impKeyRightLast AS INTEGER
        DIM impKeyUpNow AS INTEGER, impKeyDownNow AS INTEGER
        DIM impKeyLeftNow AS INTEGER, impKeyRightNow AS INTEGER
        
        impKeyUpNow% = _KEYDOWN(18432)    ' Up arrow
        impKeyDownNow% = _KEYDOWN(20480)  ' Down arrow
        impKeyLeftNow% = _KEYDOWN(19200)  ' Left arrow
        impKeyRightNow% = _KEYDOWN(19712) ' Right arrow
        
        ' Arrow keys: Ctrl=resize, Alt=pan within image, plain=move box
        IF impKeyUpNow% AND NOT impKeyUpLast% THEN
            IF impIsCtrl% THEN
                IMAGE_IMPORT_resize_by 0, -impMoveStep%
            ELSEIF impIsAlt% THEN
                IMAGE_IMPORT_pan_by 0, -impMoveStep%
            ELSE
                IMAGE_IMPORT_nudge 0, -impMoveStep%
            END IF
        END IF
        IF impKeyDownNow% AND NOT impKeyDownLast% THEN
            IF impIsCtrl% THEN
                IMAGE_IMPORT_resize_by 0, impMoveStep%
            ELSEIF impIsAlt% THEN
                IMAGE_IMPORT_pan_by 0, impMoveStep%
            ELSE
                IMAGE_IMPORT_nudge 0, impMoveStep%
            END IF
        END IF
        IF impKeyLeftNow% AND NOT impKeyLeftLast% THEN
            IF impIsCtrl% THEN
                IMAGE_IMPORT_resize_by -impMoveStep%, 0
            ELSEIF impIsAlt% THEN
                IMAGE_IMPORT_pan_by -impMoveStep%, 0
            ELSE
                IMAGE_IMPORT_nudge -impMoveStep%, 0
            END IF
        END IF
        IF impKeyRightNow% AND NOT impKeyRightLast% THEN
            IF impIsCtrl% THEN
                IMAGE_IMPORT_resize_by impMoveStep%, 0
            ELSEIF impIsAlt% THEN
                IMAGE_IMPORT_pan_by impMoveStep%, 0
            ELSE
                IMAGE_IMPORT_nudge impMoveStep%, 0
            END IF
        END IF
        
        ' Update last key states
        impKeyUpLast% = impKeyUpNow%
        impKeyDownLast% = impKeyDownNow%
        impKeyLeftLast% = impKeyLeftNow%
        impKeyRightLast% = impKeyRightNow%
        
        ' > key (Shift+.) = Rotate CW 90, < key (Shift+,) = Rotate CCW 90
        STATIC impRotateCWLast AS INTEGER, impRotateCCWLast AS INTEGER
        DIM impRotateCWNow AS INTEGER, impRotateCCWNow AS INTEGER
        impRotateCWNow% = _KEYDOWN(62)   ' ASCII 62 = >
        impRotateCCWNow% = _KEYDOWN(60)  ' ASCII 60 = <
        IF impRotateCWNow% AND NOT impRotateCWLast% THEN
            IMG_IMPORT.ROTATION = (IMG_IMPORT.ROTATION + 90) MOD 360   ' CW
            IMAGE_IMPORT_rebuild_preview
            _LOGINFO "IMAGE_IMPORT: Rotation = " + STR$(IMG_IMPORT.ROTATION) + " degrees (CW)"
        END IF
        impRotateCWLast% = impRotateCWNow%
        IF impRotateCCWNow% AND NOT impRotateCCWLast% THEN
            IMG_IMPORT.ROTATION = (IMG_IMPORT.ROTATION + 270) MOD 360  ' CCW
            IMAGE_IMPORT_rebuild_preview
            _LOGINFO "IMAGE_IMPORT: Rotation = " + STR$(IMG_IMPORT.ROTATION) + " degrees (CCW)"
        END IF
        impRotateCCWLast% = impRotateCCWNow%
        
        ' Home = Flip Horizontal, End = Flip Vertical
        STATIC impFlipHLast AS INTEGER
        DIM impFlipHNow AS INTEGER
        impFlipHNow% = _KEYDOWN(18176)  ' Home key
        IF impFlipHNow% AND NOT impFlipHLast% THEN
            IMG_IMPORT.FLIP_H = NOT IMG_IMPORT.FLIP_H
            IMAGE_IMPORT_rebuild_preview
            _LOGINFO "IMAGE_IMPORT: Flip H = " + STR$(IMG_IMPORT.FLIP_H)
        END IF
        impFlipHLast% = impFlipHNow%
        
        STATIC impFlipVLast AS INTEGER
        DIM impFlipVNow AS INTEGER
        impFlipVNow% = _KEYDOWN(20224)  ' End key
        IF impFlipVNow% AND NOT impFlipVLast% THEN
            IMG_IMPORT.FLIP_V = NOT IMG_IMPORT.FLIP_V
            IMAGE_IMPORT_rebuild_preview
            _LOGINFO "IMAGE_IMPORT: Flip V = " + STR$(IMG_IMPORT.FLIP_V)
        END IF
        impFlipVLast% = impFlipVNow%
        
        ' Page Up = Scale up 50% from original, Page Down = Scale down 50% from original
        STATIC impScaleUpLast AS INTEGER, impScaleDnLast AS INTEGER
        DIM impScaleUpNow AS INTEGER, impScaleDnNow AS INTEGER
        impScaleUpNow% = _KEYDOWN(18688)  ' Page Up
        impScaleDnNow% = _KEYDOWN(20736)  ' Page Down
        IF impScaleUpNow% AND NOT impScaleUpLast% THEN
            IMG_IMPORT.SCALE_FACTOR = IMG_IMPORT.SCALE_FACTOR * 1.5
            ' Recalculate dest dimensions from original * scale factor
            DIM impSuW AS INTEGER, impSuH AS INTEGER
            impSuW% = INT(IMG_IMPORT.IMAGE_W * IMG_IMPORT.SCALE_FACTOR)
            impSuH% = INT(IMG_IMPORT.IMAGE_H * IMG_IMPORT.SCALE_FACTOR)
            IF impSuW% < 1 THEN impSuW% = 1
            IF impSuH% < 1 THEN impSuH% = 1
            ' Center adjustment
            DIM impSuOldCX AS INTEGER, impSuOldCY AS INTEGER
            impSuOldCX% = IMG_IMPORT.DEST_X + IMG_IMPORT.DEST_W \ 2
            impSuOldCY% = IMG_IMPORT.DEST_Y + IMG_IMPORT.DEST_H \ 2
            IMG_IMPORT.DEST_W = impSuW%
            IMG_IMPORT.DEST_H = impSuH%
            IMG_IMPORT.DEST_X = impSuOldCX% - impSuW% \ 2
            IMG_IMPORT.DEST_Y = impSuOldCY% - impSuH% \ 2
            IMAGE_IMPORT_update_crop_from_zoom
            SCENE_DIRTY% = TRUE
            FRAME_IDLE% = FALSE
            _LOGINFO "IMAGE_IMPORT: Scale factor = " + STR$(IMG_IMPORT.SCALE_FACTOR)
        END IF
        impScaleUpLast% = impScaleUpNow%
        IF impScaleDnNow% AND NOT impScaleDnLast% THEN
            IMG_IMPORT.SCALE_FACTOR = IMG_IMPORT.SCALE_FACTOR * 0.5
            IF IMG_IMPORT.SCALE_FACTOR < 0.01 THEN IMG_IMPORT.SCALE_FACTOR = 0.01
            ' Recalculate dest dimensions from original * scale factor
            DIM impSdW AS INTEGER, impSdH AS INTEGER
            impSdW% = INT(IMG_IMPORT.IMAGE_W * IMG_IMPORT.SCALE_FACTOR)
            impSdH% = INT(IMG_IMPORT.IMAGE_H * IMG_IMPORT.SCALE_FACTOR)
            IF impSdW% < 1 THEN impSdW% = 1
            IF impSdH% < 1 THEN impSdH% = 1
            ' Center adjustment
            DIM impSdOldCX AS INTEGER, impSdOldCY AS INTEGER
            impSdOldCX% = IMG_IMPORT.DEST_X + IMG_IMPORT.DEST_W \ 2
            impSdOldCY% = IMG_IMPORT.DEST_Y + IMG_IMPORT.DEST_H \ 2
            IMG_IMPORT.DEST_W = impSdW%
            IMG_IMPORT.DEST_H = impSdH%
            IMG_IMPORT.DEST_X = impSdOldCX% - impSdW% \ 2
            IMG_IMPORT.DEST_Y = impSdOldCY% - impSdH% \ 2
            IMAGE_IMPORT_update_crop_from_zoom
            SCENE_DIRTY% = TRUE
            FRAME_IDLE% = FALSE
            _LOGINFO "IMAGE_IMPORT: Scale factor = " + STR$(IMG_IMPORT.SCALE_FACTOR)
        END IF
        impScaleDnLast% = impScaleDnNow%
    END IF
    
    KEYBOARD_handle_image_import% = TRUE  ' Consumed
END FUNCTION


''
' Handle crop tool keyboard input (Enter, ESC, arrow keys).
' Returns TRUE if crop mode consumed the input (caller should EXIT SUB).
'
FUNCTION KEYBOARD_handle_crop_tool% ()
    IF CROP.STATE <> CROP_STATE_ACTIVE THEN
        KEYBOARD_handle_crop_tool% = FALSE
        EXIT FUNCTION
    END IF

    DIM cropKey AS STRING
    cropKey$ = INKEY$
    IF cropKey$ <> "" THEN
        DIM cropKeyCode AS INTEGER
        cropKeyCode% = ASC(cropKey$)

        SELECT CASE cropKeyCode%
            CASE 27  ' ESC - cancel crop
                CROP_cancel
                KEYBOARD_handle_crop_tool% = TRUE
                EXIT FUNCTION
            CASE 13  ' ENTER - apply crop
                CROP_apply
                KEYBOARD_handle_crop_tool% = TRUE
                EXIT FUNCTION
        END SELECT
    END IF

    ' Arrow keys and other input fall through to normal marquee handling
    KEYBOARD_handle_crop_tool% = FALSE
END FUNCTION


''
' Handle menu bar keyboard navigation (ALT tap, arrow keys, Enter, Escape).
' Returns TRUE if menu consumed the input (caller should EXIT SUB).
'
FUNCTION KEYBOARD_handle_menubar% ()
    IF NOT (SCRN.showMenubar% AND MENU_BAR.visible%) THEN
        KEYBOARD_handle_menubar% = FALSE
        EXIT FUNCTION
    END IF
    
    DIM menuKey AS LONG
    menuKey& = 0
    ' When a menu is open, read INKEY$ and convert to key codes for arrow/Enter/Esc
    IF MENU_BAR.openMenu% >= 0 THEN
        DIM menuKeyPress AS STRING
        menuKeyPress$ = INKEY$
        IF LEN(menuKeyPress$) = 1 THEN
            menuKey& = ASC(menuKeyPress$)
        ELSEIF LEN(menuKeyPress$) = 2 THEN
            SELECT CASE ASC(menuKeyPress$, 2)
                CASE 75: menuKey& = 19200   ' Left arrow
                CASE 77: menuKey& = 19712   ' Right arrow
                CASE 72: menuKey& = 18432   ' Up arrow
                CASE 80: menuKey& = 20480   ' Down arrow
            END SELECT
        END IF
    END IF
   IF MENUBAR_handle_key%(menuKey&) THEN
        ' Menu consumed the key event — drain any remaining INKEY$ and skip
        DIM drain$ : drain$ = INKEY$
        KEYBOARD_handle_menubar% = TRUE
        EXIT FUNCTION
    END IF
    ' When a menu dropdown is open, block ALL other keyboard processing
    ' (arrow keys via _KEYDOWN would otherwise leak to marquee/move nudge)
    IF MENU_BAR.openMenu% >= 0 THEN
        KEYBOARD_handle_menubar% = TRUE
    ELSE
        KEYBOARD_handle_menubar% = FALSE
    END IF
END FUNCTION


''
' Handle palette menu keyboard input (ESC, arrows, Enter, a-z navigation).
' Returns TRUE if palette menu consumed the input (caller should EXIT SUB).
'
FUNCTION KEYBOARD_handle_palette_menu% ()
    IF NOT PALETTE_MENU_VISIBLE% THEN
        KEYBOARD_handle_palette_menu% = FALSE
        EXIT FUNCTION
    END IF
    
    IF _KEYDOWN(27) THEN  ' ESC key
        PALETTE_MENU_hide
        KEYBOARD_handle_palette_menu% = TRUE
        EXIT FUNCTION
    END IF
    
    ' Handle arrow key navigation
    STATIC menuArrowUp AS INTEGER, menuArrowDown AS INTEGER
    DIM menuArrowUpNow AS INTEGER, menuArrowDownNow AS INTEGER
    menuArrowUpNow% = _KEYDOWN(18432)  ' Up arrow
    menuArrowDownNow% = _KEYDOWN(20480)  ' Down arrow
    
    IF menuArrowUpNow% AND NOT menuArrowUp% THEN
        PALETTE_MENU_navigate_up
    END IF
    IF menuArrowDownNow% AND NOT menuArrowDown% THEN
        PALETTE_MENU_navigate_down
    END IF
    menuArrowUp% = menuArrowUpNow%
    menuArrowDown% = menuArrowDownNow%
    
    ' Handle Enter to select current hover
    STATIC menuEnterPressed AS INTEGER
    DIM menuEnterNow AS INTEGER
    menuEnterNow% = _KEYDOWN(13)
    IF menuEnterNow% AND NOT menuEnterPressed% THEN
        IF PALETTE_MENU_HOVER% >= 0 AND PALETTE_MENU_HOVER% < PALETTE_LOADER_COUNT% THEN
            DIM dummy AS INTEGER
            dummy% = PALETTE_LOADER_load_by_index%(PALETTE_MENU_HOVER%)
            PAL_set_defaults_by_size
            PALETTE_STRIP_SCROLL_OFFSET% = 0
            PALETTE_MENU_hide
            menuEnterPressed% = menuEnterNow%
            KEYBOARD_handle_palette_menu% = TRUE
            EXIT FUNCTION
        END IF
    END IF
    menuEnterPressed% = menuEnterNow%
    
    ' Handle alphabetical navigation (a-z)
    DIM menu_key AS STRING
    menu_key$ = INKEY$
    IF LEN(menu_key$) = 1 THEN
        DIM menu_key_code AS INTEGER
        menu_key_code% = ASC(menu_key$)
        ' Check if it's a letter (a-z or A-Z)
        IF (menu_key_code% >= 65 AND menu_key_code% <= 90) OR (menu_key_code% >= 97 AND menu_key_code% <= 122) THEN
            PALETTE_MENU_jump_to_char menu_key$
        END IF
    END IF
    
    KEYBOARD_handle_palette_menu% = TRUE  ' Consumed
END FUNCTION


''
' Handle text tool keyboard input when text editing is active.
' Returns TRUE if text tool consumed the input (caller should EXIT SUB).
'
FUNCTION KEYBOARD_handle_text_tool% (keypress AS STRING)
    IF NOT (CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE) THEN
        KEYBOARD_handle_text_tool% = FALSE
        EXIT FUNCTION
    END IF
    
    IF keypress$ <> "" THEN
        DIM char_code AS INTEGER
        char_code = ASC(keypress$)
        
        SELECT CASE char_code
            CASE 27  ' ESC - cancel/apply text
                TEXT_apply
            CASE 13  ' ENTER - newline
                TEXT_newline
            CASE 8   ' BACKSPACE
                TEXT_backspace
            CASE 32 TO 126  ' Printable ASCII characters
                TEXT_add_char keypress$
            ' Ignore other special keys while text editing
        END SELECT
    END IF
    KEYBOARD_handle_text_tool% = TRUE  ' Consumed - don't process other keyboard handlers
END FUNCTION


''
' Handle custom brush controls (Ctrl+B to capture, HOME/END/PgUp/PgDn/etc for transformations).
'
SUB KEYBOARD_handle_custom_brush ()
    ' Ctrl+B to capture/clear custom brush
    STATIC ctrlBPressed AS INTEGER
    IF MODIFIERS.ctrl% AND _KEYDOWN(98) THEN ' Ctrl+B (98 = 'b' key)
        IF NOT ctrlBPressed% THEN
            IF CUSTOM_BRUSH_is_active% THEN
                CUSTOM_BRUSH_reset
                GUI_NEEDS_REDRAW% = TRUE
            ELSEIF MARQUEE.ACTIVE% THEN
                CUSTOM_BRUSH_capture_from_marquee
                GUI_NEEDS_REDRAW% = TRUE
            END IF
            ctrlBPressed% = TRUE
        END IF
    ELSE
        ctrlBPressed% = FALSE
    END IF
    
    ' HOME key for horizontal flip
    STATIC homePressed AS INTEGER
    IF _KEYDOWN(18176) AND NOT MODIFIERS.ctrl% THEN
        IF NOT homePressed% THEN
            IF CUSTOM_BRUSH_is_active% THEN
                CUSTOM_BRUSH_toggle_flip_h
            ELSE
                CMD_execute_action 315 ' Flip Horizontal (layer/selection)
            END IF
            homePressed% = TRUE
        END IF
    ELSE
        homePressed% = FALSE
    END IF
    
    ' END key for vertical flip
    STATIC endPressed AS INTEGER
    IF _KEYDOWN(20224) AND NOT MODIFIERS.ctrl% THEN
        IF NOT endPressed% THEN
            IF CUSTOM_BRUSH_is_active% THEN
                CUSTOM_BRUSH_toggle_flip_v
            ELSE
                CMD_execute_action 316 ' Flip Vertical (layer/selection)
            END IF
            endPressed% = TRUE
        END IF
    ELSE
        endPressed% = FALSE
    END IF
    
    ' Page Up for scaling brush up / Scale +50%
    STATIC pgUpPressed AS INTEGER
    IF _KEYDOWN(18688) AND NOT MODIFIERS.ctrl% THEN
        IF NOT pgUpPressed% THEN
            IF CUSTOM_BRUSH_is_active% THEN
                CUSTOM_BRUSH_scale_up
            ELSE
                CMD_execute_action 318 ' Scale +50% (layer/selection)
            END IF
            pgUpPressed% = TRUE
        END IF
    ELSE
        pgUpPressed% = FALSE
    END IF
    
    ' Page Down for scaling brush down / Scale -50%
    STATIC pgDnPressed AS INTEGER
    IF _KEYDOWN(20736) AND NOT MODIFIERS.ctrl% THEN
        IF NOT pgDnPressed% THEN
            IF CUSTOM_BRUSH_is_active% THEN
                CUSTOM_BRUSH_scale_down
            ELSE
                CMD_execute_action 317 ' Scale -50% (layer/selection)
            END IF
            pgDnPressed% = TRUE
        END IF
    ELSE
        pgDnPressed% = FALSE
    END IF
    
    ' / key for resetting brush scale
    STATIC slashPressed AS INTEGER
    IF CUSTOM_BRUSH_is_active% AND _KEYDOWN(47) THEN
        IF NOT slashPressed% THEN
            CUSTOM_BRUSH_scale_reset
            slashPressed% = TRUE
        END IF
    ELSE
        slashPressed% = FALSE
    END IF
    
    ' > key (Shift+.) for rotating 90 CW (universal)
    STATIC rotateCWPressed AS INTEGER
    IF _KEYDOWN(62) THEN  ' ASCII 62 = >
        IF NOT rotateCWPressed% THEN
            CMD_execute_action 319
            rotateCWPressed% = TRUE
        END IF
    ELSE
        rotateCWPressed% = FALSE
    END IF
    
    ' < key (Shift+,) for rotating 90 CCW (universal)
    STATIC rotateCCWPressed AS INTEGER
    IF _KEYDOWN(60) THEN  ' ASCII 60 = <
        IF NOT rotateCCWPressed% THEN
            CMD_execute_action 320
            rotateCCWPressed% = TRUE
        END IF
    ELSE
        rotateCCWPressed% = FALSE
    END IF
    
    ' F9 for toggling recolor mode
    STATIC f9Pressed AS INTEGER
    IF _KEYDOWN(17152) THEN ' F9
        IF NOT f9Pressed% THEN
            _LOGINFO "F9 pressed - CUSTOM_BRUSH_is_active% = " + STR$(CUSTOM_BRUSH_is_active%)
            IF CUSTOM_BRUSH_is_active% THEN
                CUSTOM_BRUSH_toggle_recolor
            ELSE
                _LOGINFO "F9 ignored - custom brush not active"
            END IF
            f9Pressed% = TRUE
        END IF
    ELSE
        f9Pressed% = FALSE
    END IF
    
    ' ` (backtick) for toggling outline visibility
    STATIC backtickPressed AS INTEGER
    IF CUSTOM_BRUSH_is_active% AND _KEYDOWN(96) THEN
        IF NOT backtickPressed% THEN
            CUSTOM_BRUSH_toggle_outline
            backtickPressed% = TRUE
        END IF
    ELSE
        backtickPressed% = FALSE
    END IF
    
    ' Shift+O for applying outline with BG color
    STATIC shiftOPressed AS INTEGER
    IF CUSTOM_BRUSH_is_active% AND MODIFIERS.shift% AND (_KEYDOWN(79) OR _KEYDOWN(111)) THEN
        IF NOT shiftOPressed% THEN
            CUSTOM_BRUSH_apply_outline
            shiftOPressed% = TRUE
        END IF
    ELSE
        shiftOPressed% = FALSE
    END IF
    
    ' F12 for exporting custom brush
    STATIC f12Pressed AS INTEGER
    IF _KEYDOWN(34304) THEN ' F12
        IF NOT f12Pressed% THEN
            _LOGINFO "F12 key detected"
            IF CUSTOM_BRUSH_is_active% THEN
                _LOGINFO "Custom brush is active, proceeding with export"
                DIM export_filename AS STRING
                export_filename$ = "brush_" + _TRIM$(STR$(TIMER)) + ".png"
                CUSTOM_BRUSH_export_png export_filename$
            ELSE
                _LOGERROR "F12 pressed but custom brush is not active (create brush with Ctrl+B first)"
            END IF
            f12Pressed% = TRUE
        END IF
    ELSE
        f12Pressed% = FALSE
    END IF
END SUB


''
' Handle UI toggle keys (TAB, F10, F11, Ctrl+F11).
'
SUB KEYBOARD_handle_ui_toggles ()
    ' Static variables to prevent key repeat
    STATIC tabPressed AS INTEGER, f10Pressed AS INTEGER, f11Pressed AS INTEGER
    
    ' Handle TAB for toolbar toggle (but not when CTRL is held - that's for layer panel)
    IF _KEYDOWN(9) AND NOT MODIFIERS.ctrl% THEN
        IF NOT tabPressed% THEN
            SCRN.showToolbar% = NOT SCRN.showToolbar%
            SCRN.toolbarManuallyHidden% = NOT SCRN.showToolbar%
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
            FRAME_IDLE% = FALSE
            tabPressed% = TRUE
        END IF
    ELSE
        tabPressed% = FALSE
    END IF
    
    ' Handle F10 for status bar toggle
    IF _KEYDOWN(17408) THEN ' F10
        IF NOT f10Pressed% THEN
            SCRN.showStatus% = NOT SCRN.showStatus%
            SCRN.statusManuallyHidden% = NOT SCRN.showStatus%
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
            FRAME_IDLE% = FALSE
            f10Pressed% = TRUE
        END IF
    ELSE
        f10Pressed% = FALSE
    END IF
    
    ' Handle F11 for toggle all UI panels
    IF _KEYDOWN(34048) AND NOT MODIFIERS.ctrl% THEN ' F11 (not Ctrl+F11)
        IF NOT f11Pressed% THEN
            IF SCRN.showToolbar% OR SCRN.showStatus% OR LAYER_PANEL.visible% OR (SCRN.showMenubar% AND MENU_BAR.visible%) THEN
                SCRN.showToolbar% = FALSE
                SCRN.showStatus% = FALSE
                LAYER_PANEL.visible% = FALSE
                MENU_BAR.visible% = FALSE
                MENUBAR_close_all
                SCRN.toolbarManuallyHidden% = TRUE
                SCRN.statusManuallyHidden% = TRUE
                SCRN.menubarManuallyHidden% = TRUE
                SCRN.layerPanelManuallyHidden% = TRUE
            ELSE
                SCRN.showToolbar% = TRUE
                SCRN.showStatus% = TRUE
                LAYER_PANEL.visible% = TRUE
                MENU_BAR.visible% = TRUE
                SCRN.toolbarManuallyHidden% = FALSE
                SCRN.statusManuallyHidden% = FALSE
                SCRN.menubarManuallyHidden% = FALSE
                SCRN.layerPanelManuallyHidden% = FALSE
            END IF
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
            FRAME_IDLE% = FALSE
            f11Pressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(34048) THEN
        f11Pressed% = FALSE
    END IF
    
    ' Handle Ctrl+F11 for menu bar toggle only
    STATIC ctrlF11Pressed AS INTEGER
    IF _KEYDOWN(34048) AND MODIFIERS.ctrl% THEN ' Ctrl+F11
        IF NOT ctrlF11Pressed% THEN
            MENU_BAR.visible% = NOT MENU_BAR.visible%
            SCRN.showMenubar% = MENU_BAR.visible%
            SCRN.menubarManuallyHidden% = NOT MENU_BAR.visible%
            IF NOT MENU_BAR.visible% THEN MENUBAR_close_all
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
            FRAME_IDLE% = FALSE
            ctrlF11Pressed% = TRUE
        END IF
    ELSE
        ctrlF11Pressed% = FALSE
    END IF
    
    ' Handle Ctrl+R for reference image toggle
    STATIC ctrlRPressed AS INTEGER
    IF MODIFIERS.ctrl% AND NOT MODIFIERS.shift% AND NOT MODIFIERS.alt% AND (_KEYDOWN(114) OR _KEYDOWN(82)) THEN
        IF NOT ctrlRPressed% THEN
            REFIMG_toggle
            FRAME_IDLE% = FALSE
            ctrlRPressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(114) AND NOT _KEYDOWN(82) THEN
        ctrlRPressed% = FALSE
    END IF
    
    ' Handle Ctrl+Alt+R for random palette
    STATIC ctrlAltRPressed AS INTEGER
    IF MODIFIERS.ctrl% AND MODIFIERS.alt% AND NOT MODIFIERS.shift% AND (_KEYDOWN(114) OR _KEYDOWN(82)) THEN
        IF NOT ctrlAltRPressed% THEN
            CMD_execute_action 1512
            FRAME_IDLE% = FALSE
            ctrlAltRPressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(114) AND NOT _KEYDOWN(82) THEN
        ctrlAltRPressed% = FALSE
    END IF
END SUB


''
' Handle DELETE and BACKSPACE keys for canvas clearing.
'
SUB KEYBOARD_handle_delete_backspace ()
    ' DELETE for clear with prompt (skip if CTRL or SHIFT held)
    STATIC deletePressed AS INTEGER
    IF _KEYDOWN(KEY_DELETE&) AND NOT MODIFIERS.ctrl% AND NOT MODIFIERS.shift% THEN
        IF NOT deletePressed% THEN
            IF NOT (CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE) THEN
                IF CURRENT_TOOL% = TOOL_MARQUEE AND MARQUEE.MAGIC_WAND_MODE AND MARQUEE.WAND_HAS_SELECTION THEN
                    MAGIC_WAND_clear_selected_transparent
                    MAGIC_WAND_reset
                    GUI_NEEDS_REDRAW% = TRUE
                ELSE
                    PAINT_clear_with_prompt
                END IF
            END IF
            deletePressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(KEY_DELETE&) THEN
        deletePressed% = FALSE
    END IF
    
    ' BACKSPACE for clear without prompt
    STATIC backspacePressed AS INTEGER
    IF _KEYDOWN(KEY_BACKSPACE&) THEN
        IF NOT backspacePressed% THEN
            IF NOT (CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE) THEN
                PAINT_clear_no_prompt
            END IF
            backspacePressed% = TRUE
        END IF
    ELSE
        backspacePressed% = FALSE
    END IF
END SUB


''
' Handle grid control keys (apostrophe, semicolon, period, comma).
'
SUB KEYBOARD_handle_grid_controls ()
    ' Apostrophe (') for grid toggle, SHIFT+' (double quote) for pixel grid toggle
    STATIC gridTogglePressed AS INTEGER
    STATIC pixelGridTogglePressed AS INTEGER
    
    ' CTRL+' to cycle grid mode (square -> diagonal -> isometric -> hex)
    STATIC gridModeCyclePressed AS INTEGER
    IF _KEYDOWN(39) AND MODIFIERS.ctrl% THEN
        IF NOT gridModeCyclePressed% THEN
            GRID.GRID_MODE% = (GRID.GRID_MODE% + 1) MOD GRID_MODE_COUNT
            GRID_draw
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
            FRAME_IDLE% = FALSE
            gridModeCyclePressed% = TRUE
        END IF
    ELSE
        gridModeCyclePressed% = FALSE
    END IF

    ' Check for double quote (SHIFT+apostrophe = key code 34)
    IF _KEYDOWN(34) THEN ' double quote (SHIFT+')
        IF NOT pixelGridTogglePressed% THEN
            PIXEL_GRID.SHOW% = NOT PIXEL_GRID.SHOW%
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
            FRAME_IDLE% = FALSE
            pixelGridTogglePressed% = TRUE
        END IF
    ELSEIF _KEYDOWN(39) AND NOT MODIFIERS.ctrl% THEN ' apostrophe (no shift, no ctrl)
        IF NOT gridTogglePressed% THEN
            GRID.SHOW% = NOT GRID.SHOW%
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
            FRAME_IDLE% = FALSE
            gridTogglePressed% = TRUE
        END IF
    ELSE
        gridTogglePressed% = FALSE
        pixelGridTogglePressed% = FALSE
    END IF
    
    ' Semicolon (;) for snap-to-grid toggle
    STATIC snapTogglePressed AS INTEGER
    IF _KEYDOWN(59) THEN
        IF NOT snapTogglePressed% THEN
            GRID.SNAP% = NOT GRID.SNAP%
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
            snapTogglePressed% = TRUE
        END IF
    ELSE
        snapTogglePressed% = FALSE
    END IF
    
    ' Period (.) to increase grid size
    STATIC periodPressed AS INTEGER
    IF _KEYDOWN(46) THEN
        IF NOT periodPressed% THEN
            IF GRID.gridWidth% < 50 THEN
                GRID.gridWidth% = GRID.gridWidth% + 1
                GRID.gridHeight% = GRID.gridHeight% + 1
                GRID_draw
                GUI_NEEDS_REDRAW% = TRUE
                FRAME_IDLE% = FALSE
            END IF
            periodPressed% = TRUE
        END IF
    ELSE
        periodPressed% = FALSE
    END IF
    
    ' Comma (,) to decrease grid size
    STATIC commaPressed AS INTEGER
    IF _KEYDOWN(44) THEN
        IF NOT commaPressed% THEN
            IF GRID.gridWidth% > 2 THEN
                GRID.gridWidth% = GRID.gridWidth% - 1
                GRID.gridHeight% = GRID.gridHeight% - 1
                GRID_draw
                GUI_NEEDS_REDRAW% = TRUE
                FRAME_IDLE% = FALSE
            END IF
            commaPressed% = TRUE
        END IF
    ELSE
        commaPressed% = FALSE
    END IF
    
    ' CTRL+SHIFT+/ to set grid size from brush size
    ' Note: SHIFT+/ produces ? (key code 63), not / (key code 47)
    STATIC ctrlShiftSlashPressed AS INTEGER
    IF _KEYDOWN(63) AND MODIFIERS.ctrl% AND MODIFIERS.shift% THEN
        IF NOT ctrlShiftSlashPressed% THEN
            ' Set grid to brush size and enable tile mode (center alignment)
            IF CUSTOM_BRUSH_is_active% THEN
                ' Use custom brush dimensions
                GRID.gridWidth% = CUSTOM_BRUSH.WIDTH%
                GRID.gridHeight% = CUSTOM_BRUSH.HEIGHT%
            ELSE
                ' Use regular brush size
                GRID.gridWidth% = BRUSH_PIXEL_SIZES(BRUSH_SIZE.CURRENT)
                GRID.gridHeight% = BRUSH_PIXEL_SIZES(BRUSH_SIZE.CURRENT)
            END IF
            GRID.ALIGN_MODE% = GRID_ALIGN_CENTER  ' Center/tile mode for filling gaps
            GRID.SNAP% = TRUE  ' Enable snap to grid
            GRID_draw
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
            FRAME_IDLE% = FALSE
            ctrlShiftSlashPressed% = TRUE
        END IF
    ELSE
        ctrlShiftSlashPressed% = FALSE
    END IF
    
    ' Slash (/) to toggle grid alignment mode (corner vs center) - only if no modifiers
    STATIC slashPressed AS INTEGER
    IF _KEYDOWN(47) AND NOT MODIFIERS.ctrl% AND NOT MODIFIERS.shift% AND NOT MODIFIERS.alt% THEN
        IF NOT slashPressed% THEN
            ' Toggle between corner and center alignment
            IF GRID.ALIGN_MODE% = GRID_ALIGN_CORNER THEN
                GRID.ALIGN_MODE% = GRID_ALIGN_CENTER
            ELSE
                GRID.ALIGN_MODE% = GRID_ALIGN_CORNER
            END IF
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
            slashPressed% = TRUE
        END IF
    ELSE
        slashPressed% = FALSE
    END IF
END SUB


''
' Handle marquee tool arrow key controls (move/resize with single-press detection).
'
SUB KEYBOARD_handle_marquee_keys ()
    IF NOT (CURRENT_TOOL% = TOOL_MARQUEE AND MARQUEE.ACTIVE%) THEN EXIT SUB
    
    DIM moveStep AS INTEGER
    DIM marqKeyUpNow AS INTEGER, marqKeyDownNow AS INTEGER
    DIM marqKeyLeftNow AS INTEGER, marqKeyRightNow AS INTEGER
    
    moveStep% = 1
    IF MODIFIERS.shift% THEN moveStep% = 10
    
    marqKeyUpNow% = _KEYDOWN(18432)
    marqKeyDownNow% = _KEYDOWN(20480)
    marqKeyLeftNow% = _KEYDOWN(19200)
    marqKeyRightNow% = _KEYDOWN(19712)
    
    IF marqKeyUpNow% AND NOT MARQUEE.KEY_UP_LAST THEN
        IF MODIFIERS.ctrl% THEN
            MARQUEE.BOX.h = MARQUEE.BOX.h - moveStep%
            IF MARQUEE.BOX.h < 8 THEN MARQUEE.BOX.h = 8
        ELSE
            MARQUEE.BOX.y = MARQUEE.BOX.y - moveStep%
        END IF
    END IF
    IF marqKeyDownNow% AND NOT MARQUEE.KEY_DOWN_LAST THEN
        IF MODIFIERS.ctrl% THEN
            MARQUEE.BOX.h = MARQUEE.BOX.h + moveStep%
        ELSE
            MARQUEE.BOX.y = MARQUEE.BOX.y + moveStep%
        END IF
    END IF
    IF marqKeyLeftNow% AND NOT MARQUEE.KEY_LEFT_LAST THEN
        IF MODIFIERS.ctrl% THEN
            MARQUEE.BOX.w = MARQUEE.BOX.w - moveStep%
            IF MARQUEE.BOX.w < 8 THEN MARQUEE.BOX.w = 8
        ELSE
            MARQUEE.BOX.x = MARQUEE.BOX.x - moveStep%
        END IF
    END IF
    IF marqKeyRightNow% AND NOT MARQUEE.KEY_RIGHT_LAST THEN
        IF MODIFIERS.ctrl% THEN
            MARQUEE.BOX.w = MARQUEE.BOX.w + moveStep%
        ELSE
            MARQUEE.BOX.x = MARQUEE.BOX.x + moveStep%
        END IF
    END IF
    
    MARQUEE.KEY_UP_LAST = marqKeyUpNow%
    MARQUEE.KEY_DOWN_LAST = marqKeyDownNow%
    MARQUEE.KEY_LEFT_LAST = marqKeyLeftNow%
    MARQUEE.KEY_RIGHT_LAST = marqKeyRightNow%
END SUB


''
' Handle MOVE tool arrow key controls.
' CTRL+Arrows: nudge selection/layer by 1px (auto-captures if not active).
' CTRL+SHIFT+Arrows: nudge by CFG.NUDGE_N% px.
' When move IS active: bare Arrows also nudge 1px, SHIFT+Arrows nudge CFG.NUDGE_N% px.
'
SUB KEYBOARD_handle_move_keys ()
    DIM moveMoveStep AS INTEGER
    DIM keyUpNow AS INTEGER, keyDownNow AS INTEGER, keyLeftNow AS INTEGER, keyRightNow AS INTEGER

    keyUpNow% = _KEYDOWN(18432)
    keyDownNow% = _KEYDOWN(20480)
    keyLeftNow% = _KEYDOWN(19200)
    keyRightNow% = _KEYDOWN(19712)

    DIM anyArrow AS INTEGER
    anyArrow% = keyUpNow% OR keyDownNow% OR keyLeftNow% OR keyRightNow%

    ' --- CTRL+Arrow: auto-activate move tool and nudge ---
    IF MODIFIERS.ctrl% AND anyArrow% THEN
        ' If not currently in move tool, switch to it
        IF CURRENT_TOOL% <> TOOL_MOVE THEN
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_MOVE
            TOOLS_reset_all FALSE
            GUI_NEEDS_REDRAW% = TRUE
        END IF
        ' If move not active, capture the selection/layer
        IF NOT MOVE.ACTIVE THEN
            MOVE_capture_selection
        END IF

        moveMoveStep% = 1
        IF MODIFIERS.shift% THEN moveMoveStep% = CFG.NUDGE_N%

        IF keyUpNow% AND NOT MOVE_KEY_UP_LAST% THEN
            MOVE_nudge 0, -moveMoveStep%
        END IF
        IF keyDownNow% AND NOT MOVE_KEY_DOWN_LAST% THEN
            MOVE_nudge 0, moveMoveStep%
        END IF
        IF keyLeftNow% AND NOT MOVE_KEY_LEFT_LAST% THEN
            MOVE_nudge -moveMoveStep%, 0
        END IF
        IF keyRightNow% AND NOT MOVE_KEY_RIGHT_LAST% THEN
            MOVE_nudge moveMoveStep%, 0
        END IF

        MOVE_KEY_UP_LAST% = keyUpNow%
        MOVE_KEY_DOWN_LAST% = keyDownNow%
        MOVE_KEY_LEFT_LAST% = keyLeftNow%
        MOVE_KEY_RIGHT_LAST% = keyRightNow%

        ' Update clone mode based on ALT key
        MOVE.CLONING = MODIFIERS.alt%
        MOVE_update_preview_buffer
        EXIT SUB
    END IF

    ' --- Move tool active: bare arrows nudge, SHIFT = large step ---
    IF NOT (CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE) THEN
        ' Not in active move mode and no CTRL held — clear key state and exit
        MOVE_KEY_UP_LAST% = keyUpNow%
        MOVE_KEY_DOWN_LAST% = keyDownNow%
        MOVE_KEY_LEFT_LAST% = keyLeftNow%
        MOVE_KEY_RIGHT_LAST% = keyRightNow%
        EXIT SUB
    END IF

    moveMoveStep% = 1
    IF MODIFIERS.shift% THEN moveMoveStep% = CFG.NUDGE_N%

    IF keyUpNow% AND NOT MOVE_KEY_UP_LAST% THEN
        MOVE_nudge 0, -moveMoveStep%
    END IF
    IF keyDownNow% AND NOT MOVE_KEY_DOWN_LAST% THEN
        MOVE_nudge 0, moveMoveStep%
    END IF
    IF keyLeftNow% AND NOT MOVE_KEY_LEFT_LAST% THEN
        MOVE_nudge -moveMoveStep%, 0
    END IF
    IF keyRightNow% AND NOT MOVE_KEY_RIGHT_LAST% THEN
        MOVE_nudge moveMoveStep%, 0
    END IF

    MOVE_KEY_UP_LAST% = keyUpNow%
    MOVE_KEY_DOWN_LAST% = keyDownNow%
    MOVE_KEY_LEFT_LAST% = keyLeftNow%
    MOVE_KEY_RIGHT_LAST% = keyRightNow%

    ' Update clone mode based on ALT key
    MOVE.CLONING = MODIFIERS.alt%
    MOVE_update_preview_buffer
END SUB


''
' Handle clipboard, selection, and undo operations (Ctrl+C/X/V/E/T/D/A/I/Z/Y).
'
SUB KEYBOARD_handle_clipboard_operations ()
    ' Static variables for single-press detection
    STATIC CLIPBOARD_KEY_D_LAST AS INTEGER
    STATIC CLIPBOARD_KEY_A_LAST AS INTEGER
    STATIC CLIPBOARD_KEY_I_LAST AS INTEGER
    
    DIM keyDNow AS INTEGER, keyANow AS INTEGER, keyINow AS INTEGER
    IF NOT MODIFIERS.ctrl% THEN EXIT SUB
    
    DIM selIsShift AS INTEGER
    selIsShift% = MODIFIERS.shift%
    
    ' Ctrl+D: Deselect
    keyDNow% = _KEYDOWN(100)
    IF keyDNow% AND NOT CLIPBOARD_KEY_D_LAST% THEN
        IF MARQUEE.WAND_HAS_SELECTION AND MARQUEE.SELECTION_MASK < -1 THEN
            MAGIC_WAND_reset
            MARQUEE.ACTIVE% = FALSE
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
        ELSEIF MARQUEE.ACTIVE% THEN
            MARQUEE_clear
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
        END IF
    END IF
    CLIPBOARD_KEY_D_LAST% = keyDNow%
    
    ' Ctrl+A: Select All
    keyANow% = _KEYDOWN(97)
    IF keyANow% AND NOT CLIPBOARD_KEY_A_LAST% AND NOT selIsShift% THEN
        SELECTION_select_all
    END IF
    CLIPBOARD_KEY_A_LAST% = keyANow%
    
    ' Ctrl+Shift+I: Invert Selection
    keyINow% = _KEYDOWN(105) OR _KEYDOWN(73)
    IF keyINow% AND NOT CLIPBOARD_KEY_I_LAST% AND selIsShift% THEN
        SELECTION_invert
    END IF
    CLIPBOARD_KEY_I_LAST% = keyINow%
    
    ' Clipboard operations
    DIM clipIsShift AS INTEGER, clipIsAlt AS INTEGER
    DIM keyCNow AS INTEGER, keyXNow AS INTEGER, keyVNow AS INTEGER, keyENow AS INTEGER
    
    clipIsShift% = selIsShift%
    clipIsAlt% = MODIFIERS.alt%
    
    keyCNow% = _KEYDOWN(99) OR _KEYDOWN(67)
    keyXNow% = _KEYDOWN(120) OR _KEYDOWN(88)
    keyVNow% = _KEYDOWN(118) OR _KEYDOWN(86)
    keyENow% = _KEYDOWN(101) OR _KEYDOWN(69)
    
    ' Ctrl+C: Copy
    IF keyCNow% AND NOT CLIPBOARD_KEY_C_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
        CLIPBOARD_copy
    END IF
    
    ' Ctrl+Shift+C: Copy merged
    IF keyCNow% AND NOT CLIPBOARD_KEY_C_LAST% AND clipIsShift% AND NOT clipIsAlt% THEN
        CLIPBOARD_copy_merged
    END IF
    
    ' Ctrl+X: Cut
    IF keyXNow% AND NOT CLIPBOARD_KEY_X_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
        CLIPBOARD_cut
    END IF
    
    ' Ctrl+V: Paste
    IF keyVNow% AND NOT CLIPBOARD_KEY_V_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
        CLIPBOARD_paste MOUSE.X%, MOUSE.Y%
    END IF
    
    ' Ctrl+E: Clear selection
    IF keyENow% AND NOT CLIPBOARD_KEY_E_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
        IF CURRENT_TOOL% = TOOL_MARQUEE AND MARQUEE.MAGIC_WAND_MODE AND MARQUEE.WAND_HAS_SELECTION THEN
            MAGIC_WAND_clear_selected_transparent
            MAGIC_WAND_reset
            GUI_NEEDS_REDRAW% = TRUE
        ELSE
            CLIPBOARD_clear_selection
        END IF
    END IF
    
    ' Ctrl+T: Activate text tool with custom font
    DIM keyTNow AS INTEGER
    keyTNow% = _KEYDOWN(116)
    IF keyTNow% AND NOT CLIPBOARD_KEY_T_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
        _LOGINFO "CTRL-T pressed!"
        _LOGINFO "Custom font handle: " + STR$(TEXT.CUSTOM_FONT_HANDLE)
        PREVIOUS_TOOL% = CURRENT_TOOL%
        CURRENT_TOOL% = TOOL_TEXT
        TOOLS_reset_all FALSE  ' Reset all tools, preserve marquee selection
        
        IF TEXT.CUSTOM_FONT_HANDLE > 0 THEN
            _LOGINFO "Using custom font!"
            TEXT.USE_CUSTOM = TRUE
            TEXT.USE_TINY5 = FALSE
            DIM old_font_ctrl AS LONG
            old_font_ctrl& = _FONT
            _FONT TEXT.CUSTOM_FONT_HANDLE
            TEXT.CHAR_WIDTH = _PRINTWIDTH("A")
            TEXT.LINE_HEIGHT = _FONTHEIGHT + 2
            _FONT old_font_ctrl&
            _LOGINFO "Custom font activated - width: " + STR$(TEXT.CHAR_WIDTH) + " height: " + STR$(TEXT.LINE_HEIGHT)
        ELSE
            _LOGINFO "No custom font loaded - using VGA"
            TEXT.USE_CUSTOM = FALSE
            TEXT.USE_TINY5 = FALSE
            TEXT.CHAR_WIDTH = 8
            TEXT.LINE_HEIGHT = 13
        END IF
        TEXT_reset
    END IF
    
    ' Update key states
    CLIPBOARD_KEY_C_LAST% = keyCNow%
    CLIPBOARD_KEY_X_LAST% = keyXNow%
    CLIPBOARD_KEY_V_LAST% = keyVNow%
    CLIPBOARD_KEY_E_LAST% = keyENow%
    CLIPBOARD_KEY_T_LAST% = keyTNow%
    
    ' Undo/Redo operations
    DIM keyZNow AS INTEGER, keyYNow AS INTEGER
    DIM pixelUndoTs AS DOUBLE, workspaceUndoTs AS DOUBLE
    
    keyZNow% = _KEYDOWN(122) OR _KEYDOWN(90)
    keyYNow% = _KEYDOWN(121) OR _KEYDOWN(89)
    
    ' Ctrl+Z: Intelligent Undo (or abort active Move)
    IF keyZNow% AND NOT UNDO_KEY_Z_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
        IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
            ' Abort the active move instead of undoing — same as ESC
            ' Suppress undo save so MOVE_apply_transform (called by MOVE_reset)
            ' doesn't create a phantom state identical to pre-capture
            UNDO_saved_this_frame% = TRUE
            MOVE_cancel_transform
            MOVE_reset
            ' Clear auto-created marquee but keep TOOL_MOVE selected
            IF MARQUEE.ACTIVE% AND NOT MARQUEE.USER_CREATED THEN
                MARQUEE_reset
            END IF
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
        ELSE
            pixelUndoTs# = UNDO_get_last_timestamp#
            workspaceUndoTs# = WORKSPACE_UNDO_get_last_timestamp#
        
            IF workspaceUndoTs# > pixelUndoTs# AND WORKSPACE_UNDO_can_undo% THEN
                _LOGINFO "CTRL-Z: Workspace undo (ts=" + STR$(workspaceUndoTs#) + " > pixel ts=" + STR$(pixelUndoTs#) + ")"
                WORKSPACE_UNDO_undo
            ELSEIF pixelUndoTs# > 0 THEN
                _LOGINFO "CTRL-Z: Pixel undo (ts=" + STR$(pixelUndoTs#) + " >= workspace ts=" + STR$(workspaceUndoTs#) + ")"
                UNDO_undo
            END IF
            GUI_NEEDS_REDRAW% = TRUE
            FRAME_IDLE% = FALSE
        END IF
    END IF
    UNDO_KEY_Z_LAST% = keyZNow%
    
    ' Ctrl+Y OR Ctrl+Shift+Z: Intelligent Redo
    IF (keyYNow% AND NOT UNDO_KEY_Y_LAST%) OR (keyZNow% AND NOT UNDO_KEY_Z_LAST% AND clipIsShift%) THEN
        ' If workspace has something to redo, use timestamps for correct chronological order
        DIM redoPixelTs AS DOUBLE, redoWorkspaceTs AS DOUBLE
        DIM redoCanPixel AS INTEGER, redoCanWorkspace AS INTEGER
        redoCanPixel% = (UNDO.current% < UNDO.count% - 1)
        redoCanWorkspace% = WORKSPACE_UNDO_can_redo%
        redoPixelTs# = 0: redoWorkspaceTs# = 0
        IF redoCanPixel% AND (UNDO.current% + 1) <= UNDO_STATES_MAX% THEN redoPixelTs# = UNDO_STATES(UNDO.current% + 1).timestamp#
        IF redoCanWorkspace% THEN redoWorkspaceTs# = WORKSPACE_UNDO_STATES(WORKSPACE_UNDO.current% + 1).timestamp#
        IF redoCanWorkspace% AND (NOT redoCanPixel% OR redoWorkspaceTs# < redoPixelTs#) THEN
            _LOGINFO "CTRL-Y: Workspace redo (ts=" + STR$(redoWorkspaceTs#) + " < pixel ts=" + STR$(redoPixelTs#) + ")"
            WORKSPACE_UNDO_redo
        ELSEIF redoCanPixel% THEN
            _LOGINFO "CTRL-Y: Pixel redo"
            UNDO_redo
        END IF
        GUI_NEEDS_REDRAW% = TRUE
        FRAME_IDLE% = FALSE
    END IF
    UNDO_KEY_Y_LAST% = keyYNow%
END SUB


''
' Handle file operations (Ctrl+O/S/Shift+S/Alt+S).
'
SUB KEYBOARD_handle_file_operations ()
    IF NOT MODIFIERS.ctrl% THEN EXIT SUB
    
    DIM fileIsShift AS INTEGER, fileIsAlt AS INTEGER
    DIM keyONow AS INTEGER, keySNow AS INTEGER, keyNNow AS INTEGER
    
    fileIsShift% = MODIFIERS.shift%
    fileIsAlt% = MODIFIERS.alt%
    
    keyONow% = _KEYDOWN(111) OR _KEYDOWN(79)
    keySNow% = _KEYDOWN(115) OR _KEYDOWN(83)
    keyNNow% = _KEYDOWN(110) OR _KEYDOWN(78)
    
    ' Ctrl+N: New canvas (only if SHIFT not pressed - CTRL+SHIFT+N is new layer)
    IF keyNNow% AND NOT fileIsShift% AND NOT FILE_KEY_N_LAST% THEN
        DRW_new_canvas
    END IF
    
    ' Ctrl+O: Open file
    IF keyONow% AND NOT FILE_KEY_O_LAST% THEN
        LOAD_image
    END IF
    
    ' Ctrl+S variants: Save operations
    IF keySNow% AND NOT FILE_KEY_S_LAST% THEN
        IF fileIsShift% AND NOT fileIsAlt% THEN
            SAVE_as
        ELSEIF NOT fileIsShift% AND NOT fileIsAlt% THEN
            SAVE_image
        END IF
    END IF
    
    FILE_KEY_N_LAST% = keyNNow%
    FILE_KEY_O_LAST% = keyONow%
    FILE_KEY_S_LAST% = keySNow%
END SUB


''
' Handle zoom shortcuts (Ctrl+0/+/-).
'
SUB KEYBOARD_handle_zoom_shortcuts ()
    IF NOT MODIFIERS.ctrl% THEN EXIT SUB
    
    DIM zoomIsShift AS INTEGER, zoomIsAlt AS INTEGER
    zoomIsShift% = MODIFIERS.shift%
    zoomIsAlt% = MODIFIERS.alt%
    
    ' Skip if using display scale combo (Ctrl+Alt+Shift)
    IF zoomIsShift% AND zoomIsAlt% THEN EXIT SUB
    
    STATIC zoom0Pressed AS INTEGER, zoomPlusPressed AS INTEGER, zoomMinusPressed AS INTEGER
    
    ' Ctrl+0: Reset zoom to 100% and center
    IF _KEYDOWN(48) THEN
        IF NOT zoom0Pressed% THEN
            SCRN.zoom! = 1.0
            SCRN.offsetX% = 0
            SCRN.offsetY% = 0
            GUI_NEEDS_REDRAW% = TRUE
            zoom0Pressed% = TRUE
        END IF
    ELSE
        zoom0Pressed% = FALSE
    END IF
    
    ' Ctrl+=: Zoom in
    IF _KEYDOWN(61) THEN
        IF NOT zoomPlusPressed% THEN
            IF SCRN.zoom! < 0.5 THEN
                SCRN.zoom! = 0.5
            ELSEIF SCRN.zoom! < 1.0 THEN
                SCRN.zoom! = 1.0
            ELSE
                SCRN.zoom! = INT(SCRN.zoom!) + 1.0
                IF SCRN.zoom! > SCRN.zoomMax! THEN SCRN.zoom! = SCRN.zoomMax!
            END IF
            GUI_NEEDS_REDRAW% = TRUE
            zoomPlusPressed% = TRUE
        END IF
    ELSE
        zoomPlusPressed% = FALSE
    END IF
    
    ' Ctrl+-: Zoom out
    IF _KEYDOWN(45) THEN
        IF NOT zoomMinusPressed% THEN
            IF SCRN.zoom! > 1.0 THEN
                SCRN.zoom! = INT(SCRN.zoom!) - 1.0
                IF SCRN.zoom! < 1.0 THEN SCRN.zoom! = 1.0
            ELSEIF SCRN.zoom! > 0.5 THEN
                SCRN.zoom! = 0.5
            ELSE
                SCRN.zoom! = 0.25
            END IF
            GUI_NEEDS_REDRAW% = TRUE
            zoomMinusPressed% = TRUE
        END IF
    ELSE
        zoomMinusPressed% = FALSE
    END IF
END SUB


''
' Handle layer navigation shortcuts (Shift+[/], Ctrl+Alt+E/Shift+E).
'
SUB KEYBOARD_handle_layer_shortcuts ()
    DIM isCtrl AS INTEGER, isShift AS INTEGER, isAlt AS INTEGER
    isCtrl% = MODIFIERS.ctrl%
    isShift% = MODIFIERS.shift%
    isAlt% = MODIFIERS.alt%
    
    STATIC layerShiftBracketLPressed AS INTEGER, layerShiftBracketRPressed AS INTEGER
    STATIC layerCtrlEPressed AS INTEGER, layerCtrlShiftEPressed AS INTEGER
    
    ' Shift+[: Focus previous layer
    IF isShift% AND NOT isCtrl% AND _KEYDOWN(123) THEN
        IF NOT layerShiftBracketLPressed% THEN
            DIM prevZ AS INTEGER, prevIdx AS INTEGER, pi AS INTEGER
            prevZ% = 0
            prevIdx% = 0
            IF CURRENT_LAYER% >= 1 AND CURRENT_LAYER% <= 64 THEN
                IF LAYERS(CURRENT_LAYER%).imgHandle& <> 0 THEN
                    prevZ% = LAYERS(CURRENT_LAYER%).zIndex% - 1
                    IF prevZ% >= 1 THEN
                        FOR pi% = 1 TO 64
                            IF LAYERS(pi%).imgHandle& <> 0 AND LAYERS(pi%).zIndex% = prevZ% THEN
                                prevIdx% = pi%
                                EXIT FOR
                            END IF
                        NEXT pi%
                        IF prevIdx% > 0 THEN LAYERS_select prevIdx%
                    END IF
                END IF
            END IF
            layerShiftBracketLPressed% = TRUE
        END IF
    ELSE
        layerShiftBracketLPressed% = FALSE
    END IF
    
    ' Shift+]: Focus next layer
    IF isShift% AND NOT isCtrl% AND _KEYDOWN(125) THEN
        IF NOT layerShiftBracketRPressed% THEN
            DIM nextZ AS INTEGER, nextIdx AS INTEGER, ni AS INTEGER
            nextZ% = 0
            nextIdx% = 0
            IF CURRENT_LAYER% >= 1 AND CURRENT_LAYER% <= 64 THEN
                IF LAYERS(CURRENT_LAYER%).imgHandle& <> 0 THEN
                    nextZ% = LAYERS(CURRENT_LAYER%).zIndex% + 1
                    IF nextZ% <= LAYER_COUNT% THEN
                        FOR ni% = 1 TO 64
                            IF LAYERS(ni%).imgHandle& <> 0 AND LAYERS(ni%).zIndex% = nextZ% THEN
                                nextIdx% = ni%
                                EXIT FOR
                            END IF
                        NEXT ni%
                        IF nextIdx% > 0 THEN LAYERS_select nextIdx%
                    END IF
                END IF
            END IF
            layerShiftBracketRPressed% = TRUE
        END IF
    ELSE
        layerShiftBracketRPressed% = FALSE
    END IF
    
    ' Ctrl+Alt+E: Merge layer down
    IF isCtrl% AND isAlt% AND NOT isShift% AND _KEYDOWN(101) THEN
        IF NOT layerCtrlEPressed% THEN
            LAYERS_merge_down CURRENT_LAYER%
            layerCtrlEPressed% = TRUE
        END IF
    ELSE
        layerCtrlEPressed% = FALSE
    END IF
    
    ' Ctrl+Alt+Shift+E: Merge all visible layers
    IF isCtrl% AND isShift% AND isAlt% AND _KEYDOWN(69) THEN
        IF NOT layerCtrlShiftEPressed% THEN
            LAYERS_merge_visible
            layerCtrlShiftEPressed% = TRUE
        END IF
    ELSE
        layerCtrlShiftEPressed% = FALSE
    END IF
END SUB


''
' Handle keyboard input
' 
SUB KEYBOARD_input_handler ()
    DIM keypress AS STRING
    
    ' Layer keyboard handling - MUST run first before any EXIT SUB statements
    ' Uses _KEYDOWN() so runs every frame regardless of INKEY$ state
    KEYBOARD_layers
    
    ' Handle menu bar keyboard navigation (ALT tap, arrow keys, Enter, Escape)
    IF KEYBOARD_handle_menubar% THEN EXIT SUB
    
    ' Handle IMAGE IMPORT mode - intercept Enter/Escape and arrow keys
    IF KEYBOARD_handle_image_import% THEN EXIT SUB

    ' Handle CROP mode - intercept Enter/Escape and arrow keys
    IF KEYBOARD_handle_crop_tool% THEN EXIT SUB
    
    ' Handle REFERENCE IMAGE reposition mode - intercept Enter/Escape
    IF KEYBOARD_handle_refimg_reposition% THEN EXIT SUB
    
    ' Handle command palette if visible
    IF KEYBOARD_handle_command_palette% THEN EXIT SUB
    
    ' Handle palette menu if visible
    IF KEYBOARD_handle_palette_menu% THEN EXIT SUB
    
    ' NOTE: Display scale hotkeys (CTRL+ALT+SHIFT+=/-) are handled in DRAW.BAS main loop
    ' using _KEYHIT which is more reliable on Linux for complex modifier combinations
    
    ' Handle custom brush controls (Ctrl+B to capture, HOME/END/PgUp/PgDn for transformations)
    KEYBOARD_handle_custom_brush
    
    ' If text tool is active and editing, block ALL other keyboard processing except text input
    keypress$ = INKEY$
    IF KEYBOARD_handle_text_tool%(keypress$) THEN EXIT SUB
    IF keypress$ <> "" THEN
        ' Handle ? for command palette with search (before other processing)
        IF keypress$ = "?" THEN
            CMD_show_palette
        ELSE
            KEYBOARD_colors keypress$
            KEYBOARD_tools keypress$
            KEYBOARD_brush_size keypress$
            KEYBOARD_assistants keypress$
        END IF
    END IF
    
    ' Note: KEYBOARD_layers is called at the TOP of this sub before any EXIT SUB statements
    
    ' Handle function keys F1-F8 (uses _KEYDOWN, must run unconditionally)
    KEYBOARD_handle_function_keys
    
    ' Handle UI toggle keys (extracted for clarity)
    KEYBOARD_handle_ui_toggles
    
    ' Handle DELETE and BACKSPACE keys (extracted for clarity)
    KEYBOARD_handle_delete_backspace
    
    ' Handle grid control keys (extracted for clarity)
    KEYBOARD_handle_grid_controls
    
    ' Handle marquee tool arrow keys (extracted for clarity)
    KEYBOARD_handle_marquee_keys
    
    ' Handle MOVE tool arrow keys (extracted for clarity)
    KEYBOARD_handle_move_keys
    
    ' Handle clipboard, selection, and undo operations (extracted for clarity)
    KEYBOARD_handle_clipboard_operations
    
    ' Handle file operations (extracted for clarity)
    KEYBOARD_handle_file_operations
    
    ' Handle zoom shortcuts (extracted for clarity)
    KEYBOARD_handle_zoom_shortcuts
    
    ' Handle layer navigation and merge shortcuts (extracted for clarity)
    KEYBOARD_handle_layer_shortcuts
END SUB


''
' Post-render keyboard input processing loop
'
SUB KEYBOARD_input_handler_loop ()
    DIM k AS LONG
    k& = _KEYHIT
    DO WHILE k& <> 0
        k& = _KEYHIT
    LOOP
    
    ' === ALT+O / ALT+X: Open .DRAW project file / Exit (ALT-only, no CTRL) ===
    STATIC DRW_KEY_O_LAST AS INTEGER
    DIM drwIsAlt AS INTEGER, drwIsCtrl AS INTEGER
    DIM drwKeyONow AS INTEGER
    
    drwIsAlt% = MODIFIERS.alt%
    drwIsCtrl% = MODIFIERS.ctrl%
    drwKeyONow% = _KEYDOWN(111)
    
    ' ALT+O (no CTRL): Open .draw project
    IF drwIsAlt% AND NOT drwIsCtrl% AND drwKeyONow% AND NOT DRW_KEY_O_LAST% THEN
        DRW_open_dialog
        ' Reset ALT tap state so menu bar doesn't open after dialog returns
        MENU_BAR.altTapped% = FALSE
        MENU_BAR.altWasDown% = FALSE
    END IF
    
    ' ALT+X (no CTRL): Exit application
    STATIC DRW_KEY_X_LAST AS INTEGER
    DIM drwKeyXNow AS INTEGER
    drwKeyXNow% = _KEYDOWN(120)  ' lowercase x
    IF drwIsAlt% AND NOT drwIsCtrl% AND drwKeyXNow% AND NOT DRW_KEY_X_LAST% THEN
        CMD_execute_action 212
        MENU_BAR.altTapped% = FALSE
        MENU_BAR.altWasDown% = FALSE
    END IF
    DRW_KEY_X_LAST% = drwKeyXNow%
    
    DRW_KEY_O_LAST% = drwKeyONow%
END SUB


''
' Handle layer-related keyboard shortcuts
' 
SUB KEYBOARD_layers ()
    DIM isCtrl AS INTEGER, isShift AS INTEGER, isAlt AS INTEGER
    STATIC layerCtrlTabPressed AS INTEGER
    STATIC layerCtrlShiftNPressed AS INTEGER
    STATIC layerCtrlDPressed AS INTEGER
    STATIC layerCtrlShiftRPressed AS INTEGER
    STATIC layerCtrlBracketLPressed AS INTEGER
    STATIC layerCtrlBracketRPressed AS INTEGER
    STATIC layerCtrlShiftBracketLPressed AS INTEGER
    STATIC layerCtrlShiftBracketRPressed AS INTEGER
    STATIC layerCtrlShiftDelPressed AS INTEGER
    
    isCtrl% = MODIFIERS.ctrl%
    isShift% = MODIFIERS.shift%
    isAlt% = MODIFIERS.alt%
    
    ' CTRL+L: Toggle layer panel visibility
    IF isCtrl% AND (_KEYDOWN(ASC("l")) OR _KEYDOWN(ASC("L"))) AND NOT isShift% AND NOT isAlt% THEN
        IF NOT layerCtrlTabPressed% THEN
            LAYER_PANEL.visible% = NOT LAYER_PANEL.visible%
            SCRN.layerPanelManuallyHidden% = NOT LAYER_PANEL.visible%
            GUI_NEEDS_REDRAW% = TRUE
            SCENE_DIRTY% = TRUE
            FRAME_IDLE% = FALSE
            layerCtrlTabPressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(ASC("l")) AND NOT _KEYDOWN(ASC("L")) THEN
        layerCtrlTabPressed% = FALSE
    END IF
    
    ' CTRL+SHIFT+N: New layer
    IF isCtrl% AND isShift% AND (_KEYDOWN(110) OR _KEYDOWN(78)) THEN
        IF NOT layerCtrlShiftNPressed% THEN
            DIM newLayerIdx AS INTEGER
            newLayerIdx% = LAYERS_new%
            layerCtrlShiftNPressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(110) AND NOT _KEYDOWN(78) THEN
        layerCtrlShiftNPressed% = FALSE
    END IF
    
    ' CTRL+SHIFT+Delete: Delete current layer
    IF isCtrl% AND isShift% AND _KEYDOWN(21248) THEN
        IF NOT layerCtrlShiftDelPressed% THEN
            LAYERS_delete CURRENT_LAYER%
            layerCtrlShiftDelPressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(21248) THEN
        layerCtrlShiftDelPressed% = FALSE
    END IF
    
    ' CTRL+SHIFT+D: Duplicate layer
    IF isCtrl% AND isShift% AND (_KEYDOWN(100) OR _KEYDOWN(68)) THEN
        IF NOT layerCtrlDPressed% THEN
            LAYERS_duplicate CURRENT_LAYER%
            layerCtrlDPressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(100) AND NOT _KEYDOWN(68) THEN
        layerCtrlDPressed% = FALSE
    END IF
    
    ' CTRL+SHIFT+R: Rename layer
    IF isCtrl% AND isShift% AND (_KEYDOWN(114) OR _KEYDOWN(82)) THEN
        IF NOT layerCtrlShiftRPressed% THEN
            LAYERS_rename CURRENT_LAYER%
            layerCtrlShiftRPressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(114) AND NOT _KEYDOWN(82) THEN
        layerCtrlShiftRPressed% = FALSE
    END IF
    
    ' CTRL+PgUp: Move layer up in stack
    IF isCtrl% AND NOT isShift% AND _KEYDOWN(18688) THEN
        IF NOT layerCtrlBracketLPressed% THEN
            LAYERS_move_up CURRENT_LAYER%
            layerCtrlBracketLPressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(18688) THEN
        layerCtrlBracketLPressed% = FALSE
    END IF
    
    ' CTRL+PgDn: Move layer down in stack
    IF isCtrl% AND NOT isShift% AND _KEYDOWN(20736) THEN
        IF NOT layerCtrlBracketRPressed% THEN
            LAYERS_move_down CURRENT_LAYER%
            layerCtrlBracketRPressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(20736) THEN
        layerCtrlBracketRPressed% = FALSE
    END IF
    
    ' CTRL+SHIFT+[: Move layer to bottom
    IF isCtrl% AND isShift% AND _KEYDOWN(123) THEN
        IF NOT layerCtrlShiftBracketLPressed% THEN
            LAYERS_to_bottom CURRENT_LAYER%
            layerCtrlShiftBracketLPressed% = TRUE
        END IF
    ELSE
        layerCtrlShiftBracketLPressed% = FALSE
    END IF
    
    ' CTRL+SHIFT+]: Move layer to top
    IF isCtrl% AND isShift% AND _KEYDOWN(125) THEN
        IF NOT layerCtrlShiftBracketRPressed% THEN
            LAYERS_to_top CURRENT_LAYER%
            layerCtrlShiftBracketRPressed% = TRUE
        END IF
    ELSE
        layerCtrlShiftBracketRPressed% = FALSE
    END IF
    
    ' CTRL+Home: Arrange layer to top
    STATIC layerCtrlHomePressed AS INTEGER
    IF isCtrl% AND NOT isShift% AND _KEYDOWN(18176) THEN
        IF NOT layerCtrlHomePressed% THEN
            LAYERS_to_top CURRENT_LAYER%
            layerCtrlHomePressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(18176) THEN
        layerCtrlHomePressed% = FALSE
    END IF
    
    ' CTRL+End: Arrange layer to bottom
    STATIC layerCtrlEndPressed AS INTEGER
    IF isCtrl% AND NOT isShift% AND _KEYDOWN(20224) THEN
        IF NOT layerCtrlEndPressed% THEN
            LAYERS_to_bottom CURRENT_LAYER%
            layerCtrlEndPressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(20224) THEN
        layerCtrlEndPressed% = FALSE
    END IF
END SUB


''
' Handle keyboard input during reference image reposition mode.
' Returns TRUE if input was consumed (caller should EXIT SUB).
'
FUNCTION KEYBOARD_handle_refimg_reposition% ()
    IF NOT REFIMG.REPOSITION THEN
        KEYBOARD_handle_refimg_reposition% = FALSE
        EXIT FUNCTION
    END IF
    
    DIM keypress AS STRING
    keypress$ = INKEY$
    IF keypress$ <> "" THEN
        DIM kc AS INTEGER
        kc% = ASC(keypress$)
        
        SELECT CASE kc%
            CASE 27  ' ESC - cancel reposition (restore original position? no — just exit mode)
                REFIMG_reposition_finish
            CASE 13  ' ENTER - confirm reposition
                REFIMG_reposition_finish
        END SELECT
    END IF
    
    ' Arrow keys for fine positioning
    STATIC refKeyUpLast AS INTEGER, refKeyDownLast AS INTEGER
    STATIC refKeyLeftLast AS INTEGER, refKeyRightLast AS INTEGER
    DIM refStep AS INTEGER
    refStep% = 1
    IF MODIFIERS.shift% THEN refStep% = 10
    
    DIM refKeyUp AS INTEGER, refKeyDown AS INTEGER
    DIM refKeyLeft AS INTEGER, refKeyRight AS INTEGER
    refKeyUp% = _KEYDOWN(18432)
    refKeyDown% = _KEYDOWN(20480)
    refKeyLeft% = _KEYDOWN(19200)
    refKeyRight% = _KEYDOWN(19712)
    
    IF refKeyUp% AND NOT refKeyUpLast% THEN
        REFIMG.POS_Y = REFIMG.POS_Y - refStep%
        SCENE_DIRTY% = TRUE
    END IF
    IF refKeyDown% AND NOT refKeyDownLast% THEN
        REFIMG.POS_Y = REFIMG.POS_Y + refStep%
        SCENE_DIRTY% = TRUE
    END IF
    IF refKeyLeft% AND NOT refKeyLeftLast% THEN
        REFIMG.POS_X = REFIMG.POS_X - refStep%
        SCENE_DIRTY% = TRUE
    END IF
    IF refKeyRight% AND NOT refKeyRightLast% THEN
        REFIMG.POS_X = REFIMG.POS_X + refStep%
        SCENE_DIRTY% = TRUE
    END IF
    
    refKeyUpLast% = refKeyUp%
    refKeyDownLast% = refKeyDown%
    refKeyLeftLast% = refKeyLeft%
    refKeyRightLast% = refKeyRight%
    
    KEYBOARD_handle_refimg_reposition% = TRUE  ' Consumed
END FUNCTION