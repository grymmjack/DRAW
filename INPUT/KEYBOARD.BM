''
' DRAW - INPUT/KEYBOARD.BM
' =============================================================================
' Keyboard input handling subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Handles changing colors with keyboard
' @todo
' 
SUB KEYBOARD_colors (keypress AS STRING)
    SELECT CASE keypress$
        CASE "0": PAINT_COLOR~& = PAL_color(0) : PAL_FG_IDX% = 0 : GUI_NEEDS_REDRAW% = TRUE
        CASE "1": PAINT_COLOR~& = PAL_color(1) : PAL_FG_IDX% = 1 : GUI_NEEDS_REDRAW% = TRUE
        CASE "2": PAINT_COLOR~& = PAL_color(2) : PAL_FG_IDX% = 2 : GUI_NEEDS_REDRAW% = TRUE
        CASE "3": PAINT_COLOR~& = PAL_color(3) : PAL_FG_IDX% = 3 : GUI_NEEDS_REDRAW% = TRUE
        CASE "4": PAINT_COLOR~& = PAL_color(4) : PAL_FG_IDX% = 4 : GUI_NEEDS_REDRAW% = TRUE
        CASE "5": PAINT_COLOR~& = PAL_color(5) : PAL_FG_IDX% = 5 : GUI_NEEDS_REDRAW% = TRUE
        CASE "6": PAINT_COLOR~& = PAL_color(6) : PAL_FG_IDX% = 6 : GUI_NEEDS_REDRAW% = TRUE
        CASE "7": PAINT_COLOR~& = PAL_color(7) : PAL_FG_IDX% = 7 : GUI_NEEDS_REDRAW% = TRUE
        CASE ")": PAINT_COLOR~& = PAL_color(8) : PAL_FG_IDX% = 8 : GUI_NEEDS_REDRAW% = TRUE
        CASE "8": PAINT_COLOR~& = PAL_color(8) : PAL_FG_IDX% = 8 : GUI_NEEDS_REDRAW% = TRUE
        CASE "!": PAINT_COLOR~& = PAL_color(9) : PAL_FG_IDX% = 9 : GUI_NEEDS_REDRAW% = TRUE
        CASE "9": PAINT_COLOR~& = PAL_color(9) : PAL_FG_IDX% = 9 : GUI_NEEDS_REDRAW% = TRUE
        CASE "@": PAINT_COLOR~& = PAL_color(10) : PAL_FG_IDX% = 10 : GUI_NEEDS_REDRAW% = TRUE
        CASE "#": PAINT_COLOR~& = PAL_color(11) : PAL_FG_IDX% = 11 : GUI_NEEDS_REDRAW% = TRUE
        CASE "$": PAINT_COLOR~& = PAL_color(12) : PAL_FG_IDX% = 12 : GUI_NEEDS_REDRAW% = TRUE
        CASE "%": PAINT_COLOR~& = PAL_color(13) : PAL_FG_IDX% = 13 : GUI_NEEDS_REDRAW% = TRUE
        CASE CHR$(94): PAINT_COLOR~& = PAL_color(14) : PAL_FG_IDX% = 14 : GUI_NEEDS_REDRAW% = TRUE  ' ^ = SHIFT+6
        CASE CHR$(38): PAINT_COLOR~& = PAL_color(15) : PAL_FG_IDX% = 15 : GUI_NEEDS_REDRAW% = TRUE  ' & = SHIFT+7
        CASE "x", "X"  ' Swap foreground and background colors
            DIM temp_color AS _UNSIGNED LONG
            DIM temp_idx AS INTEGER
            temp_color~& = PAINT_COLOR~&
            temp_idx% = PAL_FG_IDX%
            PAINT_COLOR~& = PAINT_BG_COLOR~&
            PAL_FG_IDX% = PAL_BG_IDX%
            PAINT_BG_COLOR~& = temp_color~&
            PAL_BG_IDX% = temp_idx%
            GUI_NEEDS_REDRAW% = TRUE
        EVERYCASE:
            KEY_COLOR%   = TRUE 
            WHEEL_COLOR% = FALSE
    END SELECT
END SUB


''
' Handles tool selection with keyboard
'
SUB KEYBOARD_tools (keypress AS STRING)
    ' Handle MOVE tool specific keys first (H/V for flip)
    IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
        SELECT CASE keypress$
            CASE "h", "H"
                MOVE_flip_horizontal
                EXIT SUB  ' Don't process as tool switch
            CASE "v", "V"
                MOVE_flip_vertical
                EXIT SUB  ' Don't process as tool switch
        END SELECT
    END IF
    
    SELECT CASE keypress$
        CASE "b", "B"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_BRUSH
            FILL_deactivate
            PICKER_deactivate
            MARQUEE_reset    ' Reset marquee when switching tools
            POLY_LINE_reset  ' Reset poly line when switching tools
            LINE_reset       ' Reset line tool when switching tools
            RECT_reset       ' Reset rect tool when switching tools
            ELLIPSE_reset    ' Reset ellipse tool when switching tools
            MOVE_reset       ' Reset move tool when switching tools
            GUI_NEEDS_REDRAW% = TRUE
        CASE "f", "F"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_FILL
            FILL_activate
            PICKER_deactivate
            MARQUEE_reset    ' Reset marquee when switching tools
            POLY_LINE_reset  ' Reset poly line when switching tools
            LINE_reset       ' Reset line tool when switching tools
            RECT_reset       ' Reset rect tool when switching tools
            ELLIPSE_reset    ' Reset ellipse tool when switching tools
            MOVE_reset       ' Reset move tool when switching tools
            GUI_NEEDS_REDRAW% = TRUE
        CASE "d", "D"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_DOT
            FILL_deactivate
            PICKER_deactivate
            MARQUEE_reset    ' Reset marquee when switching tools
            POLY_LINE_reset  ' Reset poly line when switching tools
            LINE_reset       ' Reset line tool when switching tools
            RECT_reset       ' Reset rect tool when switching tools
            ELLIPSE_reset    ' Reset ellipse tool when switching tools
            MOVE_reset       ' Reset move tool when switching tools
            GUI_NEEDS_REDRAW% = TRUE
        CASE "l", "L"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_LINE
            FILL_deactivate
            PICKER_deactivate
            MARQUEE_reset    ' Reset marquee when switching tools
            POLY_LINE_reset  ' Reset poly line when switching tools
            RECT_reset       ' Reset rect tool when switching tools
            ELLIPSE_reset    ' Reset ellipse tool when switching tools
            MOVE_reset       ' Reset move tool when switching tools
            GUI_NEEDS_REDRAW% = TRUE
        CASE "p", "P"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            ' SHIFT+P = filled polygon, P = outline polygon
            IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                CURRENT_TOOL% = TOOL_POLYGON_FILLED
            ELSE
                CURRENT_TOOL% = TOOL_POLYGON
            END IF
            FILL_deactivate
            PICKER_deactivate
            MARQUEE_reset    ' Reset marquee when switching tools
            LINE_reset       ' Reset line tool when switching tools
            RECT_reset       ' Reset rect tool when switching tools
            ELLIPSE_reset    ' Reset ellipse tool when switching tools
            MOVE_reset       ' Reset move tool when switching tools
            ' Set filled flag for polygon
            POLY_LINE.FILLED = (CURRENT_TOOL% = TOOL_POLYGON_FILLED)
            GUI_NEEDS_REDRAW% = TRUE
        CASE "r", "R"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            ' SHIFT+R = filled rectangle, R = outline rectangle
            IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                CURRENT_TOOL% = TOOL_RECT_FILLED
            ELSE
                CURRENT_TOOL% = TOOL_RECT
            END IF
            FILL_deactivate
            PICKER_deactivate
            MARQUEE_reset    ' Reset marquee when switching tools
            POLY_LINE_reset  ' Reset poly line when switching tools
            LINE_reset       ' Reset line tool when switching tools
            ELLIPSE_reset    ' Reset ellipse tool when switching tools
            MOVE_reset       ' Reset move tool when switching tools
            GUI_NEEDS_REDRAW% = TRUE
        CASE "e", "E"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            ' SHIFT+E = filled ellipse, E = outline ellipse
            IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                CURRENT_TOOL% = TOOL_ELLIPSE_FILLED
            ELSE
                CURRENT_TOOL% = TOOL_ELLIPSE
            END IF
            FILL_deactivate
            PICKER_deactivate
            MARQUEE_reset    ' Reset marquee when switching tools
            POLY_LINE_reset  ' Reset poly line when switching tools
            LINE_reset       ' Reset line tool when switching tools
            RECT_reset       ' Reset rect tool when switching tools
            MOVE_reset       ' Reset move tool when switching tools
            GUI_NEEDS_REDRAW% = TRUE
        CASE "m", "M"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_MARQUEE
            FILL_deactivate
            PICKER_deactivate
            POLY_LINE_reset  ' Reset poly line when switching tools
            LINE_reset       ' Reset line tool when switching tools
            RECT_reset       ' Reset rect tool when switching tools
            ELLIPSE_reset    ' Reset ellipse tool when switching tools
            MOVE_reset       ' Reset move tool when switching tools
            GUI_NEEDS_REDRAW% = TRUE
        CASE "v", "V"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_MOVE
            FILL_deactivate
            PICKER_deactivate
            POLY_LINE_reset  ' Reset poly line when switching tools
            LINE_reset       ' Reset line tool when switching tools
            RECT_reset       ' Reset rect tool when switching tools
            ELLIPSE_reset    ' Reset ellipse tool when switching tools
            ' Capture selection if marquee is active
            IF MARQUEE.ACTIVE AND MARQUEE.INITIALIZED THEN
                MOVE_capture_selection
            END IF
            GUI_NEEDS_REDRAW% = TRUE
        CASE "i", "I"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_PICKER
            FILL_deactivate
            PICKER_activate
            MARQUEE_reset    ' Reset marquee when switching tools
            POLY_LINE_reset  ' Reset poly line when switching tools
            LINE_reset       ' Reset line tool when switching tools
            RECT_reset       ' Reset rect tool when switching tools
            ELLIPSE_reset    ' Reset ellipse tool when switching tools
            MOVE_reset       ' Reset move tool when switching tools
            GUI_NEEDS_REDRAW% = TRUE
        CASE "t", "T"
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_TEXT
            FILL_deactivate
            PICKER_deactivate
            MARQUEE_reset    ' Reset marquee when switching tools
            POLY_LINE_reset  ' Reset poly line when switching tools
            LINE_reset       ' Reset line tool when switching tools
            RECT_reset       ' Reset rect tool when switching tools
            ELLIPSE_reset    ' Reset ellipse tool when switching tools
            MOVE_reset       ' Reset move tool when switching tools
            ' SHIFT+T = Tiny5 font, T = VGA default font (CTRL+T handled separately)
            IF _KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&) THEN
                TEXT.USE_CUSTOM = FALSE
                TEXT.USE_TINY5 = TRUE
                TEXT.CHAR_WIDTH = 5
                TEXT.LINE_HEIGHT = 6  ' 5px font + 1px gap
            ELSE
                TEXT.USE_CUSTOM = FALSE
                TEXT.USE_TINY5 = FALSE
                TEXT.CHAR_WIDTH = 8
                TEXT.LINE_HEIGHT = 13  ' 8px font + larger gap for readability
            END IF
            TEXT_reset       ' Reset text tool when switching to it
            GUI_NEEDS_REDRAW% = TRUE
        CASE CHR$(27)  ' ESC key - reset poly line tool, cancel move, or apply text
            IF CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED THEN
                POLY_LINE_reset
            ELSEIF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
                MOVE_cancel_transform
                ' Return to marquee tool after canceling
                MOVE_reset
                CURRENT_TOOL% = TOOL_MARQUEE
                GUI_NEEDS_REDRAW% = TRUE
            ELSEIF CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE THEN
                TEXT_apply
            END IF
        CASE CHR$(13)  ' ENTER key - finish poly line (keeps tool active), apply move transform, or newline in text
            IF CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE THEN
                TEXT_newline
            ELSEIF CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED THEN
                POLY_LINE_reset
                CURRENT_TOOL% = TOOL_NULL
                GUI_NEEDS_REDRAW% = TRUE
            ELSEIF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
                MOVE_apply_transform
                ' After applying, clear move state and return to marquee tool
                MOVE_reset
                CURRENT_TOOL% = TOOL_MARQUEE
                ' Clear marquee selection
                MARQUEE.ACTIVE = FALSE
                MARQUEE.INITIALIZED = FALSE
                GUI_NEEDS_REDRAW% = TRUE
            END IF
        CASE CHR$(26), CHR$(90), CHR$(122) ' Ctrl+Z - handled in loop handler with single-press
            ' Do nothing here - handled in KEYBOARD_input_handler_loop
        CASE CHR$(25), CHR$(89), CHR$(121) ' Ctrl+Y - handled in loop handler with single-press
            ' Do nothing here - handled in KEYBOARD_input_handler_loop
    END SELECT
END SUB


''
' Handles brush size changes with keyboard
'
SUB KEYBOARD_brush_size (keypress AS STRING)
    SELECT CASE keypress$
        CASE "[", "{"
            BRUSH_SIZE_decrease
        CASE "]", "}"
            BRUSH_SIZE_increase
        CASE CHR$(0) + CHR$(59)  ' F1
            BRUSH_SIZE_set_preset 1
        CASE CHR$(0) + CHR$(60)  ' F2
            BRUSH_SIZE_set_preset 2
        CASE CHR$(0) + CHR$(61)  ' F3
            BRUSH_SIZE_set_preset 3
        CASE CHR$(0) + CHR$(62)  ' F4
            BRUSH_SIZE_set_preset 4
    END SELECT
END SUB


''
' Handles assistant toggles with keyboard
'
SUB KEYBOARD_assistants (keypress AS STRING)
    ' Don't trigger assistants when in text edit mode
    IF CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE THEN EXIT SUB
    
    SELECT CASE keypress$
        CASE "~", "`"
            BRUSH_SIZE_toggle_preview
        CASE "|", "\"
            BRUSH_SIZE_toggle_shape
        CASE CHR$(0) + CHR$(64)  ' F6
            BRUSH_SIZE_toggle_pixel_perfect
            GUI_NEEDS_REDRAW% = TRUE  ' Update PP indicator in status bar
        CASE CHR$(0) + CHR$(65)  ' F7 - Cycle symmetry mode
            SYMMETRY_cycle_mode
        CASE CHR$(0) + CHR$(66)  ' F8 - Clear symmetry
            SYMMETRY_clear
    END SELECT
END SUB


''
' Handle keyboard input
' 
SUB KEYBOARD_input_handler ()
    DIM keypress AS STRING
    
    ' Layer keyboard handling - MUST run first before any EXIT SUB statements
    ' Uses _KEYDOWN() so runs every frame regardless of INKEY$ state
    KEYBOARD_layers
    
    ' Handle IMAGE IMPORT mode - intercept Enter/Escape and arrow keys
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        keypress$ = INKEY$
        IF keypress$ <> "" THEN
            DIM import_key_code AS INTEGER
            import_key_code% = ASC(keypress$)
            
            SELECT CASE import_key_code%
                CASE 27  ' ESC - cancel import
                    IMAGE_IMPORT_cancel
                CASE 13  ' ENTER - apply import
                    IF IMG_IMPORT.STATE = IMPORT_STATE_LOADED THEN
                        ' If no marquee drawn yet, use full canvas
                        IMG_IMPORT.DEST_X = 0
                        IMG_IMPORT.DEST_Y = 0
                        IMG_IMPORT.DEST_W = SCRN.w&
                        IMG_IMPORT.DEST_H = SCRN.h&
                        IMAGE_IMPORT_update_crop_from_zoom
                        IMG_IMPORT.STATE = IMPORT_STATE_PLACING
                    END IF
                    IMAGE_IMPORT_apply
            END SELECT
        END IF
        
        ' Arrow key handling for import mode (works in PLACING state)
        IF IMG_IMPORT.STATE >= IMPORT_STATE_PLACING THEN
            DIM impIsCtrl AS INTEGER, impIsShift AS INTEGER, impIsAlt AS INTEGER
            DIM impMoveStep AS INTEGER
            
            impIsCtrl% = (_KEYDOWN(100305) OR _KEYDOWN(100306)) ' Left or Right Ctrl
            impIsShift% = (_KEYDOWN(100304) OR _KEYDOWN(100303)) ' Left or Right Shift
            impIsAlt% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
            impMoveStep% = 1
            IF impIsShift% THEN impMoveStep% = CFG.NUDGE_N%
            
            ' Single-press detection for arrow keys
            STATIC impKeyUpLast AS INTEGER, impKeyDownLast AS INTEGER
            STATIC impKeyLeftLast AS INTEGER, impKeyRightLast AS INTEGER
            DIM impKeyUpNow AS INTEGER, impKeyDownNow AS INTEGER
            DIM impKeyLeftNow AS INTEGER, impKeyRightNow AS INTEGER
            
            impKeyUpNow% = _KEYDOWN(18432)    ' Up arrow
            impKeyDownNow% = _KEYDOWN(20480)  ' Down arrow
            impKeyLeftNow% = _KEYDOWN(19200)  ' Left arrow
            impKeyRightNow% = _KEYDOWN(19712) ' Right arrow
            
            ' Arrow keys: Ctrl=resize, Alt=pan within image, plain=move box
            IF impKeyUpNow% AND NOT impKeyUpLast% THEN
                IF impIsCtrl% THEN
                    IMAGE_IMPORT_resize_by 0, -impMoveStep%
                ELSEIF impIsAlt% THEN
                    IMAGE_IMPORT_pan_by 0, -impMoveStep%
                ELSE
                    IMAGE_IMPORT_nudge 0, -impMoveStep%
                END IF
            END IF
            IF impKeyDownNow% AND NOT impKeyDownLast% THEN
                IF impIsCtrl% THEN
                    IMAGE_IMPORT_resize_by 0, impMoveStep%
                ELSEIF impIsAlt% THEN
                    IMAGE_IMPORT_pan_by 0, impMoveStep%
                ELSE
                    IMAGE_IMPORT_nudge 0, impMoveStep%
                END IF
            END IF
            IF impKeyLeftNow% AND NOT impKeyLeftLast% THEN
                IF impIsCtrl% THEN
                    IMAGE_IMPORT_resize_by -impMoveStep%, 0
                ELSEIF impIsAlt% THEN
                    IMAGE_IMPORT_pan_by -impMoveStep%, 0
                ELSE
                    IMAGE_IMPORT_nudge -impMoveStep%, 0
                END IF
            END IF
            IF impKeyRightNow% AND NOT impKeyRightLast% THEN
                IF impIsCtrl% THEN
                    IMAGE_IMPORT_resize_by impMoveStep%, 0
                ELSEIF impIsAlt% THEN
                    IMAGE_IMPORT_pan_by impMoveStep%, 0
                ELSE
                    IMAGE_IMPORT_nudge impMoveStep%, 0
                END IF
            END IF
            
            ' Update last key states
            impKeyUpLast% = impKeyUpNow%
            impKeyDownLast% = impKeyDownNow%
            impKeyLeftLast% = impKeyLeftNow%
            impKeyRightLast% = impKeyRightNow%
        END IF
        
        EXIT SUB  ' Don't process other keyboard handlers during import
    END IF
    
    ' Handle ESC to close palette menu if visible
    IF PALETTE_MENU_VISIBLE% THEN
        IF _KEYDOWN(27) THEN  ' ESC key
            PALETTE_MENU_hide
            EXIT SUB  ' Don't process other ESC handlers
        END IF
        
        ' Handle arrow key navigation
        STATIC menuArrowUp AS INTEGER, menuArrowDown AS INTEGER
        DIM menuArrowUpNow AS INTEGER, menuArrowDownNow AS INTEGER
        menuArrowUpNow% = _KEYDOWN(18432)  ' Up arrow
        menuArrowDownNow% = _KEYDOWN(20480)  ' Down arrow
        
        IF menuArrowUpNow% AND NOT menuArrowUp% THEN
            PALETTE_MENU_navigate_up
        END IF
        IF menuArrowDownNow% AND NOT menuArrowDown% THEN
            PALETTE_MENU_navigate_down
        END IF
        menuArrowUp% = menuArrowUpNow%
        menuArrowDown% = menuArrowDownNow%
        
        ' Handle Enter to select current hover
        STATIC menuEnterPressed AS INTEGER
        DIM menuEnterNow AS INTEGER
        menuEnterNow% = _KEYDOWN(13)
        IF menuEnterNow% AND NOT menuEnterPressed% THEN
            IF PALETTE_MENU_HOVER% >= 0 AND PALETTE_MENU_HOVER% < PALETTE_LOADER_COUNT% THEN
                DIM dummy AS INTEGER
                dummy% = PALETTE_LOADER_load_by_index%(PALETTE_MENU_HOVER%)
                PAL_set_defaults_by_size
                PALETTE_STRIP_SCROLL_OFFSET% = 0
                PALETTE_MENU_hide
                menuEnterPressed% = menuEnterNow%
                EXIT SUB
            END IF
        END IF
        menuEnterPressed% = menuEnterNow%
        
        ' Handle alphabetical navigation (a-z)
        DIM menu_key AS STRING
        menu_key$ = INKEY$
        IF LEN(menu_key$) = 1 THEN
            DIM menu_key_code AS INTEGER
            menu_key_code% = ASC(menu_key$)
            ' Check if it's a letter (a-z or A-Z)
            IF (menu_key_code% >= 65 AND menu_key_code% <= 90) OR (menu_key_code% >= 97 AND menu_key_code% <= 122) THEN
                PALETTE_MENU_jump_to_char menu_key$
                EXIT SUB
            END IF
        END IF
    END IF
    
    ' NOTE: Display scale hotkeys (CTRL+ALT+SHIFT+=/-) are handled in DRAW.BAS main loop
    ' using _KEYHIT which is more reliable on Linux for complex modifier combinations
    
    ' Handle custom brush controls (Ctrl+B, H, V)
    ' Check for Ctrl+B to capture/clear custom brush
    DIM is_ctrl_pressed AS INTEGER
    is_ctrl_pressed% = (_KEYDOWN(100305) OR _KEYDOWN(100306)) ' Left or Right Ctrl
    
    STATIC ctrlBPressed AS INTEGER
    IF is_ctrl_pressed% AND _KEYDOWN(98) THEN ' Ctrl+B (98 = 'b' key)
        IF NOT ctrlBPressed% THEN
            IF CUSTOM_BRUSH_is_active% THEN
                ' Clear existing custom brush
                CUSTOM_BRUSH_reset
            ELSEIF MARQUEE.ACTIVE% THEN
                ' Capture marquee as custom brush
                CUSTOM_BRUSH_capture_from_marquee
            END IF
            ctrlBPressed% = TRUE
        END IF
    ELSE
        ctrlBPressed% = FALSE
    END IF
    
    ' Handle HOME key for horizontal flip (when custom brush is active)
    STATIC homePressed AS INTEGER
    IF CUSTOM_BRUSH_is_active% AND _KEYDOWN(18176) THEN ' HOME key
        IF NOT homePressed% THEN
            CUSTOM_BRUSH_toggle_flip_h
            homePressed% = TRUE
        END IF
    ELSE
        homePressed% = FALSE
    END IF
    
    ' Handle END key for vertical flip (when custom brush is active)
    STATIC endPressed AS INTEGER
    IF CUSTOM_BRUSH_is_active% AND _KEYDOWN(20224) THEN ' END key
        IF NOT endPressed% THEN
            CUSTOM_BRUSH_toggle_flip_v
            endPressed% = TRUE
        END IF
    ELSE
        endPressed% = FALSE
    END IF
    
    ' Handle Page Up key for scaling brush up (when custom brush is active)
    STATIC pgUpPressed AS INTEGER
    IF CUSTOM_BRUSH_is_active% AND _KEYDOWN(18688) THEN ' Page Up key
        IF NOT pgUpPressed% THEN
            CUSTOM_BRUSH_scale_up
            pgUpPressed% = TRUE
        END IF
    ELSE
        pgUpPressed% = FALSE
    END IF
    
    ' Handle Page Down key for scaling brush down (when custom brush is active)
    STATIC pgDnPressed AS INTEGER
    IF CUSTOM_BRUSH_is_active% AND _KEYDOWN(20736) THEN ' Page Down key
        IF NOT pgDnPressed% THEN
            CUSTOM_BRUSH_scale_down
            pgDnPressed% = TRUE
        END IF
    ELSE
        pgDnPressed% = FALSE
    END IF
    
    ' Handle / key for resetting brush scale (when custom brush is active)
    STATIC slashPressed AS INTEGER
    IF CUSTOM_BRUSH_is_active% AND _KEYDOWN(47) THEN ' / key
        IF NOT slashPressed% THEN
            CUSTOM_BRUSH_scale_reset
            slashPressed% = TRUE
        END IF
    ELSE
        slashPressed% = FALSE
    END IF
    
    ' Handle F9 for toggling recolor mode (when custom brush is active)
    STATIC f9Pressed AS INTEGER
    IF _KEYDOWN(17152) THEN ' F9 = 256 * 67
        IF NOT f9Pressed% THEN
            _LOGINFO "F9 pressed - CUSTOM_BRUSH_is_active% = " + STR$(CUSTOM_BRUSH_is_active%)
            IF CUSTOM_BRUSH_is_active% THEN
                CUSTOM_BRUSH_toggle_recolor
            ELSE
                _LOGINFO "F9 ignored - custom brush not active"
            END IF
            f9Pressed% = TRUE
        END IF
    ELSE
        f9Pressed% = FALSE
    END IF
    
    ' Handle ` (backtick) for toggling custom brush outline visibility
    STATIC backtickPressed AS INTEGER
    IF CUSTOM_BRUSH_is_active% AND _KEYDOWN(96) THEN ' ` key (backtick)
        IF NOT backtickPressed% THEN
            CUSTOM_BRUSH_toggle_outline
            backtickPressed% = TRUE
        END IF
    ELSE
        backtickPressed% = FALSE
    END IF
    
    ' Handle Shift+O for applying outline to custom brush with BG color
    STATIC shiftOPressed AS INTEGER
    DIM isShiftPressed AS INTEGER
    isShiftPressed% = (_KEYDOWN(100304) OR _KEYDOWN(100303)) ' Left or Right Shift
    IF CUSTOM_BRUSH_is_active% AND isShiftPressed% AND _KEYDOWN(79) THEN ' Shift + O (79 = 'o')
        IF NOT shiftOPressed% THEN
            CUSTOM_BRUSH_apply_outline
            shiftOPressed% = TRUE
        END IF
    ELSE
        shiftOPressed% = FALSE
    END IF
    
    ' Handle F12 for exporting custom brush (when custom brush is active)
    STATIC f12Pressed AS INTEGER
    IF _KEYDOWN(34304) THEN ' F12
        IF NOT f12Pressed% THEN
            _LOGINFO "F12 key detected"
            IF CUSTOM_BRUSH_is_active% THEN
                _LOGINFO "Custom brush is active, proceeding with export"
                ' Generate filename with timestamp
                DIM export_filename AS STRING
                export_filename$ = "brush_" + _TRIM$(STR$(TIMER)) + ".png"
                CUSTOM_BRUSH_export_png export_filename$
            ELSE
                _LOGERROR "F12 pressed but custom brush is not active (create brush with Ctrl+B first)"
            END IF
            f12Pressed% = TRUE
        END IF
    ELSE
        f12Pressed% = FALSE
    END IF
    
    ' If text tool is active and editing, block ALL keyboard processing except text input
    IF CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE THEN
        keypress$ = INKEY$
        IF keypress$ <> "" THEN
            DIM char_code AS INTEGER
            char_code = ASC(keypress$)
            
            SELECT CASE char_code
                CASE 27  ' ESC - apply text
                    TEXT_apply
                CASE 13  ' ENTER - newline
                    TEXT_newline
                CASE 8   ' BACKSPACE
                    TEXT_backspace
                CASE 32 TO 126  ' Printable ASCII characters
                    TEXT_add_char keypress$
                ' Ignore other special keys while text editing
            END SELECT
        END IF
        EXIT SUB  ' Don't process ANY other keyboard handlers
    END IF
    
    ' Normal keyboard processing when not in text mode
    keypress$ = INKEY$
    IF keypress$ <> "" THEN
        KEYBOARD_colors keypress$
        KEYBOARD_tools keypress$
        KEYBOARD_brush_size keypress$
        KEYBOARD_assistants keypress$
    END IF
    
    ' Note: KEYBOARD_layers is called at the TOP of this sub before any EXIT SUB statements
    
    ' Handle NumPad dither pattern selection (NumLock ON: INKEY$ returns "1"-"9")
    ' Regular number keys 1-9 already handled by KEYBOARD_colors above
    ' NumPad with NumLock ON returns same "1"-"9" as regular keys, so this works automatically!
    ' Pattern 0 = Solid (already active), 1-9 = dither patterns
    IF keypress$ >= "1" AND keypress$ <= "9" THEN
        ' Check if this is for dither pattern (not just color selection)
        ' We'll make NumPad+Shift = select dither pattern (since Shift+NumPad returns ASCII 0)
        ' But regular 1-9 already handled by color - need alternative approach
    END IF
    
    ' Handle NumPad dither patterns with _KEYDOWN (NumLock OFF mode)
    ' These use extended codes and won't interfere with color selection
    IF _KEYDOWN(KP_1) AND NOT NUMPAD_KEY_1_LAST THEN
        BRUSH_DITHERS_set 1
        NUMPAD_KEY_1_LAST = TRUE
    ELSEIF NOT _KEYDOWN(KP_1) THEN
        NUMPAD_KEY_1_LAST = FALSE
    END IF
    
    IF _KEYDOWN(KP_2) AND NOT NUMPAD_KEY_2_LAST THEN
        BRUSH_DITHERS_set 2
        NUMPAD_KEY_2_LAST = TRUE
    ELSEIF NOT _KEYDOWN(KP_2) THEN
        NUMPAD_KEY_2_LAST = FALSE
    END IF
    
    IF _KEYDOWN(KP_3) AND NOT NUMPAD_KEY_3_LAST THEN
        BRUSH_DITHERS_set 3
        NUMPAD_KEY_3_LAST = TRUE
    ELSEIF NOT _KEYDOWN(KP_3) THEN
        NUMPAD_KEY_3_LAST = FALSE
    END IF
    
    IF _KEYDOWN(KP_4) AND NOT NUMPAD_KEY_4_LAST THEN
        BRUSH_DITHERS_set 4
        NUMPAD_KEY_4_LAST = TRUE
    ELSEIF NOT _KEYDOWN(KP_4) THEN
        NUMPAD_KEY_4_LAST = FALSE
    END IF
    
    IF _KEYDOWN(KP_5) AND NOT NUMPAD_KEY_5_LAST THEN
        BRUSH_DITHERS_set 5
        NUMPAD_KEY_5_LAST = TRUE
    ELSEIF NOT _KEYDOWN(KP_5) THEN
        NUMPAD_KEY_5_LAST = FALSE
    END IF
    
    IF _KEYDOWN(KP_6) AND NOT NUMPAD_KEY_6_LAST THEN
        BRUSH_DITHERS_set 6
        NUMPAD_KEY_6_LAST = TRUE
    ELSEIF NOT _KEYDOWN(KP_6) THEN
        NUMPAD_KEY_6_LAST = FALSE
    END IF
    
    IF _KEYDOWN(KP_7) AND NOT NUMPAD_KEY_7_LAST THEN
        BRUSH_DITHERS_set 7
        NUMPAD_KEY_7_LAST = TRUE
    ELSEIF NOT _KEYDOWN(KP_7) THEN
        NUMPAD_KEY_7_LAST = FALSE
    END IF
    
    IF _KEYDOWN(KP_8) AND NOT NUMPAD_KEY_8_LAST THEN
        BRUSH_DITHERS_set 8
        NUMPAD_KEY_8_LAST = TRUE
    ELSEIF NOT _KEYDOWN(KP_8) THEN
        NUMPAD_KEY_8_LAST = FALSE
    END IF
    
    IF _KEYDOWN(KP_9) AND NOT NUMPAD_KEY_9_LAST THEN
        BRUSH_DITHERS_set 9
        NUMPAD_KEY_9_LAST = TRUE
    ELSEIF NOT _KEYDOWN(KP_9) THEN
        NUMPAD_KEY_9_LAST = FALSE
    END IF
    
    IF _KEYDOWN(KP_0) AND NOT NUMPAD_KEY_0_LAST THEN
        BRUSH_DITHERS_set 0  ' Reset to solid
        NUMPAD_KEY_0_LAST = TRUE
    ELSEIF NOT _KEYDOWN(KP_0) THEN
        NUMPAD_KEY_0_LAST = FALSE
    END IF
    
    ' Static variables to prevent key repeat
    STATIC tabPressed AS INTEGER, f10Pressed AS INTEGER, f11Pressed AS INTEGER
    DIM tabCtrlHeld AS INTEGER
    tabCtrlHeld% = (_KEYDOWN(100305) OR _KEYDOWN(100306))  ' Left or Right Ctrl
    
    ' Handle TAB for toolbar toggle (but not when CTRL is held - that's for layer panel)
    IF _KEYDOWN(9) AND NOT tabCtrlHeld% THEN ' TAB key code is 9
        IF NOT tabPressed% THEN
            SCRN.showToolbar% = NOT SCRN.showToolbar%
            ' Mark as manually hidden/shown
            SCRN.toolbarManuallyHidden% = NOT SCRN.showToolbar%
            GUI_NEEDS_REDRAW% = TRUE
            tabPressed% = TRUE
        END IF
    ELSE
        tabPressed% = FALSE
    END IF
    
    ' Handle F10 for status bar toggle (using _KEYDOWN with correct code)
    IF _KEYDOWN(17408) THEN ' F10 = 17408
        IF NOT f10Pressed% THEN
            SCRN.showStatus% = NOT SCRN.showStatus%
            ' Mark as manually hidden/shown
            SCRN.statusManuallyHidden% = NOT SCRN.showStatus%
            GUI_NEEDS_REDRAW% = TRUE
            f10Pressed% = TRUE
        END IF
    ELSE
        f10Pressed% = FALSE
    END IF
    
    ' Handle F11 for both toolbar and status toggle (and layer panel)
    IF _KEYDOWN(34048) THEN ' F11
        IF NOT f11Pressed% THEN
            ' If any is visible, hide all. If all are hidden, show all.
            IF SCRN.showToolbar% OR SCRN.showStatus% OR LAYER_PANEL.visible% THEN
                SCRN.showToolbar% = FALSE
                SCRN.showStatus% = FALSE
                LAYER_PANEL.visible% = FALSE
                ' Mark both as manually hidden
                SCRN.toolbarManuallyHidden% = TRUE
                SCRN.statusManuallyHidden% = TRUE
            ELSE
                SCRN.showToolbar% = TRUE
                SCRN.showStatus% = TRUE
                LAYER_PANEL.visible% = TRUE
                ' Mark both as manually shown
                SCRN.toolbarManuallyHidden% = FALSE
                SCRN.statusManuallyHidden% = FALSE
            END IF
            GUI_NEEDS_REDRAW% = TRUE
            f11Pressed% = TRUE
        END IF
    ELSE
        f11Pressed% = FALSE
    END IF
    
    ' Handle DELETE key for canvas clear with prompt
    STATIC deletePressed AS INTEGER
    IF _KEYDOWN(KEY_DELETE&) THEN
        IF NOT deletePressed% THEN
            ' Don't clear canvas if text tool is active
            IF NOT (CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE) THEN
                PAINT_clear_with_prompt
            END IF
            deletePressed% = TRUE
        END IF
    ELSE
        deletePressed% = FALSE
    END IF
    
    ' Handle BACKSPACE key for canvas clear without prompt
    STATIC backspacePressed AS INTEGER
    IF _KEYDOWN(KEY_BACKSPACE&) THEN
        IF NOT backspacePressed% THEN
            ' Don't clear canvas if text tool is active (BACKSPACE is for text editing)
            IF NOT (CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE) THEN
                PAINT_clear_no_prompt
            END IF
            backspacePressed% = TRUE
        END IF
    ELSE
        backspacePressed% = FALSE
    END IF
    
    ' Handle apostrophe (') key for grid toggle, SHIFT+' (") for pixel grid toggle
    STATIC gridTogglePressed AS INTEGER
    STATIC pixelGridTogglePressed AS INTEGER
    DIM gridShiftHeld AS INTEGER
    gridShiftHeld% = (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&))
    IF _KEYDOWN(39) THEN ' 39 = apostrophe key
        IF gridShiftHeld% THEN
            ' SHIFT+' = pixel grid toggle
            IF NOT pixelGridTogglePressed% THEN
                PIXEL_GRID.SHOW% = NOT PIXEL_GRID.SHOW%
                pixelGridTogglePressed% = TRUE
            END IF
        ELSE
            ' Just ' = regular grid toggle
            IF NOT gridTogglePressed% THEN
                GRID.SHOW% = NOT GRID.SHOW%
                gridTogglePressed% = TRUE
            END IF
        END IF
    ELSE
        gridTogglePressed% = FALSE
        pixelGridTogglePressed% = FALSE
    END IF
    
    ' Handle semicolon (;) key for snap-to-grid toggle
    STATIC snapTogglePressed AS INTEGER
    IF _KEYDOWN(59) THEN ' 59 = semicolon key
        IF NOT snapTogglePressed% THEN
            GRID.SNAP% = NOT GRID.SNAP%
            snapTogglePressed% = TRUE
        END IF
    ELSE
        snapTogglePressed% = FALSE
    END IF
    
    ' Handle period (.) key to increase grid size
    STATIC periodPressed AS INTEGER
    IF _KEYDOWN(46) THEN ' 46 = period key
        IF NOT periodPressed% THEN
            IF GRID.gridWidth% < 50 THEN
                GRID.gridWidth% = GRID.gridWidth% + 1
                GRID.gridHeight% = GRID.gridHeight% + 1
                GRID_draw
            END IF
            periodPressed% = TRUE
        END IF
    ELSE
        periodPressed% = FALSE
    END IF
    
    ' Handle comma (,) key to decrease grid size
    STATIC commaPressed AS INTEGER
    IF _KEYDOWN(44) THEN ' 44 = comma key
        IF NOT commaPressed% THEN
            IF GRID.gridWidth% > 2 THEN
                GRID.gridWidth% = GRID.gridWidth% - 1
                GRID.gridHeight% = GRID.gridHeight% - 1
                GRID_draw
            END IF
            commaPressed% = TRUE
        END IF
    ELSE
        commaPressed% = FALSE
    END IF
    
    ' Marquee tool keyboard controls
    IF CURRENT_TOOL% = TOOL_MARQUEE AND MARQUEE.ACTIVE% THEN
        DIM isCtrl AS INTEGER, isShift AS INTEGER, moveStep AS INTEGER
        isCtrl% = (_KEYDOWN(100305) OR _KEYDOWN(100306)) ' Left or Right Ctrl
        isShift% = (_KEYDOWN(100304) OR _KEYDOWN(100303)) ' Left or Right Shift
        moveStep% = 1
        IF isShift% THEN moveStep% = 10
        
        ' Arrow keys move or resize the marquee
        IF _KEYDOWN(18432) THEN ' Up arrow
            IF isCtrl% THEN
                MARQUEE.BOX.h = MARQUEE.BOX.h - moveStep%
                IF MARQUEE.BOX.h < 8 THEN MARQUEE.BOX.h = 8
            ELSE
                MARQUEE.BOX.y = MARQUEE.BOX.y - moveStep%
            END IF
        END IF
        IF _KEYDOWN(20480) THEN ' Down arrow
            IF isCtrl% THEN
                MARQUEE.BOX.h = MARQUEE.BOX.h + moveStep%
            ELSE
                MARQUEE.BOX.y = MARQUEE.BOX.y + moveStep%
            END IF
        END IF
        IF _KEYDOWN(19200) THEN ' Left arrow
            IF isCtrl% THEN
                MARQUEE.BOX.w = MARQUEE.BOX.w - moveStep%
                IF MARQUEE.BOX.w < 8 THEN MARQUEE.BOX.w = 8
            ELSE
                MARQUEE.BOX.x = MARQUEE.BOX.x - moveStep%
            END IF
        END IF
        IF _KEYDOWN(19712) THEN ' Right arrow
            IF isCtrl% THEN
                MARQUEE.BOX.w = MARQUEE.BOX.w + moveStep%
            ELSE
                MARQUEE.BOX.x = MARQUEE.BOX.x + moveStep%
            END IF
        END IF
    END IF
    
    ' MOVE tool keyboard controls (same arrow key logic as marquee + flip keys)
    IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE THEN
        DIM isMoveCtrl AS INTEGER, isMoveShift AS INTEGER, moveMoveStep AS INTEGER
        DIM keyUpNow AS INTEGER, keyDownNow AS INTEGER, keyLeftNow AS INTEGER, keyRightNow AS INTEGER
        
        isMoveCtrl% = (_KEYDOWN(100305) OR _KEYDOWN(100306)) ' Left or Right Ctrl
        isMoveShift% = (_KEYDOWN(100304) OR _KEYDOWN(100303)) ' Left or Right Shift
        moveMoveStep% = 1
        IF isMoveShift% THEN moveMoveStep% = CFG.NUDGE_N%
        
        ' Get current key states
        keyUpNow% = _KEYDOWN(18432)
        keyDownNow% = _KEYDOWN(20480)
        keyLeftNow% = _KEYDOWN(19200)
        keyRightNow% = _KEYDOWN(19712)
        
        ' Arrow keys move or resize the selection (single-press only)
        IF keyUpNow% AND NOT MOVE_KEY_UP_LAST% THEN ' Up arrow - just pressed
            IF isMoveCtrl% THEN
                MOVE_resize 0, -moveMoveStep%
            ELSE
                MOVE_nudge 0, -moveMoveStep%
            END IF
        END IF
        IF keyDownNow% AND NOT MOVE_KEY_DOWN_LAST% THEN ' Down arrow - just pressed
            IF isMoveCtrl% THEN
                MOVE_resize 0, moveMoveStep%
            ELSE
                MOVE_nudge 0, moveMoveStep%
            END IF
        END IF
        IF keyLeftNow% AND NOT MOVE_KEY_LEFT_LAST% THEN ' Left arrow - just pressed
            IF isMoveCtrl% THEN
                MOVE_resize -moveMoveStep%, 0
            ELSE
                MOVE_nudge -moveMoveStep%, 0
            END IF
        END IF
        IF keyRightNow% AND NOT MOVE_KEY_RIGHT_LAST% THEN ' Right arrow - just pressed
            IF isMoveCtrl% THEN
                MOVE_resize moveMoveStep%, 0
            ELSE
                MOVE_nudge moveMoveStep%, 0
            END IF
        END IF
        
        ' Update last key states
        MOVE_KEY_UP_LAST% = keyUpNow%
        MOVE_KEY_DOWN_LAST% = keyDownNow%
        MOVE_KEY_LEFT_LAST% = keyLeftNow%
        MOVE_KEY_RIGHT_LAST% = keyRightNow%
        
        ' Update clone mode based on ALT key
        MOVE.CLONING = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
        MOVE_update_preview_buffer
    END IF
    
    ' Check for Ctrl-D to deselect marquee
    IF _KEYDOWN(100305) OR _KEYDOWN(100306) THEN ' Left or Right Ctrl
        IF _KEYDOWN(100) THEN ' D key
            IF CURRENT_TOOL% = TOOL_MARQUEE THEN
                MARQUEE_clear
            END IF
        END IF
        
        ' Clipboard operations (with single-press detection)
        DIM clipIsShift AS INTEGER, clipIsAlt AS INTEGER
        DIM keyCNow AS INTEGER, keyXNow AS INTEGER, keyVNow AS INTEGER, keyENow AS INTEGER
        
        clipIsShift% = (_KEYDOWN(100304) OR _KEYDOWN(100303)) ' Left or Right Shift
        clipIsAlt% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
        
        keyCNow% = _KEYDOWN(99)   ' 'c' key
        keyXNow% = _KEYDOWN(120)  ' 'x' key
        keyVNow% = _KEYDOWN(118)  ' 'v' key
        keyENow% = _KEYDOWN(101)  ' 'e' key
        
        ' CTRL-C: Copy selection to clipboard
        IF keyCNow% AND NOT CLIPBOARD_KEY_C_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
            CLIPBOARD_copy
        END IF
        
        ' CTRL-X: Cut selection to clipboard
        IF keyXNow% AND NOT CLIPBOARD_KEY_X_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
            CLIPBOARD_cut
        END IF
        
        ' CTRL-V: Paste clipboard at mouse position
        IF keyVNow% AND NOT CLIPBOARD_KEY_V_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
            ' Get current mouse position in painting coordinates
            DIM pasteMouseX AS INTEGER, pasteMouseY AS INTEGER
            DIM zw AS LONG, zh AS LONG, dx AS INTEGER, dy AS INTEGER
            zw& = SCRN.w& * SCRN.zoom!
            zh& = SCRN.h& * SCRN.zoom!
            dx% = (_WIDTH(SCRN.CANVAS&) - zw&) \ 2 + SCRN.offsetX%
            dy% = (_HEIGHT(SCRN.CANVAS&) - zh&) \ 2 + SCRN.offsetY%
            pasteMouseX% = INT((MOUSE.X% - dx%) / SCRN.zoom!)
            pasteMouseY% = INT((MOUSE.Y% - dy%) / SCRN.zoom!)
            CLIPBOARD_paste pasteMouseX%, pasteMouseY%
        END IF
        
        ' CTRL-E: Clear selection (fill with background color)
        IF keyENow% AND NOT CLIPBOARD_KEY_E_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
            CLIPBOARD_clear_selection
        END IF
        
        ' CTRL-T: Activate text tool with custom font (if loaded)
        DIM keyTNow AS INTEGER
        keyTNow% = _KEYDOWN(116)  ' 't' key
        IF keyTNow% AND NOT CLIPBOARD_KEY_T_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
            _LOGINFO "CTRL-T pressed!"
            _LOGINFO "Custom font handle: " + STR$(TEXT.CUSTOM_FONT_HANDLE)
            PREVIOUS_TOOL% = CURRENT_TOOL%
            CURRENT_TOOL% = TOOL_TEXT
            FILL_deactivate
            PICKER_deactivate
            MARQUEE_reset
            POLY_LINE_reset
            LINE_reset
            RECT_reset
            ELLIPSE_reset
            MOVE_reset
            
            ' Use custom font if one was loaded via middle-click
            IF TEXT.CUSTOM_FONT_HANDLE > 0 THEN
                _LOGINFO "Using custom font!"
                TEXT.USE_CUSTOM = TRUE
                TEXT.USE_TINY5 = FALSE
                ' Get dimensions from the custom font
                DIM old_font_ctrl AS LONG
                old_font_ctrl& = _FONT
                _FONT TEXT.CUSTOM_FONT_HANDLE
                TEXT.CHAR_WIDTH = _PRINTWIDTH("A")
                TEXT.LINE_HEIGHT = _FONTHEIGHT + 2
                _FONT old_font_ctrl&
                _LOGINFO "Custom font activated - width: " + STR$(TEXT.CHAR_WIDTH) + " height: " + STR$(TEXT.LINE_HEIGHT)
            ELSE
                _LOGINFO "No custom font loaded - using VGA"
                ' No custom font loaded - fall back to VGA
                TEXT.USE_CUSTOM = FALSE
                TEXT.USE_TINY5 = FALSE
                TEXT.CHAR_WIDTH = 8
                TEXT.LINE_HEIGHT = 13
            END IF
            TEXT_reset
        END IF
        
        ' Update clipboard key states
        CLIPBOARD_KEY_C_LAST% = keyCNow%
        CLIPBOARD_KEY_X_LAST% = keyXNow%
        CLIPBOARD_KEY_V_LAST% = keyVNow%
        CLIPBOARD_KEY_E_LAST% = keyENow%
        CLIPBOARD_KEY_T_LAST% = keyTNow%
        
        ' Undo/Redo operations (with single-press detection)
        DIM keyZNow AS INTEGER, keyYNow AS INTEGER
        DIM pixelUndoTs AS DOUBLE, workspaceUndoTs AS DOUBLE
        
        keyZNow% = _KEYDOWN(122) OR _KEYDOWN(90)  ' 'z' or 'Z' key
        keyYNow% = _KEYDOWN(121) OR _KEYDOWN(89)  ' 'y' or 'Y' key
        
        ' CTRL-Z: Intelligent Undo - compare timestamps to undo most recent operation
        IF keyZNow% AND NOT UNDO_KEY_Z_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
            pixelUndoTs# = UNDO_get_last_timestamp#
            workspaceUndoTs# = WORKSPACE_UNDO_get_last_timestamp#
            
            ' Undo whichever is more recent (higher timestamp)
            IF workspaceUndoTs# > pixelUndoTs# AND WORKSPACE_UNDO_can_undo% THEN
                _LOGINFO "CTRL-Z: Workspace undo (ts=" + STR$(workspaceUndoTs#) + " > pixel ts=" + STR$(pixelUndoTs#) + ")"
                WORKSPACE_UNDO_undo
            ELSEIF pixelUndoTs# > 0 THEN
                _LOGINFO "CTRL-Z: Pixel undo (ts=" + STR$(pixelUndoTs#) + " >= workspace ts=" + STR$(workspaceUndoTs#) + ")"
                UNDO_undo
            END IF
            GUI_NEEDS_REDRAW% = TRUE
        END IF
        
        ' CTRL-Y: Intelligent Redo - compare timestamps to redo in correct order
        IF keyYNow% AND NOT UNDO_KEY_Y_LAST% AND NOT clipIsShift% AND NOT clipIsAlt% THEN
            ' For redo, we need to peek at what would be redone and compare
            ' If workspace has something to redo that's older than pixel redo, do workspace first
            ' For simplicity, default to pixel redo unless workspace has pending redo and pixel doesn't
            IF WORKSPACE_UNDO_can_redo% AND UNDO.current% >= UNDO.count% - 1 THEN
                _LOGINFO "CTRL-Y: Workspace redo (pixel redo not available)"
                WORKSPACE_UNDO_redo
            ELSE
                _LOGINFO "CTRL-Y: Pixel redo"
                UNDO_redo
            END IF
            GUI_NEEDS_REDRAW% = TRUE
        END IF
        
        ' Update undo/redo key states
        UNDO_KEY_Z_LAST% = keyZNow%
        UNDO_KEY_Y_LAST% = keyYNow%
        
        ' File operations (with single-press detection)
        DIM fileIsShift AS INTEGER, fileIsAlt AS INTEGER
        DIM keyONow AS INTEGER, keySNow AS INTEGER
        
        fileIsShift% = (_KEYDOWN(100304) OR _KEYDOWN(100303)) ' Left or Right Shift
        fileIsAlt% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
        
        keyONow% = _KEYDOWN(111)  ' 'o' key
        keySNow% = (_KEYDOWN(115) OR _KEYDOWN(83))  ' 's' or 'S' key (SHIFT changes case)
        
        ' CTRL-O: Open file
        IF keyONow% AND NOT FILE_KEY_O_LAST% AND NOT fileIsShift% AND NOT fileIsAlt% THEN
            LOAD_image
        END IF
        
        ' CTRL-S: Save (with dialog)
        ' CTRL-SHIFT-S: Quick save (no dialog if previously saved)
        ' CTRL-ALT-S: Save As (always new filename)
        ' CTRL-ALT-SHIFT-S: Export selection as cropped image
        IF keySNow% AND NOT FILE_KEY_S_LAST% THEN
            IF fileIsAlt% AND fileIsShift% THEN
                ' CTRL-ALT-SHIFT-S: Export Selection
                SAVE_selection
            ELSEIF fileIsAlt% AND NOT fileIsShift% THEN
                ' CTRL-ALT-S: Save As
                SAVE_as
            ELSEIF fileIsShift% AND NOT fileIsAlt% THEN
                ' CTRL-SHIFT-S: Quick save
                SAVE_quick
            ELSEIF NOT fileIsShift% AND NOT fileIsAlt% THEN
                ' CTRL-S: Save with dialog
                SAVE_image
            END IF
        END IF
        
        ' Update file key states
        FILE_KEY_O_LAST% = keyONow%
        FILE_KEY_S_LAST% = keySNow%
        
        ' Zoom shortcuts (CTRL only, NOT CTRL+ALT+SHIFT which is display scale)
        ' Need edge detection to prevent continuous firing while key is held
        DIM zoomIsShift AS INTEGER, zoomIsAlt AS INTEGER
        zoomIsShift% = (_KEYDOWN(100304) OR _KEYDOWN(100303))
        zoomIsAlt% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
        
        STATIC zoom0Pressed AS INTEGER, zoomPlusPressed AS INTEGER, zoomMinusPressed AS INTEGER
        
        ' Only process zoom if NOT using display scale combo (CTRL+ALT+SHIFT)
        IF NOT (zoomIsShift% AND zoomIsAlt%) THEN
            ' CTRL+0 - reset zoom to 100% and center
            IF _KEYDOWN(48) THEN
                IF NOT zoom0Pressed% THEN
                    SCRN.zoom! = 1.0
                    SCRN.offsetX% = 0
                    SCRN.offsetY% = 0
                    GUI_NEEDS_REDRAW% = TRUE
                    zoom0Pressed% = TRUE
                END IF
            ELSE
                zoom0Pressed% = FALSE
            END IF
            
            ' CTRL+= - zoom in (snap to valid levels: 25%, 50%, 100%, 200%, 300%...)
            IF _KEYDOWN(61) THEN
                IF NOT zoomPlusPressed% THEN
                    IF SCRN.zoom! < 0.5 THEN
                        SCRN.zoom! = 0.5   ' 25% -> 50%
                    ELSEIF SCRN.zoom! < 1.0 THEN
                        SCRN.zoom! = 1.0   ' 50% -> 100%
                    ELSE
                        SCRN.zoom! = INT(SCRN.zoom!) + 1.0  ' 100% -> 200%, etc.
                    END IF
                    IF SCRN.zoom! > SCRN.zoomMax! THEN SCRN.zoom! = SCRN.zoomMax!
                    GUI_NEEDS_REDRAW% = TRUE
                    zoomPlusPressed% = TRUE
                END IF
            ELSE
                zoomPlusPressed% = FALSE
            END IF
            
            ' CTRL+- - zoom out (snap to valid levels: ...300%, 200%, 100%, 50%, 25%)
            IF _KEYDOWN(45) THEN
                IF NOT zoomMinusPressed% THEN
                    IF SCRN.zoom! > 1.0 THEN
                        SCRN.zoom! = INT(SCRN.zoom!) - 1.0  ' 200% -> 100%, etc.
                    ELSEIF SCRN.zoom! > 0.5 THEN
                        SCRN.zoom! = 0.5   ' 100% -> 50%
                    ELSEIF SCRN.zoom! > 0.25 THEN
                        SCRN.zoom! = 0.25  ' 50% -> 25%
                    END IF
                    IF SCRN.zoom! < SCRN.zoomMin! THEN SCRN.zoom! = SCRN.zoomMin!
                    GUI_NEEDS_REDRAW% = TRUE
                    zoomMinusPressed% = TRUE
                END IF
            ELSE
                zoomMinusPressed% = FALSE
            END IF
            
            ' NOTE: CTRL+2/3/4 are NOT available for zoom presets
            ' They are used for palette BG color shortcuts (KB.PAL_BG_02/03/04)
        END IF
    ELSE
        ' Reset key states when Ctrl is not pressed
        FILE_KEY_O_LAST% = FALSE
        FILE_KEY_S_LAST% = FALSE
        CLIPBOARD_KEY_C_LAST% = FALSE
        CLIPBOARD_KEY_X_LAST% = FALSE
        CLIPBOARD_KEY_V_LAST% = FALSE
        CLIPBOARD_KEY_E_LAST% = FALSE
    END IF
    
    ' === ALT+S / ALT+O: Save/Open .DRW project file (ALT-only, no CTRL) ===
    STATIC DRW_KEY_O_LAST AS INTEGER, DRW_KEY_S_LAST AS INTEGER
    DIM drwIsAlt AS INTEGER, drwIsCtrl AS INTEGER
    DIM drwKeyONow AS INTEGER, drwKeySNow AS INTEGER
    
    drwIsAlt% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
    drwIsCtrl% = (_KEYDOWN(100305) OR _KEYDOWN(100306))
    drwKeyONow% = _KEYDOWN(111)  ' 'o' key
    drwKeySNow% = _KEYDOWN(115)  ' 's' key
    
    ' ALT+O (no CTRL): Open .drw project
    IF drwIsAlt% AND NOT drwIsCtrl% AND drwKeyONow% AND NOT DRW_KEY_O_LAST% THEN
        DRW_open_dialog
    END IF
    
    ' ALT+S (no CTRL): Save .drw project
    IF drwIsAlt% AND NOT drwIsCtrl% AND drwKeySNow% AND NOT DRW_KEY_S_LAST% THEN
        DRW_save_dialog
    END IF
    
    ' Update DRW key states
    DRW_KEY_O_LAST% = drwKeyONow%
    DRW_KEY_S_LAST% = drwKeySNow%
    
    ' Note: KEYBOARD_layers is now called from KEYBOARD_input_handler directly
    ' because it uses _KEYDOWN() which needs to run every frame, not just when INKEY$ returns
END SUB


''
' Handle layer-related keyboard shortcuts
' 
SUB KEYBOARD_layers ()
    DIM isCtrl AS INTEGER, isShift AS INTEGER, isAlt AS INTEGER
    STATIC layerCtrlTabPressed AS INTEGER
    STATIC layerCtrlShiftNPressed AS INTEGER
    STATIC layerCtrlJPressed AS INTEGER
    STATIC layerCtrlShiftRPressed AS INTEGER
    STATIC layerCtrlBracketLPressed AS INTEGER
    STATIC layerCtrlBracketRPressed AS INTEGER
    STATIC layerCtrlShiftBracketLPressed AS INTEGER
    STATIC layerCtrlShiftBracketRPressed AS INTEGER
    STATIC layerShiftBracketLPressed AS INTEGER
    STATIC layerShiftBracketRPressed AS INTEGER
    STATIC layerCtrlEPressed AS INTEGER
    STATIC layerCtrlShiftEPressed AS INTEGER
    
    isCtrl% = (_KEYDOWN(100305) OR _KEYDOWN(100306))  ' Left or Right Ctrl
    isShift% = (_KEYDOWN(100304) OR _KEYDOWN(100303)) ' Left or Right Shift
    isAlt% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
    
    ' CTRL+L: Toggle layer panel visibility (CTRL+TAB intercepted by window manager on Linux)
    IF isCtrl% AND _KEYDOWN(ASC("l")) AND NOT isShift% AND NOT isAlt% THEN
        IF NOT layerCtrlTabPressed% THEN
            LAYER_PANEL.visible% = NOT LAYER_PANEL.visible%
            GUI_NEEDS_REDRAW% = TRUE
            layerCtrlTabPressed% = TRUE
        END IF
    ELSEIF NOT _KEYDOWN(ASC("l")) THEN
        layerCtrlTabPressed% = FALSE
    END IF
    
    ' CTRL+SHIFT+N: New layer
    IF isCtrl% AND isShift% AND _KEYDOWN(110) THEN ' 110 = 'n'
        IF NOT layerCtrlShiftNPressed% THEN
            DIM newLayerIdx AS INTEGER
            newLayerIdx% = LAYERS_new%
            layerCtrlShiftNPressed% = TRUE
        END IF
    ELSE
        layerCtrlShiftNPressed% = FALSE
    END IF
    
    ' CTRL+J: Duplicate layer
    IF isCtrl% AND NOT isShift% AND NOT isAlt% AND _KEYDOWN(106) THEN ' 106 = 'j'
        IF NOT layerCtrlJPressed% THEN
            LAYERS_duplicate CURRENT_LAYER%
            layerCtrlJPressed% = TRUE
        END IF
    ELSE
        layerCtrlJPressed% = FALSE
    END IF
    
    ' CTRL+SHIFT+R: Rename layer
    IF isCtrl% AND isShift% AND _KEYDOWN(114) THEN ' 114 = 'r'
        IF NOT layerCtrlShiftRPressed% THEN
            LAYERS_rename CURRENT_LAYER%
            layerCtrlShiftRPressed% = TRUE
        END IF
    ELSE
        layerCtrlShiftRPressed% = FALSE
    END IF
    
    ' CTRL+[: Move layer down in stack
    IF isCtrl% AND NOT isShift% AND _KEYDOWN(91) THEN ' 91 = '['
        IF NOT layerCtrlBracketLPressed% THEN
            LAYERS_move_down CURRENT_LAYER%
            layerCtrlBracketLPressed% = TRUE
        END IF
    ELSE
        layerCtrlBracketLPressed% = FALSE
    END IF
    
    ' CTRL+]: Move layer up in stack
    IF isCtrl% AND NOT isShift% AND _KEYDOWN(93) THEN ' 93 = ']'
        IF NOT layerCtrlBracketRPressed% THEN
            LAYERS_move_up CURRENT_LAYER%
            layerCtrlBracketRPressed% = TRUE
        END IF
    ELSE
        layerCtrlBracketRPressed% = FALSE
    END IF
    
    ' CTRL+SHIFT+[: Move layer to bottom
    IF isCtrl% AND isShift% AND _KEYDOWN(123) THEN ' 123 = '{' (shift+[)
        IF NOT layerCtrlShiftBracketLPressed% THEN
            LAYERS_to_bottom CURRENT_LAYER%
            layerCtrlShiftBracketLPressed% = TRUE
        END IF
    ELSE
        layerCtrlShiftBracketLPressed% = FALSE
    END IF
    
    ' CTRL+SHIFT+]: Move layer to top
    IF isCtrl% AND isShift% AND _KEYDOWN(125) THEN ' 125 = '}' (shift+])
        IF NOT layerCtrlShiftBracketRPressed% THEN
            LAYERS_to_top CURRENT_LAYER%
            layerCtrlShiftBracketRPressed% = TRUE
        END IF
    ELSE
        layerCtrlShiftBracketRPressed% = FALSE
    END IF
    
    ' SHIFT+[: Focus previous layer (select layer below)
    IF isShift% AND NOT isCtrl% AND _KEYDOWN(123) THEN ' 123 = '{'
        IF NOT layerShiftBracketLPressed% THEN
            ' Find layer with zIndex one less than current
            DIM prevZ AS INTEGER, prevIdx AS INTEGER, pi AS INTEGER
            prevZ% = 0
            prevIdx% = 0
            IF CURRENT_LAYER% >= 1 AND CURRENT_LAYER% <= 64 THEN
                IF LAYERS(CURRENT_LAYER%).imgHandle& <> 0 THEN
                    prevZ% = LAYERS(CURRENT_LAYER%).zIndex% - 1
                    IF prevZ% >= 1 THEN
                        FOR pi% = 1 TO 64
                            IF LAYERS(pi%).imgHandle& <> 0 AND LAYERS(pi%).zIndex% = prevZ% THEN
                                prevIdx% = pi%
                                EXIT FOR
                            END IF
                        NEXT pi%
                        IF prevIdx% > 0 THEN LAYERS_select prevIdx%
                    END IF
                END IF
            END IF
            layerShiftBracketLPressed% = TRUE
        END IF
    ELSE
        layerShiftBracketLPressed% = FALSE
    END IF
    
    ' SHIFT+]: Focus next layer (select layer above)
    IF isShift% AND NOT isCtrl% AND _KEYDOWN(125) THEN ' 125 = '}'
        IF NOT layerShiftBracketRPressed% THEN
            ' Find layer with zIndex one more than current
            DIM nextZ AS INTEGER, nextIdx AS INTEGER, ni AS INTEGER
            nextZ% = 0
            nextIdx% = 0
            IF CURRENT_LAYER% >= 1 AND CURRENT_LAYER% <= 64 THEN
                IF LAYERS(CURRENT_LAYER%).imgHandle& <> 0 THEN
                    nextZ% = LAYERS(CURRENT_LAYER%).zIndex% + 1
                    IF nextZ% <= LAYER_COUNT% THEN
                        FOR ni% = 1 TO 64
                            IF LAYERS(ni%).imgHandle& <> 0 AND LAYERS(ni%).zIndex% = nextZ% THEN
                                nextIdx% = ni%
                                EXIT FOR
                            END IF
                        NEXT ni%
                        IF nextIdx% > 0 THEN LAYERS_select nextIdx%
                    END IF
                END IF
            END IF
            layerShiftBracketRPressed% = TRUE
        END IF
    ELSE
        layerShiftBracketRPressed% = FALSE
    END IF
    
    ' CTRL+ALT+E: Merge layer down
    IF isCtrl% AND isAlt% AND NOT isShift% AND _KEYDOWN(101) THEN ' 101 = 'e'
        IF NOT layerCtrlEPressed% THEN
            LAYERS_merge_down CURRENT_LAYER%
            layerCtrlEPressed% = TRUE
        END IF
    ELSE
        layerCtrlEPressed% = FALSE
    END IF
    
    ' CTRL+ALT+SHIFT+E: Merge all visible layers
    IF isCtrl% AND isShift% AND isAlt% AND _KEYDOWN(69) THEN ' 69 = 'E' (shifted)
        IF NOT layerCtrlShiftEPressed% THEN
            LAYERS_merge_visible
            layerCtrlShiftEPressed% = TRUE
        END IF
    ELSE
        layerCtrlShiftEPressed% = FALSE
    END IF
END SUB


''
' Finishing stuff in the keyboard input loop
' 
SUB KEYBOARD_input_handler_loop ()
END SUB