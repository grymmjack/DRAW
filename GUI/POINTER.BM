''
' DRAW - GUI/POINTER.BM
' =============================================================================
' Pointer subs and functions.
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initializes the pointer
' 
SUB POINTER_init ()
    _MOUSEHIDE
    POINTER.W%  = 4
    POINTER.H%  = 4
    POINTER.C~& = PAL_color(4)  ' Default to red (EGA color 4)
    POINTER.O%  = 7
    POINTER.OC~& = POINTER.C~&
    POINTER.IMG& = 0
    POINTER.USE_IMG% = FALSE
    POINTER.HOTSPOT_X% = 0
    POINTER.HOTSPOT_Y% = 0
    IF SCRN.w& > 640 THEN 
        POINTER.W% = POINTER.W% * 2
        POINTER.H% = POINTER.H% * 2
    END IF
END SUB


''
' Render the pointer
' 
SUB POINTER_render ()
    POINTER_build
    POINTER_draw
END SUB


''
' Builds the pointer
' 
SUB POINTER_build ()
    DIM mx AS INTEGER, my AS INTEGER
    DIM AS INTEGER TB_RIGHT, TB_LEFT
    
    ' Calculate toolbar position dynamically to align to right edge of screen
    TB_RIGHT = SCRN.w& - TB_BTN_W - 1  ' Right column: 1px from right edge
    TB_LEFT = TB_RIGHT - TB_BTN_W - TB_BTN_PADDING  ' Left column: to the left of right column
    
    ' Scale mouse coordinates from window to logical canvas
    mx% = _MOUSEX \ SCRN.displayScale%
    my% = _MOUSEY \ SCRN.displayScale%
    
    ' Check if mouse is over toolbar area (background panel or buttons) - show simple arrow cursor
    IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(mx%, my%) THEN
        POINTER.USE_IMG% = FALSE
        ' Simple arrow using DRAW - white filled with black outline
        POINTER.S$ = "C15M1,1D8R5L2U2R2U2L2U4BM1,1C0D7R4L2U2R2U2L2U3"
        EXIT SUB
    END IF
    
    ' Check if NULL tool is active - use same pointer as toolbar
    IF CURRENT_TOOL% = TOOL_NULL THEN
        POINTER.USE_IMG% = FALSE
        ' Simple arrow using DRAW - white filled with black outline
        POINTER.S$ = "C15M1,1D8R5L2U2R2U2L2U4BM1,1C0D7R4L2U2R2U2L2U3"
        EXIT SUB
    END IF
    
    ' Check if in pan mode (spacebar held or middle mouse button) - show hand cursor
    IF _KEYDOWN(32) OR _MOUSEBUTTON(3) THEN ' Spacebar or MMB - pan mode
        POINTER.USE_IMG% = FALSE
        ' Draw a simple hand cursor (4x4 box for now, you can make it fancier)
        POINTER.S$ = "C" + STR$(PAL_color(15))
        ' Simple hand representation - could be improved
        POINTER.S$ = POINTER.S$ + "M0,2R2D2L2U2" ' Simplified hand shape
        EXIT SUB
    END IF
    
    ' Check if fill tool is active and use PNG cursor if available
    IF CURRENT_TOOL% = TOOL_FILL THEN
        POINTER_load_fill_cursor
        IF POINTER.USE_IMG% THEN EXIT SUB
    END IF
    
    ' Check if marquee tool is active - skip building default cursor
    IF CURRENT_TOOL% = TOOL_MARQUEE THEN
        POINTER.USE_IMG% = FALSE
        EXIT SUB
    END IF
    
    ' Check if move tool is active - skip building default cursor (use marquee-style)
    IF CURRENT_TOOL% = TOOL_MOVE THEN
        POINTER.USE_IMG% = FALSE
        EXIT SUB
    END IF
    
    ' Check if text tool is active - use I-beam cursor
    IF CURRENT_TOOL% = TOOL_TEXT THEN
        POINTER.USE_IMG% = FALSE
        EXIT SUB
    END IF
    
    ' Default cursor (crosshair/square)
    POINTER.USE_IMG% = FALSE
    POINTER.S$ = "C" + STR$(PAL_color(POINTER.O%)) _
              + "D"  + ns$(POINTER.H%) _ 
              + "R"  + ns$(POINTER.W%) _ 
              + "H"  + ns$(POINTER.H%) _ 
              + "B" _
              + "M+" + ns$(POINTER.W%\2) _
              + ",+" + ns$(POINTER.H%) _
              + "F"  + ns$(POINTER.W%\2)
    IF POINTER.C~& <> 0 THEN 'fill POINTER if not 0 else color is black do not.
        POINTER.S$ = POINTER.S$ _
                  + "B" _
                  + "M-" + ns$(POINTER.W%\2) _
                  + ",-" + ns$(POINTER.H% - 1) _
                  + "P"  + STR$(POINTER.C~&) _
                  + ","  + STR$(PAL_color(POINTER.O%))
    END IF
END SUB


''
' Draws the pointer
' 
SUB POINTER_draw ()
    DIM oldDest AS LONG
    DIM radius AS INTEGER
    DIM is_painting AS INTEGER
    DIM mx AS INTEGER, my AS INTEGER
    DIM cx AS INTEGER, cy AS INTEGER
    DIM dist_sq AS SINGLE, r_sq AS SINGLE
    DIM r AS INTEGER, g AS INTEGER, b AS INTEGER
    DIM AS INTEGER TB_RIGHT, TB_LEFT
    
    ' Calculate toolbar position dynamically to align to right edge of screen
    TB_RIGHT = SCRN.w& - TB_BTN_W - 1  ' Right column: 1px from right edge
    TB_LEFT = TB_RIGHT - TB_BTN_W - TB_BTN_PADDING  ' Left column: to the left of right column
    
    oldDest& = _DEST 
    _DEST SCRN.CURSOR&
    _DONTBLEND SCRN.CURSOR&
    CLS
    
    ' Get mouse position (scaled from window to logical canvas)
    mx% = _MOUSEX \ SCRN.displayScale%
    my% = _MOUSEY \ SCRN.displayScale%
    
    ' If over toolbar area (background panel or buttons), ONLY draw arrow and exit immediately
    IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(mx%, my%) THEN
        ' Draw arrow cursor - black outline first, then white fill
        LINE (mx%, my%)-(mx% + 1, my% + 10), _RGB32(0, 0, 0)
        LINE -(mx% + 7, my% + 7), _RGB32(0, 0, 0)
        LINE -(mx%, my%), _RGB32(0, 0, 0)
        PAINT (mx% + 2, my% + 5), _RGB32(0, 0, 0), _RGB32(0, 0, 0)
        ' White fill inside
        LINE (mx% + 1, my% + 1)-(mx% + 1, my% + 9), _RGB32(255, 255, 255)
        LINE -(mx% + 6, my% + 6), _RGB32(255, 255, 255)
        LINE -(mx% + 1, my% + 1), _RGB32(255, 255, 255)
        PAINT (mx% + 2, my% + 5), _RGB32(255, 255, 255), _RGB32(255, 255, 255)
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' If NULL tool is active, draw arrow cursor everywhere
    IF CURRENT_TOOL% = TOOL_NULL THEN
        ' Draw arrow cursor - black outline first, then white fill
        LINE (mx%, my%)-(mx% + 1, my% + 10), _RGB32(0, 0, 0)
        LINE -(mx% + 7, my% + 7), _RGB32(0, 0, 0)
        LINE -(mx%, my%), _RGB32(0, 0, 0)
        PAINT (mx% + 2, my% + 5), _RGB32(0, 0, 0), _RGB32(0, 0, 0)
        ' White fill inside
        LINE (mx% + 1, my% + 1)-(mx% + 1, my% + 9), _RGB32(255, 255, 255)
        LINE -(mx% + 6, my% + 6), _RGB32(255, 255, 255)
        LINE -(mx% + 1, my% + 1), _RGB32(255, 255, 255)
        PAINT (mx% + 2, my% + 5), _RGB32(255, 255, 255), _RGB32(255, 255, 255)
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' If custom brush is active, draw the brush at cursor position
    IF CUSTOM_BRUSH_is_active% THEN
        ' Draw the custom brush centered on cursor with zoom scaling
        DIM brush_x AS INTEGER, brush_y AS INTEGER
        DIM scaled_w AS INTEGER, scaled_h AS INTEGER
        
        ' Calculate scaled dimensions for cursor display
        scaled_w% = CUSTOM_BRUSH.WIDTH% * CUSTOM_BRUSH.SCALE! * SCRN.zoom!
        scaled_h% = CUSTOM_BRUSH.HEIGHT% * CUSTOM_BRUSH.SCALE! * SCRN.zoom!
        
        brush_x% = mx% - scaled_w% \ 2
        brush_y% = my% - scaled_h% \ 2
        
        ' Render the custom brush with zoom scaling
        CUSTOM_BRUSH_render_scaled brush_x%, brush_y%, SCRN.CURSOR&, SCRN.zoom!
        
        ' Draw a subtle outline to show brush bounds (if enabled)
        IF CUSTOM_BRUSH.SHOW_OUTLINE% THEN
            DIM outline_x1 AS INTEGER, outline_y1 AS INTEGER
            DIM outline_x2 AS INTEGER, outline_y2 AS INTEGER
            outline_x1% = brush_x%
            outline_y1% = brush_y%
            outline_x2% = brush_x% + scaled_w% - 1
            outline_y2% = brush_y% + scaled_h% - 1
            
            ' Draw white outline with black shadow for visibility
            LINE (outline_x1% - 1, outline_y1% - 1)-(outline_x2% + 1, outline_y2% + 1), _RGBA32(0, 0, 0, 128), B
            LINE (outline_x1%, outline_y1%)-(outline_x2%, outline_y2%), _RGBA32(255, 255, 255, 200), B
        END IF
        
        ' Draw crosshair at center point
        LINE (mx% - 3, my%)-(mx% - 1, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx% + 1, my%)-(mx% + 3, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% - 3)-(mx%, my% - 1), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% + 1)-(mx%, my% + 3), _RGBA32(255, 255, 255, 240)
        PSET (mx%, my%), _RGBA32(255, 0, 0, 255)
        
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' Check if currently painting (mouse button 1 down)
    is_painting% = (_MOUSEBUTTON(1) <> 0)
    
    ' Draw X-shaped crosshair cursor for LINE, POLY-LINE, RECT, and ELLIPSE tools
    IF CURRENT_TOOL% = TOOL_LINE OR CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED OR CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED OR CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED THEN
        ' Draw a precise X-shaped crosshair with transparent center
        ' Diagonal lines forming an X - black outline for visibility
        ' Top-left to bottom-right diagonal - black outline
        LINE (mx% - 7, my% - 8)-(mx% - 2, my% - 3), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 8, my% - 7)-(mx% - 3, my% - 2), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 2, my% + 3)-(mx% + 7, my% + 8), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 3, my% + 2)-(mx% + 8, my% + 7), _RGBA32(0, 0, 0, 180)
        ' Top-left to bottom-right diagonal - white center
        LINE (mx% - 7, my% - 7)-(mx% - 2, my% - 2), _RGBA32(255, 255, 255, 240)
        LINE (mx% + 2, my% + 2)-(mx% + 7, my% + 7), _RGBA32(255, 255, 255, 240)
        
        ' Top-right to bottom-left diagonal - black outline
        LINE (mx% + 7, my% - 8)-(mx% + 2, my% - 3), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 8, my% - 7)-(mx% + 3, my% - 2), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 2, my% + 3)-(mx% - 7, my% + 8), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 3, my% + 2)-(mx% - 8, my% + 7), _RGBA32(0, 0, 0, 180)
        ' Top-right to bottom-left diagonal - white center
        LINE (mx% + 7, my% - 7)-(mx% + 2, my% - 2), _RGBA32(255, 255, 255, 240)
        LINE (mx% - 2, my% + 2)-(mx% - 7, my% + 7), _RGBA32(255, 255, 255, 240)
        
        ' Draw colored center dot with transparency (like dot tool)
        r% = _RED32(PAINT_COLOR~&)
        g% = _GREEN32(PAINT_COLOR~&)
        b% = _BLUE32(PAINT_COLOR~&)
        ' Draw center dot with semi-transparency so you can see through it
        PSET (mx%, my%), _RGBA32(r%, g%, b%, 180)
        PSET (mx% - 1, my%), _RGBA32(r%, g%, b%, 120)
        PSET (mx% + 1, my%), _RGBA32(r%, g%, b%, 120)
        PSET (mx%, my% - 1), _RGBA32(r%, g%, b%, 120)
        PSET (mx%, my% + 1), _RGBA32(r%, g%, b%, 120)
    END IF
    
    ' Draw picker cursor if using picker tool
    IF CURRENT_TOOL% = TOOL_PICKER THEN
        ' Draw a precise crosshair with transparent center for accurate color picking
        ' Outer black outline for visibility on any background
        ' Horizontal crosshair - black outline
        LINE (mx% - 9, my% - 1)-(mx% - 2, my% - 1), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 9, my% + 1)-(mx% - 2, my% + 1), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 2, my% - 1)-(mx% + 9, my% - 1), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 2, my% + 1)-(mx% + 9, my% + 1), _RGBA32(0, 0, 0, 180)
        ' Horizontal crosshair - white center
        LINE (mx% - 9, my%)-(mx% - 2, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx% + 2, my%)-(mx% + 9, my%), _RGBA32(255, 255, 255, 240)
        
        ' Vertical crosshair - black outline
        LINE (mx% - 1, my% - 9)-(mx% - 1, my% - 2), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 1, my% - 9)-(mx% + 1, my% - 2), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 1, my% + 2)-(mx% + 1, my% + 9), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 1, my% + 2)-(mx% + 1, my% + 9), _RGBA32(0, 0, 0, 180)
        ' Vertical crosshair - white center
        LINE (mx%, my% - 9)-(mx%, my% - 2), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% + 2)-(mx%, my% + 9), _RGBA32(255, 255, 255, 240)
        
        ' Center is completely transparent (1px gap all around) so you can see the exact pixel
    END IF
    
    ' Draw brush cursor if using brush/dot tool
    IF CURRENT_TOOL% = TOOL_BRUSH OR CURRENT_TOOL% = TOOL_DOT THEN
        DIM pixel_size AS INTEGER, half AS INTEGER
        pixel_size% = BRUSH_SIZE_pixels%
        
        IF BRUSH_SIZE.PREVIEW THEN
            ' Preview mode: show dual outline with crosshair AND colored center
            IF BRUSH_SIZE.SHAPE = 0 THEN
                ' Circle preview - draw dark gray outer ring, white inner ring
                ' (Note: pure black _RGB32(0,0,0) is transparent on SCRN.CURSOR&)
                radius% = pixel_size% \ 2
                CIRCLE (mx%, my%), radius% + 1, _RGBA32(32, 32, 32, 84)
                CIRCLE (mx%, my%), radius%, _RGBA32(255, 255, 255, 84)
                
                ' Fill center with foreground color at reduced opacity
                r_sq! = (radius% - 0.5) * (radius% - 0.5)
                r% = _RED32(PAINT_COLOR~&)
                g% = _GREEN32(PAINT_COLOR~&)
                b% = _BLUE32(PAINT_COLOR~&)
                FOR cy% = my% - radius% TO my% + radius%
                    FOR cx% = mx% - radius% TO mx% + radius%
                        dist_sq! = (cx% - mx%) * (cx% - mx%) + (cy% - my%) * (cy% - my%)
                        IF dist_sq! <= r_sq! THEN
                            ' Check if we should draw based on dither pattern
                            DIM should_show AS INTEGER
                            should_show% = TRUE
                            IF BRUSH_DITHER_ACTIVE > 0 THEN
                                should_show% = BRUSH_DITHERS_should_draw%(cx%, cy%)
                            END IF
                            IF should_show% THEN
                                ' Use foreground color with transparency
                                PSET (cx%, cy%), _RGBA32(r%, g%, b%, 120)
                            END IF
                        END IF
                    NEXT cx%
                NEXT cy%
            ELSE
                ' Square preview - draw dark gray outer box, white inner box
                half% = pixel_size% \ 2
                LINE (mx% - half% - 1, my% - half% - 1)-(mx% + half% + 1, my% + half% + 1), _RGBA32(32, 32, 32, 84), B
                LINE (mx% - half%, my% - half%)-(mx% + half%, my% + half%), _RGBA32(255, 255, 255, 84), B
                
                ' Fill center with foreground color at reduced opacity
                r% = _RED32(PAINT_COLOR~&)
                g% = _GREEN32(PAINT_COLOR~&)
                b% = _BLUE32(PAINT_COLOR~&)
                ' Apply dither pattern if active
                IF BRUSH_DITHER_ACTIVE > 0 THEN
                    FOR cy% = my% - half% TO my% + half%
                        FOR cx% = mx% - half% TO mx% + half%
                            IF BRUSH_DITHERS_should_draw%(cx%, cy%) THEN
                                PSET (cx%, cy%), _RGBA32(r%, g%, b%, 120)
                            END IF
                        NEXT cx%
                    NEXT cy%
                ELSE
                    LINE (mx% - half%, my% - half%)-(mx% + half%, my% + half%), _RGBA32(r%, g%, b%, 120), BF
                END IF
            END IF
            
            ' Draw crosshair at center when not painting
            IF NOT is_painting% THEN
                LINE (mx% - 3, my%)-(mx% + 3, my%), _RGBA32(32, 32, 32, 84)
                LINE (mx%, my% - 3)-(mx%, my% + 3), _RGBA32(32, 32, 32, 84)
                LINE (mx% - 2, my%)-(mx% + 2, my%), _RGBA32(255, 255, 255, 84)
                LINE (mx%, my% - 2)-(mx%, my% + 2), _RGBA32(255, 255, 255, 84)
            END IF
        ELSE
            ' No preview: show filled shape in paint color matching exact paint algorithm
            IF pixel_size% = 1 THEN
                ' Single pixel - always show a visible crosshair dot even when painting
                ' to ensure the user can see where they're drawing (e.g., black on black)
                PSET (mx%, my%), _RGBA32(255, 255, 255, 128)
                PSET (mx% - 1, my%), _RGBA32(0, 0, 0, 64)
                PSET (mx% + 1, my%), _RGBA32(0, 0, 0, 64)
                PSET (mx%, my% - 1), _RGBA32(0, 0, 0, 64)
                PSET (mx%, my% + 1), _RGBA32(0, 0, 0, 64)
            ELSEIF pixel_size% = 3 AND BRUSH_SIZE.SHAPE = 0 THEN
                ' Plus sign for size 3 circle
                LINE (mx%, my% - 1)-(mx%, my% + 1), PAINT_COLOR~&
                LINE (mx% - 1, my%)-(mx% + 1, my%), PAINT_COLOR~&
            ELSE
                IF BRUSH_SIZE.SHAPE = 0 THEN
                    ' Filled circle using same algorithm as PAINT_draw_filled_circle
                    radius% = pixel_size% \ 2
                    r_sq! = (radius% - 0.5) * (radius% - 0.5)
                    FOR cy% = my% - radius% TO my% + radius%
                        FOR cx% = mx% - radius% TO mx% + radius%
                            dist_sq! = (cx% - mx%) * (cx% - mx%) + (cy% - my%) * (cy% - my%)
                            IF dist_sq! <= r_sq! THEN
                                PSET (cx%, cy%), PAINT_COLOR~&
                            END IF
                        NEXT cx%
                    NEXT cy%
                ELSE
                    ' Filled square
                    half% = pixel_size% \ 2
                    LINE (mx% - half%, my% - half%)-(mx% + half%, my% + half%), PAINT_COLOR~&, BF
                END IF
            END IF
        END IF
    END IF
    
    ' Draw marquee cursor if using marquee tool
    IF CURRENT_TOOL% = TOOL_MARQUEE THEN
        POINTER_draw_marquee_cursor
    END IF
    
    ' Draw marquee cursor if using move tool (same as marquee)
    IF CURRENT_TOOL% = TOOL_MOVE THEN
        POINTER_draw_marquee_cursor
    END IF
    
    ' Draw I-beam cursor if using text tool
    IF CURRENT_TOOL% = TOOL_TEXT THEN
        POINTER_draw_ibeam_cursor
    END IF
    
    ' Draw arrow cursor - but NOT for picker, marquee, line, poly-line, rect, or ellipse tools
    ' Also show arrow for brush/dot with preview enabled when not painting
    DIM show_arrow AS INTEGER
    show_arrow% = FALSE
    
    IF CURRENT_TOOL% = TOOL_PICKER OR CURRENT_TOOL% = TOOL_MARQUEE OR CURRENT_TOOL% = TOOL_MOVE OR CURRENT_TOOL% = TOOL_TEXT OR CURRENT_TOOL% = TOOL_LINE OR CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED OR CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED OR CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED THEN
        ' Never show arrow for these tools
        show_arrow% = FALSE
    ELSEIF CURRENT_TOOL% = TOOL_BRUSH OR CURRENT_TOOL% = TOOL_DOT THEN
        ' For brush/dot, only show if preview is enabled and not painting
        IF BRUSH_SIZE.PREVIEW AND NOT is_painting% THEN
            show_arrow% = TRUE
        END IF
    ELSE
        ' For all other tools, show arrow
        show_arrow% = TRUE
    END IF
    
    IF show_arrow% THEN
        ' Use image if available, otherwise use DRAW string
        IF POINTER.USE_IMG% AND POINTER.IMG& <> 0 THEN
            _PUTIMAGE (mx% - POINTER.HOTSPOT_X%, my% - POINTER.HOTSPOT_Y%), POINTER.IMG&
        ELSE
            DIM s AS STRING
            s$ = "B" _
               + "M" _
               + ns$(mx%) _
               + "," _
               + ns$(my%) _
               + POINTER.S$
            DRAW s$
        END IF
    END IF
    
    _DEST oldDest&
END SUB


''
' Updates the pointer
' 
SUB POINTER_update ()
    POINTER.C~& = PAINT_COLOR~&
END SUB


''
' Loads PNG cursor for fill tool from ASSETS/THEMES/DEFAULT/CURSORS/paint.png
'
SUB POINTER_load_fill_cursor ()
    DIM cursor_path AS STRING
    cursor_path$ = "ASSETS/THEMES/DEFAULT/CURSORS/paint.png"
    
    ' Check if file exists and load it
    IF _FILEEXISTS(cursor_path$) THEN
        ' Free old image if exists
        IF POINTER.IMG& < -1 THEN _FREEIMAGE POINTER.IMG&
        
        ' Load the PNG
        POINTER.IMG& = _LOADIMAGE(cursor_path$, 32)
        
        IF POINTER.IMG& < -1 THEN
            POINTER.USE_IMG% = TRUE
            ' Set hotspot to bottom-center pixel of cursor (where paint pours)
            POINTER.HOTSPOT_X% = _WIDTH(POINTER.IMG&) \ 2
            POINTER.HOTSPOT_Y% = _HEIGHT(POINTER.IMG&) - 1
        ELSE
            POINTER.USE_IMG% = FALSE
            POINTER_build_fill_cursor_fallback
        END IF
    ELSE
        ' Fallback to DRAW string if PNG doesn't exist
        POINTER.USE_IMG% = FALSE
        POINTER_build_fill_cursor_fallback
    END IF
END SUB


''
' Builds fill tool cursor using DRAW string (fallback if PNG not found)
'
SUB POINTER_build_fill_cursor_fallback ()
    DIM outline AS LONG
    
    outline& = PAL_color(POINTER.O%)
    
    ' Simple paint bucket using DRAW - outline only
    POINTER.S$ = "C" + STR$(outline&) + "M+2,+2R6D4L2D2L2U2L2U4M+3,+1R2"
END SUB


''
' Draws dotted crosshair cursor for marquee tool
' - 8x8 dotted crosshair
' - Semi-transparent (33% opaque = 84/255 alpha)
' - White with black outline like brush cursor
'
SUB POINTER_draw_marquee_cursor ()
    DIM i AS INTEGER
    DIM mx AS INTEGER, my AS INTEGER
    DIM white_semi AS _UNSIGNED LONG
    DIM black_semi AS _UNSIGNED LONG
    
    ' Scale mouse coordinates from window to logical canvas
    mx% = _MOUSEX \ SCRN.displayScale%
    my% = _MOUSEY \ SCRN.displayScale%
    
    ' Semi-transparent colors (33% opaque = 84/255 alpha)
    white_semi~& = _RGBA32(255, 255, 255, 84)
    black_semi~& = _RGBA32(0, 0, 0, 84)
    
    ' Draw dotted horizontal line (8 pixels total, 4 pixels on each side)
    ' Black outline
    FOR i% = -4 TO 4 STEP 2
        IF i% <> 0 THEN ' Skip center
            PSET (mx% + i%, my% - 1), black_semi~&
            PSET (mx% + i%, my% + 1), black_semi~&
        END IF
    NEXT i%
    
    ' White dots
    FOR i% = -4 TO 4 STEP 2
        IF i% <> 0 THEN ' Skip center
            PSET (mx% + i%, my%), white_semi~&
        END IF
    NEXT i%
    
    ' Draw dotted vertical line (8 pixels total, 4 pixels on each side)
    ' Black outline
    FOR i% = -4 TO 4 STEP 2
        IF i% <> 0 THEN ' Skip center
            PSET (mx% - 1, my% + i%), black_semi~&
            PSET (mx% + 1, my% + i%), black_semi~&
        END IF
    NEXT i%
    
    ' White dots
    FOR i% = -4 TO 4 STEP 2
        IF i% <> 0 THEN ' Skip center
            PSET (mx%, my% + i%), white_semi~&
        END IF
    NEXT i%
    
    ' Draw center pixel (white with black outline)
    PSET (mx% - 1, my%), black_semi~&
    PSET (mx% + 1, my%), black_semi~&
    PSET (mx%, my% - 1), black_semi~&
    PSET (mx%, my% + 1), black_semi~&
    PSET (mx%, my%), white_semi~&
END SUB

''
' Draw I-beam cursor for text tool
'
SUB POINTER_draw_ibeam_cursor ()
    DIM mx AS INTEGER, my AS INTEGER
    DIM i AS INTEGER
    DIM white_c AS _UNSIGNED LONG, black_c AS _UNSIGNED LONG
    
    ' Scale mouse coordinates from window to logical canvas
    mx% = _MOUSEX \ SCRN.displayScale%
    my% = _MOUSEY \ SCRN.displayScale%
    
    ' Solid colors for I-beam
    white_c~& = _RGB32(255, 255, 255)
    black_c~& = _RGB32(0, 0, 0)
    
    ' I-beam cursor height (8 pixels by default, matches font height)
    DIM beam_height AS INTEGER
    beam_height = 8
    
    ' Draw vertical line
    LINE (mx%, my%)-(mx%, my% + beam_height - 1), white_c~&
    
    ' Draw top horizontal bar (3 pixels wide)
    LINE (mx% - 1, my%)-(mx% + 1, my%), white_c~&
    
    ' Draw bottom horizontal bar (3 pixels wide)
    LINE (mx% - 1, my% + beam_height - 1)-(mx% + 1, my% + beam_height - 1), white_c~&
END SUB

