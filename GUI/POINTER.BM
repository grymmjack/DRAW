''
' DRAW - GUI/POINTER.BM
' =============================================================================
' Pointer subs and functions.
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initializes the pointer
' 
SUB POINTER_init ()
    _MOUSEHIDE
    POINTER.W%  = 4
    POINTER.H%  = 4
    POINTER.C~& = PAL_color(4)  ' Default to red (EGA color 4)
    POINTER.O%  = 7
    POINTER.OC~& = POINTER.C~&
    POINTER.CURSOR_ID% = CURSOR_NULL
    POINTER.CURSOR_FLIP% = 0
    POINTER.PREV_DRAW_X% = -9999
    POINTER.PREV_DRAW_Y% = -9999
    CURSOR_init
    IF SCRN.w& > 640 THEN 
        POINTER.W% = POINTER.W% * 2
        POINTER.H% = POINTER.H% * 2
    END IF
END SUB


''
' Render the pointer
' 
SUB POINTER_render ()
    IF POINTER.HIDDEN THEN EXIT SUB
    POINTER_build
    POINTER_draw
END SUB


''
' Hide the custom pointer before opening a native dialog.
' Renders one frame without the pointer, waits briefly so the
' user sees the pointer disappear, then shows the system cursor.
'
SUB POINTER_hide_for_dialog ()
    POINTER.HIDDEN = TRUE
    ' Render a frame so the custom pointer vanishes on-screen
    SCREEN_render
    ' Brief delay so the pointerless frame is visible before
    ' the OS dialog steals focus and backgrounds QB64PE
    _DELAY 0.15
    _MOUSESHOW
END SUB


''
' Restore the custom pointer after a native dialog closes.
' Hides the system cursor and re-enables custom pointer rendering.
'
SUB POINTER_show_after_dialog ()
    _MOUSEHIDE
    POINTER.HIDDEN = FALSE
    ' Reset to null (arrow) cursor after dialog so the tool-specific
    ' cursor doesn't flash before the user moves the mouse
    POINTER.CURSOR_ID% = CURSOR_NULL
END SUB


''
' Builds the pointer
' 
SUB POINTER_build ()
    DIM mx AS INTEGER, my AS INTEGER
    DIM AS INTEGER TB_RIGHT, TB_LEFT
    
    ' Calculate toolbar position dynamically to align to right edge of screen
    TB_RIGHT = SCRN.w& - TB_BTN_W - 1  ' Right column: 1px from right edge
    TB_LEFT = TB_RIGHT - TB_BTN_W - TB_BTN_PADDING  ' Left column: to the left of right column
    
    ' Scale mouse coordinates from window to logical canvas
    mx% = _MOUSEX
    my% = _MOUSEY
    
    ' --- UI area checks: use null (arrow) cursor ---
    
    ' Check if mouse is over toolbar area
    IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(mx%, my%) THEN
        POINTER.CURSOR_ID% = CURSOR_NULL
        EXIT SUB
    END IF
    
    ' Check if mouse is over layer panel
    IF LAYER_PANEL.visible% AND mx% < CFG.LAYER_PANEL_WIDTH% THEN
        POINTER.CURSOR_ID% = CURSOR_NULL
        EXIT SUB
    END IF
    
    ' Check if mouse is over menu bar area (top MENU_BAR_HEIGHT pixels in the bar region)
    IF SCRN.showMenubar% AND MENU_BAR.visible% THEN
        IF my% < MENU_BAR_HEIGHT AND mx% >= MENU_BAR.barX% THEN
            POINTER.CURSOR_ID% = CURSOR_NULL
            EXIT SUB
        END IF
        ' Check if submenu is open and mouse is over it
        IF MENUBAR_submenu_in_bounds%(mx%, my%) THEN
            POINTER.CURSOR_ID% = CURSOR_NULL
            EXIT SUB
        END IF
    END IF

    ' Check if mouse is over status bar or palette strip
    IF SCRN.showStatus% THEN
        DIM strip_top_build AS INTEGER
        strip_top_build% = SCRN.h& - THEME.STATUS_height% - PALETTE_STRIP_get_height%
        IF my% >= strip_top_build% THEN
            POINTER.CURSOR_ID% = CURSOR_NULL
            EXIT SUB
        END IF
    END IF
    
    ' Check if palette menu is visible
    IF PALETTE_MENU_VISIBLE% THEN
        POINTER.CURSOR_ID% = CURSOR_NULL
        EXIT SUB
    END IF
    
    ' Check if NULL tool is active
    IF CURRENT_TOOL% = TOOL_NULL THEN
        POINTER.CURSOR_ID% = CURSOR_NULL
        EXIT SUB
    END IF
    
    ' --- Pan mode: use hand cursor ---
    ' Block spacebar pan cursor when text tool is active (SPACE needed for typing)
    DIM allowSpacePanCursor AS INTEGER
    allowSpacePanCursor% = NOT (CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE)
    
    IF (_KEYDOWN(32) AND allowSpacePanCursor%) OR _MOUSEBUTTON(3) THEN ' Spacebar or MMB - pan mode
        POINTER.CURSOR_ID% = CURSOR_HAND
        EXIT SUB
    END IF
    
    ' --- Tool-specific cursors ---
    
    ' Pan tool
    IF CURRENT_TOOL% = TOOL_PAN THEN
        POINTER.CURSOR_ID% = CURSOR_HAND
        EXIT SUB
    END IF
    
    ' Zoom tool
    IF CURRENT_TOOL% = TOOL_ZOOM THEN
        POINTER.CURSOR_ID% = CURSOR_ZOOM
        EXIT SUB
    END IF
    
    ' Fill tool
    IF CURRENT_TOOL% = TOOL_FILL THEN
        POINTER.CURSOR_ID% = CURSOR_FILL
        EXIT SUB
    END IF
    
    ' Picker / Dropper tool
    IF CURRENT_TOOL% = TOOL_PICKER THEN
        POINTER.CURSOR_ID% = CURSOR_DROPPER
        EXIT SUB
    END IF
    
    ' Marquee tool (or magic wand mode) - with resize cursor support
    IF CURRENT_TOOL% = TOOL_MARQUEE THEN
        POINTER.CURSOR_FLIP% = 0  ' Reset flip
        IF MARQUEE.MAGIC_WAND_MODE% THEN
            POINTER.CURSOR_ID% = CURSOR_WAND
        ELSEIF MARQUEE.RESIZING% THEN
            ' Currently dragging a resize handle
            SELECT CASE MARQUEE.RESIZE_HANDLE%
                CASE 1  ' TL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 0
                CASE 3  ' TR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 1
                CASE 8  ' BR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 3
                CASE 6  ' BL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 2
                CASE 2, 7  ' Top/Bottom edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_VERT
                CASE 4, 5  ' Left/Right edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_HORIZ
                CASE ELSE
                    POINTER.CURSOR_ID% = CURSOR_MARQUEE
            END SELECT
        ELSEIF MARQUEE.ACTIVE% THEN
            ' Hover detection over handles
            DIM marq_hover AS INTEGER
            marq_hover% = MARQUEE_get_handle_at%(MOUSE.X%, MOUSE.Y%)
            SELECT CASE marq_hover%
                CASE 1  ' TL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 0
                CASE 3  ' TR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 1
                CASE 8  ' BR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 3
                CASE 6  ' BL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 2
                CASE 2, 7  ' Top/Bottom edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_VERT
                CASE 4, 5  ' Left/Right edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_HORIZ
                CASE ELSE
                    POINTER.CURSOR_ID% = CURSOR_MARQUEE
            END SELECT
        ELSE
            POINTER.CURSOR_ID% = CURSOR_MARQUEE
        END IF
        EXIT SUB
    END IF
    
    ' Move tool - pick cursor based on handle being hovered/dragged
    IF CURRENT_TOOL% = TOOL_MOVE THEN
        POINTER.CURSOR_FLIP% = 0  ' Reset flip
        IF MOVE.ACTIVE AND MOVE.TRANSFORMING THEN
            ' Currently dragging a handle - cursor based on MOVE.HANDLE
            SELECT CASE MOVE.HANDLE
                CASE 0  ' Center - move
                    POINTER.CURSOR_ID% = CURSOR_MOVE
                CASE 1  ' TL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 0  ' No flip (default orientation)
                CASE 2  ' TR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 1  ' Flip horizontal
                CASE 3  ' BR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 3  ' Flip both
                CASE 4  ' BL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 2  ' Flip vertical
                CASE 5, 7  ' Top/Bottom edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_VERT
                CASE 6, 8  ' Right/Left edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_HORIZ
                CASE ELSE
                    POINTER.CURSOR_ID% = CURSOR_MOVE
            END SELECT
        ELSEIF MOVE.ACTIVE AND MARQUEE.ACTIVE% THEN
            ' Selection exists - check which handle mouse is hovering
            DIM hover_handle AS INTEGER
            hover_handle% = MARQUEE_get_handle_at%(MOUSE.X%, MOUSE.Y%)
            SELECT CASE hover_handle%
                CASE 0  ' No handle / interior
                    POINTER.CURSOR_ID% = CURSOR_MOVE
                CASE 1  ' TL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 0
                CASE 3  ' TR corner (MARQUEE numbering)
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 1
                CASE 8  ' BR corner (MARQUEE numbering)
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 3
                CASE 6  ' BL corner (MARQUEE numbering)
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 2
                CASE 2, 7  ' Top/Bottom edge (MARQUEE numbering)
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_VERT
                CASE 4, 5  ' Left/Right edge (MARQUEE numbering)
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_HORIZ
                CASE ELSE
                    POINTER.CURSOR_ID% = CURSOR_MOVE
            END SELECT
        ELSE
            POINTER.CURSOR_ID% = CURSOR_MOVE
        END IF
        EXIT SUB
    END IF
    
    ' Text tool - keep procedural I-beam (no PNG for this)
    IF CURRENT_TOOL% = TOOL_TEXT THEN
        POINTER.CURSOR_ID% = -1  ' No PNG cursor, use procedural
        EXIT SUB
    END IF
    
    ' Line/Polygon/Rect/Ellipse tools - keep procedural crosshair (no PNG for these)
    IF CURRENT_TOOL% = TOOL_LINE OR CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED OR CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED OR CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED THEN
        POINTER.CURSOR_ID% = -1  ' No PNG cursor, use procedural
        EXIT SUB
    END IF
    
    ' Brush / Dot tool - use brush cursor when showing arrow, procedural for brush preview
    IF CURRENT_TOOL% = TOOL_BRUSH OR CURRENT_TOOL% = TOOL_DOT THEN
        POINTER.CURSOR_ID% = CURSOR_BRUSH
        EXIT SUB
    END IF
    
    ' Pan tool - use hand cursor
    IF CURRENT_TOOL% = TOOL_PAN THEN
        POINTER.CURSOR_ID% = CURSOR_HAND
        EXIT SUB
    END IF
    
    ' Spray tool - use spray cursor
    IF CURRENT_TOOL% = TOOL_SPRAY THEN
        POINTER.CURSOR_ID% = CURSOR_SPRAY
        EXIT SUB
    END IF
    
    ' Crop tool - use marquee cursor
    IF CURRENT_TOOL% = TOOL_CROP THEN
        POINTER.CURSOR_ID% = CURSOR_MARQUEE
        EXIT SUB
    END IF
    
    ' Default fallback - crosshair/square
    POINTER.CURSOR_ID% = -1  ' procedural default
    POINTER.S$ = "C" + STR$(PAL_color(POINTER.O%)) _
              + "D"  + ns$(POINTER.H%) _ 
              + "R"  + ns$(POINTER.W%) _ 
              + "H"  + ns$(POINTER.H%) _ 
              + "B" _
              + "M+" + ns$(POINTER.W%\2) _
              + ",+" + ns$(POINTER.H%) _
              + "F"  + ns$(POINTER.W%\2)
    IF POINTER.C~& <> 0 THEN 'fill POINTER if not 0 else color is black do not.
        POINTER.S$ = POINTER.S$ _
                  + "B" _
                  + "M-" + ns$(POINTER.W%\2) _
                  + ",-" + ns$(POINTER.H% - 1) _
                  + "P"  + STR$(POINTER.C~&) _
                  + ","  + STR$(PAL_color(POINTER.O%))
    END IF
END SUB


''
' Draws the pointer
' 
SUB POINTER_draw ()
    DIM oldDest AS LONG
    DIM radius AS INTEGER
    DIM is_painting AS INTEGER
    DIM mx AS INTEGER, my AS INTEGER
    DIM cx AS INTEGER, cy AS INTEGER
    DIM dist_sq AS SINGLE, r_sq AS SINGLE
    DIM r AS INTEGER, g AS INTEGER, b AS INTEGER
    DIM AS INTEGER TB_RIGHT, TB_LEFT
    
    ' Calculate toolbar position dynamically to align to right edge of screen
    TB_RIGHT = SCRN.w& - TB_BTN_W - 1  ' Right column: 1px from right edge
    TB_LEFT = TB_RIGHT - TB_BTN_W - TB_BTN_PADDING  ' Left column: to the left of right column
    
    oldDest& = _DEST 
    _DEST SCRN.CANVAS&
    _BLEND SCRN.CANVAS&
    
    ' Get mouse position (scaled from window to logical canvas)
    mx% = _MOUSEX
    my% = _MOUSEY
    
    ' =========================================================================
    ' Panning mode - draw hand PNG cursor or fallback
    ' =========================================================================
    IF SCRN.panning% THEN
        IF CURSORS(CURSOR_HAND).img& < -1 THEN
            ' Use PNG hand cursor
            _PUTIMAGE (mx% - CURSORS(CURSOR_HAND).hotspot_pos_x%, my% - CURSORS(CURSOR_HAND).hotspot_pos_y%), CURSORS(CURSOR_HAND).img&, SCRN.CANVAS&
            CURSOR_render_overlays CURSOR_HAND, mx% - CURSORS(CURSOR_HAND).hotspot_pos_x%, my% - CURSORS(CURSOR_HAND).hotspot_pos_y%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
        ELSE
            ' Fallback: procedural hand cursor
            LINE (mx% - 3, my% + 2)-(mx% + 3, my% + 6), _RGB32(255, 255, 255), BF
            LINE (mx% - 2, my% + 1)-(mx% + 2, my% + 1), _RGB32(255, 255, 255)
            LINE (mx% - 2, my% - 3)-(mx% - 2, my% + 1), _RGB32(255, 255, 255)
            LINE (mx%, my% - 4)-(mx%, my% + 1), _RGB32(255, 255, 255)
            LINE (mx% + 2, my% - 3)-(mx% + 2, my% + 1), _RGB32(255, 255, 255)
            LINE (mx% - 4, my% + 2)-(mx% - 4, my% + 4), _RGB32(255, 255, 255)
            LINE (mx% - 4, my% + 1)-(mx% - 4, my% + 5), _RGB32(0, 0, 0)
            LINE (mx% - 3, my%)-(mx% + 3, my%), _RGB32(0, 0, 0)
            LINE (mx% + 4, my% + 1)-(mx% + 4, my% + 7), _RGB32(0, 0, 0)
            LINE (mx% - 4, my% + 7)-(mx% + 4, my% + 7), _RGB32(0, 0, 0)
        END IF
        _DEST oldDest&
        EXIT SUB
    END IF

    ' =========================================================================
    ' UI area checks: toolbar, layer panel, status bar, palette menu, NULL tool
    ' Use PNG null cursor (arrow) or fallback procedural arrow
    ' =========================================================================
    DIM use_ui_cursor AS INTEGER
    use_ui_cursor% = FALSE

    IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(mx%, my%) THEN use_ui_cursor% = TRUE
    IF NOT use_ui_cursor% AND LAYER_PANEL.visible% AND mx% < CFG.LAYER_PANEL_WIDTH% THEN use_ui_cursor% = TRUE
    ' Check menu bar area
    IF NOT use_ui_cursor% AND SCRN.showMenubar% AND MENU_BAR.visible% THEN
        IF my% < MENU_BAR_HEIGHT AND mx% >= MENU_BAR.barX% THEN use_ui_cursor% = TRUE
        IF NOT use_ui_cursor% AND MENUBAR_submenu_in_bounds%(mx%, my%) THEN use_ui_cursor% = TRUE
    END IF
    IF NOT use_ui_cursor% AND SCRN.showStatus% THEN
        DIM strip_top AS INTEGER
        strip_top% = SCRN.h& - THEME.STATUS_height% - PALETTE_STRIP_get_height%
        IF my% >= strip_top% THEN use_ui_cursor% = TRUE
    END IF
    IF NOT use_ui_cursor% AND PALETTE_MENU_VISIBLE% THEN use_ui_cursor% = TRUE
    IF NOT use_ui_cursor% AND CURRENT_TOOL% = TOOL_NULL THEN use_ui_cursor% = TRUE

    IF use_ui_cursor% THEN
        IF CURSORS(CURSOR_NULL).img& < -1 THEN
            ' Use PNG null/arrow cursor
            _PUTIMAGE (mx% - CURSORS(CURSOR_NULL).hotspot_pos_x%, my% - CURSORS(CURSOR_NULL).hotspot_pos_y%), CURSORS(CURSOR_NULL).img&, SCRN.CANVAS&
            CURSOR_render_overlays CURSOR_NULL, mx% - CURSORS(CURSOR_NULL).hotspot_pos_x%, my% - CURSORS(CURSOR_NULL).hotspot_pos_y%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
        ELSE
            ' Fallback: procedural arrow cursor (no PAINT, alpha-safe)
            DIM arr_i AS INTEGER
            FOR arr_i% = 0 TO 10
                DIM arr_w AS INTEGER
                IF arr_i% <= 7 THEN
                    arr_w% = arr_i%
                ELSE
                    arr_w% = 3
                END IF
                ' Black outline
                IF arr_i% <= 7 THEN
                    LINE (mx%, my% + arr_i%)-(mx% + arr_w% + 1, my% + arr_i%), _RGB32(0, 0, 0)
                ELSE
                    LINE (mx%, my% + arr_i%)-(mx% + arr_w% + 1, my% + arr_i%), _RGB32(0, 0, 0)
                END IF
            NEXT arr_i%
            ' White interior fill
            FOR arr_i% = 1 TO 9
                IF arr_i% <= 6 THEN
                    arr_w% = arr_i% - 1
                ELSE
                    arr_w% = 2
                END IF
                IF arr_w% >= 1 THEN
                    LINE (mx% + 1, my% + arr_i%)-(mx% + arr_w%, my% + arr_i%), _RGB32(255, 255, 255)
                END IF
            NEXT arr_i%
        END IF
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' =========================================================================
    ' Custom brush active - draw the brush at cursor position
    ' =========================================================================
    IF CUSTOM_BRUSH_is_active% THEN
        DIM brush_x AS INTEGER, brush_y AS INTEGER
        DIM scaled_w AS INTEGER, scaled_h AS INTEGER
        
        scaled_w% = CUSTOM_BRUSH.WIDTH% * CUSTOM_BRUSH.SCALE! * SCRN.zoom!
        scaled_h% = CUSTOM_BRUSH.HEIGHT% * CUSTOM_BRUSH.SCALE! * SCRN.zoom!
        
        brush_x% = mx% - scaled_w% \ 2
        brush_y% = my% - scaled_h% \ 2
        
        CUSTOM_BRUSH_render_scaled brush_x%, brush_y%, SCRN.CANVAS&, SCRN.zoom!
        
        IF CUSTOM_BRUSH.SHOW_OUTLINE% THEN
            DIM outline_x1 AS INTEGER, outline_y1 AS INTEGER
            DIM outline_x2 AS INTEGER, outline_y2 AS INTEGER
            outline_x1% = brush_x%
            outline_y1% = brush_y%
            outline_x2% = brush_x% + scaled_w% - 1
            outline_y2% = brush_y% + scaled_h% - 1
            
            LINE (outline_x1% - 1, outline_y1% - 1)-(outline_x2% + 1, outline_y2% + 1), _RGBA32(0, 0, 0, 128), B
            LINE (outline_x1%, outline_y1%)-(outline_x2%, outline_y2%), _RGBA32(255, 255, 255, 200), B
        END IF
        
        LINE (mx% - 3, my%)-(mx% - 1, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx% + 1, my%)-(mx% + 3, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% - 3)-(mx%, my% - 1), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% + 1)-(mx%, my% + 3), _RGBA32(255, 255, 255, 240)
        PSET (mx%, my%), _RGBA32(255, 0, 0, 255)
        
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' Check if currently painting (mouse button 1 down)
    is_painting% = (_MOUSEBUTTON(1) <> 0)
    
    ' =========================================================================
    ' Line/Polygon/Rect/Ellipse tools - procedural X-shaped crosshair
    ' =========================================================================
    IF CURRENT_TOOL% = TOOL_LINE OR CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED OR CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED OR CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED THEN
        ' Diagonal lines forming an X - black outline for visibility
        LINE (mx% - 7, my% - 8)-(mx% - 2, my% - 3), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 8, my% - 7)-(mx% - 3, my% - 2), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 2, my% + 3)-(mx% + 7, my% + 8), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 3, my% + 2)-(mx% + 8, my% + 7), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 7, my% - 7)-(mx% - 2, my% - 2), _RGBA32(255, 255, 255, 240)
        LINE (mx% + 2, my% + 2)-(mx% + 7, my% + 7), _RGBA32(255, 255, 255, 240)
        
        LINE (mx% + 7, my% - 8)-(mx% + 2, my% - 3), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 8, my% - 7)-(mx% + 3, my% - 2), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 2, my% + 3)-(mx% - 7, my% + 8), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 3, my% + 2)-(mx% - 8, my% + 7), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 7, my% - 7)-(mx% + 2, my% - 2), _RGBA32(255, 255, 255, 240)
        LINE (mx% - 2, my% + 2)-(mx% - 7, my% + 7), _RGBA32(255, 255, 255, 240)
        
        r% = _RED32(PAINT_COLOR~&)
        g% = _GREEN32(PAINT_COLOR~&)
        b% = _BLUE32(PAINT_COLOR~&)
        PSET (mx%, my%), _RGBA32(r%, g%, b%, 180)
        PSET (mx% - 1, my%), _RGBA32(r%, g%, b%, 120)
        PSET (mx% + 1, my%), _RGBA32(r%, g%, b%, 120)
        PSET (mx%, my% - 1), _RGBA32(r%, g%, b%, 120)
        PSET (mx%, my% + 1), _RGBA32(r%, g%, b%, 120)
    END IF
    
    ' =========================================================================
    ' Picker tool - PNG dropper cursor or procedural crosshair fallback
    ' =========================================================================
    IF CURRENT_TOOL% = TOOL_PICKER THEN
        IF CURSORS(CURSOR_DROPPER).img& < -1 THEN
            _PUTIMAGE (mx% - CURSORS(CURSOR_DROPPER).hotspot_pos_x%, my% - CURSORS(CURSOR_DROPPER).hotspot_pos_y%), CURSORS(CURSOR_DROPPER).img&, SCRN.CANVAS&
            CURSOR_render_overlays CURSOR_DROPPER, mx% - CURSORS(CURSOR_DROPPER).hotspot_pos_x%, my% - CURSORS(CURSOR_DROPPER).hotspot_pos_y%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
        ELSE
            ' Fallback: procedural crosshair
            LINE (mx% - 9, my% - 1)-(mx% - 2, my% - 1), _RGBA32(0, 0, 0, 180)
            LINE (mx% - 9, my% + 1)-(mx% - 2, my% + 1), _RGBA32(0, 0, 0, 180)
            LINE (mx% + 2, my% - 1)-(mx% + 9, my% - 1), _RGBA32(0, 0, 0, 180)
            LINE (mx% + 2, my% + 1)-(mx% + 9, my% + 1), _RGBA32(0, 0, 0, 180)
            LINE (mx% - 9, my%)-(mx% - 2, my%), _RGBA32(255, 255, 255, 240)
            LINE (mx% + 2, my%)-(mx% + 9, my%), _RGBA32(255, 255, 255, 240)
            
            LINE (mx% - 1, my% - 9)-(mx% - 1, my% - 2), _RGBA32(0, 0, 0, 180)
            LINE (mx% + 1, my% - 9)-(mx% + 1, my% - 2), _RGBA32(0, 0, 0, 180)
            LINE (mx% - 1, my% + 2)-(mx% + 1, my% + 9), _RGBA32(0, 0, 0, 180)
            LINE (mx% + 1, my% + 2)-(mx% + 1, my% + 9), _RGBA32(0, 0, 0, 180)
            LINE (mx%, my% - 9)-(mx%, my% - 2), _RGBA32(255, 255, 255, 240)
            LINE (mx%, my% + 2)-(mx%, my% + 9), _RGBA32(255, 255, 255, 240)
        END IF
    END IF
    
    ' =========================================================================
    ' Brush / Dot tool - procedural brush preview (keeps functional preview logic)
    ' =========================================================================
    IF CURRENT_TOOL% = TOOL_BRUSH OR CURRENT_TOOL% = TOOL_DOT THEN
        DIM pixel_size AS INTEGER, half AS INTEGER
        pixel_size% = INT(BRUSH_SIZE_pixels% * SCRN.zoom!)
        IF pixel_size% < 1 THEN pixel_size% = 1
        
        IF BRUSH_SIZE.PREVIEW THEN
            IF BRUSH_SIZE.SHAPE = 0 THEN
                radius% = pixel_size% \ 2
                CIRCLE (mx%, my%), radius% + 1, _RGBA32(32, 32, 32, 84)
                CIRCLE (mx%, my%), radius%, _RGBA32(255, 255, 255, 84)
                
                r% = _RED32(PAINT_COLOR~&)
                g% = _GREEN32(PAINT_COLOR~&)
                b% = _BLUE32(PAINT_COLOR~&)
                DIM fill_c AS _UNSIGNED LONG
                fill_c~& = _RGBA32(r%, g%, b%, 120)
                ' Scanline circle fill: O(n) LINEs instead of O(n^2) PSETs
                r_sq! = (radius% - 0.5) * (radius% - 0.5)
                FOR cy% = my% - radius% TO my% + radius%
                    DIM dy_sq AS SINGLE
                    DIM scan_w AS INTEGER
                    dy_sq! = (cy% - my%) * (cy% - my%)
                    IF dy_sq! > r_sq! THEN _CONTINUE
                    scan_w% = INT(SQR(r_sq! - dy_sq!))
                    IF BRUSH_DITHER_ACTIVE > 0 THEN
                        FOR cx% = mx% - scan_w% TO mx% + scan_w%
                            IF BRUSH_DITHERS_should_draw%(cx%, cy%) THEN
                                PSET (cx%, cy%), fill_c~&
                            END IF
                        NEXT cx%
                    ELSE
                        LINE (mx% - scan_w%, cy%)-(mx% + scan_w%, cy%), fill_c~&
                    END IF
                NEXT cy%
            ELSE
                half% = pixel_size% \ 2
                LINE (mx% - half% - 1, my% - half% - 1)-(mx% + half% + 1, my% + half% + 1), _RGBA32(32, 32, 32, 84), B
                LINE (mx% - half%, my% - half%)-(mx% + half%, my% + half%), _RGBA32(255, 255, 255, 84), B
                
                r% = _RED32(PAINT_COLOR~&)
                g% = _GREEN32(PAINT_COLOR~&)
                b% = _BLUE32(PAINT_COLOR~&)
                IF BRUSH_DITHER_ACTIVE > 0 THEN
                    FOR cy% = my% - half% TO my% + half%
                        FOR cx% = mx% - half% TO mx% + half%
                            IF BRUSH_DITHERS_should_draw%(cx%, cy%) THEN
                                PSET (cx%, cy%), _RGBA32(r%, g%, b%, 120)
                            END IF
                        NEXT cx%
                    NEXT cy%
                ELSE
                    LINE (mx% - half%, my% - half%)-(mx% + half%, my% + half%), _RGBA32(r%, g%, b%, 120), BF
                END IF
            END IF
            
            IF NOT is_painting% THEN
                LINE (mx% - 3, my%)-(mx% + 3, my%), _RGBA32(32, 32, 32, 84)
                LINE (mx%, my% - 3)-(mx%, my% + 3), _RGBA32(32, 32, 32, 84)
                LINE (mx% - 2, my%)-(mx% + 2, my%), _RGBA32(255, 255, 255, 84)
                LINE (mx%, my% - 2)-(mx%, my% + 2), _RGBA32(255, 255, 255, 84)
            END IF
        ELSE
            IF pixel_size% = 1 THEN
                PSET (mx%, my%), _RGBA32(255, 255, 255, 128)
                PSET (mx% - 1, my%), _RGBA32(0, 0, 0, 64)
                PSET (mx% + 1, my%), _RGBA32(0, 0, 0, 64)
                PSET (mx%, my% - 1), _RGBA32(0, 0, 0, 64)
                PSET (mx%, my% + 1), _RGBA32(0, 0, 0, 64)
            ELSEIF pixel_size% = 3 AND BRUSH_SIZE.SHAPE = 0 THEN
                LINE (mx%, my% - 1)-(mx%, my% + 1), PAINT_COLOR~&
                LINE (mx% - 1, my%)-(mx% + 1, my%), PAINT_COLOR~&
            ELSE
                IF BRUSH_SIZE.SHAPE = 0 THEN
                    ' Scanline circle fill (no-preview mode)
                    radius% = pixel_size% \ 2
                    r_sq! = (radius% - 0.5) * (radius% - 0.5)
                    FOR cy% = my% - radius% TO my% + radius%
                        DIM dy_sq2 AS SINGLE
                        DIM scan_w2 AS INTEGER
                        dy_sq2! = (cy% - my%) * (cy% - my%)
                        IF dy_sq2! > r_sq! THEN _CONTINUE
                        scan_w2% = INT(SQR(r_sq! - dy_sq2!))
                        LINE (mx% - scan_w2%, cy%)-(mx% + scan_w2%, cy%), PAINT_COLOR~&
                    NEXT cy%
                ELSE
                    half% = pixel_size% \ 2
                    LINE (mx% - half%, my% - half%)-(mx% + half%, my% + half%), PAINT_COLOR~&, BF
                END IF
            END IF
        END IF
    END IF
    
    ' =========================================================================
    ' Spray tool - procedural spray preview (circle outline + dot pattern)
    ' =========================================================================
    IF CURRENT_TOOL% = TOOL_SPRAY THEN
        DIM spray_radius AS INTEGER
        DIM spray_pixel_size AS INTEGER
        DIM spray_r AS INTEGER, spray_g AS INTEGER, spray_b AS INTEGER
        DIM spray_cx AS INTEGER, spray_cy AS INTEGER
        DIM spray_dist_sq AS SINGLE, spray_r_sq AS SINGLE
        DIM spray_density AS INTEGER
        
        ' Get radius from brush size system (same as SPRAY_on uses)
        spray_pixel_size% = INT(BRUSH_PIXEL_SIZES(BRUSH_SIZE.CURRENT) * SCRN.zoom!)
        IF spray_pixel_size% < 1 THEN spray_pixel_size% = 1
        spray_radius% = spray_pixel_size% \ 2
        IF spray_radius% < 1 THEN spray_radius% = 1
        
        ' Draw circle outline (dark + light for visibility)
        CIRCLE (mx%, my%), spray_radius% + 1, _RGBA32(32, 32, 32, 84)
        CIRCLE (mx%, my%), spray_radius%, _RGBA32(255, 255, 255, 84)
        
        ' Draw preview dot pattern inside the circle using FG color
        spray_r% = _RED32(PAINT_COLOR~&)
        spray_g% = _GREEN32(PAINT_COLOR~&)
        spray_b% = _BLUE32(PAINT_COLOR~&)
        
        ' Static dot pattern preview (fixed seed for stable appearance)
        ' Show approximate density dots in the foreground color
        spray_density% = INT(spray_radius% * spray_radius% * 0.15) + 3
        IF spray_density% > 50 THEN spray_density% = 50
        
        ' Use a deterministic pattern based on position so preview doesn't flicker
        spray_r_sq! = (spray_radius% - 0.5) * (spray_radius% - 0.5)
        DIM spray_step AS INTEGER
        spray_step% = INT(SQR(3.14159 * spray_r_sq! / spray_density%))
        IF spray_step% < 1 THEN spray_step% = 1
        
        FOR spray_cy% = my% - spray_radius% TO my% + spray_radius% STEP spray_step%
            FOR spray_cx% = mx% - spray_radius% TO mx% + spray_radius% STEP spray_step%
                spray_dist_sq! = (spray_cx% - mx%) * (spray_cx% - mx%) + (spray_cy% - my%) * (spray_cy% - my%)
                IF spray_dist_sq! <= spray_r_sq! THEN
                    PSET (spray_cx%, spray_cy%), _RGBA32(spray_r%, spray_g%, spray_b%, 120)
                END IF
            NEXT spray_cx%
        NEXT spray_cy%
        
        ' Draw center crosshair when not painting
        IF NOT is_painting% THEN
            LINE (mx% - 3, my%)-(mx% + 3, my%), _RGBA32(32, 32, 32, 84)
            LINE (mx%, my% - 3)-(mx%, my% + 3), _RGBA32(32, 32, 32, 84)
            LINE (mx% - 2, my%)-(mx% + 2, my%), _RGBA32(255, 255, 255, 84)
            LINE (mx%, my% - 2)-(mx%, my% + 2), _RGBA32(255, 255, 255, 84)
        END IF
    END IF
    
    ' =========================================================================
    ' Marquee tool - PNG cursor with resize handle support or procedural fallback
    ' =========================================================================
    IF CURRENT_TOOL% = TOOL_MARQUEE THEN
        DIM marq_cursor_id AS INTEGER
        marq_cursor_id% = POINTER.CURSOR_ID%
        IF marq_cursor_id% >= 0 AND marq_cursor_id% <= CURSOR_COUNT AND CURSORS(marq_cursor_id%).img& < -1 THEN
            ' Render PNG cursor with optional flip
            DIM mq_dx AS INTEGER, mq_dy AS INTEGER
            DIM mq_w AS INTEGER, mq_h AS INTEGER
            mq_w% = CURSORS(marq_cursor_id%).w%
            mq_h% = CURSORS(marq_cursor_id%).h%
            mq_dx% = mx% - CURSORS(marq_cursor_id%).hotspot_pos_x%
            mq_dy% = my% - CURSORS(marq_cursor_id%).hotspot_pos_y%
            SELECT CASE POINTER.CURSOR_FLIP%
                CASE 1  ' Flip horizontal
                    _PUTIMAGE (mq_dx% + mq_w% - 1, mq_dy%)-(mq_dx%, mq_dy% + mq_h% - 1), CURSORS(marq_cursor_id%).img&, SCRN.CANVAS&
                CASE 2  ' Flip vertical
                    _PUTIMAGE (mq_dx%, mq_dy% + mq_h% - 1)-(mq_dx% + mq_w% - 1, mq_dy%), CURSORS(marq_cursor_id%).img&, SCRN.CANVAS&
                CASE 3  ' Flip both
                    _PUTIMAGE (mq_dx% + mq_w% - 1, mq_dy% + mq_h% - 1)-(mq_dx%, mq_dy%), CURSORS(marq_cursor_id%).img&, SCRN.CANVAS&
                CASE ELSE  ' No flip
                    _PUTIMAGE (mq_dx%, mq_dy%), CURSORS(marq_cursor_id%).img&, SCRN.CANVAS&
            END SELECT
            CURSOR_render_overlays marq_cursor_id%, mq_dx%, mq_dy%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
        ELSE
            ' Fallback: procedural dotted crosshair
            POINTER_draw_marquee_cursor
        END IF
    END IF
    
    ' =========================================================================
    ' Move tool - PNG cursor with resize handles or procedural fallback
    ' =========================================================================
    IF CURRENT_TOOL% = TOOL_MOVE THEN
        DIM move_cid AS INTEGER
        move_cid% = POINTER.CURSOR_ID%
        IF move_cid% >= 0 AND move_cid% <= CURSOR_COUNT AND CURSORS(move_cid%).img& < -1 THEN
            ' Render PNG cursor with optional flip
            DIM mc_dx AS INTEGER, mc_dy AS INTEGER
            DIM mc_w AS INTEGER, mc_h AS INTEGER
            mc_w% = CURSORS(move_cid%).w%
            mc_h% = CURSORS(move_cid%).h%
            mc_dx% = mx% - CURSORS(move_cid%).hotspot_pos_x%
            mc_dy% = my% - CURSORS(move_cid%).hotspot_pos_y%
            SELECT CASE POINTER.CURSOR_FLIP%
                CASE 1  ' Flip horizontal
                    _PUTIMAGE (mc_dx% + mc_w% - 1, mc_dy%)-(mc_dx%, mc_dy% + mc_h% - 1), CURSORS(move_cid%).img&, SCRN.CANVAS&
                CASE 2  ' Flip vertical
                    _PUTIMAGE (mc_dx%, mc_dy% + mc_h% - 1)-(mc_dx% + mc_w% - 1, mc_dy%), CURSORS(move_cid%).img&, SCRN.CANVAS&
                CASE 3  ' Flip both
                    _PUTIMAGE (mc_dx% + mc_w% - 1, mc_dy% + mc_h% - 1)-(mc_dx%, mc_dy%), CURSORS(move_cid%).img&, SCRN.CANVAS&
                CASE ELSE  ' No flip
                    _PUTIMAGE (mc_dx%, mc_dy%), CURSORS(move_cid%).img&, SCRN.CANVAS&
            END SELECT
            CURSOR_render_overlays move_cid%, mc_dx%, mc_dy%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
        ELSE
            ' Fallback: procedural 4-directional move arrow
            DIM move_mx AS INTEGER, move_my AS INTEGER
            move_mx% = MOUSE.RAW_X%
            move_my% = MOUSE.RAW_Y%
            LINE (move_mx% - 1, move_my% - 6)-(move_mx% + 1, move_my% + 6), _RGB32(0, 0, 0), BF
            LINE (move_mx%, move_my% - 5)-(move_mx%, move_my% + 5), _RGB32(255, 255, 255)
            LINE (move_mx% - 6, move_my% - 1)-(move_mx% + 6, move_my% + 1), _RGB32(0, 0, 0), BF
            LINE (move_mx% - 5, move_my%)-(move_mx% + 5, move_my%), _RGB32(255, 255, 255)
            LINE (move_mx% - 3, move_my% - 4)-(move_mx%, move_my% - 7), _RGB32(0, 0, 0)
            LINE (move_mx% + 3, move_my% - 4)-(move_mx%, move_my% - 7), _RGB32(0, 0, 0)
            LINE (move_mx% - 2, move_my% - 4)-(move_mx%, move_my% - 6), _RGB32(255, 255, 255)
            LINE (move_mx% + 2, move_my% - 4)-(move_mx%, move_my% - 6), _RGB32(255, 255, 255)
            LINE (move_mx% - 3, move_my% + 4)-(move_mx%, move_my% + 7), _RGB32(0, 0, 0)
            LINE (move_mx% + 3, move_my% + 4)-(move_mx%, move_my% + 7), _RGB32(0, 0, 0)
            LINE (move_mx% - 2, move_my% + 4)-(move_mx%, move_my% + 6), _RGB32(255, 255, 255)
            LINE (move_mx% + 2, move_my% + 4)-(move_mx%, move_my% + 6), _RGB32(255, 255, 255)
            LINE (move_mx% - 4, move_my% - 3)-(move_mx% - 7, move_my%), _RGB32(0, 0, 0)
            LINE (move_mx% - 4, move_my% + 3)-(move_mx% - 7, move_my%), _RGB32(0, 0, 0)
            LINE (move_mx% - 4, move_my% - 2)-(move_mx% - 6, move_my%), _RGB32(255, 255, 255)
            LINE (move_mx% - 4, move_my% + 2)-(move_mx% - 6, move_my%), _RGB32(255, 255, 255)
            LINE (move_mx% + 4, move_my% - 3)-(move_mx% + 7, move_my%), _RGB32(0, 0, 0)
            LINE (move_mx% + 4, move_my% + 3)-(move_mx% + 7, move_my%), _RGB32(0, 0, 0)
            LINE (move_mx% + 4, move_my% - 2)-(move_mx% + 6, move_my%), _RGB32(255, 255, 255)
            LINE (move_mx% + 4, move_my% + 2)-(move_mx% + 6, move_my%), _RGB32(255, 255, 255)
        END IF
    END IF
    
    ' =========================================================================
    ' Text tool - procedural I-beam cursor (no PNG for this)
    ' =========================================================================
    IF CURRENT_TOOL% = TOOL_TEXT THEN
        POINTER_draw_ibeam_cursor
    END IF
    
    ' =========================================================================
    ' Fill tool - PNG fill cursor or procedural fallback
    ' =========================================================================
    IF CURRENT_TOOL% = TOOL_FILL THEN
        IF CURSORS(CURSOR_FILL).img& < -1 THEN
            _PUTIMAGE (mx% - CURSORS(CURSOR_FILL).hotspot_pos_x%, my% - CURSORS(CURSOR_FILL).hotspot_pos_y%), CURSORS(CURSOR_FILL).img&, SCRN.CANVAS&
            CURSOR_render_overlays CURSOR_FILL, mx% - CURSORS(CURSOR_FILL).hotspot_pos_x%, my% - CURSORS(CURSOR_FILL).hotspot_pos_y%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
        ELSE
            ' Fallback: procedural fill bucket
            DIM fill_s AS STRING
            fill_s$ = "B" + "M" + ns$(mx%) + "," + ns$(my%)
            fill_s$ = fill_s$ + "C" + STR$(PAL_color(POINTER.O%)) + "M+2,+2R6D4L2D2L2U2L2U4M+3,+1R2"
            DRAW fill_s$
        END IF
    END IF
    
    ' =========================================================================
    ' Brush/Dot tool arrow: show PNG brush cursor when in preview mode
    ' and not painting, or when no preview (show instead of brush shape)
    ' =========================================================================
    DIM show_arrow AS INTEGER
    show_arrow% = FALSE
    
    IF CURRENT_TOOL% = TOOL_PICKER OR CURRENT_TOOL% = TOOL_MARQUEE OR CURRENT_TOOL% = TOOL_MOVE OR CURRENT_TOOL% = TOOL_TEXT OR CURRENT_TOOL% = TOOL_LINE OR CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED OR CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED OR CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED OR CURRENT_TOOL% = TOOL_FILL THEN
        show_arrow% = FALSE
    ELSEIF CURRENT_TOOL% = TOOL_BRUSH OR CURRENT_TOOL% = TOOL_DOT THEN
        IF BRUSH_SIZE.PREVIEW AND NOT is_painting% THEN
            show_arrow% = TRUE
        END IF
    ELSEIF CURRENT_TOOL% = TOOL_SPRAY THEN
        IF NOT is_painting% THEN
            show_arrow% = TRUE
        END IF
    ELSE
        show_arrow% = TRUE
    END IF
    
    IF show_arrow% THEN
        IF CURRENT_TOOL% = TOOL_DOT OR CURRENT_TOOL% = TOOL_BRUSH THEN
            ' For brush/dot: try PNG brush cursor, fallback to procedural arrow with FG chip
            IF CURSORS(CURSOR_BRUSH).img& < -1 THEN
                _PUTIMAGE (mx% - CURSORS(CURSOR_BRUSH).hotspot_pos_x%, my% - CURSORS(CURSOR_BRUSH).hotspot_pos_y%), CURSORS(CURSOR_BRUSH).img&, SCRN.CANVAS&
                CURSOR_render_overlays CURSOR_BRUSH, mx% - CURSORS(CURSOR_BRUSH).hotspot_pos_x%, my% - CURSORS(CURSOR_BRUSH).hotspot_pos_y%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
            ELSE
                ' Fallback: procedural arrow with FG color chip
                DIM i AS INTEGER, lineEnd AS INTEGER
                LINE (mx%, my%)-(mx%, my% + 12), _RGB32(0, 0, 0)
                LINE (mx%, my%)-(mx% + 8, my% + 8), _RGB32(0, 0, 0)
                LINE (mx% + 8, my% + 8)-(mx% + 3, my% + 8), _RGB32(0, 0, 0)
                LINE (mx% + 3, my% + 8)-(mx% + 3, my% + 12), _RGB32(0, 0, 0)
                LINE (mx% + 3, my% + 12)-(mx%, my% + 12), _RGB32(0, 0, 0)
                LINE (mx% - 1, my%)-(mx% - 1, my% + 13), _RGB32(0, 0, 0)
                LINE (mx% + 4, my% + 13)-(mx% - 1, my% + 13), _RGB32(0, 0, 0)
                LINE (mx% + 4, my% + 8)-(mx% + 4, my% + 13), _RGB32(0, 0, 0)
                LINE (mx% + 9, my% + 8)-(mx% + 4, my% + 8), _RGB32(0, 0, 0)
                LINE (mx%, my% - 1)-(mx% + 9, my% + 8), _RGB32(0, 0, 0)
                
                FOR i% = 1 TO 11
                    IF i% <= 7 THEN
                        lineEnd% = i%
                    ELSEIF i% <= 11 THEN
                        lineEnd% = 3
                    END IF
                    LINE (mx% + 1, my% + i%)-(mx% + lineEnd%, my% + i%), _RGB32(255, 255, 255)
                NEXT i%
                
                LINE (mx% + 2, my% + 4)-(mx% + 4, my% + 6), PAINT_COLOR~&, BF
            END IF
        ELSE
            ' Generic: try PNG cursor from POINTER.CURSOR_ID%, fallback to DRAW string
            IF POINTER.CURSOR_ID% >= 0 AND POINTER.CURSOR_ID% <= CURSOR_COUNT THEN
                IF CURSORS(POINTER.CURSOR_ID%).img& < -1 THEN
                    _PUTIMAGE (mx% - CURSORS(POINTER.CURSOR_ID%).hotspot_pos_x%, my% - CURSORS(POINTER.CURSOR_ID%).hotspot_pos_y%), CURSORS(POINTER.CURSOR_ID%).img&, SCRN.CANVAS&
                    CURSOR_render_overlays POINTER.CURSOR_ID%, mx% - CURSORS(POINTER.CURSOR_ID%).hotspot_pos_x%, my% - CURSORS(POINTER.CURSOR_ID%).hotspot_pos_y%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
                ELSE
                    DIM s AS STRING
                    s$ = "B" + "M" + ns$(mx%) + "," + ns$(my%) + POINTER.S$
                    DRAW s$
                END IF
            ELSE
                DIM s2 AS STRING
                s2$ = "B" + "M" + ns$(mx%) + "," + ns$(my%) + POINTER.S$
                DRAW s2$
            END IF
        END IF
    END IF
    
    _DEST oldDest&
END SUB


''
' Updates the pointer
' 
SUB POINTER_update ()
    POINTER.C~& = PAINT_COLOR~&
END SUB


''
' Draws dotted crosshair cursor for marquee tool
' - 8x8 dotted crosshair
' - Semi-transparent (33% opaque = 84/255 alpha)
' - White with black outline like brush cursor
'
SUB POINTER_draw_marquee_cursor ()
    DIM i AS INTEGER
    DIM mx AS INTEGER, my AS INTEGER
    DIM white_semi AS _UNSIGNED LONG
    DIM black_semi AS _UNSIGNED LONG
    
    ' Scale mouse coordinates from window to logical canvas
    mx% = _MOUSEX
    my% = _MOUSEY
    
    ' Semi-transparent colors (33% opaque = 84/255 alpha)
    white_semi~& = _RGBA32(255, 255, 255, 84)
    black_semi~& = _RGBA32(0, 0, 0, 84)
    
    ' Draw dotted horizontal line (8 pixels total, 4 pixels on each side)
    ' Black outline
    FOR i% = -4 TO 4 STEP 2
        IF i% <> 0 THEN ' Skip center
            PSET (mx% + i%, my% - 1), black_semi~&
            PSET (mx% + i%, my% + 1), black_semi~&
        END IF
    NEXT i%
    
    ' White dots
    FOR i% = -4 TO 4 STEP 2
        IF i% <> 0 THEN ' Skip center
            PSET (mx% + i%, my%), white_semi~&
        END IF
    NEXT i%
    
    ' Draw dotted vertical line (8 pixels total, 4 pixels on each side)
    ' Black outline
    FOR i% = -4 TO 4 STEP 2
        IF i% <> 0 THEN ' Skip center
            PSET (mx% - 1, my% + i%), black_semi~&
            PSET (mx% + 1, my% + i%), black_semi~&
        END IF
    NEXT i%
    
    ' White dots
    FOR i% = -4 TO 4 STEP 2
        IF i% <> 0 THEN ' Skip center
            PSET (mx%, my% + i%), white_semi~&
        END IF
    NEXT i%
    
    ' Draw center pixel (white with black outline)
    PSET (mx% - 1, my%), black_semi~&
    PSET (mx% + 1, my%), black_semi~&
    PSET (mx%, my% - 1), black_semi~&
    PSET (mx%, my% + 1), black_semi~&
    PSET (mx%, my%), white_semi~&
END SUB

''
' Draw I-beam cursor for text tool
'
SUB POINTER_draw_ibeam_cursor ()
    DIM mx AS INTEGER, my AS INTEGER
    DIM i AS INTEGER
    DIM white_c AS _UNSIGNED LONG, black_c AS _UNSIGNED LONG
    
    ' Scale mouse coordinates from window to logical canvas
    mx% = _MOUSEX
    my% = _MOUSEY
    
    ' Solid colors for I-beam
    white_c~& = _RGB32(255, 255, 255)
    black_c~& = _RGB32(0, 0, 0)
    
    ' I-beam cursor height (8 pixels by default, matches font height)
    DIM beam_height AS INTEGER
    beam_height = 8
    
    ' Draw vertical line
    LINE (mx%, my%)-(mx%, my% + beam_height - 1), white_c~&
    
    ' Draw top horizontal bar (3 pixels wide)
    LINE (mx% - 1, my%)-(mx% + 1, my%), white_c~&
    
    ' Draw bottom horizontal bar (3 pixels wide)
    LINE (mx% - 1, my% + beam_height - 1)-(mx% + 1, my% + beam_height - 1), white_c~&
END SUB


''
' Returns the padding (in canvas pixels) around the pointer position needed
' for the dirty-rect fast path. Accounts for cursor type and brush preview size.
'
FUNCTION POINTER_get_dirty_pad% ()
    DIM pad AS INTEGER
    pad% = 32 ' Default: covers PNG cursors + overlays (max ~21px cursor + color chips)

    ' Brush / Dot tool: circle preview radius = BRUSH_SIZE_pixels * zoom / 2
    IF CURRENT_TOOL% = TOOL_BRUSH OR CURRENT_TOOL% = TOOL_DOT THEN
        DIM bp AS INTEGER
        bp% = INT(BRUSH_SIZE_pixels% * SCRN.zoom! / 2) + 4
        IF bp% > pad% THEN pad% = bp%
    END IF

    ' Spray tool: same radius calculation as brush preview
    IF CURRENT_TOOL% = TOOL_SPRAY THEN
        DIM sp AS INTEGER
        sp% = INT(BRUSH_PIXEL_SIZES(BRUSH_SIZE.CURRENT) * SCRN.zoom! / 2) + 4
        IF sp% > pad% THEN pad% = sp%
    END IF

    ' Custom brush: scaled stamp preview
    IF CUSTOM_BRUSH_is_active% THEN
        DIM cbw AS INTEGER, cbh AS INTEGER
        cbw% = INT(CUSTOM_BRUSH.WIDTH% * CUSTOM_BRUSH.SCALE! * SCRN.zoom! / 2) + 4
        cbh% = INT(CUSTOM_BRUSH.HEIGHT% * CUSTOM_BRUSH.SCALE! * SCRN.zoom! / 2) + 4
        IF cbw% > pad% THEN pad% = cbw%
        IF cbh% > pad% THEN pad% = cbh%
    END IF

    POINTER_get_dirty_pad% = pad%
END FUNCTION


''
' Render just the cursor overlay on top of GUI elements.
' This is called AFTER GUI re-composite to ensure the cursor is visible
' above GUI widgets, even when brush previews are drawn underneath.
'
' Does NOT draw brush previews - only the small cursor indicator.
'
SUB POINTER_render_cursor_overlay ()
    IF POINTER.HIDDEN THEN EXIT SUB
    
    DIM oldDest AS LONG
    DIM mx AS INTEGER, my AS INTEGER
    
    oldDest& = _DEST
    _DEST SCRN.CANVAS&
    _BLEND SCRN.CANVAS&
    
    mx% = _MOUSEX
    my% = _MOUSEY
    
    ' Panning mode - hand cursor
    IF SCRN.panning% THEN
        IF CURSORS(CURSOR_HAND).img& < -1 THEN
            _PUTIMAGE (mx% - CURSORS(CURSOR_HAND).hotspot_pos_x%, my% - CURSORS(CURSOR_HAND).hotspot_pos_y%), CURSORS(CURSOR_HAND).img&, SCRN.CANVAS&
        ELSE
            LINE (mx% - 3, my% + 2)-(mx% + 3, my% + 6), _RGB32(255, 255, 255), BF
        END IF
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' UI area - arrow cursor
    DIM use_ui_cursor AS INTEGER
    use_ui_cursor% = FALSE
    IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(mx%, my%) THEN use_ui_cursor% = TRUE
    IF NOT use_ui_cursor% AND LAYER_PANEL.visible% AND mx% < CFG.LAYER_PANEL_WIDTH% THEN use_ui_cursor% = TRUE
    IF NOT use_ui_cursor% AND SCRN.showMenubar% AND MENU_BAR.visible% THEN
        IF my% < MENU_BAR_HEIGHT AND mx% >= MENU_BAR.barX% THEN use_ui_cursor% = TRUE
        IF NOT use_ui_cursor% AND MENUBAR_submenu_in_bounds%(mx%, my%) THEN use_ui_cursor% = TRUE
    END IF
    IF NOT use_ui_cursor% AND SCRN.showStatus% THEN
        DIM strip_top AS INTEGER
        strip_top% = SCRN.h& - THEME.STATUS_height% - PALETTE_STRIP_get_height%
        IF my% >= strip_top% THEN use_ui_cursor% = TRUE
    END IF
    IF NOT use_ui_cursor% AND PALETTE_MENU_VISIBLE% THEN use_ui_cursor% = TRUE
    IF NOT use_ui_cursor% AND CURRENT_TOOL% = TOOL_NULL THEN use_ui_cursor% = TRUE
    
    IF use_ui_cursor% THEN
        IF CURSORS(CURSOR_NULL).img& < -1 THEN
            _PUTIMAGE (mx% - CURSORS(CURSOR_NULL).hotspot_pos_x%, my% - CURSORS(CURSOR_NULL).hotspot_pos_y%), CURSORS(CURSOR_NULL).img&, SCRN.CANVAS&
        ELSE
            ' Fallback procedural arrow
            DIM arr_i AS INTEGER, arr_w AS INTEGER
            FOR arr_i% = 0 TO 10
                IF arr_i% <= 7 THEN arr_w% = arr_i% ELSE arr_w% = 3
                LINE (mx%, my% + arr_i%)-(mx% + arr_w% + 1, my% + arr_i%), _RGB32(0, 0, 0)
            NEXT arr_i%
            FOR arr_i% = 1 TO 9
                IF arr_i% <= 6 THEN arr_w% = arr_i% - 1 ELSE arr_w% = 2
                IF arr_w% >= 1 THEN LINE (mx% + 1, my% + arr_i%)-(mx% + arr_w%, my% + arr_i%), _RGB32(255, 255, 255)
            NEXT arr_i%
        END IF
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' Custom brush - crosshair only (no brush preview)
    IF CUSTOM_BRUSH_is_active% THEN
        LINE (mx% - 3, my%)-(mx% - 1, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx% + 1, my%)-(mx% + 3, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% - 3)-(mx%, my% - 1), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% + 1)-(mx%, my% + 3), _RGBA32(255, 255, 255, 240)
        PSET (mx%, my%), _RGBA32(255, 0, 0, 255)
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' Shape tools and brush - crosshair
    IF CURRENT_TOOL% = TOOL_LINE OR CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED OR _
       CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED OR _
       CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED OR _
       CURRENT_TOOL% = TOOL_BRUSH OR CURRENT_TOOL% = TOOL_DOT OR CURRENT_TOOL% = TOOL_SPRAY THEN
        ' Small crosshair
        LINE (mx% - 4, my%)-(mx% - 1, my%), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 1, my%)-(mx% + 4, my%), _RGBA32(0, 0, 0, 180)
        LINE (mx%, my% - 4)-(mx%, my% - 1), _RGBA32(0, 0, 0, 180)
        LINE (mx%, my% + 1)-(mx%, my% + 4), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 3, my%)-(mx% - 1, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx% + 1, my%)-(mx% + 3, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% - 3)-(mx%, my% - 1), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% + 1)-(mx%, my% + 3), _RGBA32(255, 255, 255, 240)
        PSET (mx%, my%), _RGBA32(255, 0, 0, 255)
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' Marquee/Move/Fill/Picker - PNG cursor
    DIM cursor_id AS INTEGER
    SELECT CASE CURRENT_TOOL%
        CASE TOOL_MARQUEE: cursor_id% = CURSOR_MARQUEE
        CASE TOOL_MOVE: cursor_id% = CURSOR_MOVE
        CASE TOOL_FILL: cursor_id% = CURSOR_FILL
        CASE TOOL_PICKER: cursor_id% = CURSOR_DROPPER
        CASE TOOL_ZOOM: cursor_id% = CURSOR_ZOOM
        CASE TOOL_TEXT: cursor_id% = CURSOR_NULL
        CASE ELSE: cursor_id% = CURSOR_NULL
    END SELECT
    
    IF CURSORS(cursor_id%).img& < -1 THEN
        _PUTIMAGE (mx% - CURSORS(cursor_id%).hotspot_pos_x%, my% - CURSORS(cursor_id%).hotspot_pos_y%), CURSORS(cursor_id%).img&, SCRN.CANVAS&
    END IF
    
    _DEST oldDest&
END SUB