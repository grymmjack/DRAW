''
' DRAW - GUI/POINTER.BM
' =============================================================================
' Pointer subs and functions.
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initializes the pointer
' 
SUB POINTER_init ()
    _MOUSEHIDE
    POINTER.W%  = 4
    POINTER.H%  = 4
    POINTER.C~& = PAL_color(4)  ' Default to red (EGA color 4)
    POINTER.O%  = 7
    POINTER.OC~& = POINTER.C~&
    POINTER.CURSOR_ID% = CURSOR_NULL
    POINTER.CURSOR_FLIP% = 0
    POINTER.PREV_DRAW_X% = -9999
    POINTER.PREV_DRAW_Y% = -9999
    CURSOR_init
    IF SCRN.w& > 640 THEN 
        POINTER.W% = POINTER.W% * 2
        POINTER.H% = POINTER.H% * 2
    END IF
END SUB


''
' Render the pointer
' 
SUB POINTER_render ()
    IF POINTER.HIDDEN THEN EXIT SUB
    POINTER_build
    POINTER_draw
END SUB


''
' Hide the custom pointer before opening a native dialog.
' Renders one frame without the pointer, waits briefly so the
' user sees the pointer disappear, then shows the system cursor.
'
SUB POINTER_hide_for_dialog ()
    POINTER.HIDDEN = TRUE
    ' Render a frame so the custom pointer vanishes on-screen
    SCREEN_render
    ' Brief delay so the pointerless frame is visible before
    ' the OS dialog steals focus and backgrounds QB64PE
    _DELAY 0.15
    _MOUSESHOW
END SUB


''
' Restore the custom pointer after a native dialog closes.
' Hides the system cursor and re-enables custom pointer rendering.
'
SUB POINTER_show_after_dialog ()
    _MOUSEHIDE
    POINTER.HIDDEN = FALSE
    ' Reset to null (arrow) cursor after dialog so the tool-specific
    ' cursor doesn't flash before the user moves the mouse
    POINTER.CURSOR_ID% = CURSOR_NULL
END SUB


''
' Builds the pointer
' 
SUB POINTER_build ()
    DIM mx AS INTEGER, my AS INTEGER
    DIM AS INTEGER TB_RIGHT, TB_LEFT
    
    ' Calculate toolbar position dynamically to align to right edge of screen
    TB_RIGHT = SCRN.w& - TB_BTN_W - 1  ' Right column: 1px from right edge
    TB_LEFT = TB_RIGHT - TB_BTN_W - TB_BTN_PADDING  ' Left column: to the left of right column
    
    ' Scale mouse coordinates from window to logical canvas
    mx% = _MOUSEX
    my% = _MOUSEY
    
    ' --- UI area checks: use null (arrow) cursor ---
    
    ' Check if mouse is over toolbar area
    IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(mx%, my%) THEN
        POINTER.CURSOR_ID% = CURSOR_NULL
        EXIT SUB
    END IF

    ' Check if mouse is over organizer area (beneath toolbar)
    IF SCRN.showToolbar% AND ORGANIZER_is_over_area%(mx%, my%) THEN
        POINTER.CURSOR_ID% = CURSOR_NULL
        EXIT SUB
    END IF
    
    ' Check if mouse is over layer panel
    IF LAYER_PANEL.visible% AND mx% < CFG.LAYER_PANEL_WIDTH% THEN
        POINTER.CURSOR_ID% = CURSOR_NULL
        EXIT SUB
    END IF
    
    ' Check if mouse is over menu bar area (top MENU_BAR_HEIGHT pixels in the bar region)
    IF SCRN.showMenubar% AND MENU_BAR.visible% THEN
        IF my% < MENU_BAR_HEIGHT AND mx% >= MENU_BAR.barX% THEN
            POINTER.CURSOR_ID% = CURSOR_NULL
            EXIT SUB
        END IF
        ' Check if submenu is open and mouse is over it
        IF MENUBAR_submenu_in_bounds%(mx%, my%) THEN
            POINTER.CURSOR_ID% = CURSOR_NULL
            EXIT SUB
        END IF
        ' Check if recent files submenu is open and mouse is over it
        IF MENU_BAR.recentOpen% AND MENU_BAR.recentW% > 0 AND MENU_BAR.recentH% > 0 THEN
            IF mx% >= MENU_BAR.recentX% AND mx% < MENU_BAR.recentX% + MENU_BAR.recentW% _
                AND my% >= MENU_BAR.recentY% AND my% < MENU_BAR.recentY% + MENU_BAR.recentH% THEN
                POINTER.CURSOR_ID% = CURSOR_NULL
                EXIT SUB
            END IF
        END IF
    END IF

    ' Check if mouse is over status bar or palette strip
    IF SCRN.showStatus% THEN
        DIM strip_top_build AS INTEGER
        strip_top_build% = SCRN.h& - THEME.STATUS_height% - PALETTE_STRIP_get_height%
        IF my% >= strip_top_build% THEN
            POINTER.CURSOR_ID% = CURSOR_NULL
            EXIT SUB
        END IF
    END IF
    
    ' Check if palette menu is visible
    IF PALETTE_MENU_VISIBLE% THEN
        POINTER.CURSOR_ID% = CURSOR_NULL
        EXIT SUB
    END IF
    
    ' Check if NULL tool is active
    IF CURRENT_TOOL% = TOOL_NULL THEN
        POINTER.CURSOR_ID% = CURSOR_NULL
        EXIT SUB
    END IF
    
    ' --- Pan mode: use hand cursor ---
    ' Block spacebar pan cursor when text tool is active (SPACE needed for typing)
    DIM allowSpacePanCursor AS INTEGER
    allowSpacePanCursor% = NOT (CURRENT_TOOL% = TOOL_TEXT AND TEXT.ACTIVE)
    
    IF (_KEYDOWN(32) AND allowSpacePanCursor%) OR _MOUSEBUTTON(3) THEN ' Spacebar or MMB - pan mode
        POINTER.CURSOR_ID% = CURSOR_HAND
        EXIT SUB
    END IF
    
    ' --- Tool-specific cursors ---
    
    ' Pan tool
    IF CURRENT_TOOL% = TOOL_PAN THEN
        POINTER.CURSOR_ID% = CURSOR_HAND
        EXIT SUB
    END IF
    
    ' Zoom tool
    IF CURRENT_TOOL% = TOOL_ZOOM THEN
        POINTER.CURSOR_ID% = CURSOR_ZOOM
        EXIT SUB
    END IF
    
    ' Fill tool
    IF CURRENT_TOOL% = TOOL_FILL THEN
        POINTER.CURSOR_ID% = CURSOR_FILL
        EXIT SUB
    END IF
    
    ' Picker / Dropper tool
    IF CURRENT_TOOL% = TOOL_PICKER THEN
        POINTER.CURSOR_ID% = CURSOR_DROPPER
        EXIT SUB
    END IF
    
    ' Marquee tool (or magic wand mode) - with resize cursor support
    IF CURRENT_TOOL% = TOOL_MARQUEE THEN
        POINTER.CURSOR_FLIP% = 0  ' Reset flip
        IF MARQUEE.MAGIC_WAND_MODE% THEN
            POINTER.CURSOR_ID% = CURSOR_WAND
        ELSEIF MARQUEE.RESIZING% THEN
            ' Currently dragging a resize handle
            SELECT CASE MARQUEE.RESIZE_HANDLE%
                CASE 1  ' TL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 0
                CASE 3  ' TR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 1
                CASE 8  ' BR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 3
                CASE 6  ' BL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 2
                CASE 2, 7  ' Top/Bottom edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_VERT
                CASE 4, 5  ' Left/Right edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_HORIZ
                CASE ELSE
                    POINTER.CURSOR_ID% = CURSOR_MARQUEE
            END SELECT
        ELSEIF MARQUEE.ACTIVE% THEN
            ' Hover detection over handles
            DIM marq_hover AS INTEGER
            marq_hover% = MARQUEE_get_handle_at%(MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%)
            SELECT CASE marq_hover%
                CASE 1  ' TL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 0
                CASE 3  ' TR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 1
                CASE 8  ' BR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 3
                CASE 6  ' BL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 2
                CASE 2, 7  ' Top/Bottom edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_VERT
                CASE 4, 5  ' Left/Right edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_HORIZ
                CASE ELSE
                    POINTER.CURSOR_ID% = CURSOR_MARQUEE
            END SELECT
        ELSE
            POINTER.CURSOR_ID% = CURSOR_MARQUEE
        END IF
        EXIT SUB
    END IF
    
    ' Move tool - pick cursor based on handle being hovered/dragged
    IF CURRENT_TOOL% = TOOL_MOVE THEN
        POINTER.CURSOR_FLIP% = 0  ' Reset flip
        IF MOVE.ACTIVE AND MOVE.TRANSFORMING THEN
            ' Currently dragging a handle - cursor based on MOVE.HANDLE
            SELECT CASE MOVE.HANDLE
                CASE 0  ' Center - move
                    POINTER.CURSOR_ID% = CURSOR_MOVE
                CASE 1  ' TL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 0  ' No flip (default orientation)
                CASE 2  ' TR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 1  ' Flip horizontal
                CASE 3  ' BR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 3  ' Flip both
                CASE 4  ' BL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 2  ' Flip vertical
                CASE 5, 7  ' Top/Bottom edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_VERT
                CASE 6, 8  ' Right/Left edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_HORIZ
                CASE ELSE
                    POINTER.CURSOR_ID% = CURSOR_MOVE
            END SELECT
        ELSEIF MOVE.ACTIVE AND MARQUEE.ACTIVE% THEN
            ' Selection exists - check which handle mouse is hovering
            DIM hover_handle AS INTEGER
            hover_handle% = MARQUEE_get_handle_at%(MOUSE.UNSNAPPED_X%, MOUSE.UNSNAPPED_Y%)
            SELECT CASE hover_handle%
                CASE 0  ' No handle / interior
                    POINTER.CURSOR_ID% = CURSOR_MOVE
                CASE 1  ' TL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 0
                CASE 3  ' TR corner (MARQUEE numbering)
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 1
                CASE 8  ' BR corner (MARQUEE numbering)
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 3
                CASE 6  ' BL corner (MARQUEE numbering)
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 2
                CASE 2, 7  ' Top/Bottom edge (MARQUEE numbering)
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_VERT
                CASE 4, 5  ' Left/Right edge (MARQUEE numbering)
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_HORIZ
                CASE ELSE
                    POINTER.CURSOR_ID% = CURSOR_MOVE
            END SELECT
        ELSE
            POINTER.CURSOR_ID% = CURSOR_MOVE
        END IF
        EXIT SUB
    END IF
    
    ' Image Import mode - show move/resize cursors like Move tool
    IF IMG_IMPORT.STATE > IMPORT_STATE_IDLE THEN
        POINTER.CURSOR_FLIP% = 0
        IF IMG_IMPORT.RESIZING THEN
            SELECT CASE IMG_IMPORT.RESIZE_HANDLE
                CASE 1  ' TL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 0
                CASE 2  ' TR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 1
                CASE 3  ' BR corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 3
                CASE 4  ' BL corner
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 2
                CASE 5, 7  ' Top/Bottom edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_VERT
                CASE 6, 8  ' Left/Right edge
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_HORIZ
                CASE ELSE
                    POINTER.CURSOR_ID% = CURSOR_MOVE
            END SELECT
        ELSEIF IMG_IMPORT.PANNING THEN
            POINTER.CURSOR_ID% = CURSOR_HAND
        ELSEIF IMG_IMPORT.HOVER_HANDLE > 0 THEN
            SELECT CASE IMG_IMPORT.HOVER_HANDLE
                CASE 1  ' TL
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 0
                CASE 2  ' TR
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 1
                CASE 3  ' BR
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 3
                CASE 4  ' BL
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_CORNER
                    POINTER.CURSOR_FLIP% = 2
                CASE 5, 7  ' Top/Bottom
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_VERT
                CASE 6, 8  ' Left/Right
                    POINTER.CURSOR_ID% = CURSOR_RESIZE_HORIZ
                CASE ELSE
                    POINTER.CURSOR_ID% = CURSOR_MOVE
            END SELECT
        ELSEIF IMG_IMPORT.STATE = IMPORT_STATE_PLACING THEN
            POINTER.CURSOR_ID% = CURSOR_HAND
        ELSE
            POINTER.CURSOR_ID% = CURSOR_MOVE
        END IF
        EXIT SUB
    END IF

    ' Text tool - keep procedural I-beam (no PNG for this)
    IF CURRENT_TOOL% = TOOL_TEXT THEN
        POINTER.CURSOR_ID% = -1  ' No PNG cursor, use procedural
        EXIT SUB
    END IF
    
    ' Line/Polygon/Rect/Ellipse tools - keep procedural crosshair (no PNG for these)
    IF CURRENT_TOOL% = TOOL_LINE OR CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED OR CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED OR CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED THEN
        POINTER.CURSOR_ID% = -1  ' No PNG cursor, use procedural
        EXIT SUB
    END IF
    
    ' Brush / Dot tool - use brush cursor when showing arrow, procedural for brush preview
    IF CURRENT_TOOL% = TOOL_BRUSH OR CURRENT_TOOL% = TOOL_DOT THEN
        POINTER.CURSOR_ID% = CURSOR_BRUSH
        EXIT SUB
    END IF
    
    ' Pan tool - use hand cursor
    IF CURRENT_TOOL% = TOOL_PAN THEN
        POINTER.CURSOR_ID% = CURSOR_HAND
        EXIT SUB
    END IF
    
    ' Spray tool - use spray cursor
    IF CURRENT_TOOL% = TOOL_SPRAY THEN
        POINTER.CURSOR_ID% = CURSOR_SPRAY
        EXIT SUB
    END IF
    
    ' Crop tool - use marquee cursor
    IF CURRENT_TOOL% = TOOL_CROP THEN
        POINTER.CURSOR_ID% = CURSOR_MARQUEE
        EXIT SUB
    END IF
    
    ' Default fallback - crosshair/square
    POINTER.CURSOR_ID% = -1  ' procedural default
    POINTER.S$ = "C" + STR$(PAL_color(POINTER.O%)) _
              + "D"  + ns$(POINTER.H%) _ 
              + "R"  + ns$(POINTER.W%) _ 
              + "H"  + ns$(POINTER.H%) _ 
              + "B" _
              + "M+" + ns$(POINTER.W%\2) _
              + ",+" + ns$(POINTER.H%) _
              + "F"  + ns$(POINTER.W%\2)
    IF POINTER.C~& <> 0 THEN 'fill POINTER if not 0 else color is black do not.
        POINTER.S$ = POINTER.S$ _
                  + "B" _
                  + "M-" + ns$(POINTER.W%\2) _
                  + ",-" + ns$(POINTER.H% - 1) _
                  + "P"  + STR$(POINTER.C~&) _
                  + ","  + STR$(PAL_color(POINTER.O%))
    END IF
END SUB


''
' Draw panning cursor (hand PNG or procedural fallback).
'
SUB POINTER_draw_pan (mx AS INTEGER, my AS INTEGER)
    IF CURSORS(CURSOR_HAND).img& < -1 THEN
        _PUTIMAGE (mx% - CURSORS(CURSOR_HAND).hotspot_pos_x%, my% - CURSORS(CURSOR_HAND).hotspot_pos_y%), CURSORS(CURSOR_HAND).img&, SCRN.CANVAS&
        CURSOR_render_overlays CURSOR_HAND, mx% - CURSORS(CURSOR_HAND).hotspot_pos_x%, my% - CURSORS(CURSOR_HAND).hotspot_pos_y%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
    ELSE
        ' Fallback: procedural hand cursor
        LINE (mx% - 3, my% + 2)-(mx% + 3, my% + 6), _RGB32(255, 255, 255), BF
        LINE (mx% - 2, my% + 1)-(mx% + 2, my% + 1), _RGB32(255, 255, 255)
        LINE (mx% - 2, my% - 3)-(mx% - 2, my% + 1), _RGB32(255, 255, 255)
        LINE (mx%, my% - 4)-(mx%, my% + 1), _RGB32(255, 255, 255)
        LINE (mx% + 2, my% - 3)-(mx% + 2, my% + 1), _RGB32(255, 255, 255)
        LINE (mx% - 4, my% + 2)-(mx% - 4, my% + 4), _RGB32(255, 255, 255)
        LINE (mx% - 4, my% + 1)-(mx% - 4, my% + 5), _RGB32(0, 0, 0)
        LINE (mx% - 3, my%)-(mx% + 3, my%), _RGB32(0, 0, 0)
        LINE (mx% + 4, my% + 1)-(mx% + 4, my% + 7), _RGB32(0, 0, 0)
        LINE (mx% - 4, my% + 7)-(mx% + 4, my% + 7), _RGB32(0, 0, 0)
    END IF
END SUB


''
' Draw UI area cursor (arrow PNG or procedural fallback).
' Used when hovering over toolbar, layer panel, status bar, palette menu, or NULL tool.
'
SUB POINTER_draw_ui_cursor (mx AS INTEGER, my AS INTEGER)
    IF CURSORS(CURSOR_NULL).img& < -1 THEN
        _PUTIMAGE (mx% - CURSORS(CURSOR_NULL).hotspot_pos_x%, my% - CURSORS(CURSOR_NULL).hotspot_pos_y%), CURSORS(CURSOR_NULL).img&, SCRN.CANVAS&
        CURSOR_render_overlays CURSOR_NULL, mx% - CURSORS(CURSOR_NULL).hotspot_pos_x%, my% - CURSORS(CURSOR_NULL).hotspot_pos_y%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
    ELSE
        ' Fallback: procedural arrow cursor (no PAINT, alpha-safe)
        DIM arr_i AS INTEGER
        FOR arr_i% = 0 TO 10
            DIM arr_w AS INTEGER
            IF arr_i% <= 7 THEN
                arr_w% = arr_i%
            ELSE
                arr_w% = 3
            END IF
            ' Black outline
            IF arr_i% <= 7 THEN
                LINE (mx%, my% + arr_i%)-(mx% + arr_w% + 1, my% + arr_i%), _RGB32(0, 0, 0)
            ELSE
                LINE (mx%, my% + arr_i%)-(mx% + arr_w% + 1, my% + arr_i%), _RGB32(0, 0, 0)
            END IF
        NEXT arr_i%
        ' White interior fill
        FOR arr_i% = 1 TO 9
            IF arr_i% <= 6 THEN
                arr_w% = arr_i% - 1
            ELSE
                arr_w% = 2
            END IF
            IF arr_w% >= 1 THEN
                LINE (mx% + 1, my% + arr_i%)-(mx% + arr_w%, my% + arr_i%), _RGB32(255, 255, 255)
            END IF
        NEXT arr_i%
    END IF
END SUB


''
' Draw custom brush cursor (scaled brush preview + outline + center crosshair).
'
SUB POINTER_draw_custom_brush (mx AS INTEGER, my AS INTEGER)
    DIM brush_x AS INTEGER, brush_y AS INTEGER
    DIM scaled_w AS INTEGER, scaled_h AS INTEGER

    scaled_w% = CUSTOM_BRUSH.WIDTH% * SCRN.zoom!
    scaled_h% = CUSTOM_BRUSH.HEIGHT% * SCRN.zoom!

    brush_x% = mx% - scaled_w% \ 2
    brush_y% = my% - scaled_h% \ 2

    CUSTOM_BRUSH_render_scaled brush_x%, brush_y%, SCRN.CANVAS&, SCRN.zoom!

    IF CUSTOM_BRUSH.SHOW_OUTLINE% THEN
        DIM outline_x1 AS INTEGER, outline_y1 AS INTEGER
        DIM outline_x2 AS INTEGER, outline_y2 AS INTEGER
        outline_x1% = brush_x%
        outline_y1% = brush_y%
        outline_x2% = brush_x% + scaled_w% - 1
        outline_y2% = brush_y% + scaled_h% - 1

        LINE (outline_x1% - 1, outline_y1% - 1)-(outline_x2% + 1, outline_y2% + 1), _RGBA32(0, 0, 0, 128), B
        LINE (outline_x1%, outline_y1%)-(outline_x2%, outline_y2%), _RGBA32(255, 255, 255, 200), B
    END IF

    LINE (mx% - 3, my%)-(mx% - 1, my%), _RGBA32(255, 255, 255, 240)
    LINE (mx% + 1, my%)-(mx% + 3, my%), _RGBA32(255, 255, 255, 240)
    LINE (mx%, my% - 3)-(mx%, my% - 1), _RGBA32(255, 255, 255, 240)
    LINE (mx%, my% + 1)-(mx%, my% + 3), _RGBA32(255, 255, 255, 240)
    PSET (mx%, my%), _RGBA32(255, 0, 0, 255)
END SUB


''
' Draw shape tool cursor (X-shaped crosshair with color center dot).
' Used for line, polygon, rect, ellipse tools.
'
SUB POINTER_draw_shape_crosshair (mx AS INTEGER, my AS INTEGER)
    DIM r AS INTEGER, g AS INTEGER, b AS INTEGER
    ' Diagonal lines forming an X - black outline for visibility
    LINE (mx% - 7, my% - 8)-(mx% - 2, my% - 3), _RGBA32(0, 0, 0, 180)
    LINE (mx% - 8, my% - 7)-(mx% - 3, my% - 2), _RGBA32(0, 0, 0, 180)
    LINE (mx% + 2, my% + 3)-(mx% + 7, my% + 8), _RGBA32(0, 0, 0, 180)
    LINE (mx% + 3, my% + 2)-(mx% + 8, my% + 7), _RGBA32(0, 0, 0, 180)
    LINE (mx% - 7, my% - 7)-(mx% - 2, my% - 2), _RGBA32(255, 255, 255, 240)
    LINE (mx% + 2, my% + 2)-(mx% + 7, my% + 7), _RGBA32(255, 255, 255, 240)

    LINE (mx% + 7, my% - 8)-(mx% + 2, my% - 3), _RGBA32(0, 0, 0, 180)
    LINE (mx% + 8, my% - 7)-(mx% + 3, my% - 2), _RGBA32(0, 0, 0, 180)
    LINE (mx% - 2, my% + 3)-(mx% - 7, my% + 8), _RGBA32(0, 0, 0, 180)
    LINE (mx% - 3, my% + 2)-(mx% - 8, my% + 7), _RGBA32(0, 0, 0, 180)
    LINE (mx% + 7, my% - 7)-(mx% + 2, my% - 2), _RGBA32(255, 255, 255, 240)
    LINE (mx% - 2, my% + 2)-(mx% - 7, my% + 7), _RGBA32(255, 255, 255, 240)

    r% = _RED32(PAINT_COLOR~&)
    g% = _GREEN32(PAINT_COLOR~&)
    b% = _BLUE32(PAINT_COLOR~&)
    PSET (mx%, my%), _RGBA32(r%, g%, b%, 180)
    PSET (mx% - 1, my%), _RGBA32(r%, g%, b%, 120)
    PSET (mx% + 1, my%), _RGBA32(r%, g%, b%, 120)
    PSET (mx%, my% - 1), _RGBA32(r%, g%, b%, 120)
    PSET (mx%, my% + 1), _RGBA32(r%, g%, b%, 120)
END SUB


''
' Draw picker tool cursor (dropper PNG or procedural crosshair fallback).
'
SUB POINTER_draw_picker (mx AS INTEGER, my AS INTEGER)
    IF CURSORS(CURSOR_DROPPER).img& < -1 THEN
        _PUTIMAGE (mx% - CURSORS(CURSOR_DROPPER).hotspot_pos_x%, my% - CURSORS(CURSOR_DROPPER).hotspot_pos_y%), CURSORS(CURSOR_DROPPER).img&, SCRN.CANVAS&
        CURSOR_render_overlays CURSOR_DROPPER, mx% - CURSORS(CURSOR_DROPPER).hotspot_pos_x%, my% - CURSORS(CURSOR_DROPPER).hotspot_pos_y%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
    ELSE
        ' Fallback: procedural crosshair
        LINE (mx% - 9, my% - 1)-(mx% - 2, my% - 1), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 9, my% + 1)-(mx% - 2, my% + 1), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 2, my% - 1)-(mx% + 9, my% - 1), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 2, my% + 1)-(mx% + 9, my% + 1), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 9, my%)-(mx% - 2, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx% + 2, my%)-(mx% + 9, my%), _RGBA32(255, 255, 255, 240)

        LINE (mx% - 1, my% - 9)-(mx% - 1, my% - 2), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 1, my% - 9)-(mx% + 1, my% - 2), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 1, my% + 2)-(mx% + 1, my% + 9), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 1, my% + 2)-(mx% + 1, my% + 9), _RGBA32(0, 0, 0, 180)
        LINE (mx%, my% - 9)-(mx%, my% - 2), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% + 2)-(mx%, my% + 9), _RGBA32(255, 255, 255, 240)
    END IF
END SUB


''
' Draw brush/dot tool preview (circle or square, scanline fill).
'
SUB POINTER_draw_brush_preview (mx AS INTEGER, my AS INTEGER, is_painting AS INTEGER)
    DIM pixel_size AS INTEGER, half AS INTEGER
    DIM radius AS INTEGER
    DIM r AS INTEGER, g AS INTEGER, b AS INTEGER
    DIM cx AS INTEGER, cy AS INTEGER
    DIM r_sq AS SINGLE

    pixel_size% = INT(BRUSH_SIZE_pixels% * SCRN.zoom!)
    IF pixel_size% < 1 THEN pixel_size% = 1

    IF BRUSH_SIZE.PREVIEW THEN
        IF BRUSH_SIZE.SHAPE = 0 THEN
            radius% = pixel_size% \ 2
            CIRCLE (mx%, my%), radius% + 1, _RGBA32(32, 32, 32, 84)
            CIRCLE (mx%, my%), radius%, _RGBA32(255, 255, 255, 84)

            r% = _RED32(PAINT_COLOR~&)
            g% = _GREEN32(PAINT_COLOR~&)
            b% = _BLUE32(PAINT_COLOR~&)
            DIM fill_c AS _UNSIGNED LONG
            fill_c~& = _RGBA32(r%, g%, b%, 120)
            ' Scanline circle fill: O(n) LINEs instead of O(n^2) PSETs
            r_sq! = (radius% - 0.5) * (radius% - 0.5)
            FOR cy% = my% - radius% TO my% + radius%
                DIM dy_sq AS SINGLE
                DIM scan_w AS INTEGER
                dy_sq! = (cy% - my%) * (cy% - my%)
                IF dy_sq! > r_sq! THEN _CONTINUE
                scan_w% = INT(SQR(r_sq! - dy_sq!))
                LINE (mx% - scan_w%, cy%)-(mx% + scan_w%, cy%), fill_c~&
            NEXT cy%
        ELSE
            half% = pixel_size% \ 2
            LINE (mx% - half% - 1, my% - half% - 1)-(mx% + half% + 1, my% + half% + 1), _RGBA32(32, 32, 32, 84), B
            LINE (mx% - half%, my% - half%)-(mx% + half%, my% + half%), _RGBA32(255, 255, 255, 84), B

            r% = _RED32(PAINT_COLOR~&)
            g% = _GREEN32(PAINT_COLOR~&)
            b% = _BLUE32(PAINT_COLOR~&)
            LINE (mx% - half%, my% - half%)-(mx% + half%, my% + half%), _RGBA32(r%, g%, b%, 120), BF
        END IF

        IF NOT is_painting% THEN
            LINE (mx% - 3, my%)-(mx% + 3, my%), _RGBA32(32, 32, 32, 84)
            LINE (mx%, my% - 3)-(mx%, my% + 3), _RGBA32(32, 32, 32, 84)
            LINE (mx% - 2, my%)-(mx% + 2, my%), _RGBA32(255, 255, 255, 84)
            LINE (mx%, my% - 2)-(mx%, my% + 2), _RGBA32(255, 255, 255, 84)
        END IF
    ELSE
        IF pixel_size% = 1 THEN
            PSET (mx%, my%), _RGBA32(255, 255, 255, 128)
            PSET (mx% - 1, my%), _RGBA32(0, 0, 0, 64)
            PSET (mx% + 1, my%), _RGBA32(0, 0, 0, 64)
            PSET (mx%, my% - 1), _RGBA32(0, 0, 0, 64)
            PSET (mx%, my% + 1), _RGBA32(0, 0, 0, 64)
        ELSEIF pixel_size% = 3 AND BRUSH_SIZE.SHAPE = 0 THEN
            LINE (mx%, my% - 1)-(mx%, my% + 1), PAINT_COLOR~&
            LINE (mx% - 1, my%)-(mx% + 1, my%), PAINT_COLOR~&
        ELSE
            IF BRUSH_SIZE.SHAPE = 0 THEN
                ' Scanline circle fill (no-preview mode)
                radius% = pixel_size% \ 2
                r_sq! = (radius% - 0.5) * (radius% - 0.5)
                FOR cy% = my% - radius% TO my% + radius%
                    DIM dy_sq2 AS SINGLE
                    DIM scan_w2 AS INTEGER
                    dy_sq2! = (cy% - my%) * (cy% - my%)
                    IF dy_sq2! > r_sq! THEN _CONTINUE
                    scan_w2% = INT(SQR(r_sq! - dy_sq2!))
                    LINE (mx% - scan_w2%, cy%)-(mx% + scan_w2%, cy%), PAINT_COLOR~&
                NEXT cy%
            ELSE
                half% = pixel_size% \ 2
                LINE (mx% - half%, my% - half%)-(mx% + half%, my% + half%), PAINT_COLOR~&, BF
            END IF
        END IF
    END IF
END SUB


''
' Draw spray tool preview (circle outline + dot pattern).
'
SUB POINTER_draw_spray_preview (mx AS INTEGER, my AS INTEGER, is_painting AS INTEGER)
    DIM spray_radius AS INTEGER
    DIM spray_pixel_size AS INTEGER
    DIM spray_r AS INTEGER, spray_g AS INTEGER, spray_b AS INTEGER
    DIM spray_cx AS INTEGER, spray_cy AS INTEGER
    DIM spray_dist_sq AS SINGLE, spray_r_sq AS SINGLE
    DIM spray_density AS INTEGER

    ' Get radius from brush size system (same as SPRAY_on uses)
    spray_pixel_size% = INT(BRUSH_PIXEL_SIZES(BRUSH_SIZE.CURRENT) * SCRN.zoom!)
    IF spray_pixel_size% < 1 THEN spray_pixel_size% = 1
    spray_radius% = spray_pixel_size% \ 2
    IF spray_radius% < 1 THEN spray_radius% = 1

    ' Draw circle outline (dark + light for visibility)
    CIRCLE (mx%, my%), spray_radius% + 1, _RGBA32(32, 32, 32, 84)
    CIRCLE (mx%, my%), spray_radius%, _RGBA32(255, 255, 255, 84)

    ' Draw preview dot pattern inside the circle using FG color
    spray_r% = _RED32(PAINT_COLOR~&)
    spray_g% = _GREEN32(PAINT_COLOR~&)
    spray_b% = _BLUE32(PAINT_COLOR~&)

    ' Static dot pattern preview (fixed seed for stable appearance)
    spray_density% = INT(spray_radius% * spray_radius% * 0.15) + 3
    IF spray_density% > 50 THEN spray_density% = 50

    ' Use a deterministic pattern based on position so preview doesn't flicker
    spray_r_sq! = (spray_radius% - 0.5) * (spray_radius% - 0.5)
    DIM spray_step AS INTEGER
    spray_step% = INT(SQR(3.14159 * spray_r_sq! / spray_density%))
    IF spray_step% < 1 THEN spray_step% = 1

    FOR spray_cy% = my% - spray_radius% TO my% + spray_radius% STEP spray_step%
        FOR spray_cx% = mx% - spray_radius% TO mx% + spray_radius% STEP spray_step%
            spray_dist_sq! = (spray_cx% - mx%) * (spray_cx% - mx%) + (spray_cy% - my%) * (spray_cy% - my%)
            IF spray_dist_sq! <= spray_r_sq! THEN
                PSET (spray_cx%, spray_cy%), _RGBA32(spray_r%, spray_g%, spray_b%, 120)
            END IF
        NEXT spray_cx%
    NEXT spray_cy%

    ' Draw center crosshair when not painting
    IF NOT is_painting% THEN
        LINE (mx% - 3, my%)-(mx% + 3, my%), _RGBA32(32, 32, 32, 84)
        LINE (mx%, my% - 3)-(mx%, my% + 3), _RGBA32(32, 32, 32, 84)
        LINE (mx% - 2, my%)-(mx% + 2, my%), _RGBA32(255, 255, 255, 84)
        LINE (mx%, my% - 2)-(mx%, my% + 2), _RGBA32(255, 255, 255, 84)
    END IF
END SUB


''
' Draw marquee tool cursor (PNG with flip support or procedural fallback).
'
SUB POINTER_draw_marquee (mx AS INTEGER, my AS INTEGER)
    DIM marq_cursor_id AS INTEGER
    marq_cursor_id% = POINTER.CURSOR_ID%
    IF marq_cursor_id% >= 0 AND marq_cursor_id% <= CURSOR_COUNT AND CURSORS(marq_cursor_id%).img& < -1 THEN
        ' Render PNG cursor with optional flip
        DIM mq_dx AS INTEGER, mq_dy AS INTEGER
        DIM mq_w AS INTEGER, mq_h AS INTEGER
        mq_w% = CURSORS(marq_cursor_id%).w%
        mq_h% = CURSORS(marq_cursor_id%).h%
        mq_dx% = mx% - CURSORS(marq_cursor_id%).hotspot_pos_x%
        mq_dy% = my% - CURSORS(marq_cursor_id%).hotspot_pos_y%
        SELECT CASE POINTER.CURSOR_FLIP%
            CASE 1  ' Flip horizontal
                _PUTIMAGE (mq_dx% + mq_w% - 1, mq_dy%)-(mq_dx%, mq_dy% + mq_h% - 1), CURSORS(marq_cursor_id%).img&, SCRN.CANVAS&
            CASE 2  ' Flip vertical
                _PUTIMAGE (mq_dx%, mq_dy% + mq_h% - 1)-(mq_dx% + mq_w% - 1, mq_dy%), CURSORS(marq_cursor_id%).img&, SCRN.CANVAS&
            CASE 3  ' Flip both
                _PUTIMAGE (mq_dx% + mq_w% - 1, mq_dy% + mq_h% - 1)-(mq_dx%, mq_dy%), CURSORS(marq_cursor_id%).img&, SCRN.CANVAS&
            CASE ELSE  ' No flip
                _PUTIMAGE (mq_dx%, mq_dy%), CURSORS(marq_cursor_id%).img&, SCRN.CANVAS&
        END SELECT
        CURSOR_render_overlays marq_cursor_id%, mq_dx%, mq_dy%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
    ELSE
        ' Fallback: procedural dotted crosshair
        POINTER_draw_marquee_cursor
    END IF
END SUB


''
' Draw move tool cursor (PNG with flip support or procedural 4-dir arrows fallback).
'
SUB POINTER_draw_move_cursor (mx AS INTEGER, my AS INTEGER)
    DIM move_cid AS INTEGER
    move_cid% = POINTER.CURSOR_ID%
    
    ' Handle resize cursors - PNG only, no procedural fallback, NO move cursor overlay
    IF move_cid% = CURSOR_RESIZE_CORNER OR move_cid% = CURSOR_RESIZE_HORIZ OR move_cid% = CURSOR_RESIZE_VERT THEN
        ' Only draw if PNG is available
        IF CURSORS(move_cid%).img& < -1 THEN
            DIM mc_dx AS INTEGER, mc_dy AS INTEGER
            DIM mc_w AS INTEGER, mc_h AS INTEGER
            mc_w% = CURSORS(move_cid%).w%
            mc_h% = CURSORS(move_cid%).h%
            mc_dx% = mx% - CURSORS(move_cid%).hotspot_pos_x%
            mc_dy% = my% - CURSORS(move_cid%).hotspot_pos_y%
            SELECT CASE POINTER.CURSOR_FLIP%
                CASE 1  ' Flip horizontal
                    _PUTIMAGE (mc_dx% + mc_w% - 1, mc_dy%)-(mc_dx%, mc_dy% + mc_h% - 1), CURSORS(move_cid%).img&, SCRN.CANVAS&
                CASE 2  ' Flip vertical
                    _PUTIMAGE (mc_dx%, mc_dy% + mc_h% - 1)-(mc_dx% + mc_w% - 1, mc_dy%), CURSORS(move_cid%).img&, SCRN.CANVAS&
                CASE 3  ' Flip both
                    _PUTIMAGE (mc_dx% + mc_w% - 1, mc_dy% + mc_h% - 1)-(mc_dx%, mc_dy%), CURSORS(move_cid%).img&, SCRN.CANVAS&
                CASE ELSE  ' No flip
                    _PUTIMAGE (mc_dx%, mc_dy%), CURSORS(move_cid%).img&, SCRN.CANVAS&
            END SELECT
            CURSOR_render_overlays move_cid%, mc_dx%, mc_dy%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
        END IF
        ' Critical: Exit immediately for resize cursors - never draw move cursor
        EXIT SUB
    END IF
    
    ' Handle move cursor ONLY if cursor ID is actually CURSOR_MOVE
    IF move_cid% <> CURSOR_MOVE THEN EXIT SUB
    
    ' Now we know it's CURSOR_MOVE - draw PNG or procedural fallback
    IF CURSORS(CURSOR_MOVE).img& < -1 THEN
        ' Draw move cursor PNG
        DIM mm_dx AS INTEGER, mm_dy AS INTEGER
        DIM mm_w AS INTEGER, mm_h AS INTEGER
        mm_w% = CURSORS(CURSOR_MOVE).w%
        mm_h% = CURSORS(CURSOR_MOVE).h%
        mm_dx% = mx% - CURSORS(CURSOR_MOVE).hotspot_pos_x%
        mm_dy% = my% - CURSORS(CURSOR_MOVE).hotspot_pos_y%
        _PUTIMAGE (mm_dx%, mm_dy%), CURSORS(CURSOR_MOVE).img&, SCRN.CANVAS&
        CURSOR_render_overlays CURSOR_MOVE, mm_dx%, mm_dy%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
    ELSE
        ' Procedural 4-directional move arrow fallback
        DIM move_mx AS INTEGER, move_my AS INTEGER
        move_mx% = MOUSE.RAW_X%
        move_my% = MOUSE.RAW_Y%
        LINE (move_mx% - 1, move_my% - 6)-(move_mx% + 1, move_my% + 6), _RGB32(0, 0, 0), BF
        LINE (move_mx%, move_my% - 5)-(move_mx%, move_my% + 5), _RGB32(255, 255, 255)
        LINE (move_mx% - 6, move_my% - 1)-(move_mx% + 6, move_my% + 1), _RGB32(0, 0, 0), BF
        LINE (move_mx% - 5, move_my%)-(move_mx% + 5, move_my%), _RGB32(255, 255, 255)
        LINE (move_mx% - 3, move_my% - 4)-(move_mx%, move_my% - 7), _RGB32(0, 0, 0)
        LINE (move_mx% + 3, move_my% - 4)-(move_mx%, move_my% - 7), _RGB32(0, 0, 0)
        LINE (move_mx% - 2, move_my% - 4)-(move_mx%, move_my% - 6), _RGB32(255, 255, 255)
        LINE (move_mx% + 2, move_my% - 4)-(move_mx%, move_my% - 6), _RGB32(255, 255, 255)
        LINE (move_mx% - 3, move_my% + 4)-(move_mx%, move_my% + 7), _RGB32(0, 0, 0)
        LINE (move_mx% + 3, move_my% + 4)-(move_mx%, move_my% + 7), _RGB32(0, 0, 0)
        LINE (move_mx% - 2, move_my% + 4)-(move_mx%, move_my% + 6), _RGB32(255, 255, 255)
        LINE (move_mx% + 2, move_my% + 4)-(move_mx%, move_my% + 6), _RGB32(255, 255, 255)
        LINE (move_mx% - 4, move_my% - 3)-(move_mx% - 7, move_my%), _RGB32(0, 0, 0)
        LINE (move_mx% - 4, move_my% + 3)-(move_mx% - 7, move_my%), _RGB32(0, 0, 0)
        LINE (move_mx% - 4, move_my% - 2)-(move_mx% - 6, move_my%), _RGB32(255, 255, 255)
        LINE (move_mx% - 4, move_my% + 2)-(move_mx% - 6, move_my%), _RGB32(255, 255, 255)
        LINE (move_mx% + 4, move_my% - 3)-(move_mx% + 7, move_my%), _RGB32(0, 0, 0)
        LINE (move_mx% + 4, move_my% + 3)-(move_mx% + 7, move_my%), _RGB32(0, 0, 0)
        LINE (move_mx% + 4, move_my% - 2)-(move_mx% + 6, move_my%), _RGB32(255, 255, 255)
        LINE (move_mx% + 4, move_my% + 2)-(move_mx% + 6, move_my%), _RGB32(255, 255, 255)
    END IF
END SUB


''
' Draw fill tool cursor (PNG bucket or procedural fallback).
'
SUB POINTER_draw_fill_cursor (mx AS INTEGER, my AS INTEGER)
    IF CURSORS(CURSOR_FILL).img& < -1 THEN
        _PUTIMAGE (mx% - CURSORS(CURSOR_FILL).hotspot_pos_x%, my% - CURSORS(CURSOR_FILL).hotspot_pos_y%), CURSORS(CURSOR_FILL).img&, SCRN.CANVAS&
        CURSOR_render_overlays CURSOR_FILL, mx% - CURSORS(CURSOR_FILL).hotspot_pos_x%, my% - CURSORS(CURSOR_FILL).hotspot_pos_y%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
    ELSE
        ' Fallback: procedural fill bucket
        DIM fill_s AS STRING
        fill_s$ = "B" + "M" + ns$(mx%) + "," + ns$(my%)
        fill_s$ = fill_s$ + "C" + STR$(PAL_color(POINTER.O%)) + "M+2,+2R6D4L2D2L2U2L2U4M+3,+1R2"
        DRAW fill_s$
    END IF
END SUB


''
' Draw arrow cursor overlay for brush/spray tools (PNG brush arrow or procedural fallback).
' Determines whether arrow should be shown based on tool state and painting status.
'
SUB POINTER_draw_arrow_overlay (mx AS INTEGER, my AS INTEGER, is_painting AS INTEGER)
    DIM show_arrow AS INTEGER
    show_arrow% = FALSE

    IF CURRENT_TOOL% = TOOL_PICKER OR CURRENT_TOOL% = TOOL_MARQUEE OR CURRENT_TOOL% = TOOL_MOVE OR CURRENT_TOOL% = TOOL_TEXT OR CURRENT_TOOL% = TOOL_LINE OR CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED OR CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED OR CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED OR CURRENT_TOOL% = TOOL_FILL THEN
        show_arrow% = FALSE
    ELSEIF CURRENT_TOOL% = TOOL_BRUSH OR CURRENT_TOOL% = TOOL_DOT THEN
        IF BRUSH_SIZE.PREVIEW AND NOT is_painting% THEN
            show_arrow% = TRUE
        END IF
    ELSEIF CURRENT_TOOL% = TOOL_SPRAY THEN
        IF NOT is_painting% THEN
            show_arrow% = TRUE
        END IF
    ELSE
        show_arrow% = TRUE
    END IF

    IF show_arrow% THEN
        IF CURRENT_TOOL% = TOOL_DOT OR CURRENT_TOOL% = TOOL_BRUSH THEN
            ' For brush/dot: try PNG brush cursor, fallback to procedural arrow with FG chip
            IF CURSORS(CURSOR_BRUSH).img& < -1 THEN
                _PUTIMAGE (mx% - CURSORS(CURSOR_BRUSH).hotspot_pos_x%, my% - CURSORS(CURSOR_BRUSH).hotspot_pos_y%), CURSORS(CURSOR_BRUSH).img&, SCRN.CANVAS&
                CURSOR_render_overlays CURSOR_BRUSH, mx% - CURSORS(CURSOR_BRUSH).hotspot_pos_x%, my% - CURSORS(CURSOR_BRUSH).hotspot_pos_y%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
            ELSE
                ' Fallback: procedural arrow with FG color chip
                DIM i AS INTEGER, lineEnd AS INTEGER
                LINE (mx%, my%)-(mx%, my% + 12), _RGB32(0, 0, 0)
                LINE (mx%, my%)-(mx% + 8, my% + 8), _RGB32(0, 0, 0)
                LINE (mx% + 8, my% + 8)-(mx% + 3, my% + 8), _RGB32(0, 0, 0)
                LINE (mx% + 3, my% + 8)-(mx% + 3, my% + 12), _RGB32(0, 0, 0)
                LINE (mx% + 3, my% + 12)-(mx%, my% + 12), _RGB32(0, 0, 0)
                LINE (mx% - 1, my%)-(mx% - 1, my% + 13), _RGB32(0, 0, 0)
                LINE (mx% + 4, my% + 13)-(mx% - 1, my% + 13), _RGB32(0, 0, 0)
                LINE (mx% + 4, my% + 8)-(mx% + 4, my% + 13), _RGB32(0, 0, 0)
                LINE (mx% + 9, my% + 8)-(mx% + 4, my% + 8), _RGB32(0, 0, 0)
                LINE (mx%, my% - 1)-(mx% + 9, my% + 8), _RGB32(0, 0, 0)

                FOR i% = 1 TO 11
                    IF i% <= 7 THEN
                        lineEnd% = i%
                    ELSEIF i% <= 11 THEN
                        lineEnd% = 3
                    END IF
                    LINE (mx% + 1, my% + i%)-(mx% + lineEnd%, my% + i%), _RGB32(255, 255, 255)
                NEXT i%

                LINE (mx% + 2, my% + 4)-(mx% + 4, my% + 6), PAINT_COLOR~&, BF
            END IF
        ELSE
            ' Generic: try PNG cursor from POINTER.CURSOR_ID%, fallback to DRAW string
            IF POINTER.CURSOR_ID% >= 0 AND POINTER.CURSOR_ID% <= CURSOR_COUNT THEN
                IF CURSORS(POINTER.CURSOR_ID%).img& < -1 THEN
                    _PUTIMAGE (mx% - CURSORS(POINTER.CURSOR_ID%).hotspot_pos_x%, my% - CURSORS(POINTER.CURSOR_ID%).hotspot_pos_y%), CURSORS(POINTER.CURSOR_ID%).img&, SCRN.CANVAS&
                    CURSOR_render_overlays POINTER.CURSOR_ID%, mx% - CURSORS(POINTER.CURSOR_ID%).hotspot_pos_x%, my% - CURSORS(POINTER.CURSOR_ID%).hotspot_pos_y%, mx%, my%, 0, 0, 0, 0, 0, 0, 0, 0
                ELSE
                    DIM s AS STRING
                    s$ = "B" + "M" + ns$(mx%) + "," + ns$(my%) + POINTER.S$
                    DRAW s$
                END IF
            ELSE
                DIM s2 AS STRING
                s2$ = "B" + "M" + ns$(mx%) + "," + ns$(my%) + POINTER.S$
                DRAW s2$
            END IF
        END IF
    END IF
END SUB


''
' Draws the pointer
' 
SUB POINTER_draw ()
    DIM oldDest AS LONG
    DIM is_painting AS INTEGER
    DIM mx AS INTEGER, my AS INTEGER

    oldDest& = _DEST
    _DEST SCRN.CANVAS&
    _BLEND SCRN.CANVAS&

    mx% = _MOUSEX
    my% = _MOUSEY

    ' --- Early exits: panning, UI areas, custom brush ---
    IF SCRN.panning% THEN
        POINTER_draw_pan mx%, my%
        _DEST oldDest&
        EXIT SUB
    END IF

    DIM use_ui_cursor AS INTEGER
    use_ui_cursor% = FALSE

    IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(mx%, my%) THEN use_ui_cursor% = TRUE
    IF NOT use_ui_cursor% AND SCRN.showToolbar% AND ORGANIZER_is_over_area%(mx%, my%) THEN use_ui_cursor% = TRUE
    IF NOT use_ui_cursor% AND LAYER_PANEL.visible% AND mx% < CFG.LAYER_PANEL_WIDTH% THEN use_ui_cursor% = TRUE
    ' Check menu bar area
    IF NOT use_ui_cursor% AND SCRN.showMenubar% AND MENU_BAR.visible% THEN
        IF my% < MENU_BAR_HEIGHT AND mx% >= MENU_BAR.barX% THEN use_ui_cursor% = TRUE
        IF NOT use_ui_cursor% AND MENUBAR_submenu_in_bounds%(mx%, my%) THEN use_ui_cursor% = TRUE
    END IF
    IF NOT use_ui_cursor% AND SCRN.showStatus% THEN
        DIM strip_top AS INTEGER
        strip_top% = SCRN.h& - THEME.STATUS_height% - PALETTE_STRIP_get_height%
        IF my% >= strip_top% THEN use_ui_cursor% = TRUE
    END IF
    IF NOT use_ui_cursor% AND PALETTE_MENU_VISIBLE% THEN use_ui_cursor% = TRUE
    IF NOT use_ui_cursor% AND CURRENT_TOOL% = TOOL_NULL THEN use_ui_cursor% = TRUE

    IF use_ui_cursor% THEN
        POINTER_draw_ui_cursor mx%, my%
        _DEST oldDest&
        EXIT SUB
    END IF

    IF CUSTOM_BRUSH_is_active% THEN
        POINTER_draw_custom_brush mx%, my%
        _DEST oldDest&
        EXIT SUB
    END IF

    ' --- Tool-specific cursor rendering ---
    is_painting% = (_MOUSEBUTTON(1) <> 0)

    SELECT CASE CURRENT_TOOL%
        CASE TOOL_LINE, TOOL_POLYGON, TOOL_POLYGON_FILLED, TOOL_RECT, TOOL_RECT_FILLED, TOOL_ELLIPSE, TOOL_ELLIPSE_FILLED
            POINTER_draw_shape_crosshair mx%, my%
        CASE TOOL_PICKER
            POINTER_draw_picker mx%, my%
        CASE TOOL_BRUSH, TOOL_DOT
            POINTER_draw_brush_preview mx%, my%, is_painting%
        CASE TOOL_SPRAY
            POINTER_draw_spray_preview mx%, my%, is_painting%
        CASE TOOL_MARQUEE
            POINTER_draw_marquee mx%, my%
        CASE TOOL_MOVE
            POINTER_draw_move_cursor mx%, my%
        CASE TOOL_TEXT
            POINTER_draw_ibeam_cursor
        CASE TOOL_FILL
            POINTER_draw_fill_cursor mx%, my%
    END SELECT

    ' --- Arrow overlay for brush/spray/generic tools ---
    POINTER_draw_arrow_overlay mx%, my%, is_painting%

    _DEST oldDest&
END SUB


''
' Updates the pointer
' 
SUB POINTER_update ()
    POINTER.C~& = PAINT_COLOR~&
END SUB


''
' Draws dotted crosshair cursor for marquee tool
' - 8x8 dotted crosshair
' - Semi-transparent (33% opaque = 84/255 alpha)
' - White with black outline like brush cursor
'
SUB POINTER_draw_marquee_cursor ()
    DIM i AS INTEGER
    DIM mx AS INTEGER, my AS INTEGER
    DIM white_semi AS _UNSIGNED LONG
    DIM black_semi AS _UNSIGNED LONG
    
    ' Scale mouse coordinates from window to logical canvas
    mx% = _MOUSEX
    my% = _MOUSEY
    
    ' Semi-transparent colors (33% opaque = 84/255 alpha)
    white_semi~& = _RGBA32(255, 255, 255, 84)
    black_semi~& = _RGBA32(0, 0, 0, 84)
    
    ' Draw dotted horizontal line (8 pixels total, 4 pixels on each side)
    ' Black outline
    FOR i% = -4 TO 4 STEP 2
        IF i% <> 0 THEN ' Skip center
            PSET (mx% + i%, my% - 1), black_semi~&
            PSET (mx% + i%, my% + 1), black_semi~&
        END IF
    NEXT i%
    
    ' White dots
    FOR i% = -4 TO 4 STEP 2
        IF i% <> 0 THEN ' Skip center
            PSET (mx% + i%, my%), white_semi~&
        END IF
    NEXT i%
    
    ' Draw dotted vertical line (8 pixels total, 4 pixels on each side)
    ' Black outline
    FOR i% = -4 TO 4 STEP 2
        IF i% <> 0 THEN ' Skip center
            PSET (mx% - 1, my% + i%), black_semi~&
            PSET (mx% + 1, my% + i%), black_semi~&
        END IF
    NEXT i%
    
    ' White dots
    FOR i% = -4 TO 4 STEP 2
        IF i% <> 0 THEN ' Skip center
            PSET (mx%, my% + i%), white_semi~&
        END IF
    NEXT i%
    
    ' Draw center pixel (white with black outline)
    PSET (mx% - 1, my%), black_semi~&
    PSET (mx% + 1, my%), black_semi~&
    PSET (mx%, my% - 1), black_semi~&
    PSET (mx%, my% + 1), black_semi~&
    PSET (mx%, my%), white_semi~&
END SUB

''
' Draw I-beam cursor for text tool
'
SUB POINTER_draw_ibeam_cursor ()
    DIM mx AS INTEGER, my AS INTEGER
    DIM i AS INTEGER
    DIM white_c AS _UNSIGNED LONG, black_c AS _UNSIGNED LONG
    
    ' Scale mouse coordinates from window to logical canvas
    mx% = _MOUSEX
    my% = _MOUSEY
    
    ' Solid colors for I-beam
    white_c~& = _RGB32(255, 255, 255)
    black_c~& = _RGB32(0, 0, 0)
    
    ' I-beam cursor height (8 pixels by default, matches font height)
    DIM beam_height AS INTEGER
    beam_height = 8
    
    ' Draw vertical line
    LINE (mx%, my%)-(mx%, my% + beam_height - 1), white_c~&
    
    ' Draw top horizontal bar (3 pixels wide)
    LINE (mx% - 1, my%)-(mx% + 1, my%), white_c~&
    
    ' Draw bottom horizontal bar (3 pixels wide)
    LINE (mx% - 1, my% + beam_height - 1)-(mx% + 1, my% + beam_height - 1), white_c~&
END SUB


''
' Returns the padding (in canvas pixels) around the pointer position needed
' for the dirty-rect fast path. Accounts for cursor type and brush preview size.
'
FUNCTION POINTER_get_dirty_pad% ()
    DIM pad AS INTEGER
    pad% = 32 ' Default: covers PNG cursors + overlays (max ~21px cursor + color chips)

    ' Brush / Dot tool: circle preview radius = BRUSH_SIZE_pixels * zoom / 2
    IF CURRENT_TOOL% = TOOL_BRUSH OR CURRENT_TOOL% = TOOL_DOT THEN
        DIM bp AS INTEGER
        bp% = INT(BRUSH_SIZE_pixels% * SCRN.zoom! / 2) + 4
        IF bp% > pad% THEN pad% = bp%
    END IF

    ' Spray tool: same radius calculation as brush preview
    IF CURRENT_TOOL% = TOOL_SPRAY THEN
        DIM sp AS INTEGER
        sp% = INT(BRUSH_PIXEL_SIZES(BRUSH_SIZE.CURRENT) * SCRN.zoom! / 2) + 4
        IF sp% > pad% THEN pad% = sp%
    END IF

    ' Custom brush: scaled stamp preview
    IF CUSTOM_BRUSH_is_active% THEN
        DIM cbw AS INTEGER, cbh AS INTEGER
        cbw% = INT(CUSTOM_BRUSH.WIDTH% * SCRN.zoom! / 2) + 4
        cbh% = INT(CUSTOM_BRUSH.HEIGHT% * SCRN.zoom! / 2) + 4
        IF cbw% > pad% THEN pad% = cbw%
        IF cbh% > pad% THEN pad% = cbh%
    END IF

    POINTER_get_dirty_pad% = pad%
END FUNCTION


''
' Render just the cursor overlay on top of GUI elements.
' This is called AFTER GUI re-composite to ensure the cursor is visible
' above GUI widgets, even when brush previews are drawn underneath.
'
' Does NOT draw brush previews - only the small cursor indicator.
'
SUB POINTER_render_cursor_overlay ()
    IF POINTER.HIDDEN THEN EXIT SUB
    
    DIM oldDest AS LONG
    DIM mx AS INTEGER, my AS INTEGER
    
    oldDest& = _DEST
    _DEST SCRN.CANVAS&
    _BLEND SCRN.CANVAS&
    
    mx% = _MOUSEX
    my% = _MOUSEY
    
    ' Panning mode - hand cursor
    IF SCRN.panning% THEN
        IF CURSORS(CURSOR_HAND).img& < -1 THEN
            _PUTIMAGE (mx% - CURSORS(CURSOR_HAND).hotspot_pos_x%, my% - CURSORS(CURSOR_HAND).hotspot_pos_y%), CURSORS(CURSOR_HAND).img&, SCRN.CANVAS&
        ELSE
            LINE (mx% - 3, my% + 2)-(mx% + 3, my% + 6), _RGB32(255, 255, 255), BF
        END IF
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' UI area - arrow cursor
    DIM use_ui_cursor AS INTEGER
    use_ui_cursor% = FALSE
    IF SCRN.showToolbar% AND TOOLBAR_is_over_area%(mx%, my%) THEN use_ui_cursor% = TRUE
    IF NOT use_ui_cursor% AND SCRN.showToolbar% AND ORGANIZER_is_over_area%(mx%, my%) THEN use_ui_cursor% = TRUE
    IF NOT use_ui_cursor% AND LAYER_PANEL.visible% AND mx% < CFG.LAYER_PANEL_WIDTH% THEN use_ui_cursor% = TRUE
    IF NOT use_ui_cursor% AND SCRN.showMenubar% AND MENU_BAR.visible% THEN
        IF my% < MENU_BAR_HEIGHT AND mx% >= MENU_BAR.barX% THEN use_ui_cursor% = TRUE
        IF NOT use_ui_cursor% AND MENUBAR_submenu_in_bounds%(mx%, my%) THEN use_ui_cursor% = TRUE
    END IF
    IF NOT use_ui_cursor% AND SCRN.showStatus% THEN
        DIM strip_top AS INTEGER
        strip_top% = SCRN.h& - THEME.STATUS_height% - PALETTE_STRIP_get_height%
        IF my% >= strip_top% THEN use_ui_cursor% = TRUE
    END IF
    IF NOT use_ui_cursor% AND PALETTE_MENU_VISIBLE% THEN use_ui_cursor% = TRUE
    IF NOT use_ui_cursor% AND CURRENT_TOOL% = TOOL_NULL THEN use_ui_cursor% = TRUE
    
    IF use_ui_cursor% THEN
        IF CURSORS(CURSOR_NULL).img& < -1 THEN
            _PUTIMAGE (mx% - CURSORS(CURSOR_NULL).hotspot_pos_x%, my% - CURSORS(CURSOR_NULL).hotspot_pos_y%), CURSORS(CURSOR_NULL).img&, SCRN.CANVAS&
        ELSE
            ' Fallback procedural arrow
            DIM arr_i AS INTEGER, arr_w AS INTEGER
            FOR arr_i% = 0 TO 10
                IF arr_i% <= 7 THEN arr_w% = arr_i% ELSE arr_w% = 3
                LINE (mx%, my% + arr_i%)-(mx% + arr_w% + 1, my% + arr_i%), _RGB32(0, 0, 0)
            NEXT arr_i%
            FOR arr_i% = 1 TO 9
                IF arr_i% <= 6 THEN arr_w% = arr_i% - 1 ELSE arr_w% = 2
                IF arr_w% >= 1 THEN LINE (mx% + 1, my% + arr_i%)-(mx% + arr_w%, my% + arr_i%), _RGB32(255, 255, 255)
            NEXT arr_i%
        END IF
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' Custom brush - crosshair only (no brush preview)
    IF CUSTOM_BRUSH_is_active% THEN
        LINE (mx% - 3, my%)-(mx% - 1, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx% + 1, my%)-(mx% + 3, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% - 3)-(mx%, my% - 1), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% + 1)-(mx%, my% + 3), _RGBA32(255, 255, 255, 240)
        PSET (mx%, my%), _RGBA32(255, 0, 0, 255)
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' Shape tools and brush - crosshair
    IF CURRENT_TOOL% = TOOL_LINE OR CURRENT_TOOL% = TOOL_POLYGON OR CURRENT_TOOL% = TOOL_POLYGON_FILLED OR _
       CURRENT_TOOL% = TOOL_RECT OR CURRENT_TOOL% = TOOL_RECT_FILLED OR _
       CURRENT_TOOL% = TOOL_ELLIPSE OR CURRENT_TOOL% = TOOL_ELLIPSE_FILLED OR _
       CURRENT_TOOL% = TOOL_BRUSH OR CURRENT_TOOL% = TOOL_DOT OR CURRENT_TOOL% = TOOL_SPRAY THEN
        ' Small crosshair
        LINE (mx% - 4, my%)-(mx% - 1, my%), _RGBA32(0, 0, 0, 180)
        LINE (mx% + 1, my%)-(mx% + 4, my%), _RGBA32(0, 0, 0, 180)
        LINE (mx%, my% - 4)-(mx%, my% - 1), _RGBA32(0, 0, 0, 180)
        LINE (mx%, my% + 1)-(mx%, my% + 4), _RGBA32(0, 0, 0, 180)
        LINE (mx% - 3, my%)-(mx% - 1, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx% + 1, my%)-(mx% + 3, my%), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% - 3)-(mx%, my% - 1), _RGBA32(255, 255, 255, 240)
        LINE (mx%, my% + 1)-(mx%, my% + 3), _RGBA32(255, 255, 255, 240)
        PSET (mx%, my%), _RGBA32(255, 0, 0, 255)
        _DEST oldDest&
        EXIT SUB
    END IF
    
    ' Marquee/Move/Fill/Picker - PNG cursor
    ' Use POINTER.CURSOR_ID% which was set by POINTER_build to respect
    ' resize handle detection (avoids drawing move/marquee cursor over resize cursors)
    DIM cursor_id AS INTEGER
    cursor_id% = POINTER.CURSOR_ID%
    
    ' If POINTER_build didn't set a specific cursor, fall back to tool default
    IF cursor_id% = CURSOR_NULL OR cursor_id% < 0 THEN
        SELECT CASE CURRENT_TOOL%
            CASE TOOL_MARQUEE
                IF MARQUEE.MAGIC_WAND_MODE% THEN
                    cursor_id% = CURSOR_WAND
                ELSE
                    cursor_id% = CURSOR_MARQUEE
                END IF
            CASE TOOL_MOVE: cursor_id% = CURSOR_MOVE
            CASE TOOL_FILL: cursor_id% = CURSOR_FILL
            CASE TOOL_PICKER: cursor_id% = CURSOR_DROPPER
            CASE TOOL_ZOOM: cursor_id% = CURSOR_ZOOM
            CASE TOOL_PAN: cursor_id% = CURSOR_HAND
            CASE TOOL_TEXT: cursor_id% = -1  ' No PNG cursor  uses procedural I-beam
            CASE ELSE: cursor_id% = CURSOR_NULL
        END SELECT
    END IF
    
    IF cursor_id% >= 0 AND cursor_id% <= CURSOR_COUNT AND CURSORS(cursor_id%).img& < -1 THEN
        DIM ov_dx AS INTEGER, ov_dy AS INTEGER
        DIM ov_w AS INTEGER, ov_h AS INTEGER
        ov_w% = CURSORS(cursor_id%).w%
        ov_h% = CURSORS(cursor_id%).h%
        ov_dx% = mx% - CURSORS(cursor_id%).hotspot_pos_x%
        ov_dy% = my% - CURSORS(cursor_id%).hotspot_pos_y%
        SELECT CASE POINTER.CURSOR_FLIP%
            CASE 1  ' Flip horizontal
                _PUTIMAGE (ov_dx% + ov_w% - 1, ov_dy%)-(ov_dx%, ov_dy% + ov_h% - 1), CURSORS(cursor_id%).img&, SCRN.CANVAS&
            CASE 2  ' Flip vertical
                _PUTIMAGE (ov_dx%, ov_dy% + ov_h% - 1)-(ov_dx% + ov_w% - 1, ov_dy%), CURSORS(cursor_id%).img&, SCRN.CANVAS&
            CASE 3  ' Flip both
                _PUTIMAGE (ov_dx% + ov_w% - 1, ov_dy% + ov_h% - 1)-(ov_dx%, ov_dy%), CURSORS(cursor_id%).img&, SCRN.CANVAS&
            CASE ELSE  ' No flip
                _PUTIMAGE (ov_dx%, ov_dy%), CURSORS(cursor_id%).img&, SCRN.CANVAS&
        END SELECT
    END IF
    
    _DEST oldDest&
END SUB