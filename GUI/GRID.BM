''
' DRAW - GUI/GRID.BM
' =============================================================================
' Grid assistant subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initialize the grid assistant
' 
SUB GRID_init ()
    ' Setup the grid object
    GRID.imgWidth%   = SCRN.canvasW&                      ' Width of the painting canvas
    GRID.imgHeight%  = SCRN.canvasH&                      ' Height of the painting canvas
    ' Grid color: config overrides theme (CFG 0 = use theme default)
    IF CFG.GRID_COLOR_FG~& <> 0 THEN
        GRID.fgColor~& = CFG.GRID_COLOR_FG~&
    ELSE
        GRID.fgColor~& = THEME.GRID_color_fg~&
    END IF
    GRID.xPos%       = 0                            ' Left-most pixel of screen
    GRID.yPos%       = 0                            ' Top-most pixel of screen
    ' Grid size: config overrides theme (CFG 0 = use theme default)
    IF CFG.GRID_SIZE_X% > 0 THEN
        GRID.gridWidth% = CFG.GRID_SIZE_X%
    ELSE
        GRID.gridWidth% = THEME.GRID_size_x%
    END IF
    IF CFG.GRID_SIZE_Y% > 0 THEN
        GRID.gridHeight% = CFG.GRID_SIZE_Y%
    ELSE
        GRID.gridHeight% = THEME.GRID_size_y%
    END IF
    GRID.hStyle%     = &B1111111111111111           ' Solid
    GRID.vStyle%     = &B1111111111111111           ' Solid
    GRID.imgHandle&  = _NEWIMAGE(GRID.imgWidth%, GRID.imgHeight%, 32)  ' Mode 32 to match canvas
    GRID.SHOW%       = FALSE                        ' Grid hidden by default
    GRID.SNAP%       = FALSE                        ' Snap disabled by default
    GRID.ALIGN_MODE% = GRID_ALIGN_CORNER            ' Corner alignment by default (snap to grid lines)
    GRID.GRID_MODE%  = CFG.GRID_MODE%                ' Grid mode from config (0=square default)
    GRID.CELL_FILL%  = (CFG.GRID_CELL_FILL% <> 0)     ' Cell fill mode from config
    
    ' Draw the grid image once
    GRID_draw
END SUB


''
' Draw grid
' 
SUB GRID_draw ()
    DIM AS INTEGER x, y
    DIM gridOpacity AS INTEGER
    DIM oldDest AS LONG
    oldDest& = _DEST
    _DEST GRID.imgHandle&
    CLS , _RGBA32(0, 0, 0, 0)  ' Clear with transparency
    
    ' Resolve grid angle: config overrides theme (CFG 0 = use theme default)
    DIM gridAngle AS SINGLE
    IF CFG.GRID_ANGLE! <> 0 THEN
        gridAngle! = CFG.GRID_ANGLE!
    ELSE
        gridAngle! = THEME.GRID_angle!
    END IF

    ' Determine effective grid mode: GRID_MODE takes priority, then angle-based
    DIM effectiveMode AS INTEGER
    effectiveMode% = GRID.GRID_MODE%

    SELECT CASE effectiveMode%
        CASE GRID_MODE_DIAGONAL
            ' === 45-degree diagonal grid: pure integer math ===
            DIM cx45 AS INTEGER, cy45 AS INTEGER
            DIM c0 AS INTEGER, d0 AS INTEGER
            DIM ymxStep AS INTEGER, ypxStep AS INTEGER
            DIM numC AS INTEGER, numD AS INTEGER
            DIM ic AS INTEGER, id AS INTEGER
            DIM c AS INTEGER, d AS INTEGER
            DIM imgW AS INTEGER, imgH AS INTEGER

            cx45% = GRID.imgWidth% \ 2
            cy45% = GRID.imgHeight% \ 2
            c0% = cy45% - cx45%
            d0% = cy45% + cx45%
            imgW% = GRID.imgWidth%
            imgH% = GRID.imgHeight%

            ' Step = nearest even integer to gridSize*sqrt(2)
            ymxStep% = INT(GRID.gridWidth% * 1.41421356! / 2! + 0.5!) * 2
            ypxStep% = INT(GRID.gridHeight% * 1.41421356! / 2! + 0.5!) * 2
            IF ymxStep% < 2 THEN ymxStep% = 2
            IF ypxStep% < 2 THEN ypxStep% = 2

            ' slope +1 family: y = x + c
            numC% = (imgW% + imgH%) \ ymxStep% + 1
            FOR ic% = -numC% TO numC%
                c% = c0% + ic% * ymxStep%
                LINE (0, c%)-(imgW% - 1, c% + imgW% - 1), GRID.fgColor~&
            NEXT ic%

            ' slope -1 family: y = -x + d
            numD% = (imgW% + imgH%) \ ypxStep% + 1
            FOR id% = -numD% TO numD%
                d% = d0% + id% * ypxStep%
                LINE (0, d%)-(imgW% - 1, d% - imgW% + 1), GRID.fgColor~&
            NEXT id%

        CASE GRID_MODE_ISOMETRIC
            ' === 2:1 Pixel Isometric grid: vertical lines + 26.565° diagonals ===
            ' Three families of lines that ALL share intersection points:
            '   1) Vertical lines at x = k * W
            '   2) +26.565° lines: y = 0.5*x + n * W  (slope +0.5, 2px right per 1px down)
            '   3) -26.565° lines: y = -0.5*x + n * W  (slope -0.5, 2px right per 1px up)
            '
            ' Key math: slope = 0.5 (arctan(1/2) = 26.565°), yStep = W.
            ' Diagonal intersections land exactly on vertical lines.
            ' At column k: y = (k/2 + n) * W for integer n.
            ' Even columns: y at integer multiples of W
            ' Odd columns: y at half-integer multiples of W
            DIM isoW AS INTEGER, isoH AS INTEGER
            DIM isoGW AS SINGLE
            DIM isoYStep AS SINGLE  ' y-intercept spacing = W
            DIM isoSlope AS SINGLE  ' slope = 0.5 (2:1 pixel ratio)
            DIM isoNumV AS INTEGER, isoNumD AS INTEGER
            DIM ii AS INTEGER

            isoW% = GRID.imgWidth%
            isoH% = GRID.imgHeight%
            isoGW! = GRID.gridWidth%
            isoSlope! = 0.5!        ' 2:1 pixel isometric (arctan(0.5) = 26.565°)
            isoYStep! = isoGW!      ' yStep = W (clean integer spacing)

            ' 1) Vertical lines
            isoNumV% = isoW% \ GRID.gridWidth% + 2
            FOR ii% = -1 TO isoNumV%
                x% = ii% * GRID.gridWidth%
                IF x% >= -1 AND x% <= isoW% THEN
                    LINE (x%, 0)-(x%, isoH% - 1), GRID.fgColor~&
                END IF
            NEXT ii%

            ' 2) +26.565° family: y = isoSlope * x + n * isoYStep
            '    At x=0: y = n*W.  At x=isoW: y = 0.5*isoW + n*W
            isoNumD% = INT((isoH% + isoSlope! * isoW%) / isoYStep!) + 2
            FOR ii% = -isoNumD% TO isoNumD%
                DIM iy1s AS SINGLE, iy2s AS SINGLE
                iy1s! = ii% * isoYStep!
                iy2s! = isoSlope! * isoW% + ii% * isoYStep!
                LINE (0, INT(iy1s! + 0.5!))-(isoW% - 1, INT(iy2s! + 0.5!)), GRID.fgColor~&
            NEXT ii%

            ' 3) -26.565° family: y = -isoSlope * x + n * isoYStep
            FOR ii% = -isoNumD% TO isoNumD%
                iy1s! = ii% * isoYStep!
                iy2s! = -isoSlope! * isoW% + ii% * isoYStep!
                LINE (0, INT(iy1s! + 0.5!))-(isoW% - 1, INT(iy2s! + 0.5!)), GRID.fgColor~&
            NEXT ii%

        CASE GRID_MODE_HEX
            ' === Hexagonal grid ===
            ' Flat-top hexagons tiled in offset columns.
            ' Hex geometry (flat-top, R = circumradius = hexW/2):
            '   hexW = gridWidth (point-to-point horizontal = 2R)
            '   hexH = R * sqrt(3) = hexW * sqrt(3)/2 (flat-to-flat vertical)
            '   Column spacing = hexW * 3/4 = 3R/2
            '   Row spacing = hexH = R * sqrt(3)
            '   Odd columns offset by hexH/2
            DIM hexW AS SINGLE, hexH AS SINGLE
            DIM hexColStep AS SINGLE, hexRowStep AS SINGLE
            DIM hexNumCols AS INTEGER, hexNumRows AS INTEGER
            DIM hCol AS INTEGER, hRow AS INTEGER
            DIM hcx AS SINGLE, hcy AS SINGLE
            DIM hx0 AS INTEGER, hy0 AS INTEGER
            DIM hx1 AS INTEGER, hy1 AS INTEGER
            DIM hx2 AS INTEGER, hy2 AS INTEGER
            DIM hx3 AS INTEGER, hy3 AS INTEGER
            DIM hx4 AS INTEGER, hy4 AS INTEGER
            DIM hx5 AS INTEGER, hy5 AS INTEGER

            hexW! = GRID.gridWidth%
            hexH! = hexW! * 0.5!  ' 45-degree diagonal height
            hexColStep! = hexW! * 0.75!
            hexRowStep! = hexH!
            hexNumCols% = INT(GRID.imgWidth% / hexColStep!) + 3
            hexNumRows% = INT(GRID.imgHeight% / hexRowStep!) + 3

            FOR hCol% = -1 TO hexNumCols%
                FOR hRow% = -1 TO hexNumRows%
                    ' Center of this hex
                    hcx! = hCol% * hexColStep!
                    hcy! = hRow% * hexRowStep!
                    ' Odd columns are offset by half a row
                    IF (hCol% AND 1) THEN hcy! = hcy! + hexRowStep! * 0.5!

                    ' 6 vertices of flat-top hex (radius = hexW/2)
                    DIM hexR AS SINGLE
                    hexR! = hexW! / 2.0!
                    ' Flat-top hex vertices at angles 0, 60, 120, 180, 240, 300 degrees
                    hx0% = INT(hcx! + hexR! + 0.5!)
                    hy0% = INT(hcy! + 0.5!)
                    hx1% = INT(hcx! + hexR! * 0.5! + 0.5!)
                    hy1% = INT(hcy! - hexR! * 0.5! + 0.5!)
                    hx2% = INT(hcx! - hexR! * 0.5! + 0.5!)
                    hy2% = INT(hcy! - hexR! * 0.5! + 0.5!)
                    hx3% = INT(hcx! - hexR! + 0.5!)
                    hy3% = INT(hcy! + 0.5!)
                    hx4% = INT(hcx! - hexR! * 0.5! + 0.5!)
                    hy4% = INT(hcy! + hexR! * 0.5! + 0.5!)
                    hx5% = INT(hcx! + hexR! * 0.5! + 0.5!)
                    hy5% = INT(hcy! + hexR! * 0.5! + 0.5!)

                    ' Draw the 6 edges
                    LINE (hx0%, hy0%)-(hx1%, hy1%), GRID.fgColor~&
                    LINE (hx1%, hy1%)-(hx2%, hy2%), GRID.fgColor~&
                    LINE (hx2%, hy2%)-(hx3%, hy3%), GRID.fgColor~&
                    LINE (hx3%, hy3%)-(hx4%, hy4%), GRID.fgColor~&
                    LINE (hx4%, hy4%)-(hx5%, hy5%), GRID.fgColor~&
                    LINE (hx5%, hy5%)-(hx0%, hy0%), GRID.fgColor~&
                NEXT hRow%
            NEXT hCol%

        CASE ELSE
            ' Check for angle-based rotation (legacy GRID_ANGLE support)
            IF gridAngle! <> 0 THEN
                ' === General rotated grid: continuous edge-to-edge lines ===
                DIM angleRad AS SINGLE
                DIM cosA AS SINGLE, sinA AS SINGLE
                DIM diagLen AS SINGLE
                DIM cx AS SINGLE, cy AS SINGLE
                DIM numA AS INTEGER, numB AS INTEGER
                DIM i AS INTEGER
                DIM x1 AS SINGLE, y1 AS SINGLE
                DIM x2 AS SINGLE, y2 AS SINGLE

                angleRad! = gridAngle! * 3.14159265! / 180.0!
                cosA! = COS(angleRad!)
                sinA! = SIN(angleRad!)
                diagLen! = SQR(1! * GRID.imgWidth% * GRID.imgWidth% + 1! * GRID.imgHeight% * GRID.imgHeight%)
                cx! = GRID.imgWidth% / 2.0!
                cy! = GRID.imgHeight% / 2.0!

                numA% = INT(diagLen! / GRID.gridWidth%) + 1
                FOR i% = -numA% TO numA%
                    DIM lcxA AS SINGLE, lcyA AS SINGLE
                    lcxA! = cx! + i% * GRID.gridWidth% * (-sinA!)
                    lcyA! = cy! + i% * GRID.gridWidth% * cosA!
                    x1! = lcxA! - diagLen! * 0.5! * cosA!
                    y1! = lcyA! - diagLen! * 0.5! * sinA!
                    x2! = lcxA! + diagLen! * 0.5! * cosA!
                    y2! = lcyA! + diagLen! * 0.5! * sinA!
                    LINE (INT(x1!), INT(y1!))-(INT(x2!), INT(y2!)), GRID.fgColor~&
                NEXT i%

                numB% = INT(diagLen! / GRID.gridHeight%) + 1
                FOR i% = -numB% TO numB%
                    DIM lcxB AS SINGLE, lcyB AS SINGLE
                    lcxB! = cx! + i% * GRID.gridHeight% * cosA!
                    lcyB! = cy! + i% * GRID.gridHeight% * sinA!
                    x1! = lcxB! - diagLen! * 0.5! * (-sinA!)
                    y1! = lcyB! - diagLen! * 0.5! * cosA!
                    x2! = lcxB! + diagLen! * 0.5! * (-sinA!)
                    y2! = lcyB! + diagLen! * 0.5! * cosA!
                    LINE (INT(x1!), INT(y1!))-(INT(x2!), INT(y2!)), GRID.fgColor~&
                NEXT i%
            ELSE
                ' === Standard axis-aligned grid ===
                FOR x% = GRID.xPos% TO GRID.imgWidth% STEP GRID.gridWidth%
                    LINE (x%, GRID.yPos%)-(x%, GRID.imgHeight%), _
                        GRID.fgColor~&, , GRID.vStyle%
                NEXT x%
                FOR y% = GRID.yPos% TO GRID.imgHeight% STEP GRID.gridHeight%
                    LINE (GRID.xPos%, y%)-(GRID.imgWidth%, y%), _
                        GRID.fgColor~&, , GRID.hStyle%
                NEXT y%
            END IF
    END SELECT

    ' Grid opacity: config overrides theme (CFG 0 = use theme default)
    IF CFG.GRID_OPACITY% > 0 THEN
        gridOpacity% = CFG.GRID_OPACITY%
    ELSE
        gridOpacity% = THEME.GRID_opacity%
    END IF
    _SETALPHA gridOpacity%, GRID.fgColor~& TO GRID.fgColor~&, GRID.imgHandle&
    _DEST oldDest&
END SUB


''
' Put the grid onto the screen
' description
' 
SUB GRID_put ()
    _PUTIMAGE (GRID.xPos%, GRID.yPos%), GRID.imgHandle
END SUB


''
' Snap coordinate to nearest grid point
' @param INTEGER value - The coordinate value to snap
' @return INTEGER - The snapped coordinate value
' 
FUNCTION GRID_snap% (value AS INTEGER)
    IF GRID.SNAP% THEN
        IF GRID.ALIGN_MODE% = GRID_ALIGN_CENTER THEN
            ' Snap to cell centers (halfway between grid lines)
            DIM halfGrid AS INTEGER
            halfGrid% = GRID.gridWidth% \ 2
            GRID_snap% = INT((value - halfGrid% + GRID.gridWidth% / 2) / GRID.gridWidth%) * GRID.gridWidth% + halfGrid%
        ELSE
            ' Snap to intersections (on grid lines)
            GRID_snap% = INT((value + GRID.gridWidth% / 2) / GRID.gridWidth%) * GRID.gridWidth%
        END IF
    ELSE
        ' Return original value if snap is disabled
        GRID_snap% = value
    END IF
END FUNCTION


''
' Snap X,Y coordinate pair to nearest grid intersection point.
' Handles all grid modes: square, diagonal, isometric, hex, and angle-based.
' @param INTEGER snapX - X coordinate (modified in place)
' @param INTEGER snapY - Y coordinate (modified in place)
'
SUB GRID_snap_xy (snapX AS INTEGER, snapY AS INTEGER)
    IF NOT GRID.SNAP% THEN EXIT SUB

    SELECT CASE GRID.GRID_MODE%
        CASE GRID_MODE_DIAGONAL
            ' === 45-degree snap: pure integer diagonal math ===
            DIM scx AS INTEGER, scy AS INTEGER
            DIM sc0 AS INTEGER, sd0 AS INTEGER
            DIM sYmxStep AS INTEGER, sYpxStep AS INTEGER
            DIM mc AS INTEGER, md AS INTEGER
            DIM nearI AS INTEGER, nearJ AS INTEGER
            DIM snappedC AS INTEGER, snappedD AS INTEGER

            scx% = GRID.imgWidth% \ 2
            scy% = GRID.imgHeight% \ 2
            sc0% = scy% - scx%
            sd0% = scy% + scx%

            sYmxStep% = INT(GRID.gridWidth% * 1.41421356! / 2! + 0.5!) * 2
            sYpxStep% = INT(GRID.gridHeight% * 1.41421356! / 2! + 0.5!) * 2
            IF sYmxStep% < 2 THEN sYmxStep% = 2
            IF sYpxStep% < 2 THEN sYpxStep% = 2

            mc% = snapY% - snapX%
            md% = snapY% + snapX%

            IF GRID.ALIGN_MODE% = GRID_ALIGN_CENTER THEN
                DIM halfSA AS INTEGER, halfSB AS INTEGER
                halfSA% = sYmxStep% \ 2
                halfSB% = sYpxStep% \ 2
                nearI% = INT(CSNG(mc% - sc0% - halfSA%) / CSNG(sYmxStep%) + 0.5!)
                snappedC% = sc0% + halfSA% + nearI% * sYmxStep%
                nearJ% = INT(CSNG(md% - sd0% - halfSB%) / CSNG(sYpxStep%) + 0.5!)
                snappedD% = sd0% + halfSB% + nearJ% * sYpxStep%
            ELSE
                nearI% = INT(CSNG(mc% - sc0%) / CSNG(sYmxStep%) + 0.5!)
                snappedC% = sc0% + nearI% * sYmxStep%
                nearJ% = INT(CSNG(md% - sd0%) / CSNG(sYpxStep%) + 0.5!)
                snappedD% = sd0% + nearJ% * sYpxStep%
            END IF

            snapX% = (snappedD% - snappedC%) \ 2
            snapY% = (snappedD% + snappedC%) \ 2

        CASE GRID_MODE_ISOMETRIC
            ' === 2:1 Pixel Isometric snap ===
            ' Intersection points at (k*W, (k/2 + n) * W) for integers k, n.
            ' Staggered pattern: even columns at y = n*W,
            ' odd columns at y = (n + 0.5)*W. Check 3 nearest vertical
            ' columns and find the closest intersection point.
            DIM isoGW AS SINGLE
            DIM isoHalfSlope AS SINGLE ' W * 0.5 (half-step for odd columns)
            DIM isoYStep AS SINGLE     ' W
            DIM nearK AS INTEGER
            DIM bestDistSq AS SINGLE, bestSnapX AS SINGLE, bestSnapY AS SINGLE
            DIM kk AS INTEGER, nn AS INTEGER
            DIM xSnap AS SINGLE, yBase AS SINGLE, nApprox AS SINGLE
            DIM ySnap AS SINGLE, dSq AS SINGLE

            isoGW! = GRID.gridWidth%
            isoHalfSlope! = isoGW! * 0.5!  ' W/2 (y-offset per column)
            isoYStep! = isoGW!              ' W (spacing between parallel diagonals)

            nearK% = INT(CSNG(snapX%) / isoGW! + 0.5!)
            bestDistSq! = 999999!
            bestSnapX! = snapX%
            bestSnapY! = snapY%

            FOR kk% = nearK% - 1 TO nearK% + 1
                xSnap! = kk% * isoGW!
                ' On vertical k, intersections at y = k*W/2 + n*W
                yBase! = kk% * isoHalfSlope!
                nApprox! = (CSNG(snapY%) - yBase!) / isoYStep!
                FOR nn% = INT(nApprox!) TO INT(nApprox!) + 1
                    ySnap! = yBase! + nn% * isoYStep!
                    dSq! = (snapX% - xSnap!) * (snapX% - xSnap!) + (snapY% - ySnap!) * (snapY% - ySnap!)
                    IF dSq! < bestDistSq! THEN
                        bestDistSq! = dSq!
                        bestSnapX! = xSnap!
                        bestSnapY! = ySnap!
                    END IF
                NEXT nn%
            NEXT kk%

            snapX% = INT(bestSnapX! + 0.5!)
            snapY% = INT(bestSnapY! + 0.5!)

        CASE GRID_MODE_HEX
            ' === Hexagonal snap: snap to nearest hex VERTEX ===
            ' Find the nearest hex center, then snap to the closest of its
            ' 6 vertices (corners where edges meet). This is analogous to
            ' isometric snapping to line intersections.
            DIM hexW AS SINGLE, hexR AS SINGLE
            DIM hexColStep AS SINGLE, hexRowStep AS SINGLE
            DIM nearHCol AS INTEGER
            DIM hBestDist AS SINGLE, hBestX AS SINGLE, hBestY AS SINGLE
            DIM hcc AS INTEGER, hrr AS INTEGER
            DIM hcxS AS SINGLE, hcyS AS SINGLE, hRowOff AS SINGLE
            DIM hvx AS SINGLE, hvy AS SINGLE, hdSq AS SINGLE
            DIM hv AS INTEGER

            hexW! = GRID.gridWidth%
            hexR! = hexW! / 2.0!
            hexColStep! = hexW! * 0.75!
            hexRowStep! = hexW! * 0.5!  ' 45-degree hex height

            ' Find approximate nearest column
            nearHCol% = INT(CSNG(snapX%) / hexColStep! + 0.5!)
            hBestDist! = 999999!
            hBestX! = snapX%
            hBestY! = snapY%

            ' Check nearby hex centers and their 6 vertices
            FOR hcc% = nearHCol% - 1 TO nearHCol% + 1
                hcxS! = hcc% * hexColStep!
                IF (hcc% AND 1) THEN
                    hRowOff! = hexRowStep! * 0.5!
                ELSE
                    hRowOff! = 0!
                END IF
                DIM nearHRow AS INTEGER
                nearHRow% = INT((CSNG(snapY%) - hRowOff!) / hexRowStep! + 0.5!)
                FOR hrr% = nearHRow% - 1 TO nearHRow% + 1
                    hcyS! = hrr% * hexRowStep! + hRowOff!
                    ' Test all 6 vertices of this hex
                    FOR hv% = 0 TO 5
                        SELECT CASE hv%
                            CASE 0: hvx! = hcxS! + hexR!:          hvy! = hcyS!
                            CASE 1: hvx! = hcxS! + hexR! * 0.5!:   hvy! = hcyS! - hexR! * 0.5!
                            CASE 2: hvx! = hcxS! - hexR! * 0.5!:   hvy! = hcyS! - hexR! * 0.5!
                            CASE 3: hvx! = hcxS! - hexR!:          hvy! = hcyS!
                            CASE 4: hvx! = hcxS! - hexR! * 0.5!:   hvy! = hcyS! + hexR! * 0.5!
                            CASE 5: hvx! = hcxS! + hexR! * 0.5!:   hvy! = hcyS! + hexR! * 0.5!
                        END SELECT
                        hdSq! = (snapX% - hvx!) * (snapX% - hvx!) + (snapY% - hvy!) * (snapY% - hvy!)
                        IF hdSq! < hBestDist! THEN
                            hBestDist! = hdSq!
                            hBestX! = hvx!
                            hBestY! = hvy!
                        END IF
                    NEXT hv%
                NEXT hrr%
            NEXT hcc%

            snapX% = INT(hBestX! + 0.5!)
            snapY% = INT(hBestY! + 0.5!)

        CASE ELSE
            ' Check for angle-based rotation (legacy GRID_ANGLE support)
            DIM gridAngle AS SINGLE
            IF CFG.GRID_ANGLE! <> 0 THEN
                gridAngle! = CFG.GRID_ANGLE!
            ELSE
                gridAngle! = THEME.GRID_angle!
            END IF

            IF gridAngle! = 0 THEN
                ' Standard axis-aligned snap
                snapX% = GRID_snap%(snapX%)
                snapY% = GRID_snap%(snapY%)
            ELSE
                ' General rotated grid snap (trig-based)
                DIM angleRad AS SINGLE
                DIM cosA AS SINGLE, sinA AS SINGLE
                DIM cx AS SINGLE, cy AS SINGLE
                DIM relX AS SINGLE, relY AS SINGLE
                DIM projA AS SINGLE, projB AS SINGLE
                DIM snappedA AS SINGLE, snappedB AS SINGLE

                angleRad! = gridAngle! * 3.14159265! / 180.0!
                cosA! = COS(angleRad!)
                sinA! = SIN(angleRad!)
                cx! = GRID.imgWidth% / 2.0!
                cy! = GRID.imgHeight% / 2.0!
                relX! = snapX% - cx!
                relY! = snapY% - cy!

                projA! = relX! * cosA! + relY! * sinA!
                projB! = -relX! * sinA! + relY! * cosA!

                IF GRID.ALIGN_MODE% = GRID_ALIGN_CENTER THEN
                    DIM halfW AS SINGLE, halfH AS SINGLE
                    halfH! = GRID.gridHeight% / 2.0!
                    halfW! = GRID.gridWidth% / 2.0!
                    snappedA! = INT((projA! - halfH! + GRID.gridHeight% / 2.0!) / GRID.gridHeight%) * GRID.gridHeight% + halfH!
                    snappedB! = INT((projB! - halfW! + GRID.gridWidth% / 2.0!) / GRID.gridWidth%) * GRID.gridWidth% + halfW!
                ELSE
                    snappedA! = INT((projA! + GRID.gridHeight% / 2.0!) / GRID.gridHeight%) * GRID.gridHeight%
                    snappedB! = INT((projB! + GRID.gridWidth% / 2.0!) / GRID.gridWidth%) * GRID.gridWidth%
                END IF

                snapX% = INT(cx! + snappedA! * cosA! - snappedB! * sinA!)
                snapY% = INT(cy! + snappedA! * sinA! + snappedB! * cosA!)
            END IF
    END SELECT
END SUB


''
' Initialize the pixel grid (checkerboard for high zoom levels)
'
SUB PIXEL_GRID_init ()
    PIXEL_GRID.SHOW% = TRUE  ' Enabled by default (auto-shows at 400%+ zoom)
    PIXEL_GRID.color1~& = THEME.PIXEL_GRID_color1~&
    PIXEL_GRID.color2~& = THEME.PIXEL_GRID_color2~&
    PIXEL_GRID.imgHandle& = _NEWIMAGE(SCRN.canvasW&, SCRN.canvasH&, 32)
    PIXEL_GRID_draw
END SUB


''
' Draw the pixel grid - single pixel lines around each pixel
'
SUB PIXEL_GRID_draw ()
    DIM AS INTEGER x, y
    DIM oldDest AS LONG
    oldDest& = _DEST
    _DEST PIXEL_GRID.imgHandle&
    CLS , _RGBA32(0, 0, 0, 0)  ' Clear with transparency
    
    ' Draw vertical lines (at each x position)
    FOR x% = 0 TO SCRN.canvasW& - 1
        LINE (x%, 0)-(x%, SCRN.canvasH& - 1), PIXEL_GRID.color1~&
    NEXT x%
    
    ' Draw horizontal lines (at each y position)
    FOR y% = 0 TO SCRN.canvasH& - 1
        LINE (0, y%)-(SCRN.canvasW& - 1, y%), PIXEL_GRID.color1~&
    NEXT y%
    
    _DEST oldDest&
END SUB


''
' Scanline-fill a triangle. No PAINT needed, no leak possible.
' @param SINGLE x1,y1,x2,y2,x3,y3 - triangle vertices
' @param _UNSIGNED LONG c - fill color
'
SUB GRID_fill_tri (x1 AS SINGLE, y1 AS SINGLE, x2 AS SINGLE, y2 AS SINGLE, x3 AS SINGLE, y3 AS SINGLE, c AS _UNSIGNED LONG)
    ' Sort vertices by y (ascending)
    DIM ax AS SINGLE, ay AS SINGLE
    DIM bx AS SINGLE, by AS SINGLE
    DIM cx AS SINGLE, cy AS SINGLE
    DIM tmp AS SINGLE
    ax! = x1!: ay! = y1!
    bx! = x2!: by! = y2!
    cx! = x3!: cy! = y3!
    IF ay! > by! THEN tmp! = ax!: ax! = bx!: bx! = tmp!: tmp! = ay!: ay! = by!: by! = tmp!
    IF ay! > cy! THEN tmp! = ax!: ax! = cx!: cx! = tmp!: tmp! = ay!: ay! = cy!: cy! = tmp!
    IF by! > cy! THEN tmp! = bx!: bx! = cx!: cx! = tmp!: tmp! = by!: by! = cy!: cy! = tmp!

    DIM yMin AS INTEGER, yMax AS INTEGER
    DIM yMid AS INTEGER, scanY AS INTEGER
    DIM xAC AS SINGLE, xShort AS SINGLE
    DIM xLeft AS SINGLE, xRight AS SINGLE
    DIM t AS SINGLE

    yMin% = INT(ay! + 0.5!)
    yMax% = INT(cy! + 0.5!)
    yMid% = INT(by! + 0.5!)
    IF yMax% < yMin% THEN EXIT SUB

    FOR scanY% = yMin% TO yMax%
        ' Long edge A->C
        IF cy! - ay! > 0.001! THEN
            t! = (CSNG(scanY%) - ay!) / (cy! - ay!)
        ELSE
            t! = 0!
        END IF
        xAC! = ax! + t! * (cx! - ax!)

        ' Short edge: A->B or B->C
        IF scanY% < yMid% THEN
            IF by! - ay! > 0.001! THEN
                t! = (CSNG(scanY%) - ay!) / (by! - ay!)
            ELSE
                t! = 0!
            END IF
            xShort! = ax! + t! * (bx! - ax!)
        ELSE
            IF cy! - by! > 0.001! THEN
                t! = (CSNG(scanY%) - by!) / (cy! - by!)
            ELSE
                t! = 0!
            END IF
            xShort! = bx! + t! * (cx! - bx!)
        END IF

        IF xAC! < xShort! THEN
            xLeft! = xAC!: xRight! = xShort!
        ELSE
            xLeft! = xShort!: xRight! = xAC!
        END IF
        LINE (INT(xLeft! + 0.5!), scanY%)-(INT(xRight! + 0.5!), scanY%), c~&
    NEXT scanY%

    ' Draw outline in fill color to seal any sub-pixel gaps at shared edges
    LINE (INT(ax! + 0.5!), INT(ay! + 0.5!))-(INT(bx! + 0.5!), INT(by! + 0.5!)), c~&
    LINE (INT(bx! + 0.5!), INT(by! + 0.5!))-(INT(cx! + 0.5!), INT(cy! + 0.5!)), c~&
    LINE (INT(cx! + 0.5!), INT(cy! + 0.5!))-(INT(ax! + 0.5!), INT(ay! + 0.5!)), c~&
END SUB


''
' Scanline-fill a convex polygon (up to 8 vertices). No PAINT leak.
' @param INTEGER n - number of vertices
' @param SINGLE vx() - x coordinates (0 to n-1)
' @param SINGLE vy() - y coordinates (0 to n-1)
' @param _UNSIGNED LONG c - fill color
'
SUB GRID_fill_poly (n AS INTEGER, vx() AS SINGLE, vy() AS SINGLE, c AS _UNSIGNED LONG)
    IF n% < 3 THEN EXIT SUB

    ' Find y range
    DIM pyMin AS SINGLE, pyMax AS SINGLE
    DIM pi AS INTEGER
    pyMin! = vy(0): pyMax! = vy(0)
    FOR pi% = 1 TO n% - 1
        IF vy(pi%) < pyMin! THEN pyMin! = vy(pi%)
        IF vy(pi%) > pyMax! THEN pyMax! = vy(pi%)
    NEXT pi%

    DIM yStart AS INTEGER, yEnd AS INTEGER
    yStart% = INT(pyMin! + 0.5!)
    yEnd% = INT(pyMax! + 0.5!)

    DIM scanY AS INTEGER
    DIM xMin AS SINGLE, xMax AS SINGLE
    DIM gotHit AS INTEGER
    DIM j AS INTEGER
    DIM ey1 AS SINGLE, ey2 AS SINGLE
    DIM ex1 AS SINGLE, ex2 AS SINGLE
    DIM xHit AS SINGLE

    FOR scanY% = yStart% TO yEnd%
        gotHit% = FALSE
        FOR pi% = 0 TO n% - 1
            j% = (pi% + 1) MOD n%
            ey1! = vy(pi%): ey2! = vy(j%)
            ex1! = vx(pi%): ex2! = vx(j%)

            ' Does this edge span scanY?
            IF (ey1! <= CSNG(scanY%) AND ey2! >= CSNG(scanY%)) OR _
               (ey2! <= CSNG(scanY%) AND ey1! >= CSNG(scanY%)) THEN
                IF ABS(ey2! - ey1!) > 0.001! THEN
                    xHit! = ex1! + (CSNG(scanY%) - ey1!) / (ey2! - ey1!) * (ex2! - ex1!)
                ELSE
                    xHit! = (ex1! + ex2!) / 2!
                END IF
                IF NOT gotHit% THEN
                    xMin! = xHit!: xMax! = xHit!
                    gotHit% = TRUE
                ELSE
                    IF xHit! < xMin! THEN xMin! = xHit!
                    IF xHit! > xMax! THEN xMax! = xHit!
                END IF
            END IF
        NEXT pi%

        IF gotHit% THEN
            LINE (INT(xMin! + 0.5!), scanY%)-(INT(xMax! + 0.5!), scanY%), c~&
        END IF
    NEXT scanY%

    ' Draw outline in fill color to seal any sub-pixel gaps at shared edges
    DIM oi AS INTEGER, oj AS INTEGER
    FOR oi% = 0 TO n% - 1
        oj% = (oi% + 1) MOD n%
        LINE (INT(vx(oi%) + 0.5!), INT(vy(oi%) + 0.5!))-(INT(vx(oj%) + 0.5!), INT(vy(oj%) + 0.5!)), c~&
    NEXT oi%
END SUB


''
' Fill the grid cell containing the given point.
' Uses scanline triangle/polygon fill (no PAINT, no leak).
' Works for all grid modes: square, diagonal, isometric, hex.
'
' @param INTEGER px - X coordinate of click (canvas space)
' @param INTEGER py - Y coordinate of click (canvas space)
' @param _UNSIGNED LONG fillColor - Color to fill with
'
SUB GRID_fill_cell (px AS INTEGER, py AS INTEGER, fillColor AS _UNSIGNED LONG)
    DIM targetImg AS LONG
    DIM oldDest AS LONG
    DIM oldSource AS LONG
    
    targetImg& = LAYER_current_image&
    oldDest& = _DEST
    oldSource& = _SOURCE
    _DEST targetImg&
    _SOURCE targetImg&
    
    SELECT CASE GRID.GRID_MODE%
        CASE GRID_MODE_SQUARE
            ' === Square: simple filled rectangle ===
            DIM cellX AS INTEGER, cellY AS INTEGER
            DIM sqx1 AS INTEGER, sqy1 AS INTEGER
            DIM sqx2 AS INTEGER, sqy2 AS INTEGER
            cellX% = INT(CSNG(px%) / CSNG(GRID.gridWidth%))
            cellY% = INT(CSNG(py%) / CSNG(GRID.gridHeight%))
            IF px% < 0 THEN cellX% = cellX% - 1
            IF py% < 0 THEN cellY% = cellY% - 1
            sqx1% = cellX% * GRID.gridWidth%
            sqy1% = cellY% * GRID.gridHeight%
            sqx2% = sqx1% + GRID.gridWidth% - 1
            sqy2% = sqy1% + GRID.gridHeight% - 1
            LINE (sqx1%, sqy1%)-(sqx2%, sqy2%), fillColor~&, BF

        CASE GRID_MODE_DIAGONAL
            ' === Diagonal: diamond cell via scanline polygon ===
            DIM dcx AS INTEGER, dcy AS INTEGER
            DIM dc0 AS INTEGER, dd0 AS INTEGER
            DIM dYmxStep AS INTEGER, dYpxStep AS INTEGER
            DIM dmc AS INTEGER, dmd AS INTEGER
            DIM di AS INTEGER, dj AS INTEGER
            DIM c1v AS INTEGER, c2v AS INTEGER
            DIM d1v AS INTEGER, d2v AS INTEGER
            
            dcx% = GRID.imgWidth% \ 2
            dcy% = GRID.imgHeight% \ 2
            dc0% = dcy% - dcx%
            dd0% = dcy% + dcx%
            dYmxStep% = INT(GRID.gridWidth% * 1.41421356! / 2! + 0.5!) * 2
            dYpxStep% = INT(GRID.gridHeight% * 1.41421356! / 2! + 0.5!) * 2
            IF dYmxStep% < 2 THEN dYmxStep% = 2
            IF dYpxStep% < 2 THEN dYpxStep% = 2
            
            dmc% = py% - px%
            dmd% = py% + px%
            di% = INT(CSNG(dmc% - dc0%) / CSNG(dYmxStep%))
            dj% = INT(CSNG(dmd% - dd0%) / CSNG(dYpxStep%))
            
            c1v% = dc0% + di% * dYmxStep%
            c2v% = c1v% + dYmxStep%
            d1v% = dd0% + dj% * dYpxStep%
            d2v% = d1v% + dYpxStep%
            
            ' Diamond corners via scanline polygon fill
            DIM dvx(0 TO 3) AS SINGLE, dvy(0 TO 3) AS SINGLE
            dvx(0) = CSNG((d1v% - c1v%) \ 2): dvy(0) = CSNG((d1v% + c1v%) \ 2) ' top
            dvx(1) = CSNG((d2v% - c1v%) \ 2): dvy(1) = CSNG((d2v% + c1v%) \ 2) ' right
            dvx(2) = CSNG((d2v% - c2v%) \ 2): dvy(2) = CSNG((d2v% + c2v%) \ 2) ' bottom
            dvx(3) = CSNG((d1v% - c2v%) \ 2): dvy(3) = CSNG((d1v% + c2v%) \ 2) ' left
            GRID_fill_poly 4, dvx(), dvy(), fillColor~&

        CASE GRID_MODE_ISOMETRIC
            ' === 2:1 Pixel Isometric cell fill ===
            ' Grid has 3 line families:
            '   Vertical: x = k * W
            '   +26.565° : y = 0.5*x + n*W  (goes down-right on screen)
            '   -26.565° : y = -0.5*x + m*W (goes up-right on screen)
            ' where yStep = W
            '
            ' In column k, the two valid triangle types use DERIVED m values:
            '   Left-pointing:  m = n + k     (crossing at left vertical)
            '   Right-pointing: m = n + k + 1 (crossing at right vertical)
            ' We test 6 candidates (3 n-values x 2 types) with point-in-triangle
            ' to robustly handle float precision at cell boundaries.
            DIM isoW AS SINGLE
            DIM isoSlope AS SINGLE
            DIM isoYStepF AS SINGLE
            DIM isoCol AS INTEGER
            DIM isoColX AS SINGLE, isoColXR AS SINGLE
            DIM isoN AS INTEGER
            
            isoW! = GRID.gridWidth%
            isoSlope! = 0.5!        ' 2:1 pixel isometric
            isoYStepF! = isoW!      ' yStep = W
            
            ' Column band
            isoCol% = INT(CSNG(px%) / isoW!)
            IF px% < 0 THEN isoCol% = isoCol% - 1
            isoColX! = CSNG(isoCol%) * isoW!
            isoColXR! = CSNG(isoCol% + 1) * isoW!
            
            ' Approximate diagonal line index from click point
            isoN% = INT((CSNG(py%) - isoSlope! * CSNG(px%)) / isoYStepF!)
            
            ' Test 6 candidate triangles: n-1, n, n+1 each with both types
            DIM pxf AS SINGLE, pyf AS SINGLE
            pxf! = CSNG(px%): pyf! = CSNG(py%)
            
            DIM itx1 AS SINGLE, ity1 AS SINGLE
            DIM itx2 AS SINGLE, ity2 AS SINGLE
            DIM itx3 AS SINGLE, ity3 AS SINGLE
            DIM foundTri AS INTEGER
            foundTri% = FALSE
            
            DIM tryN AS INTEGER, tryM AS INTEGER, cn AS INTEGER
            DIM cx1 AS SINGLE, cy1 AS SINGLE
            DIM cx2 AS SINGLE, cy2 AS SINGLE
            DIM cx3 AS SINGLE, cy3 AS SINGLE
            DIM d1 AS SINGLE, d2 AS SINGLE, d3 AS SINGLE
            
            FOR cn% = 0 TO 5
                ' 6 candidates: n, n-1, n+1 each with left/right type
                SELECT CASE cn%
                    CASE 0: tryN% = isoN%
                    CASE 1: tryN% = isoN%
                    CASE 2: tryN% = isoN% - 1
                    CASE 3: tryN% = isoN% - 1
                    CASE 4: tryN% = isoN% + 1
                    CASE 5: tryN% = isoN% + 1
                END SELECT
                
                IF (cn% AND 1) = 0 THEN
                    ' Left-pointing: m = n + k
                    tryM% = tryN% + isoCol%
                    cx1! = isoColX!
                    cy1! = isoSlope! * isoColX! + CSNG(tryN%) * isoYStepF!
                    cx2! = isoColXR!
                    cy2! = -isoSlope! * isoColXR! + CSNG(tryM%) * isoYStepF!
                    cx3! = isoColXR!
                    cy3! = isoSlope! * isoColXR! + CSNG(tryN%) * isoYStepF!
                ELSE
                    ' Right-pointing: m = n + k + 1
                    tryM% = tryN% + isoCol% + 1
                    cx1! = isoColXR!
                    cy1! = isoSlope! * isoColXR! + CSNG(tryN%) * isoYStepF!
                    cx2! = isoColX!
                    cy2! = isoSlope! * isoColX! + CSNG(tryN%) * isoYStepF!
                    cx3! = isoColX!
                    cy3! = -isoSlope! * isoColX! + CSNG(tryM%) * isoYStepF!
                END IF
                
                ' Point-in-triangle test (cross products - same sign = inside)
                d1! = (cx2! - cx1!) * (pyf! - cy1!) - (cy2! - cy1!) * (pxf! - cx1!)
                d2! = (cx3! - cx2!) * (pyf! - cy2!) - (cy3! - cy2!) * (pxf! - cx2!)
                d3! = (cx1! - cx3!) * (pyf! - cy3!) - (cy1! - cy3!) * (pxf! - cx3!)
                
                IF (d1! >= 0 AND d2! >= 0 AND d3! >= 0) OR _
                   (d1! <= 0 AND d2! <= 0 AND d3! <= 0) THEN
                    itx1! = cx1!: ity1! = cy1!
                    itx2! = cx2!: ity2! = cy2!
                    itx3! = cx3!: ity3! = cy3!
                    foundTri% = TRUE
                    EXIT FOR
                END IF
            NEXT cn%
            
            ' Fallback (shouldn't happen)
            IF NOT foundTri% THEN
                tryM% = isoN% + isoCol%
                itx1! = isoColX!
                ity1! = isoSlope! * isoColX! + CSNG(isoN%) * isoYStepF!
                itx2! = isoColXR!
                ity2! = -isoSlope! * isoColXR! + CSNG(tryM%) * isoYStepF!
                itx3! = isoColXR!
                ity3! = isoSlope! * isoColXR! + CSNG(isoN%) * isoYStepF!
            END IF
            
            ' Fill triangle using scanline (no PAINT, no leak)
            GRID_fill_tri itx1!, ity1!, itx2!, ity2!, itx3!, ity3!, fillColor~&

        CASE GRID_MODE_HEX
            ' === Hex cell fill ===
            ' Find nearest hex center, fill with scanline polygon fill
            DIM hxW AS SINGLE, hxR AS SINGLE
            DIM hxColStep AS SINGLE, hxRowStep AS SINGLE
            DIM hxNearCol AS INTEGER
            DIM hxBestDist AS SINGLE
            DIM hxBcx AS SINGLE, hxBcy AS SINGLE
            DIM hxCC AS INTEGER, hxRR AS INTEGER
            DIM hxTestCx AS SINGLE, hxTestCy AS SINGLE, hxRowOff AS SINGLE
            DIM hxDist AS SINGLE
            DIM hxNearRow AS INTEGER
            
            hxW! = GRID.gridWidth%
            hxR! = hxW! / 2.0!
            hxColStep! = hxW! * 0.75!
            hxRowStep! = hxW! * 0.5!
            
            hxNearCol% = INT(CSNG(px%) / hxColStep! + 0.5!)
            hxBestDist! = 999999!
            hxBcx! = 0!: hxBcy! = 0!
            
            FOR hxCC% = hxNearCol% - 1 TO hxNearCol% + 1
                hxTestCx! = hxCC% * hxColStep!
                IF (hxCC% AND 1) THEN
                    hxRowOff! = hxRowStep! * 0.5!
                ELSE
                    hxRowOff! = 0!
                END IF
                hxNearRow% = INT((CSNG(py%) - hxRowOff!) / hxRowStep! + 0.5!)
                FOR hxRR% = hxNearRow% - 1 TO hxNearRow% + 1
                    hxTestCy! = hxRR% * hxRowStep! + hxRowOff!
                    hxDist! = (px% - hxTestCx!) * (px% - hxTestCx!) + (py% - hxTestCy!) * (py% - hxTestCy!)
                    IF hxDist! < hxBestDist! THEN
                        hxBestDist! = hxDist!
                        hxBcx! = hxTestCx!
                        hxBcy! = hxTestCy!
                    END IF
                NEXT hxRR%
            NEXT hxCC%
            
            ' 6 hex vertices as polygon for scanline fill (no PAINT leak)
            DIM hvx(0 TO 5) AS SINGLE, hvy(0 TO 5) AS SINGLE
            hvx(0) = hxBcx! + hxR!:                hvy(0) = hxBcy!
            hvx(1) = hxBcx! + hxR! * 0.5!:         hvy(1) = hxBcy! - hxR! * 0.5!
            hvx(2) = hxBcx! - hxR! * 0.5!:         hvy(2) = hxBcy! - hxR! * 0.5!
            hvx(3) = hxBcx! - hxR!:                hvy(3) = hxBcy!
            hvx(4) = hxBcx! - hxR! * 0.5!:         hvy(4) = hxBcy! + hxR! * 0.5!
            hvx(5) = hxBcx! + hxR! * 0.5!:         hvy(5) = hxBcy! + hxR! * 0.5!
            GRID_fill_poly 6, hvx(), hvy(), fillColor~&

        CASE ELSE
            ' Fallback: standard axis-aligned square grid fill
            DIM fcx AS INTEGER, fcy AS INTEGER
            DIM fsx1 AS INTEGER, fsy1 AS INTEGER
            DIM fsx2 AS INTEGER, fsy2 AS INTEGER
            fcx% = INT(CSNG(px%) / CSNG(GRID.gridWidth%))
            fcy% = INT(CSNG(py%) / CSNG(GRID.gridHeight%))
            IF px% < 0 THEN fcx% = fcx% - 1
            IF py% < 0 THEN fcy% = fcy% - 1
            fsx1% = fcx% * GRID.gridWidth%
            fsy1% = fcy% * GRID.gridHeight%
            fsx2% = fsx1% + GRID.gridWidth% - 1
            fsy2% = fsy1% + GRID.gridHeight% - 1
            LINE (fsx1%, fsy1%)-(fsx2%, fsy2%), fillColor~&, BF
    END SELECT
    
    _SOURCE oldSource&
    _DEST oldDest&
END SUB
