''
' DRAW - GUI/GRID.BM
' =============================================================================
' Grid assistant subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initialize the grid assistant
' 
SUB GRID_init ()
    ' Setup the grid object
    GRID.imgWidth%   = SCRN.w&                      ' Width of the painting canvas
    GRID.imgHeight%  = SCRN.h&                      ' Height of the painting canvas
    ' Grid color: config overrides theme (CFG 0 = use theme default)
    IF CFG.GRID_COLOR_FG~& <> 0 THEN
        GRID.fgColor~& = CFG.GRID_COLOR_FG~&
    ELSE
        GRID.fgColor~& = THEME.GRID_color_fg~&
    END IF
    GRID.xPos%       = 0                            ' Left-most pixel of screen
    GRID.yPos%       = 0                            ' Top-most pixel of screen
    ' Grid size: config overrides theme (CFG 0 = use theme default)
    IF CFG.GRID_SIZE_X% > 0 THEN
        GRID.gridWidth% = CFG.GRID_SIZE_X%
    ELSE
        GRID.gridWidth% = THEME.GRID_size_x%
    END IF
    IF CFG.GRID_SIZE_Y% > 0 THEN
        GRID.gridHeight% = CFG.GRID_SIZE_Y%
    ELSE
        GRID.gridHeight% = THEME.GRID_size_y%
    END IF
    GRID.hStyle%     = &B1111111111111111           ' Solid
    GRID.vStyle%     = &B1111111111111111           ' Solid
    GRID.imgHandle&  = _NEWIMAGE(GRID.imgWidth%, GRID.imgHeight%, 32)  ' Mode 32 to match canvas
    GRID.SHOW%       = FALSE                        ' Grid hidden by default
    GRID.SNAP%       = FALSE                        ' Snap disabled by default
    GRID.ALIGN_MODE% = GRID_ALIGN_CORNER            ' Corner alignment by default (snap to grid lines)
    GRID.GRID_MODE%  = CFG.GRID_MODE%                ' Grid mode from config (0=square default)
    
    ' Draw the grid image once
    GRID_draw
END SUB


''
' Draw grid
' 
SUB GRID_draw ()
    DIM AS INTEGER x, y
    DIM gridOpacity AS INTEGER
    DIM oldDest AS LONG
    oldDest& = _DEST
    _DEST GRID.imgHandle&
    CLS , _RGBA32(0, 0, 0, 0)  ' Clear with transparency
    
    ' Resolve grid angle: config overrides theme (CFG 0 = use theme default)
    DIM gridAngle AS SINGLE
    IF CFG.GRID_ANGLE! <> 0 THEN
        gridAngle! = CFG.GRID_ANGLE!
    ELSE
        gridAngle! = THEME.GRID_angle!
    END IF

    ' Determine effective grid mode: GRID_MODE takes priority, then angle-based
    DIM effectiveMode AS INTEGER
    effectiveMode% = GRID.GRID_MODE%

    SELECT CASE effectiveMode%
        CASE GRID_MODE_DIAGONAL
            ' === 45-degree diagonal grid: pure integer math ===
            DIM cx45 AS INTEGER, cy45 AS INTEGER
            DIM c0 AS INTEGER, d0 AS INTEGER
            DIM ymxStep AS INTEGER, ypxStep AS INTEGER
            DIM numC AS INTEGER, numD AS INTEGER
            DIM ic AS INTEGER, id AS INTEGER
            DIM c AS INTEGER, d AS INTEGER
            DIM imgW AS INTEGER, imgH AS INTEGER

            cx45% = GRID.imgWidth% \ 2
            cy45% = GRID.imgHeight% \ 2
            c0% = cy45% - cx45%
            d0% = cy45% + cx45%
            imgW% = GRID.imgWidth%
            imgH% = GRID.imgHeight%

            ' Step = nearest even integer to gridSize*sqrt(2)
            ymxStep% = INT(GRID.gridWidth% * 1.41421356! / 2! + 0.5!) * 2
            ypxStep% = INT(GRID.gridHeight% * 1.41421356! / 2! + 0.5!) * 2
            IF ymxStep% < 2 THEN ymxStep% = 2
            IF ypxStep% < 2 THEN ypxStep% = 2

            ' slope +1 family: y = x + c
            numC% = (imgW% + imgH%) \ ymxStep% + 1
            FOR ic% = -numC% TO numC%
                c% = c0% + ic% * ymxStep%
                LINE (0, c%)-(imgW% - 1, c% + imgW% - 1), GRID.fgColor~&
            NEXT ic%

            ' slope -1 family: y = -x + d
            numD% = (imgW% + imgH%) \ ypxStep% + 1
            FOR id% = -numD% TO numD%
                d% = d0% + id% * ypxStep%
                LINE (0, d%)-(imgW% - 1, d% - imgW% + 1), GRID.fgColor~&
            NEXT id%

        CASE GRID_MODE_ISOMETRIC
            ' === Isometric grid: vertical lines + ±30° diagonals ===
            ' Three families of lines that ALL share intersection points:
            '   1) Vertical lines at x = k * W
            '   2) +30° lines: y = (1/√3)*x + n * yStep  (slope +0.5774)
            '   3) -30° lines: y = -(1/√3)*x + n * yStep (slope -0.5774)
            '
            ' Key math: yStep = 2*W/√3 makes diagonal intersections land
            ' exactly on vertical lines. Intersection points form a staggered
            ' pattern: at column k, y = (k + 2n) * W/√3 for integer n.
            ' Even columns: y at even multiples of W/√3
            ' Odd columns: y at odd multiples of W/√3
            DIM isoW AS INTEGER, isoH AS INTEGER
            DIM isoGW AS SINGLE
            DIM isoYStep AS SINGLE  ' y-intercept spacing = 2*W/sqrt(3)
            DIM isoTanA AS SINGLE   ' tan(30°) = 1/sqrt(3)
            DIM isoNumV AS INTEGER, isoNumD AS INTEGER
            DIM ii AS INTEGER

            isoW% = GRID.imgWidth%
            isoH% = GRID.imgHeight%
            isoGW! = GRID.gridWidth%
            isoTanA! = 0.57735027!  ' 1/sqrt(3) = tan(30°)
            isoYStep! = isoGW! * 1.15470054!  ' 2/sqrt(3) * W

            ' 1) Vertical lines
            isoNumV% = isoW% \ GRID.gridWidth% + 2
            FOR ii% = -1 TO isoNumV%
                x% = ii% * GRID.gridWidth%
                IF x% >= -1 AND x% <= isoW% THEN
                    LINE (x%, 0)-(x%, isoH% - 1), GRID.fgColor~&
                END IF
            NEXT ii%

            ' 2) +30° family: y = isoTanA * x + n * isoYStep
            '    At x=0: y = n*isoYStep.  At x=isoW: y = isoTanA*isoW + n*isoYStep
            isoNumD% = INT((isoH% + isoTanA! * isoW%) / isoYStep!) + 2
            FOR ii% = -isoNumD% TO isoNumD%
                DIM iy1s AS SINGLE, iy2s AS SINGLE
                iy1s! = ii% * isoYStep!
                iy2s! = isoTanA! * isoW% + ii% * isoYStep!
                LINE (0, INT(iy1s! + 0.5!))-(isoW% - 1, INT(iy2s! + 0.5!)), GRID.fgColor~&
            NEXT ii%

            ' 3) -30° family: y = -isoTanA * x + n * isoYStep
            FOR ii% = -isoNumD% TO isoNumD%
                iy1s! = ii% * isoYStep!
                iy2s! = -isoTanA! * isoW% + ii% * isoYStep!
                LINE (0, INT(iy1s! + 0.5!))-(isoW% - 1, INT(iy2s! + 0.5!)), GRID.fgColor~&
            NEXT ii%

        CASE GRID_MODE_HEX
            ' === Hexagonal grid ===
            ' Flat-top hexagons tiled in offset columns.
            ' Hex geometry (flat-top, R = circumradius = hexW/2):
            '   hexW = gridWidth (point-to-point horizontal = 2R)
            '   hexH = R * sqrt(3) = hexW * sqrt(3)/2 (flat-to-flat vertical)
            '   Column spacing = hexW * 3/4 = 3R/2
            '   Row spacing = hexH = R * sqrt(3)
            '   Odd columns offset by hexH/2
            DIM hexW AS SINGLE, hexH AS SINGLE
            DIM hexColStep AS SINGLE, hexRowStep AS SINGLE
            DIM hexNumCols AS INTEGER, hexNumRows AS INTEGER
            DIM hCol AS INTEGER, hRow AS INTEGER
            DIM hcx AS SINGLE, hcy AS SINGLE
            DIM hx0 AS INTEGER, hy0 AS INTEGER
            DIM hx1 AS INTEGER, hy1 AS INTEGER
            DIM hx2 AS INTEGER, hy2 AS INTEGER
            DIM hx3 AS INTEGER, hy3 AS INTEGER
            DIM hx4 AS INTEGER, hy4 AS INTEGER
            DIM hx5 AS INTEGER, hy5 AS INTEGER

            hexW! = GRID.gridWidth%
            hexH! = hexW! * 0.86602540!  ' sqrt(3)/2 = flat-to-flat height
            hexColStep! = hexW! * 0.75!
            hexRowStep! = hexH!
            hexNumCols% = INT(GRID.imgWidth% / hexColStep!) + 3
            hexNumRows% = INT(GRID.imgHeight% / hexRowStep!) + 3

            FOR hCol% = -1 TO hexNumCols%
                FOR hRow% = -1 TO hexNumRows%
                    ' Center of this hex
                    hcx! = hCol% * hexColStep!
                    hcy! = hRow% * hexRowStep!
                    ' Odd columns are offset by half a row
                    IF (hCol% AND 1) THEN hcy! = hcy! + hexRowStep! * 0.5!

                    ' 6 vertices of flat-top hex (radius = hexW/2)
                    DIM hexR AS SINGLE
                    hexR! = hexW! / 2.0!
                    ' Flat-top hex vertices at angles 0, 60, 120, 180, 240, 300 degrees
                    hx0% = INT(hcx! + hexR! + 0.5!)
                    hy0% = INT(hcy! + 0.5!)
                    hx1% = INT(hcx! + hexR! * 0.5! + 0.5!)
                    hy1% = INT(hcy! - hexR! * 0.86602540! + 0.5!)
                    hx2% = INT(hcx! - hexR! * 0.5! + 0.5!)
                    hy2% = INT(hcy! - hexR! * 0.86602540! + 0.5!)
                    hx3% = INT(hcx! - hexR! + 0.5!)
                    hy3% = INT(hcy! + 0.5!)
                    hx4% = INT(hcx! - hexR! * 0.5! + 0.5!)
                    hy4% = INT(hcy! + hexR! * 0.86602540! + 0.5!)
                    hx5% = INT(hcx! + hexR! * 0.5! + 0.5!)
                    hy5% = INT(hcy! + hexR! * 0.86602540! + 0.5!)

                    ' Draw the 6 edges
                    LINE (hx0%, hy0%)-(hx1%, hy1%), GRID.fgColor~&
                    LINE (hx1%, hy1%)-(hx2%, hy2%), GRID.fgColor~&
                    LINE (hx2%, hy2%)-(hx3%, hy3%), GRID.fgColor~&
                    LINE (hx3%, hy3%)-(hx4%, hy4%), GRID.fgColor~&
                    LINE (hx4%, hy4%)-(hx5%, hy5%), GRID.fgColor~&
                    LINE (hx5%, hy5%)-(hx0%, hy0%), GRID.fgColor~&
                NEXT hRow%
            NEXT hCol%

        CASE ELSE
            ' Check for angle-based rotation (legacy GRID_ANGLE support)
            IF gridAngle! <> 0 THEN
                ' === General rotated grid: continuous edge-to-edge lines ===
                DIM angleRad AS SINGLE
                DIM cosA AS SINGLE, sinA AS SINGLE
                DIM diagLen AS SINGLE
                DIM cx AS SINGLE, cy AS SINGLE
                DIM numA AS INTEGER, numB AS INTEGER
                DIM i AS INTEGER
                DIM x1 AS SINGLE, y1 AS SINGLE
                DIM x2 AS SINGLE, y2 AS SINGLE

                angleRad! = gridAngle! * 3.14159265! / 180.0!
                cosA! = COS(angleRad!)
                sinA! = SIN(angleRad!)
                diagLen! = SQR(1! * GRID.imgWidth% * GRID.imgWidth% + 1! * GRID.imgHeight% * GRID.imgHeight%)
                cx! = GRID.imgWidth% / 2.0!
                cy! = GRID.imgHeight% / 2.0!

                numA% = INT(diagLen! / GRID.gridWidth%) + 1
                FOR i% = -numA% TO numA%
                    DIM lcxA AS SINGLE, lcyA AS SINGLE
                    lcxA! = cx! + i% * GRID.gridWidth% * (-sinA!)
                    lcyA! = cy! + i% * GRID.gridWidth% * cosA!
                    x1! = lcxA! - diagLen! * 0.5! * cosA!
                    y1! = lcyA! - diagLen! * 0.5! * sinA!
                    x2! = lcxA! + diagLen! * 0.5! * cosA!
                    y2! = lcyA! + diagLen! * 0.5! * sinA!
                    LINE (INT(x1!), INT(y1!))-(INT(x2!), INT(y2!)), GRID.fgColor~&
                NEXT i%

                numB% = INT(diagLen! / GRID.gridHeight%) + 1
                FOR i% = -numB% TO numB%
                    DIM lcxB AS SINGLE, lcyB AS SINGLE
                    lcxB! = cx! + i% * GRID.gridHeight% * cosA!
                    lcyB! = cy! + i% * GRID.gridHeight% * sinA!
                    x1! = lcxB! - diagLen! * 0.5! * (-sinA!)
                    y1! = lcyB! - diagLen! * 0.5! * cosA!
                    x2! = lcxB! + diagLen! * 0.5! * (-sinA!)
                    y2! = lcyB! + diagLen! * 0.5! * cosA!
                    LINE (INT(x1!), INT(y1!))-(INT(x2!), INT(y2!)), GRID.fgColor~&
                NEXT i%
            ELSE
                ' === Standard axis-aligned grid ===
                FOR x% = GRID.xPos% TO GRID.imgWidth% STEP GRID.gridWidth%
                    LINE (x%, GRID.yPos%)-(x%, GRID.imgHeight%), _
                        GRID.fgColor~&, , GRID.vStyle%
                NEXT x%
                FOR y% = GRID.yPos% TO GRID.imgHeight% STEP GRID.gridHeight%
                    LINE (GRID.xPos%, y%)-(GRID.imgWidth%, y%), _
                        GRID.fgColor~&, , GRID.hStyle%
                NEXT y%
            END IF
    END SELECT

    ' Grid opacity: config overrides theme (CFG 0 = use theme default)
    IF CFG.GRID_OPACITY% > 0 THEN
        gridOpacity% = CFG.GRID_OPACITY%
    ELSE
        gridOpacity% = THEME.GRID_opacity%
    END IF
    _SETALPHA gridOpacity%, GRID.fgColor~& TO GRID.fgColor~&, GRID.imgHandle&
    _DEST oldDest&
END SUB


''
' Put the grid onto the screen
' description
' 
SUB GRID_put ()
    _PUTIMAGE (GRID.xPos%, GRID.yPos%), GRID.imgHandle
END SUB


''
' Snap coordinate to nearest grid point
' @param INTEGER value - The coordinate value to snap
' @return INTEGER - The snapped coordinate value
' 
FUNCTION GRID_snap% (value AS INTEGER)
    IF GRID.SNAP% THEN
        IF GRID.ALIGN_MODE% = GRID_ALIGN_CENTER THEN
            ' Snap to cell centers (halfway between grid lines)
            DIM halfGrid AS INTEGER
            halfGrid% = GRID.gridWidth% \ 2
            GRID_snap% = INT((value - halfGrid% + GRID.gridWidth% / 2) / GRID.gridWidth%) * GRID.gridWidth% + halfGrid%
        ELSE
            ' Snap to intersections (on grid lines)
            GRID_snap% = INT((value + GRID.gridWidth% / 2) / GRID.gridWidth%) * GRID.gridWidth%
        END IF
    ELSE
        ' Return original value if snap is disabled
        GRID_snap% = value
    END IF
END FUNCTION


''
' Snap X,Y coordinate pair to nearest grid intersection point.
' Handles all grid modes: square, diagonal, isometric, hex, and angle-based.
' @param INTEGER snapX - X coordinate (modified in place)
' @param INTEGER snapY - Y coordinate (modified in place)
'
SUB GRID_snap_xy (snapX AS INTEGER, snapY AS INTEGER)
    IF NOT GRID.SNAP% THEN EXIT SUB

    SELECT CASE GRID.GRID_MODE%
        CASE GRID_MODE_DIAGONAL
            ' === 45-degree snap: pure integer diagonal math ===
            DIM scx AS INTEGER, scy AS INTEGER
            DIM sc0 AS INTEGER, sd0 AS INTEGER
            DIM sYmxStep AS INTEGER, sYpxStep AS INTEGER
            DIM mc AS INTEGER, md AS INTEGER
            DIM nearI AS INTEGER, nearJ AS INTEGER
            DIM snappedC AS INTEGER, snappedD AS INTEGER

            scx% = GRID.imgWidth% \ 2
            scy% = GRID.imgHeight% \ 2
            sc0% = scy% - scx%
            sd0% = scy% + scx%

            sYmxStep% = INT(GRID.gridWidth% * 1.41421356! / 2! + 0.5!) * 2
            sYpxStep% = INT(GRID.gridHeight% * 1.41421356! / 2! + 0.5!) * 2
            IF sYmxStep% < 2 THEN sYmxStep% = 2
            IF sYpxStep% < 2 THEN sYpxStep% = 2

            mc% = snapY% - snapX%
            md% = snapY% + snapX%

            IF GRID.ALIGN_MODE% = GRID_ALIGN_CENTER THEN
                DIM halfSA AS INTEGER, halfSB AS INTEGER
                halfSA% = sYmxStep% \ 2
                halfSB% = sYpxStep% \ 2
                nearI% = INT(CSNG(mc% - sc0% - halfSA%) / CSNG(sYmxStep%) + 0.5!)
                snappedC% = sc0% + halfSA% + nearI% * sYmxStep%
                nearJ% = INT(CSNG(md% - sd0% - halfSB%) / CSNG(sYpxStep%) + 0.5!)
                snappedD% = sd0% + halfSB% + nearJ% * sYpxStep%
            ELSE
                nearI% = INT(CSNG(mc% - sc0%) / CSNG(sYmxStep%) + 0.5!)
                snappedC% = sc0% + nearI% * sYmxStep%
                nearJ% = INT(CSNG(md% - sd0%) / CSNG(sYpxStep%) + 0.5!)
                snappedD% = sd0% + nearJ% * sYpxStep%
            END IF

            snapX% = (snappedD% - snappedC%) \ 2
            snapY% = (snappedD% + snappedC%) \ 2

        CASE GRID_MODE_ISOMETRIC
            ' === Isometric snap ===
            ' Intersection points are at (k*W, (k + 2n) * W/√3) for integers k, n.
            ' This forms a staggered pattern: even columns have even q = k+2n,
            ' odd columns have odd q. Check the 3 nearest vertical columns and
            ' find the closest intersection point.
            DIM isoGW AS SINGLE
            DIM isoInvSqrt3 AS SINGLE  ' W / sqrt(3)
            DIM isoYStep AS SINGLE     ' 2 * W / sqrt(3)
            DIM nearK AS INTEGER
            DIM bestDistSq AS SINGLE, bestSnapX AS SINGLE, bestSnapY AS SINGLE
            DIM kk AS INTEGER, nn AS INTEGER
            DIM xSnap AS SINGLE, yBase AS SINGLE, nApprox AS SINGLE
            DIM ySnap AS SINGLE, dSq AS SINGLE

            isoGW! = GRID.gridWidth%
            isoInvSqrt3! = isoGW! * 0.57735027!  ' W / sqrt(3) = W * tan(30°)
            isoYStep! = isoGW! * 1.15470054!      ' 2 * W / sqrt(3)

            nearK% = INT(CSNG(snapX%) / isoGW! + 0.5!)
            bestDistSq! = 999999!
            bestSnapX! = snapX%
            bestSnapY! = snapY%

            FOR kk% = nearK% - 1 TO nearK% + 1
                xSnap! = kk% * isoGW!
                ' On vertical k, intersections at y = kk*W/√3 + n * 2W/√3
                yBase! = kk% * isoInvSqrt3!
                nApprox! = (CSNG(snapY%) - yBase!) / isoYStep!
                FOR nn% = INT(nApprox!) TO INT(nApprox!) + 1
                    ySnap! = yBase! + nn% * isoYStep!
                    dSq! = (snapX% - xSnap!) * (snapX% - xSnap!) + (snapY% - ySnap!) * (snapY% - ySnap!)
                    IF dSq! < bestDistSq! THEN
                        bestDistSq! = dSq!
                        bestSnapX! = xSnap!
                        bestSnapY! = ySnap!
                    END IF
                NEXT nn%
            NEXT kk%

            snapX% = INT(bestSnapX! + 0.5!)
            snapY% = INT(bestSnapY! + 0.5!)

        CASE GRID_MODE_HEX
            ' === Hexagonal snap: snap to nearest hex VERTEX ===
            ' Find the nearest hex center, then snap to the closest of its
            ' 6 vertices (corners where edges meet). This is analogous to
            ' isometric snapping to line intersections.
            DIM hexW AS SINGLE, hexR AS SINGLE
            DIM hexColStep AS SINGLE, hexRowStep AS SINGLE
            DIM nearHCol AS INTEGER
            DIM hBestDist AS SINGLE, hBestX AS SINGLE, hBestY AS SINGLE
            DIM hcc AS INTEGER, hrr AS INTEGER
            DIM hcxS AS SINGLE, hcyS AS SINGLE, hRowOff AS SINGLE
            DIM hvx AS SINGLE, hvy AS SINGLE, hdSq AS SINGLE
            DIM hv AS INTEGER

            hexW! = GRID.gridWidth%
            hexR! = hexW! / 2.0!
            hexColStep! = hexW! * 0.75!
            hexRowStep! = hexW! * 0.86602540!  ' sqrt(3)/2

            ' Find approximate nearest column
            nearHCol% = INT(CSNG(snapX%) / hexColStep! + 0.5!)
            hBestDist! = 999999!
            hBestX! = snapX%
            hBestY! = snapY%

            ' Check nearby hex centers and their 6 vertices
            FOR hcc% = nearHCol% - 1 TO nearHCol% + 1
                hcxS! = hcc% * hexColStep!
                IF (hcc% AND 1) THEN
                    hRowOff! = hexRowStep! * 0.5!
                ELSE
                    hRowOff! = 0!
                END IF
                DIM nearHRow AS INTEGER
                nearHRow% = INT((CSNG(snapY%) - hRowOff!) / hexRowStep! + 0.5!)
                FOR hrr% = nearHRow% - 1 TO nearHRow% + 1
                    hcyS! = hrr% * hexRowStep! + hRowOff!
                    ' Test all 6 vertices of this hex
                    FOR hv% = 0 TO 5
                        SELECT CASE hv%
                            CASE 0: hvx! = hcxS! + hexR!:          hvy! = hcyS!
                            CASE 1: hvx! = hcxS! + hexR! * 0.5!:   hvy! = hcyS! - hexR! * 0.86602540!
                            CASE 2: hvx! = hcxS! - hexR! * 0.5!:   hvy! = hcyS! - hexR! * 0.86602540!
                            CASE 3: hvx! = hcxS! - hexR!:          hvy! = hcyS!
                            CASE 4: hvx! = hcxS! - hexR! * 0.5!:   hvy! = hcyS! + hexR! * 0.86602540!
                            CASE 5: hvx! = hcxS! + hexR! * 0.5!:   hvy! = hcyS! + hexR! * 0.86602540!
                        END SELECT
                        hdSq! = (snapX% - hvx!) * (snapX% - hvx!) + (snapY% - hvy!) * (snapY% - hvy!)
                        IF hdSq! < hBestDist! THEN
                            hBestDist! = hdSq!
                            hBestX! = hvx!
                            hBestY! = hvy!
                        END IF
                    NEXT hv%
                NEXT hrr%
            NEXT hcc%

            snapX% = INT(hBestX! + 0.5!)
            snapY% = INT(hBestY! + 0.5!)

        CASE ELSE
            ' Check for angle-based rotation (legacy GRID_ANGLE support)
            DIM gridAngle AS SINGLE
            IF CFG.GRID_ANGLE! <> 0 THEN
                gridAngle! = CFG.GRID_ANGLE!
            ELSE
                gridAngle! = THEME.GRID_angle!
            END IF

            IF gridAngle! = 0 THEN
                ' Standard axis-aligned snap
                snapX% = GRID_snap%(snapX%)
                snapY% = GRID_snap%(snapY%)
            ELSE
                ' General rotated grid snap (trig-based)
                DIM angleRad AS SINGLE
                DIM cosA AS SINGLE, sinA AS SINGLE
                DIM cx AS SINGLE, cy AS SINGLE
                DIM relX AS SINGLE, relY AS SINGLE
                DIM projA AS SINGLE, projB AS SINGLE
                DIM snappedA AS SINGLE, snappedB AS SINGLE

                angleRad! = gridAngle! * 3.14159265! / 180.0!
                cosA! = COS(angleRad!)
                sinA! = SIN(angleRad!)
                cx! = GRID.imgWidth% / 2.0!
                cy! = GRID.imgHeight% / 2.0!
                relX! = snapX% - cx!
                relY! = snapY% - cy!

                projA! = relX! * cosA! + relY! * sinA!
                projB! = -relX! * sinA! + relY! * cosA!

                IF GRID.ALIGN_MODE% = GRID_ALIGN_CENTER THEN
                    DIM halfW AS SINGLE, halfH AS SINGLE
                    halfH! = GRID.gridHeight% / 2.0!
                    halfW! = GRID.gridWidth% / 2.0!
                    snappedA! = INT((projA! - halfH! + GRID.gridHeight% / 2.0!) / GRID.gridHeight%) * GRID.gridHeight% + halfH!
                    snappedB! = INT((projB! - halfW! + GRID.gridWidth% / 2.0!) / GRID.gridWidth%) * GRID.gridWidth% + halfW!
                ELSE
                    snappedA! = INT((projA! + GRID.gridHeight% / 2.0!) / GRID.gridHeight%) * GRID.gridHeight%
                    snappedB! = INT((projB! + GRID.gridWidth% / 2.0!) / GRID.gridWidth%) * GRID.gridWidth%
                END IF

                snapX% = INT(cx! + snappedA! * cosA! - snappedB! * sinA!)
                snapY% = INT(cy! + snappedA! * sinA! + snappedB! * cosA!)
            END IF
    END SELECT
END SUB


''
' Initialize the pixel grid (checkerboard for high zoom levels)
'
SUB PIXEL_GRID_init ()
    PIXEL_GRID.SHOW% = TRUE  ' Enabled by default (auto-shows at 400%+ zoom)
    PIXEL_GRID.color1~& = THEME.PIXEL_GRID_color1~&
    PIXEL_GRID.color2~& = THEME.PIXEL_GRID_color2~&
    PIXEL_GRID.imgHandle& = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    PIXEL_GRID_draw
END SUB


''
' Draw the pixel grid - single pixel lines around each pixel
'
SUB PIXEL_GRID_draw ()
    DIM AS INTEGER x, y
    DIM oldDest AS LONG
    oldDest& = _DEST
    _DEST PIXEL_GRID.imgHandle&
    CLS , _RGBA32(0, 0, 0, 0)  ' Clear with transparency
    
    ' Draw vertical lines (at each x position)
    FOR x% = 0 TO SCRN.w& - 1
        LINE (x%, 0)-(x%, SCRN.h& - 1), PIXEL_GRID.color1~&
    NEXT x%
    
    ' Draw horizontal lines (at each y position)
    FOR y% = 0 TO SCRN.h& - 1
        LINE (0, y%)-(SCRN.w& - 1, y%), PIXEL_GRID.color1~&
    NEXT y%
    
    _DEST oldDest&
END SUB
