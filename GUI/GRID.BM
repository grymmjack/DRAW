''
' DRAW - GUI/GRID.BM
' =============================================================================
' Grid assistant subs and functions.
'
' @todo
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initialize the grid assistant
' 
SUB GRID_init ()
    ' Setup the grid object
    GRID.imgWidth%   = SCRN.w&                      ' Width of the painting canvas
    GRID.imgHeight%  = SCRN.h&                      ' Height of the painting canvas
    GRID.fgColor~&   = _RGB32(250, 250, 250)        ' Bright white at full opacity
    GRID.xPos%       = 0                            ' Left-most pixel of screen
    GRID.yPos%       = 0                            ' Top-most pixel of screen
    GRID.gridWidth%  = 10                           ' Grid width of 10 divides evenly
    GRID.gridHeight% = 10                           ' Grid height of 10 divides evenly
    GRID.hStyle%     = &B1111111111111111           ' Solid
    GRID.vStyle%     = &B1111111111111111           ' Solid
    GRID.imgHandle&  = _NEWIMAGE(GRID.imgWidth%, GRID.imgHeight%, 32)  ' Mode 32 to match canvas
    GRID.SHOW%       = FALSE                        ' Grid hidden by default
    GRID.SNAP%       = FALSE                        ' Snap disabled by default
    
    ' Draw the grid image once
    GRID_draw
END SUB


''
' Draw grid
' 
SUB GRID_draw ()
    DIM AS INTEGER x, y
    DIM oldDest AS LONG
    oldDest& = _DEST
    _DEST GRID.imgHandle&
    CLS , _RGBA32(0, 0, 0, 0)  ' Clear with transparency
    ' Draw vertical lines at full opacity
    FOR x% = GRID.xPos% to GRID.imgWidth% STEP GRID.gridWidth%
        LINE (x%, GRID.yPos%)-(x%, GRID.imgHeight%), _
            GRID.fgColor~&, , GRID.vStyle%
    NEXT x%
    ' Draw horizontal lines at full opacity
    FOR y% = GRID.yPos% to GRID.imgHeight% STEP GRID.gridHeight%
        LINE (GRID.xPos%, y%)-(GRID.imgWidth%, y%), _
            GRID.fgColor~&, , GRID.hStyle%
    NEXT y%
    ' Apply 15% opacity only to the grid color (alpha = 38), preserve transparency
    _SETALPHA 38, GRID.fgColor~& TO GRID.fgColor~&, GRID.imgHandle&
    _DEST oldDest&
END SUB


''
' Put the grid onto the screen
' description
' 
SUB GRID_put ()
    _PUTIMAGE (GRID.xPos%, GRID.yPos%), GRID.imgHandle
END SUB


''
' Snap coordinate to nearest grid point
' @param INTEGER value - The coordinate value to snap
' @return INTEGER - The snapped coordinate value
' 
FUNCTION GRID_snap% (value AS INTEGER)
    IF GRID.SNAP% THEN
        ' Round to nearest grid point
        GRID_snap% = INT((value + GRID.gridWidth% / 2) / GRID.gridWidth%) * GRID.gridWidth%
    ELSE
        ' Return original value if snap is disabled
        GRID_snap% = value
    END IF
END FUNCTION


''
' Initialize the pixel grid (checkerboard for high zoom levels)
'
SUB PIXEL_GRID_init ()
    PIXEL_GRID.SHOW% = TRUE  ' Enabled by default (auto-shows at 400%+ zoom)
    PIXEL_GRID.color1~& = THEME.PIXEL_GRID_color1~&
    PIXEL_GRID.color2~& = THEME.PIXEL_GRID_color2~&
    PIXEL_GRID.imgHandle& = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    PIXEL_GRID_draw
END SUB


''
' Draw the pixel grid - single pixel lines around each pixel
'
SUB PIXEL_GRID_draw ()
    DIM AS INTEGER x, y
    DIM oldDest AS LONG
    oldDest& = _DEST
    _DEST PIXEL_GRID.imgHandle&
    CLS , _RGBA32(0, 0, 0, 0)  ' Clear with transparency
    
    ' Draw vertical lines (at each x position)
    FOR x% = 0 TO SCRN.w& - 1
        LINE (x%, 0)-(x%, SCRN.h& - 1), PIXEL_GRID.color1~&
    NEXT x%
    
    ' Draw horizontal lines (at each y position)
    FOR y% = 0 TO SCRN.h& - 1
        LINE (0, y%)-(SCRN.w& - 1, y%), PIXEL_GRID.color1~&
    NEXT y%
    
    _DEST oldDest&
END SUB
