''
' DRAW - GUI/LAYERS.BM
' =============================================================================
' Layers management subs and functions.
'
' @author Rick Christy <grymmjack@gmail.com>
'
$INCLUDEONCE

''
' Initialize the layer system
' Creates first layer and loads font
' 
SUB LAYERS_init ()
    DIM i AS INTEGER
    DIM firstLayer AS INTEGER
    
    ' Initialize all layer slots to empty
    FOR i% = 1 TO 64
        LAYERS(i%).zIndex%       = 0
        LAYERS(i%).imgWidth%     = 0
        LAYERS(i%).imgHeight%    = 0
        LAYERS(i%).imgHandle&    = 0
        LAYERS(i%).visible%      = FALSE
        LAYERS(i%).isSelected%   = FALSE
        LAYERS(i%).lastSelected% = FALSE
        LAYERS(i%).name          = ""
        LAYERS(i%).opacity%      = 255
        LAYERS(i%).opacityLock%  = FALSE
        LAYERS(i%).opacityCacheImg& = 0
        LAYERS(i%).opacityCacheVal% = 0
        LAYERS(i%).contentDirty%    = FALSE
    NEXT i%
    
    ' Initialize panel state
    LAYER_PANEL.visible%      = TRUE   ' Visible by default
    LAYER_PANEL.scrollOffset% = 0
    LAYER_PANEL.hoverRow%     = -1
    LAYER_PANEL.draggingRow%  = -1
    LAYER_PANEL.dragStartY%   = 0
    LAYER_PANEL.opacityDrag%  = FALSE
    LAYER_PANEL.opacityDragLayer% = 0
    
    ' Load Tiny5 font for panel text
    LAYER_PANEL.fontHandle& = _LOADFONT("ASSETS/FONTS/Tiny5-Regular.ttf", 8, "DONTBLEND")
    IF LAYER_PANEL.fontHandle& <= 0 THEN
        LAYER_PANEL.fontHandle& = 16  ' Fallback to default font
    END IF
    
    ' Initialize layer count and current layer
    LAYER_COUNT% = 0
    CURRENT_LAYER% = 0
    
    ' Create default initial layer (Background)
    DIM defaultLayer AS INTEGER
    defaultLayer% = LAYERS_new%
    IF defaultLayer% > 0 THEN
        LAYERS(defaultLayer%).name = "Background"
        ' Fill background layer with configured default color
        DIM oldDest2 AS LONG
        oldDest2& = _DEST
        _DEST LAYERS(defaultLayer%).imgHandle&
        CLS , CFG.DEFAULT_LAYER_BG_COLOR~&
        ' Copy any existing content from SCRN.PAINTING to the layer
        _PUTIMAGE , SCRN.PAINTING&
        _DEST oldDest2&
    END IF
END SUB


''
' Create a new layer above the currently selected layer
' Returns the index of the new layer, or 0 if max layers reached
' 
FUNCTION LAYERS_new% ()
    DIM newIndex AS INTEGER
    DIM i AS INTEGER
    DIM currentZ AS INTEGER
    DIM newZ AS INTEGER
    
    ' Check if we've hit the max
    IF LAYER_COUNT% >= CFG.NUM_LAYERS% THEN
        LAYERS_new% = 0
        EXIT FUNCTION
    END IF
    
    ' Find first empty slot
    newIndex% = 0
    FOR i% = 1 TO 64
        IF LAYERS(i%).imgHandle& = 0 THEN
            newIndex% = i%
            EXIT FOR
        END IF
    NEXT i%
    
    IF newIndex% = 0 THEN
        LAYERS_new% = 0
        EXIT FUNCTION
    END IF
    
    ' Get the zIndex of the currently selected layer
    ' New layer will be inserted directly above it
    DIM hasCurrentLayer AS INTEGER
    hasCurrentLayer% = FALSE
    IF CURRENT_LAYER% > 0 AND CURRENT_LAYER% <= 64 THEN
        IF LAYERS(CURRENT_LAYER%).imgHandle& <> 0 THEN
            hasCurrentLayer% = TRUE
        END IF
    END IF
    
    IF hasCurrentLayer% THEN
        currentZ% = LAYERS(CURRENT_LAYER%).zIndex%
        newZ% = currentZ% + 1
        
        ' Shift all layers with zIndex > currentZ up by 1 to make room
        FOR i% = 1 TO 64
            IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% > currentZ% THEN
                LAYERS(i%).zIndex% = LAYERS(i%).zIndex% + 1
            END IF
        NEXT i%
    ELSE
        ' No valid current layer, put new layer on top
        newZ% = LAYER_COUNT% + 1
    END IF
    
    ' Create the layer image buffer
    LAYERS(newIndex%).imgWidth%  = SCRN.w&
    LAYERS(newIndex%).imgHeight% = SCRN.h&
    LAYERS(newIndex%).imgHandle& = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    
    ' Clear to transparent (new layers are always transparent)
    DIM oldDest AS LONG
    oldDest& = _DEST
    _DEST LAYERS(newIndex%).imgHandle&
    CLS , _RGBA32(0, 0, 0, 0)
    _DEST oldDest&
    
    ' Set default properties
    LAYER_COUNT% = LAYER_COUNT% + 1
    LAYERS(newIndex%).zIndex%      = newZ%  ' Insert above current layer
    LAYERS(newIndex%).visible%     = TRUE
    LAYERS(newIndex%).isSelected%  = FALSE
    LAYERS(newIndex%).lastSelected% = FALSE
    LAYERS(newIndex%).name         = "Layer " + _TRIM$(STR$(LAYER_COUNT%))
    LAYERS(newIndex%).opacity%     = 255
    LAYERS(newIndex%).opacityLock% = FALSE
    LAYERS(newIndex%).blendMode%   = BLEND_NORMAL
    
    ' Select the new layer
    LAYERS_select newIndex%
    
    ' Save workspace undo state for layer addition
    WORKSPACE_UNDO_save_layer_add newIndex%
    
    BLEND_invalidate_cache
    GUI_NEEDS_REDRAW% = TRUE
    LAYERS_new% = newIndex%
END FUNCTION


''
' Delete a layer
' 
SUB LAYERS_delete (layerIndex AS INTEGER)
    DIM i AS INTEGER
    DIM deletedZ AS INTEGER
    
    ' Can't delete if only one layer
    IF LAYER_COUNT% <= 1 THEN EXIT SUB
    
    ' Validate index
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    ' Save workspace undo state BEFORE deletion (captures layer content)
    WORKSPACE_UNDO_save_layer_delete layerIndex%
    
    ' Cancel any pending/active drag that refers to this layer
    IF LAYER_PANEL.dragLayerIdx% = layerIndex% THEN
        LAYER_PANEL_drag_cancel
    END IF
    
    ' Store zIndex before deleting
    deletedZ% = LAYERS(layerIndex%).zIndex%
    
    ' Free the image
    IF LAYERS(layerIndex%).imgHandle& < -1 THEN
        _FREEIMAGE LAYERS(layerIndex%).imgHandle&
    END IF
    ' Free opacity cache image
    IF LAYERS(layerIndex%).opacityCacheImg& < -1 THEN
        _FREEIMAGE LAYERS(layerIndex%).opacityCacheImg&
    END IF
    
    ' Clear the slot
    LAYERS(layerIndex%).imgHandle& = 0
    LAYERS(layerIndex%).imgWidth%  = 0
    LAYERS(layerIndex%).imgHeight% = 0
    LAYERS(layerIndex%).zIndex%    = 0
    LAYERS(layerIndex%).visible%   = FALSE
    LAYERS(layerIndex%).isSelected% = FALSE
    LAYERS(layerIndex%).name       = ""
    LAYERS(layerIndex%).opacity%   = 255
    LAYERS(layerIndex%).opacityLock% = FALSE
    LAYERS(layerIndex%).opacityCacheImg& = 0
    LAYERS(layerIndex%).opacityCacheVal% = 0
    LAYERS(layerIndex%).contentDirty% = FALSE
    
    LAYER_COUNT% = LAYER_COUNT% - 1
    
    ' Adjust zIndex of layers above the deleted one
    FOR i% = 1 TO 64
        IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% > deletedZ% THEN
            LAYERS(i%).zIndex% = LAYERS(i%).zIndex% - 1
        END IF
    NEXT i%
    
    ' Select another layer if the deleted one was selected
    IF CURRENT_LAYER% = layerIndex% THEN
        ' Find the layer that is now at the position below where deleted layer was
        ' (which now has zIndex = deletedZ% - 1 after the adjustment above)
        DIM targetZ AS INTEGER
        DIM foundLayer AS INTEGER
        foundLayer% = 0
        
        ' First try to select the layer that was below (zIndex = deletedZ% - 1)
        targetZ% = deletedZ% - 1
        IF targetZ% >= 1 THEN
            FOR i% = 1 TO 64
                IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% = targetZ% THEN
                    foundLayer% = i%
                    EXIT FOR
                END IF
            NEXT i%
        END IF
        
        ' If no layer below, try the layer that was above (now at deletedZ% after adjustment)
        IF foundLayer% = 0 THEN
            FOR i% = 1 TO 64
                IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% = deletedZ% THEN
                    foundLayer% = i%
                    EXIT FOR
                END IF
            NEXT i%
        END IF
        
        ' Fallback: select any valid layer
        IF foundLayer% = 0 THEN
            FOR i% = 1 TO 64
                IF LAYERS(i%).imgHandle& <> 0 THEN
                    foundLayer% = i%
                    EXIT FOR
                END IF
            NEXT i%
        END IF
        
        IF foundLayer% > 0 THEN LAYERS_select foundLayer%
    END IF
    
    BLEND_invalidate_cache
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Duplicate a layer
' 
SUB LAYERS_duplicate (layerIndex AS INTEGER)
    DIM newIndex AS INTEGER
    DIM srcImg AS LONG
    DIM oldDest AS LONG
    
    ' Validate
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    ' Check if we've hit the max layers
    IF LAYER_COUNT% >= CFG.NUM_LAYERS% THEN EXIT SUB
    
    ' Find first empty slot
    newIndex% = 0
    DIM i AS INTEGER
    FOR i% = 1 TO 64
        IF LAYERS(i%).imgHandle& = 0 THEN
            newIndex% = i%
            EXIT FOR
        END IF
    NEXT i%
    IF newIndex% = 0 THEN EXIT SUB
    
    ' DIRECTLY copy the source layer image (creates a new image with same content)
    srcImg& = LAYERS(layerIndex%).imgHandle&
    LAYERS(newIndex%).imgHandle& = _COPYIMAGE(srcImg&, 32)
    
    ' Set layer properties
    LAYER_COUNT% = LAYER_COUNT% + 1
    LAYERS(newIndex%).imgWidth%    = _WIDTH(LAYERS(newIndex%).imgHandle&)
    LAYERS(newIndex%).imgHeight%   = _HEIGHT(LAYERS(newIndex%).imgHandle&)
    LAYERS(newIndex%).zIndex%      = LAYER_COUNT%
    LAYERS(newIndex%).visible%     = LAYERS(layerIndex%).visible%
    LAYERS(newIndex%).isSelected%  = FALSE
    LAYERS(newIndex%).lastSelected% = FALSE
    LAYERS(newIndex%).name         = _TRIM$(LAYERS(layerIndex%).name) + " copy"
    LAYERS(newIndex%).opacity%     = LAYERS(layerIndex%).opacity%
    LAYERS(newIndex%).opacityLock% = LAYERS(layerIndex%).opacityLock%
    LAYERS(newIndex%).contentDirty% = TRUE  ' New pixel data needs opacity cache build
    
    ' Select the new layer
    LAYERS_select newIndex%
    
    ' Save workspace undo state
    WORKSPACE_UNDO_save_layer_add newIndex%
    
    BLEND_invalidate_cache
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Clear a layer (fill with transparency)
' 
SUB LAYERS_clear (layerIndex AS INTEGER)
    DIM oldDest AS LONG
    
    ' Validate
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    oldDest& = _DEST
    _DEST LAYERS(layerIndex%).imgHandle&
    CLS , _RGBA32(0, 0, 0, 0)
    _DEST oldDest&
    
    LAYERS(layerIndex%).contentDirty% = TRUE
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Rename a layer using input dialog
' 
SUB LAYERS_rename (layerIndex AS INTEGER)
    DIM newName AS STRING
    
    ' Validate
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    POINTER_hide_for_dialog
    newName$ = _INPUTBOX$("Rename Layer", "Enter new name:", _TRIM$(LAYERS(layerIndex%).name))
    POINTER_show_after_dialog
    MOUSE_cleanup_after_dialog FALSE  ' Clear buffers but don't move mouse
    
    IF LEN(newName$) > 0 THEN
        ' Truncate to max length
        IF LEN(newName$) > CFG.LAYER_NAME_MAX_LEN% THEN
            newName$ = LEFT$(newName$, CFG.LAYER_NAME_MAX_LEN%)
        END IF
        
        ' Save workspace undo state for rename
        WORKSPACE_UNDO_save_layer_rename layerIndex%, _TRIM$(LAYERS(layerIndex%).name), newName$
        
        LAYERS(layerIndex%).name = newName$
        GUI_NEEDS_REDRAW% = TRUE
    END IF
END SUB


''
' Select a layer as the current working layer
' 
SUB LAYERS_select (layerIndex AS INTEGER)
    DIM i AS INTEGER
    
    ' Validate
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    ' If MOVE tool is active on a different layer, commit and reset before switching
    IF CURRENT_TOOL% = TOOL_MOVE AND MOVE.ACTIVE AND layerIndex% <> CURRENT_LAYER% THEN
        MOVE_reset  ' This applies the transform and cleans up
    END IF
    
    ' Deselect all layers
    FOR i% = 1 TO 64
        LAYERS(i%).lastSelected% = LAYERS(i%).isSelected%
        LAYERS(i%).isSelected% = FALSE
    NEXT i%
    
    ' Select the target layer
    LAYERS(layerIndex%).isSelected% = TRUE
    CURRENT_LAYER% = layerIndex%
    
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Move a layer up in the stack (increase zIndex)
' 
SUB LAYERS_move_up (layerIndex AS INTEGER)
    DIM i AS INTEGER
    DIM currentZ AS INTEGER
    DIM targetIndex AS INTEGER
    
    ' Validate
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    currentZ% = LAYERS(layerIndex%).zIndex%
    IF currentZ% >= LAYER_COUNT% THEN EXIT SUB  ' Already at top
    
    ' Find layer with zIndex = currentZ + 1
    targetIndex% = 0
    FOR i% = 1 TO 64
        IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% = currentZ% + 1 THEN
            targetIndex% = i%
            EXIT FOR
        END IF
    NEXT i%
    
    IF targetIndex% > 0 THEN
        ' Save workspace undo state for reorder
        WORKSPACE_UNDO_save_layer_reorder layerIndex%, currentZ%, currentZ% + 1
        
        ' Swap zIndex values
        LAYERS(layerIndex%).zIndex% = currentZ% + 1
        LAYERS(targetIndex%).zIndex% = currentZ%
    END IF
    
    BLEND_invalidate_cache
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Move a layer down in the stack (decrease zIndex)
' 
SUB LAYERS_move_down (layerIndex AS INTEGER)
    DIM i AS INTEGER
    DIM currentZ AS INTEGER
    DIM targetIndex AS INTEGER
    
    ' Validate
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    currentZ% = LAYERS(layerIndex%).zIndex%
    IF currentZ% <= 1 THEN EXIT SUB  ' Already at bottom
    
    ' Find layer with zIndex = currentZ - 1
    targetIndex% = 0
    FOR i% = 1 TO 64
        IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% = currentZ% - 1 THEN
            targetIndex% = i%
            EXIT FOR
        END IF
    NEXT i%
    
    IF targetIndex% > 0 THEN
        ' Save workspace undo state for reorder
        WORKSPACE_UNDO_save_layer_reorder layerIndex%, currentZ%, currentZ% - 1
        
        ' Swap zIndex values
        LAYERS(layerIndex%).zIndex% = currentZ% - 1
        LAYERS(targetIndex%).zIndex% = currentZ%
    END IF
    
    BLEND_invalidate_cache
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Move a layer to the top of the stack
' 
SUB LAYERS_to_top (layerIndex AS INTEGER)
    DIM i AS INTEGER
    DIM currentZ AS INTEGER
    
    ' Validate
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    currentZ% = LAYERS(layerIndex%).zIndex%
    IF currentZ% = LAYER_COUNT% THEN EXIT SUB  ' Already at top
    
    ' Decrease zIndex of all layers above this one
    FOR i% = 1 TO 64
        IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% > currentZ% THEN
            LAYERS(i%).zIndex% = LAYERS(i%).zIndex% - 1
        END IF
    NEXT i%
    
    ' Set this layer to top
    LAYERS(layerIndex%).zIndex% = LAYER_COUNT%
    
    BLEND_invalidate_cache
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Move a layer to the bottom of the stack
' 
SUB LAYERS_to_bottom (layerIndex AS INTEGER)
    DIM i AS INTEGER
    DIM currentZ AS INTEGER
    
    ' Validate
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    currentZ% = LAYERS(layerIndex%).zIndex%
    IF currentZ% = 1 THEN EXIT SUB  ' Already at bottom
    
    ' Increase zIndex of all layers below this one
    FOR i% = 1 TO 64
        IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% < currentZ% THEN
            LAYERS(i%).zIndex% = LAYERS(i%).zIndex% + 1
        END IF
    NEXT i%
    
    ' Set this layer to bottom
    LAYERS(layerIndex%).zIndex% = 1
    
    BLEND_invalidate_cache
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Toggle layer visibility
' 
SUB LAYERS_toggle_visibility (layerIndex AS INTEGER)
    ' Validate
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    LAYERS(layerIndex%).visible% = NOT LAYERS(layerIndex%).visible%
    BLEND_invalidate_cache
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Set layer opacity
' 
SUB LAYERS_set_opacity (layerIndex AS INTEGER, opacity AS INTEGER)
    DIM clampedOpacity AS INTEGER
    
    ' Validate
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    ' Clamp opacity to valid range
    clampedOpacity% = opacity%
    IF clampedOpacity% < 0 THEN clampedOpacity% = 0
    IF clampedOpacity% > 255 THEN clampedOpacity% = 255
    
    LAYERS(layerIndex%).opacity% = clampedOpacity%
    BLEND_COMPOSITE_DIRTY% = TRUE
    COMPOSITE_BELOW_VALID% = FALSE
    SCENE_DIRTY% = TRUE
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Toggle opacity lock (draw only on non-transparent pixels)
' 
SUB LAYERS_toggle_opacity_lock (layerIndex AS INTEGER)
    ' Validate
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    LAYERS(layerIndex%).opacityLock% = NOT LAYERS(layerIndex%).opacityLock%
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Merge current layer down into the layer below it
' 
SUB LAYERS_merge_down (layerIndex AS INTEGER)
    DIM i AS INTEGER
    DIM currentZ AS INTEGER
    DIM targetIndex AS INTEGER
    DIM oldDest AS LONG
    DIM tempImg AS LONG
    
    ' Validate
    IF layerIndex% < 1 OR layerIndex% > 64 THEN EXIT SUB
    IF LAYERS(layerIndex%).imgHandle& = 0 THEN EXIT SUB
    
    currentZ% = LAYERS(layerIndex%).zIndex%
    IF currentZ% <= 1 THEN EXIT SUB  ' No layer below to merge into
    
    ' Find layer below (zIndex = currentZ - 1)
    targetIndex% = 0
    FOR i% = 1 TO 64
        IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% = currentZ% - 1 THEN
            targetIndex% = i%
            EXIT FOR
        END IF
    NEXT i%
    
    IF targetIndex% = 0 THEN EXIT SUB
    
    ' Save workspace undo state BEFORE merge (captures both layers' content)
    WORKSPACE_UNDO_save_layer_merge layerIndex%, targetIndex%
    
    ' Merge: composite current layer onto target with opacity
    oldDest& = _DEST
    
    IF LAYERS(layerIndex%).opacity% < 255 THEN
        ' Create temp image with opacity applied
        tempImg& = _COPYIMAGE(LAYERS(layerIndex%).imgHandle&, 32)
        _SETALPHA LAYERS(layerIndex%).opacity%, , tempImg&
        _DEST LAYERS(targetIndex%).imgHandle&
        _BLEND LAYERS(targetIndex%).imgHandle&
        _PUTIMAGE , tempImg&
        IF tempImg& < -1 THEN _FREEIMAGE tempImg&
    ELSE
        _DEST LAYERS(targetIndex%).imgHandle&
        _BLEND LAYERS(targetIndex%).imgHandle&
        _PUTIMAGE , LAYERS(layerIndex%).imgHandle&
    END IF
    
    _DEST oldDest&
    
    ' Mark target layer content dirty (its pixels changed from merge)
    LAYERS(targetIndex%).contentDirty% = TRUE
    
    ' Delete the merged layer (suppress undo save since we already saved merge state)
    WORKSPACE_UNDO_IN_PROGRESS% = TRUE
    LAYERS_delete layerIndex%
    WORKSPACE_UNDO_IN_PROGRESS% = FALSE
    
    ' Select the target layer
    LAYERS_select targetIndex%
    
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Merge all visible layers into a new layer
' 
SUB LAYERS_merge_visible ()
    DIM newIndex AS INTEGER
    DIM i AS INTEGER, z AS INTEGER
    DIM oldDest AS LONG
    DIM tempImg AS LONG
    DIM sortedLayers(1 TO 64) AS INTEGER
    DIM sortCount AS INTEGER
    
    ' Build sorted list of visible layers by zIndex
    sortCount% = 0
    FOR z% = 1 TO LAYER_COUNT%
        FOR i% = 1 TO 64
            IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).visible% AND LAYERS(i%).zIndex% = z% THEN
                sortCount% = sortCount% + 1
                sortedLayers%(sortCount%) = i%
                EXIT FOR
            END IF
        NEXT i%
    NEXT z%
    
    IF sortCount% < 2 THEN EXIT SUB  ' Need at least 2 visible layers to merge
    
    ' Create new layer for merged result
    newIndex% = LAYERS_new%
    IF newIndex% = 0 THEN EXIT SUB
    
    LAYERS(newIndex%).name = "Merged"
    
    ' Composite all visible layers bottom-to-top
    oldDest& = _DEST
    _DEST LAYERS(newIndex%).imgHandle&
    CLS , _RGBA32(0, 0, 0, 0)
    _BLEND LAYERS(newIndex%).imgHandle&
    
    FOR i% = 1 TO sortCount%
        DIM srcIdx AS INTEGER
        srcIdx% = sortedLayers%(i%)
        
        IF LAYERS(srcIdx%).opacity% < 255 THEN
            tempImg& = _COPYIMAGE(LAYERS(srcIdx%).imgHandle&, 32)
            _SETALPHA LAYERS(srcIdx%).opacity%, , tempImg&
            _PUTIMAGE , tempImg&
            IF tempImg& < -1 THEN _FREEIMAGE tempImg&
        ELSE
            _PUTIMAGE , LAYERS(srcIdx%).imgHandle&
        END IF
    NEXT i%
    
    _DEST oldDest&
    
    ' Delete the source visible layers (except the new one)
    FOR i% = 1 TO sortCount%
        IF sortedLayers%(i%) <> newIndex% THEN
            LAYERS_delete sortedLayers%(i%)
        END IF
    NEXT i%
    
    ' Select the merged layer
    LAYERS_select newIndex%
    
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Flatten all visible layers and return a new image handle
' Caller is responsible for freeing the returned image
' 
FUNCTION LAYERS_flatten& ()
    DIM result AS LONG
    DIM i AS INTEGER, z AS INTEGER
    DIM oldDest AS LONG
    DIM tempImg AS LONG
    
    result& = _NEWIMAGE(SCRN.w&, SCRN.h&, 32)
    
    oldDest& = _DEST
    _DEST result&
    CLS , _RGBA32(0, 0, 0, 0)
    _BLEND result&
    _DEST oldDest&
    
    ' Composite visible layers bottom-to-top by zIndex
    FOR z% = 1 TO LAYER_COUNT%
        FOR i% = 1 TO 64
            IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).visible% AND LAYERS(i%).zIndex% = z% THEN
                IF LAYERS(i%).blendMode% <> BLEND_NORMAL THEN
                    ' Non-Normal blend: use per-pixel blend composite
                    LAYER_blend_composite result&, LAYERS(i%).imgHandle&, LAYERS(i%).blendMode%, LAYERS(i%).opacity%
                ELSE
                    ' Normal blend: standard alpha composite via _PUTIMAGE
                    oldDest& = _DEST
                    _DEST result&
                    IF LAYERS(i%).opacity% < 255 THEN
                        tempImg& = _COPYIMAGE(LAYERS(i%).imgHandle&, 32)
                        _SETALPHA LAYERS(i%).opacity%, , tempImg&
                        _PUTIMAGE , tempImg&
                        IF tempImg& < -1 THEN _FREEIMAGE tempImg&
                    ELSE
                        _PUTIMAGE , LAYERS(i%).imgHandle&
                    END IF
                    _DEST oldDest&
                END IF
                EXIT FOR
            END IF
        NEXT i%
    NEXT z%
    
    LAYERS_flatten& = result&
END FUNCTION


''
' Get the current layer's image handle for drawing
' 
FUNCTION LAYER_current_image& ()
    IF CURRENT_LAYER% >= 1 AND CURRENT_LAYER% <= 64 THEN
        IF LAYERS(CURRENT_LAYER%).imgHandle& <> 0 THEN
            LAYER_current_image& = LAYERS(CURRENT_LAYER%).imgHandle&
            EXIT FUNCTION
        END IF
    END IF
    
    ' Fallback to SCRN.PAINTING if no valid layer
    LAYER_current_image& = SCRN.PAINTING&
END FUNCTION


''
' Render the layer panel
' 
SUB LAYER_PANEL_render (canvasHeight AS INTEGER)
    DIM panelX AS INTEGER, panelY AS INTEGER
    DIM panelW AS INTEGER, panelH AS INTEGER
    DIM rowY AS INTEGER
    DIM i AS INTEGER, z AS INTEGER
    DIM layerIdx AS INTEGER
    DIM oldDest AS LONG
    DIM oldFont AS LONG
    DIM bgColor AS _UNSIGNED LONG
    DIM fgColor AS _UNSIGNED LONG
    DIM rowBg AS _UNSIGNED LONG
    DIM visibleIcon AS STRING
    DIM lockIcon AS STRING
    DIM opacityBarW AS INTEGER
    DIM opacityFill AS INTEGER
    DIM bottomBarsHeight AS INTEGER
    DIM listTop AS INTEGER, listBottom AS INTEGER, listHeight AS INTEGER
    DIM totalContentHeight AS INTEGER
    DIM scrollbarX AS INTEGER, scrollbarY AS INTEGER, scrollbarH AS INTEGER
    DIM thumbH AS INTEGER, thumbY AS INTEGER
    DIM maxScroll AS INTEGER
    
    IF NOT LAYER_PANEL.visible% THEN EXIT SUB
    
    ' Calculate height of bottom bars (status bar + palette strip) only if visible
    IF SCRN.showStatus% THEN
        bottomBarsHeight% = THEME.STATUS_height% + PALETTE_STRIP_get_height%
    ELSE
        bottomBarsHeight% = 0  ' No bottom bars when status bar is hidden
    END IF
    
    panelX% = 0
    panelY% = 0
    panelW% = CFG.LAYER_PANEL_WIDTH%
    panelH% = canvasHeight% - bottomBarsHeight%  ' Extend to bottom when status bar hidden
    
    ' Define areas: header (16px), list area (variable), button area (24px)
    CONST HEADER_HEIGHT = 16
    CONST BUTTON_AREA_HEIGHT = 24
    listTop% = panelY% + HEADER_HEIGHT
    listBottom% = panelH% - BUTTON_AREA_HEIGHT
    listHeight% = listBottom% - listTop%
    
    ' Calculate total content height
    totalContentHeight% = LAYER_COUNT% * LAYER_ROW_HEIGHT
    
    ' Calculate max scroll offset
    maxScroll% = totalContentHeight% - listHeight%
    IF maxScroll% < 0 THEN maxScroll% = 0
    
    ' Clamp scroll offset
    IF LAYER_PANEL.scrollOffset% > maxScroll% THEN LAYER_PANEL.scrollOffset% = maxScroll%
    IF LAYER_PANEL.scrollOffset% < 0 THEN LAYER_PANEL.scrollOffset% = 0
    
    oldDest& = _DEST
    _DEST SCRN.GUI&
    
    ' Draw panel background
    bgColor~& = _RGB32(40, 40, 40)
    LINE (panelX%, panelY%)-(panelX% + panelW% - 1, panelY% + panelH% - 1), bgColor~&, BF
    
    ' Draw right border
    LINE (panelX% + panelW% - 1, panelY%)-(panelX% + panelW% - 1, panelY% + panelH% - 1), _RGB32(60, 60, 60)
    
    ' Draw header
    LINE (panelX%, panelY%)-(panelX% + panelW% - 1, panelY% + HEADER_HEIGHT - 1), _RGB32(50, 50, 50), BF
    
    oldFont& = _FONT
    IF LAYER_PANEL.fontHandle& > 0 THEN _FONT LAYER_PANEL.fontHandle&
    
    COLOR _RGB32(200, 200, 200), _RGBA32(0, 0, 0, 0)
    _PRINTSTRING (panelX% + 4, panelY% + 3), "LAYERS"
    
    ' Draw layer count in header
    COLOR _RGB32(150, 150, 150), _RGBA32(0, 0, 0, 0)
    _PRINTSTRING (panelX% + panelW% - 20, panelY% + 3), _TRIM$(STR$(LAYER_COUNT%))
    
    ' Draw layer rows (top to bottom = highest zIndex to lowest)
    ' Only draw rows that are visible in the list area
    rowY% = listTop%
    
    FOR z% = LAYER_COUNT% TO 1 STEP -1
        ' Find layer with this zIndex
        layerIdx% = 0
        FOR i% = 1 TO 64
            IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% = z% THEN
                layerIdx% = i%
                EXIT FOR
            END IF
        NEXT i%
        
        IF layerIdx% > 0 THEN
            DIM drawY AS INTEGER
            drawY% = rowY% - LAYER_PANEL.scrollOffset%
            
            ' Only draw if row is visible in list area
            IF drawY% + LAYER_ROW_HEIGHT > listTop% AND drawY% < listBottom% THEN
                ' Clip to list area
                DIM clipTop AS INTEGER, clipBottom AS INTEGER
                clipTop% = drawY%
                IF clipTop% < listTop% THEN clipTop% = listTop%
                clipBottom% = drawY% + LAYER_ROW_HEIGHT - 1
                IF clipBottom% >= listBottom% THEN clipBottom% = listBottom% - 1
                
                ' Row background (selected = highlight)
                IF LAYERS(layerIdx%).isSelected% THEN
                    rowBg~& = _RGB32(70, 100, 140)
                ELSEIF LAYER_PANEL.hoverRow% = layerIdx% THEN
                    rowBg~& = _RGB32(55, 55, 55)
                ELSE
                    rowBg~& = _RGB32(45, 45, 45)
                END IF
                LINE (panelX% + 2, clipTop%)-(panelX% + panelW% - 12, clipBottom%), rowBg~&, BF
                
                ' Only draw text if fully visible
                IF drawY% >= listTop% AND drawY% + LAYER_ROW_HEIGHT <= listBottom% THEN
                    ' Visibility toggle (eye icon) - PNG with text fallback
                    DIM visIcon AS LONG
                    IF LAYERS(layerIdx%).visible% THEN
                        visIcon& = LAYER_PANEL.iconVisOn&
                        fgColor~& = _RGB32(200, 200, 200)
                        visibleIcon$ = "O"  ' Fallback text
                    ELSE
                        visIcon& = LAYER_PANEL.iconVisOff&
                        fgColor~& = _RGB32(100, 100, 100)
                        visibleIcon$ = "-"  ' Fallback text
                    END IF
                    IF visIcon& < -1 THEN
                        ' Draw PNG icon centered vertically in row
                        DIM viW AS INTEGER, viH AS INTEGER
                        viW% = _WIDTH(visIcon&)
                        viH% = _HEIGHT(visIcon&)
                        _PUTIMAGE (panelX% + 3, drawY% + (LAYER_ROW_HEIGHT - viH%) \ 2)-(panelX% + 3 + viW% - 1, drawY% + (LAYER_ROW_HEIGHT - viH%) \ 2 + viH% - 1), visIcon&, SCRN.GUI&
                    ELSE
                        ' Fallback to text
                        COLOR fgColor~&, _RGBA32(0, 0, 0, 0)
                        _PRINTSTRING (panelX% + 4, drawY% + 4), visibleIcon$
                    END IF
                    
                    ' Opacity lock icon - PNG with text fallback
                    DIM lkIcon AS LONG
                    IF LAYERS(layerIdx%).opacityLock% THEN
                        lkIcon& = LAYER_PANEL.iconLockOn&
                    ELSE
                        lkIcon& = LAYER_PANEL.iconLockOff&
                    END IF
                    IF lkIcon& < -1 THEN
                        ' Draw PNG icon centered vertically in row
                        DIM lkW AS INTEGER, lkH AS INTEGER
                        lkW% = _WIDTH(lkIcon&)
                        lkH% = _HEIGHT(lkIcon&)
                        _PUTIMAGE (panelX% + 14, drawY% + (LAYER_ROW_HEIGHT - lkH%) \ 2)-(panelX% + 14 + lkW% - 1, drawY% + (LAYER_ROW_HEIGHT - lkH%) \ 2 + lkH% - 1), lkIcon&, SCRN.GUI&
                    ELSE
                        ' Fallback to text (only show when locked)
                        IF LAYERS(layerIdx%).opacityLock% THEN
                            lockIcon$ = "L"
                            COLOR _RGB32(255, 180, 0), _RGBA32(0, 0, 0, 0)
                            _PRINTSTRING (panelX% + 14, drawY% + 4), lockIcon$
                        END IF
                    END IF
                    
                    ' Layer name (fit to available panel space using pixel width)
                    DIM layerName AS STRING
                    DIM availW AS INTEGER
                    layerName$ = _TRIM$(LAYERS(layerIdx%).name)
                    availW% = panelW% - 24 - 14  ' left icons offset - scrollbar/right padding
                    ' Trim from end until it fits the available pixel width
                    DO WHILE LEN(layerName$) > 0 AND _PRINTWIDTH(layerName$) > availW%
                        layerName$ = LEFT$(layerName$, LEN(layerName$) - 1)
                    LOOP
                    COLOR _RGB32(220, 220, 220), _RGBA32(0, 0, 0, 0)
                    _PRINTSTRING (panelX% + 24, drawY% + 4), layerName$
                    
                    ' Blend mode indicator (show short name if not Normal)
                    IF LAYERS(layerIdx%).blendMode% <> BLEND_NORMAL THEN
                        DIM blendShort AS STRING
                        blendShort$ = BLEND_mode_short$(LAYERS(layerIdx%).blendMode%)
                        COLOR _RGB32(180, 140, 255), _RGBA32(0, 0, 0, 0)
                        _PRINTSTRING (panelX% + 24, drawY% + 12), blendShort$
                    END IF
                    
                    ' Opacity bar (small bar showing opacity level)
                    opacityBarW% = 30
                    opacityFill% = INT((LAYERS(layerIdx%).opacity% / 255.0) * opacityBarW%)
                    LINE (panelX% + panelW% - opacityBarW% - 14, drawY% + 14)-(panelX% + panelW% - 14, drawY% + 17), _RGB32(30, 30, 30), BF
                    IF opacityFill% > 0 THEN
                        LINE (panelX% + panelW% - opacityBarW% - 14, drawY% + 14)-(panelX% + panelW% - opacityBarW% - 14 + opacityFill%, drawY% + 17), _RGB32(100, 150, 200), BF
                    END IF
                END IF
            END IF
            
            rowY% = rowY% + LAYER_ROW_HEIGHT
        END IF
    NEXT z%
    
    ' --- Draw drop target indicator when dragging ---
    IF LAYER_PANEL.isDragging% AND LAYER_PANEL.dropTargetZIndex% >= 1 THEN
        DIM dropY AS INTEGER
        DIM dropRowFromTop AS INTEGER
        DIM draggedZ AS INTEGER
        
        draggedZ% = LAYERS(LAYER_PANEL.dragLayerIdx%).zIndex%
        
        ' Draw indicator (dropTargetZIndex is already validated, -1 means no valid target)
        ' Calculate Y position for drop indicator
        ' dropTargetZIndex is the final zIndex position the layer will have
        ' For visual, we draw the line ABOVE that position
        ' If moving up (target > current), line goes above the target position
        ' If moving down (target < current), line goes below the position above target
        IF LAYER_PANEL.dropTargetZIndex% > draggedZ% THEN
            ' Moving up - draw line above the layer currently at target zIndex
            dropRowFromTop% = LAYER_COUNT% - LAYER_PANEL.dropTargetZIndex%
        ELSE
            ' Moving down - draw line below the layer currently above target zIndex
            dropRowFromTop% = LAYER_COUNT% - LAYER_PANEL.dropTargetZIndex% + 1
        END IF
        dropY% = listTop% + (dropRowFromTop% * LAYER_ROW_HEIGHT) - LAYER_PANEL.scrollOffset%
        
        ' Draw indicator line if visible
        IF dropY% >= listTop% - 2 AND dropY% <= listBottom% + 2 THEN
            LINE (panelX% + 4, dropY%)-(panelX% + panelW% - 14, dropY%), _RGB32(100, 200, 255)
            LINE (panelX% + 4, dropY% - 1)-(panelX% + panelW% - 14, dropY% - 1), _RGB32(50, 150, 200)
            ' Draw small triangles at ends
            LINE (panelX% + 2, dropY% - 3)-(panelX% + 6, dropY%), _RGB32(100, 200, 255)
            LINE (panelX% + 2, dropY% + 3)-(panelX% + 6, dropY%), _RGB32(100, 200, 255)
            LINE (panelX% + panelW% - 12, dropY% - 3)-(panelX% + panelW% - 16, dropY%), _RGB32(100, 200, 255)
            LINE (panelX% + panelW% - 12, dropY% + 3)-(panelX% + panelW% - 16, dropY%), _RGB32(100, 200, 255)
        END IF
    END IF
    
    ' --- Draw drag cursor preview (mini layer row following mouse) ---
    IF LAYER_PANEL.isDragging% AND LAYER_PANEL.dragLayerIdx% > 0 THEN
        DIM previewY AS INTEGER
        DIM previewH AS INTEGER
        DIM dragLayerName AS STRING
        DIM dragLayerZ AS INTEGER
        
        previewY% = LAYER_PANEL.dragPreviewY% - (LAYER_ROW_HEIGHT \ 2)
        previewH% = LAYER_ROW_HEIGHT
        
        ' Clamp preview to panel bounds
        IF previewY% < listTop% THEN previewY% = listTop%
        IF previewY% + previewH% > listBottom% THEN previewY% = listBottom% - previewH%
        
        dragLayerName$ = RTRIM$(LAYERS(LAYER_PANEL.dragLayerIdx%).name)
        dragLayerZ% = LAYERS(LAYER_PANEL.dragLayerIdx%).zIndex%
        
        ' Draw semi-transparent preview row
        LINE (panelX% + 2, previewY%)-(panelX% + panelW% - 4, previewY% + previewH% - 2), _RGBA32(60, 120, 180, 180), BF
        LINE (panelX% + 2, previewY%)-(panelX% + panelW% - 4, previewY% + previewH% - 2), _RGB32(100, 200, 255), B
        
        ' Draw layer name in preview
        COLOR _RGB32(255, 255, 255), _RGBA32(0, 0, 0, 0)
        IF LEN(dragLayerName$) > 12 THEN dragLayerName$ = LEFT$(dragLayerName$, 11) + "~"
        _PRINTSTRING (panelX% + 26, previewY% + 4), dragLayerName$
    END IF
    
    ' Draw scrollbar if content exceeds list height
    IF totalContentHeight% > listHeight% THEN
        scrollbarX% = panelX% + panelW% - 10
        scrollbarY% = listTop%
        scrollbarH% = listHeight%
        
        ' Scrollbar track
        LINE (scrollbarX%, scrollbarY%)-(scrollbarX% + 7, scrollbarY% + scrollbarH% - 1), _RGB32(30, 30, 30), BF
        
        ' Scrollbar thumb
        thumbH% = INT((listHeight% / totalContentHeight%) * scrollbarH%)
        IF thumbH% < 20 THEN thumbH% = 20  ' Minimum thumb size
        IF thumbH% > scrollbarH% THEN thumbH% = scrollbarH%
        
        IF maxScroll% > 0 THEN
            thumbY% = scrollbarY% + INT((LAYER_PANEL.scrollOffset% / maxScroll%) * (scrollbarH% - thumbH%))
        ELSE
            thumbY% = scrollbarY%
        END IF
        
        LINE (scrollbarX% + 1, thumbY%)-(scrollbarX% + 6, thumbY% + thumbH% - 1), _RGB32(80, 80, 80), BF
    END IF
    
    ' Draw separator line above button area
    LINE (panelX%, listBottom%)-(panelX% + panelW% - 1, listBottom%), _RGB32(60, 60, 60)
    
    ' Draw button bar at bottom (5 buttons: ^ v # x +)
    DIM btnY AS INTEGER
    DIM btnW AS INTEGER
    DIM btnX AS INTEGER
    DIM btnSpacing AS INTEGER
    DIM btnEnabled AS INTEGER
    DIM btnIcon AS LONG
    DIM biW AS INTEGER, biH AS INTEGER
    
    btnY% = listBottom% + 3
    btnSpacing% = 2
    btnW% = (panelW% - 8 - (4 * btnSpacing%)) \ 5  ' 5 buttons with spacing
    
    ' Button 1: Move Up (^)
    btnX% = panelX% + 4
    btnEnabled% = (CURRENT_LAYER% > 0 AND LAYERS(CURRENT_LAYER%).zIndex% < LAYER_COUNT%)
    btnIcon& = LAYER_PANEL.iconBtnUp&
    IF btnIcon& < -1 THEN
        biW% = _WIDTH(btnIcon&): biH% = _HEIGHT(btnIcon&)
        _PUTIMAGE (btnX% + (btnW% - biW%) \ 2, btnY% + (16 - biH%) \ 2)-(btnX% + (btnW% - biW%) \ 2 + biW% - 1, btnY% + (16 - biH%) \ 2 + biH% - 1), btnIcon&, SCRN.GUI&
    ELSE
        IF btnEnabled% THEN
            LINE (btnX%, btnY%)-(btnX% + btnW% - 1, btnY% + 16), _RGB32(60, 70, 80), BF
        ELSE
            LINE (btnX%, btnY%)-(btnX% + btnW% - 1, btnY% + 16), _RGB32(45, 45, 45), BF
        END IF
    END IF
    
    ' Button 2: Move Down (v)
    btnX% = btnX% + btnW% + btnSpacing%
    btnEnabled% = (CURRENT_LAYER% > 0 AND LAYERS(CURRENT_LAYER%).zIndex% > 1)
    btnIcon& = LAYER_PANEL.iconBtnDown&
    IF btnIcon& < -1 THEN
        biW% = _WIDTH(btnIcon&): biH% = _HEIGHT(btnIcon&)
        _PUTIMAGE (btnX% + (btnW% - biW%) \ 2, btnY% + (16 - biH%) \ 2)-(btnX% + (btnW% - biW%) \ 2 + biW% - 1, btnY% + (16 - biH%) \ 2 + biH% - 1), btnIcon&, SCRN.GUI&
    ELSE
        IF btnEnabled% THEN
            LINE (btnX%, btnY%)-(btnX% + btnW% - 1, btnY% + 16), _RGB32(60, 70, 80), BF
        ELSE
            LINE (btnX%, btnY%)-(btnX% + btnW% - 1, btnY% + 16), _RGB32(45, 45, 45), BF
        END IF
    END IF
    
    ' Button 3: Merge Down (#)
    btnX% = btnX% + btnW% + btnSpacing%
    btnEnabled% = (CURRENT_LAYER% > 0 AND LAYERS(CURRENT_LAYER%).zIndex% > 1)
    btnIcon& = LAYER_PANEL.iconBtnMerge&
    IF btnIcon& < -1 THEN
        biW% = _WIDTH(btnIcon&): biH% = _HEIGHT(btnIcon&)
        _PUTIMAGE (btnX% + (btnW% - biW%) \ 2, btnY% + (16 - biH%) \ 2)-(btnX% + (btnW% - biW%) \ 2 + biW% - 1, btnY% + (16 - biH%) \ 2 + biH% - 1), btnIcon&, SCRN.GUI&
    ELSE
        IF btnEnabled% THEN
            LINE (btnX%, btnY%)-(btnX% + btnW% - 1, btnY% + 16), _RGB32(70, 70, 60), BF
        ELSE
            LINE (btnX%, btnY%)-(btnX% + btnW% - 1, btnY% + 16), _RGB32(45, 45, 45), BF
        END IF
    END IF
    
    ' Button 4: Delete Layer (x)
    btnX% = btnX% + btnW% + btnSpacing%
    btnEnabled% = (LAYER_COUNT% > 1)
    btnIcon& = LAYER_PANEL.iconBtnDelete&
    IF btnIcon& < -1 THEN
        biW% = _WIDTH(btnIcon&): biH% = _HEIGHT(btnIcon&)
        _PUTIMAGE (btnX% + (btnW% - biW%) \ 2, btnY% + (16 - biH%) \ 2)-(btnX% + (btnW% - biW%) \ 2 + biW% - 1, btnY% + (16 - biH%) \ 2 + biH% - 1), btnIcon&, SCRN.GUI&
    ELSE
        IF btnEnabled% THEN
            LINE (btnX%, btnY%)-(btnX% + btnW% - 1, btnY% + 16), _RGB32(80, 50, 50), BF
        ELSE
            LINE (btnX%, btnY%)-(btnX% + btnW% - 1, btnY% + 16), _RGB32(45, 45, 45), BF
        END IF
    END IF
    
    ' Button 5: New Layer (+)
    btnX% = btnX% + btnW% + btnSpacing%
    btnIcon& = LAYER_PANEL.iconBtnAdd&
    IF btnIcon& < -1 THEN
        biW% = _WIDTH(btnIcon&): biH% = _HEIGHT(btnIcon&)
        _PUTIMAGE (btnX% + (btnW% - biW%) \ 2, btnY% + (16 - biH%) \ 2)-(btnX% + (btnW% - biW%) \ 2 + biW% - 1, btnY% + (16 - biH%) \ 2 + biH% - 1), btnIcon&, SCRN.GUI&
    ELSE
        LINE (btnX%, btnY%)-(btnX% + btnW% - 1, btnY% + 16), _RGB32(50, 70, 50), BF
    END IF
    
    _FONT oldFont&
    _DEST oldDest&
END SUB


''
' Check if mouse coordinates are within the layer panel
' 
FUNCTION LAYER_PANEL_in_bounds% (rawX AS INTEGER, rawY AS INTEGER)
    DIM bottomBarsHeight AS INTEGER
    DIM panelH AS INTEGER
    
    IF NOT LAYER_PANEL.visible% THEN
        LAYER_PANEL_in_bounds% = FALSE
        EXIT FUNCTION
    END IF
    
    ' Calculate panel height (stops above bottom bars only if visible)
    IF SCRN.showStatus% THEN
        bottomBarsHeight% = THEME.STATUS_height% + PALETTE_STRIP_get_height%
    ELSE
        bottomBarsHeight% = 0
    END IF
    panelH% = SCRN.h& - bottomBarsHeight%
    
    LAYER_PANEL_in_bounds% = (rawX% >= 0 AND rawX% < CFG.LAYER_PANEL_WIDTH% AND rawY% >= 0 AND rawY% < panelH%)
END FUNCTION


''
' Handle click events in the layer panel
' Returns TRUE if click was handled, FALSE otherwise
' 
FUNCTION LAYER_PANEL_handle_click% (rawX AS INTEGER, rawY AS INTEGER, button AS INTEGER)
    DIM panelW AS INTEGER, panelH AS INTEGER
    DIM rowY AS INTEGER
    DIM i AS INTEGER, z AS INTEGER
    DIM layerIdx AS INTEGER
    DIM clickY AS INTEGER
    DIM bottomBarsHeight AS INTEGER
    ' Note: btnClickedThisPress is no longer needed - the caller (MOUSE.BM) already 
    ' ensures we only get called on fresh clicks (MOUSE.B1% AND NOT MOUSE.OLD_B1%)
    
    IF NOT LAYER_PANEL.visible% THEN
        LAYER_PANEL_handle_click% = FALSE
        EXIT FUNCTION
    END IF
    
    ' Calculate panel height (stops above bottom bars only if visible)
    IF SCRN.showStatus% THEN
        bottomBarsHeight% = THEME.STATUS_height% + PALETTE_STRIP_get_height%
    ELSE
        bottomBarsHeight% = 0
    END IF
    panelW% = CFG.LAYER_PANEL_WIDTH%
    panelH% = SCRN.h& - bottomBarsHeight%
    
    ' Check if click is within panel
    IF rawX% < 0 OR rawX% >= panelW% THEN
        LAYER_PANEL_handle_click% = FALSE
        EXIT FUNCTION
    END IF
    
    ' Check for button bar clicks
    DIM btnY AS INTEGER
    DIM btnW AS INTEGER
    DIM btnX AS INTEGER
    DIM btnSpacing AS INTEGER
    
    btnY% = panelH% - 21  ' Button area starts here
    btnSpacing% = 2
    btnW% = (panelW% - 8 - (4 * btnSpacing%)) \ 5
    
    IF rawY% >= btnY% AND rawY% < btnY% + 16 AND button% = 1 THEN
        ' Determine which button was clicked
        DIM clickBtn AS INTEGER
        clickBtn% = -1
        btnX% = 4
        
        ' Button 1: Move Up (^)
        IF rawX% >= btnX% AND rawX% < btnX% + btnW% THEN
            clickBtn% = 1
        END IF
        btnX% = btnX% + btnW% + btnSpacing%
        
        ' Button 2: Move Down (v)
        IF rawX% >= btnX% AND rawX% < btnX% + btnW% THEN
            clickBtn% = 2
        END IF
        btnX% = btnX% + btnW% + btnSpacing%
        
        ' Button 3: Merge Down (#)
        IF rawX% >= btnX% AND rawX% < btnX% + btnW% THEN
            clickBtn% = 3
        END IF
        btnX% = btnX% + btnW% + btnSpacing%
        
        ' Button 4: Delete (x)
        IF rawX% >= btnX% AND rawX% < btnX% + btnW% THEN
            clickBtn% = 4
        END IF
        btnX% = btnX% + btnW% + btnSpacing%
        
        ' Button 5: New (+)
        IF rawX% >= btnX% AND rawX% < btnX% + btnW% THEN
            clickBtn% = 5
        END IF
        
        ' Execute button action (only if a button was actually clicked)
        IF clickBtn% > 0 THEN
            SELECT CASE clickBtn%
                CASE 1  ' Move Up
                    IF CURRENT_LAYER% > 0 THEN LAYERS_move_up CURRENT_LAYER%
                CASE 2  ' Move Down
                    IF CURRENT_LAYER% > 0 THEN LAYERS_move_down CURRENT_LAYER%
                CASE 3  ' Merge Down
                    IF CURRENT_LAYER% > 0 THEN LAYERS_merge_down CURRENT_LAYER%
                CASE 4  ' Delete
                    IF LAYER_COUNT% > 1 AND CURRENT_LAYER% > 0 THEN LAYERS_delete CURRENT_LAYER%
                CASE 5  ' New
                    DIM dummy AS INTEGER
                    dummy% = LAYERS_new%
            END SELECT
        END IF
        
        LAYER_PANEL_handle_click% = TRUE
        EXIT FUNCTION
    END IF
    
    ' Check for layer row clicks
    clickY% = rawY% + LAYER_PANEL.scrollOffset%
    rowY% = 16  ' Start after header
    
    FOR z% = LAYER_COUNT% TO 1 STEP -1
        ' Find layer with this zIndex
        layerIdx% = 0
        FOR i% = 1 TO 64
            IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% = z% THEN
                layerIdx% = i%
                EXIT FOR
            END IF
        NEXT i%
        
        IF layerIdx% > 0 THEN
            IF clickY% >= rowY% AND clickY% < rowY% + LAYER_ROW_HEIGHT THEN
                ' Clicked on this layer row
                DIM localX AS INTEGER
                localX% = rawX%
                
                IF button% = 1 THEN
                    ' Check if clicking visibility toggle (first 12 pixels)
                    IF localX% < 14 THEN
                        DIM altHeld AS INTEGER
                        $IF MAC THEN
                            altHeld% = MAC_ALT_HELD%
                        $ELSE
                            altHeld% = (_KEYDOWN(KEY_LALT&) OR _KEYDOWN(KEY_RALT&))
                        $END IF
                        IF altHeld% THEN
                            ' Alt+click: solo/unsolo layer
                            IF LAYER_PANEL.soloLayer% = layerIdx% THEN
                                ' Unsolo: restore all saved visibility states
                                DIM ri AS INTEGER
                                FOR ri% = 1 TO 64
                                    IF LAYERS(ri%).imgHandle& <> 0 THEN
                                        LAYERS(ri%).visible% = ASC(MID$(LAYER_PANEL.savedVisibility, ri%, 1))
                                    END IF
                                NEXT ri%
                                LAYER_PANEL.soloLayer% = 0
                                BLEND_invalidate_cache
                            ELSE
                                ' Solo: save all states, hide all except clicked
                                DIM si AS INTEGER
                                FOR si% = 1 TO 64
                                    IF LAYERS(si%).imgHandle& <> 0 THEN
                                        IF LAYERS(si%).visible% THEN
                                            MID$(LAYER_PANEL.savedVisibility, si%, 1) = CHR$(1)
                                        ELSE
                                            MID$(LAYER_PANEL.savedVisibility, si%, 1) = CHR$(0)
                                        END IF
                                        IF si% = layerIdx% THEN
                                            LAYERS(si%).visible% = TRUE
                                        ELSE
                                            LAYERS(si%).visible% = FALSE
                                        END IF
                                    END IF
                                NEXT si%
                                LAYER_PANEL.soloLayer% = layerIdx%
                                BLEND_invalidate_cache
                            END IF
                            GUI_NEEDS_REDRAW% = TRUE
                        ELSE
                            ' Normal click: toggle visibility and start swipe
                            LAYERS_toggle_visibility layerIdx%
                            ' Clear solo mode if user manually toggles
                            LAYER_PANEL.soloLayer% = 0
                            ' Start visibility swipe â€” action matches what we just did
                            LAYER_PANEL.visSwiping% = TRUE
                            LAYER_PANEL.visSwipeAction% = LAYERS(layerIdx%).visible%
                            LAYER_PANEL.visSwipedLayers = STRING$(64, CHR$(0))
                            MID$(LAYER_PANEL.visSwipedLayers, layerIdx%, 1) = CHR$(1)
                        END IF
                    ' Check if clicking lock toggle (next area)
                    ELSEIF localX% < 24 THEN
                        LAYERS_toggle_opacity_lock layerIdx%
                    ' Check if clicking opacity bar (last 36 pixels)
                    ELSEIF localX% >= panelW% - 40 THEN
                        ' Start opacity drag
                        LAYER_PANEL.opacityDrag% = TRUE
                        LAYER_PANEL.opacityDragLayer% = layerIdx%
                        DIM barX AS INTEGER
                        barX% = localX% - (panelW% - 36)
                        IF barX% < 0 THEN barX% = 0
                        IF barX% > 30 THEN barX% = 30
                        LAYERS_set_opacity layerIdx%, INT((barX% / 30.0) * 255)
                    ELSE
                        ' Check for CTRL+Click to select non-transparent pixels
                        DIM ctrlHeld AS INTEGER
                        ctrlHeld% = (_KEYDOWN(KEY_LCTRL&) OR _KEYDOWN(KEY_RCTRL&))
                        IF ctrlHeld% THEN
                            LAYERS_select layerIdx%
                            LAYER_select_non_transparent layerIdx%
                        ELSE
                            ' Select the layer and start pending drag (threshold required)
                            LAYERS_select layerIdx%
                            ' Start PENDING drag - will only become active after moving 10+ pixels
                            LAYER_PANEL.dragPending% = TRUE
                            LAYER_PANEL.isDragging% = FALSE
                            LAYER_PANEL.dragLayerIdx% = layerIdx%
                            LAYER_PANEL.dropTargetZIndex% = LAYERS(layerIdx%).zIndex%
                            LAYER_PANEL.dragStartX% = rawX%
                            LAYER_PANEL.dragStartY% = rawY%
                            LAYER_PANEL.dragOffsetY% = clickY% - rowY%  ' Offset within row
                            LAYER_PANEL.dragPreviewY% = rawY%
                            LAYER_PANEL.autoScrollTimer! = TIMER
                        END IF
                    END IF
                ELSEIF button% = 2 THEN
                    ' Right click context actions
                    LAYERS_select layerIdx%
                    ' Shift+right-click: cycle blend mode
                    DIM shiftHeld AS INTEGER
                    shiftHeld% = (_KEYDOWN(KEY_LSHIFT&) OR _KEYDOWN(KEY_RSHIFT&))
                    IF shiftHeld% THEN
                        LAYERS(layerIdx%).blendMode% = (LAYERS(layerIdx%).blendMode% + 1) MOD BLEND_MODE_COUNT
                        BLEND_invalidate_cache
                        GUI_NEEDS_REDRAW% = TRUE
                    ELSE
                        ' Plain right-click: rename
                        LAYERS_rename layerIdx%
                    END IF
                END IF
                
                LAYER_PANEL_handle_click% = TRUE
                EXIT FUNCTION
            END IF
            
            rowY% = rowY% + LAYER_ROW_HEIGHT
        END IF
    NEXT z%
    
    LAYER_PANEL_handle_click% = TRUE  ' Click was in panel, just not on anything specific
END FUNCTION


''
' Handle mouse wheel scrolling in layer panel
' Also handles opacity adjustment when wheel is over opacity bar
' 
SUB LAYER_PANEL_handle_wheel (rawX AS INTEGER, rawY AS INTEGER, delta AS INTEGER)
    DIM panelW AS INTEGER, panelH AS INTEGER
    DIM bottomBarsHeight AS INTEGER
    DIM listTop AS INTEGER, listBottom AS INTEGER
    DIM opacityBarX AS INTEGER, opacityBarW AS INTEGER
    DIM rowY AS INTEGER, i AS INTEGER, z AS INTEGER
    DIM layerIdx AS INTEGER
    CONST HEADER_HEIGHT = 16
    CONST BUTTON_AREA_HEIGHT = 24  ' Must match LAYER_PANEL_render
    
    IF NOT LAYER_PANEL.visible% THEN EXIT SUB
    
    ' Calculate panel dimensions (account for status bar visibility)
    IF SCRN.showStatus% THEN
        bottomBarsHeight% = THEME.STATUS_height% + PALETTE_STRIP_get_height%
    ELSE
        bottomBarsHeight% = 0
    END IF
    panelW% = CFG.LAYER_PANEL_WIDTH%
    panelH% = SCRN.h& - bottomBarsHeight%
    listTop% = HEADER_HEIGHT
    listBottom% = panelH% - BUTTON_AREA_HEIGHT
    
    ' Opacity bar is on the right side of each row
    opacityBarW% = 30
    opacityBarX% = panelW% - opacityBarW% - 14
    
    ' Check if mouse is over an opacity bar area
    IF rawX% >= opacityBarX% AND rawX% <= panelW% - 10 THEN
        ' Find which layer row the mouse is over
        rowY% = listTop%
        FOR z% = LAYER_COUNT% TO 1 STEP -1
            layerIdx% = 0
            FOR i% = 1 TO 64
                IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% = z% THEN
                    layerIdx% = i%
                    EXIT FOR
                END IF
            NEXT i%
            
            IF layerIdx% > 0 THEN
                DIM drawY AS INTEGER
                drawY% = rowY% - LAYER_PANEL.scrollOffset%
                
                ' Check if mouse Y is within this row's opacity bar area (Y+14 to Y+17)
                IF rawY% >= drawY% + 12 AND rawY% <= drawY% + 19 THEN
                    IF drawY% >= listTop% AND drawY% + LAYER_ROW_HEIGHT <= listBottom% THEN
                        ' Adjust opacity - wheel up (negative delta) = more opaque
                        DIM newOpacity AS INTEGER
                        newOpacity% = LAYERS(layerIdx%).opacity% - (delta% * 15)  ' 15 per tick
                        IF newOpacity% < 0 THEN newOpacity% = 0
                        IF newOpacity% > 255 THEN newOpacity% = 255
                        LAYERS_set_opacity layerIdx%, newOpacity%
                        EXIT SUB  ' Handled opacity, don't scroll
                    END IF
                END IF
                
                rowY% = rowY% + LAYER_ROW_HEIGHT
            END IF
        NEXT z%
    END IF
    
    ' Not over opacity bar - scroll the layer list
    ' Reverse direction: wheel up (negative) = scroll up (see higher layers)
    LAYER_PANEL.scrollOffset% = LAYER_PANEL.scrollOffset% + (delta% * LAYER_ROW_HEIGHT)
    
    ' Clamp scroll offset
    IF LAYER_PANEL.scrollOffset% < 0 THEN LAYER_PANEL.scrollOffset% = 0
    
    DIM maxScroll AS INTEGER
    DIM listHeight AS INTEGER
    listHeight% = listBottom% - listTop%
    maxScroll% = (LAYER_COUNT% * LAYER_ROW_HEIGHT) - listHeight%
    IF maxScroll% < 0 THEN maxScroll% = 0
    IF LAYER_PANEL.scrollOffset% > maxScroll% THEN LAYER_PANEL.scrollOffset% = maxScroll%
    
    GUI_NEEDS_REDRAW% = TRUE
END SUB

''
' Check if layer panel is currently in a drag operation
' 
FUNCTION LAYER_PANEL_is_dragging% ()
    LAYER_PANEL_is_dragging% = LAYER_PANEL.isDragging% OR LAYER_PANEL.dragPending%
END FUNCTION


''
' Handle visibility swipe - apply show/hide to layers as mouse drags over eye icons
'
SUB LAYER_PANEL_handle_vis_swipe (rawX AS INTEGER, rawY AS INTEGER)
    DIM panelW AS INTEGER, panelH AS INTEGER
    DIM bottomBarsHeight AS INTEGER
    DIM listTop AS INTEGER, listBottom AS INTEGER
    DIM rowY AS INTEGER
    DIM i AS INTEGER, z AS INTEGER
    DIM layerIdx AS INTEGER
    CONST HEADER_HEIGHT = 16
    CONST BUTTON_AREA_HEIGHT = 24

    IF NOT LAYER_PANEL.visSwiping% THEN EXIT SUB
    IF NOT LAYER_PANEL.visible% THEN
        LAYER_PANEL.visSwiping% = FALSE
        EXIT SUB
    END IF

    ' Calculate panel layout
    IF SCRN.showStatus% THEN
        bottomBarsHeight% = THEME.STATUS_height% + PALETTE_STRIP_get_height%
    ELSE
        bottomBarsHeight% = 0
    END IF
    panelW% = CFG.LAYER_PANEL_WIDTH%
    panelH% = SCRN.h& - bottomBarsHeight%
    listTop% = HEADER_HEIGHT
    listBottom% = panelH% - BUTTON_AREA_HEIGHT

    ' Only swipe if mouse is in the eye icon column (first 14 pixels)
    IF rawX% >= 14 THEN EXIT SUB

    ' Find which layer row the mouse is over
    DIM clickY AS INTEGER
    clickY% = rawY%
    rowY% = listTop%

    FOR z% = LAYER_COUNT% TO 1 STEP -1
        layerIdx% = 0
        FOR i% = 1 TO 64
            IF LAYERS(i%).imgHandle& <> 0 AND LAYERS(i%).zIndex% = z% THEN
                layerIdx% = i%
                EXIT FOR
            END IF
        NEXT i%

        IF layerIdx% > 0 THEN
            DIM drawY AS INTEGER
            drawY% = rowY% - LAYER_PANEL.scrollOffset%

            IF clickY% >= drawY% AND clickY% < drawY% + LAYER_ROW_HEIGHT THEN
                ' Mouse is over this layer row
                ' Only apply if not already swiped this layer
                IF ASC(MID$(LAYER_PANEL.visSwipedLayers, layerIdx%, 1)) = 0 THEN
                    ' Apply swipe action
                    IF LAYER_PANEL.visSwipeAction% THEN
                        LAYERS(layerIdx%).visible% = TRUE
                    ELSE
                        LAYERS(layerIdx%).visible% = FALSE
                    END IF
                    MID$(LAYER_PANEL.visSwipedLayers, layerIdx%, 1) = CHR$(1)
                    BLEND_invalidate_cache
                    GUI_NEEDS_REDRAW% = TRUE
                END IF
                EXIT SUB
            END IF

            rowY% = rowY% + LAYER_ROW_HEIGHT
        END IF
    NEXT z%
END SUB


''
' End visibility swipe on mouse release
'
SUB LAYER_PANEL_end_vis_swipe ()
    LAYER_PANEL.visSwiping% = FALSE
END SUB


''
' Cancel any ongoing layer drag operation
' 
SUB LAYER_PANEL_drag_cancel ()
    LAYER_PANEL.dragPending% = FALSE
    LAYER_PANEL.isDragging% = FALSE
    LAYER_PANEL.dragLayerIdx% = 0
    LAYER_PANEL.dropTargetZIndex% = -1
    LAYER_PANEL.dragOffsetY% = 0
    LAYER_PANEL.autoScrollTimer! = 0
    LAYER_PANEL.dragPreviewY% = 0
    LAYER_PANEL.dragStartX% = 0
    LAYER_PANEL.dragStartY% = 0
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Handle mouse movement during layer drag operation
' Calculates drop target position, handles auto-scroll, and updates preview
' 
SUB LAYER_PANEL_handle_drag (rawX AS INTEGER, rawY AS INTEGER)
    DIM panelW AS INTEGER, panelH AS INTEGER
    DIM bottomBarsHeight AS INTEGER
    DIM listTop AS INTEGER, listBottom AS INTEGER, listHeight AS INTEGER
    DIM targetZIndex AS INTEGER
    DIM maxScroll AS INTEGER
    CONST HEADER_HEIGHT = 16
    CONST BUTTON_AREA_HEIGHT = 24
    CONST AUTO_SCROLL_ZONE = 30      ' Pixels from edge to trigger auto-scroll
    CONST AUTO_SCROLL_DELAY = 0.15   ' Seconds before auto-scroll starts
    CONST DRAG_THRESHOLD = 5         ' Pixels of movement required to start drag
    
    ' Check if we have a pending drag that needs threshold check
    IF LAYER_PANEL.dragPending% THEN
        DIM dy AS INTEGER
        dy% = ABS(rawY% - LAYER_PANEL.dragStartY%)  ' Only check vertical movement
        
        IF dy% >= DRAG_THRESHOLD THEN
            ' Threshold exceeded - activate real drag
            LAYER_PANEL.dragPending% = FALSE
            LAYER_PANEL.isDragging% = TRUE
            ' Continue to process this drag event below
        ELSE
            ' Not enough movement yet - just exit, don't update anything
            EXIT SUB
        END IF
    END IF
    
    IF NOT LAYER_PANEL.isDragging% THEN EXIT SUB
    IF NOT LAYER_PANEL.visible% THEN
        LAYER_PANEL_drag_cancel
        EXIT SUB
    END IF
    
    ' Calculate panel dimensions
    IF SCRN.showStatus% THEN
        bottomBarsHeight% = THEME.STATUS_height% + PALETTE_STRIP_get_height%
    ELSE
        bottomBarsHeight% = 0
    END IF
    panelW% = CFG.LAYER_PANEL_WIDTH%
    panelH% = SCRN.h& - bottomBarsHeight%
    listTop% = HEADER_HEIGHT
    listBottom% = panelH% - BUTTON_AREA_HEIGHT
    listHeight% = listBottom% - listTop%
    
    ' Update preview Y position (following mouse)
    LAYER_PANEL.dragPreviewY% = rawY%
    
    ' --- Auto-scroll logic ---
    maxScroll% = (LAYER_COUNT% * LAYER_ROW_HEIGHT) - listHeight%
    IF maxScroll% < 0 THEN maxScroll% = 0
    
    IF rawY% < listTop% + AUTO_SCROLL_ZONE AND rawY% >= 0 THEN
        ' Near top edge - scroll up
        IF TIMER - LAYER_PANEL.autoScrollTimer! > AUTO_SCROLL_DELAY THEN
            IF LAYER_PANEL.scrollOffset% > 0 THEN
                LAYER_PANEL.scrollOffset% = LAYER_PANEL.scrollOffset% - LAYER_ROW_HEIGHT
                IF LAYER_PANEL.scrollOffset% < 0 THEN LAYER_PANEL.scrollOffset% = 0
                LAYER_PANEL.autoScrollTimer! = TIMER - (AUTO_SCROLL_DELAY * 0.7)  ' Faster repeat
            END IF
        END IF
    ELSEIF rawY% > listBottom% - AUTO_SCROLL_ZONE AND rawY% < listBottom% THEN
        ' Near bottom edge - scroll down
        IF TIMER - LAYER_PANEL.autoScrollTimer! > AUTO_SCROLL_DELAY THEN
            IF LAYER_PANEL.scrollOffset% < maxScroll% THEN
                LAYER_PANEL.scrollOffset% = LAYER_PANEL.scrollOffset% + LAYER_ROW_HEIGHT
                IF LAYER_PANEL.scrollOffset% > maxScroll% THEN LAYER_PANEL.scrollOffset% = maxScroll%
                LAYER_PANEL.autoScrollTimer! = TIMER - (AUTO_SCROLL_DELAY * 0.7)
            END IF
        END IF
    ELSE
        ' Not in auto-scroll zone, reset timer
        LAYER_PANEL.autoScrollTimer! = TIMER
    END IF
    
    ' --- Calculate drop target zIndex based on mouse position ---
    ' Transform raw Y to content Y (accounting for scroll)
    DIM contentY AS INTEGER
    contentY% = rawY% + LAYER_PANEL.scrollOffset% - listTop%
    
    ' Find which row gap the mouse is closest to
    ' Layers are rendered from highest zIndex to lowest (top to bottom)
    ' So row 0 = layer with zIndex=LAYER_COUNT, row 1 = zIndex=LAYER_COUNT-1, etc.
    ' We want to find the GAP between rows, not the row itself
    ' Gap 0 = above topmost layer (insert at zIndex = LAYER_COUNT + 1, becomes top)
    ' Gap 1 = between layer at zIndex=LAYER_COUNT and zIndex=LAYER_COUNT-1
    ' Gap N = below bottommost layer (insert at zIndex = 1, becomes bottom)
    DIM closestGap AS INTEGER
    closestGap% = INT((contentY% + (LAYER_ROW_HEIGHT \ 2)) / LAYER_ROW_HEIGHT)
    
    ' Clamp gap to valid range (0 to LAYER_COUNT)
    IF closestGap% < 0 THEN closestGap% = 0
    IF closestGap% > LAYER_COUNT% THEN closestGap% = LAYER_COUNT%
    
    ' Convert gap to target zIndex position
    ' Gap 0 = will become zIndex LAYER_COUNT (top position)
    ' Gap LAYER_COUNT = will become zIndex 1 (bottom position)
    ' The targetZIndex represents WHERE the layer will END UP after the move
    targetZIndex% = LAYER_COUNT% - closestGap%
    
    ' Clamp to valid final position range (1 to LAYER_COUNT)
    IF targetZIndex% < 1 THEN targetZIndex% = 1
    IF targetZIndex% > LAYER_COUNT% THEN targetZIndex% = LAYER_COUNT%
    
    ' Check if this is actually a no-op (same position)
    DIM draggedZ AS INTEGER
    draggedZ% = LAYERS(LAYER_PANEL.dragLayerIdx%).zIndex%
    
    ' Only show as "no change" if layer would stay in same position
    IF targetZIndex% = draggedZ% THEN
        ' Already at target position - no visual indicator needed
        LAYER_PANEL.dropTargetZIndex% = -1
    ELSE
        LAYER_PANEL.dropTargetZIndex% = targetZIndex%
    END IF
    GUI_NEEDS_REDRAW% = TRUE
END SUB


''
' Handle drop when mouse is released during layer drag
' Moves the layer to the new position
' 
SUB LAYER_PANEL_handle_drop ()
    DIM draggedIdx AS INTEGER
    DIM draggedZ AS INTEGER
    DIM targetZ AS INTEGER
    DIM i AS INTEGER
    
    ' Always cancel pending drag on mouse release, even if not actively dragging
    IF NOT LAYER_PANEL.isDragging% THEN
        LAYER_PANEL_drag_cancel
        EXIT SUB
    END IF
    
    draggedIdx% = LAYER_PANEL.dragLayerIdx%
    draggedZ% = LAYERS(draggedIdx%).zIndex%
    targetZ% = LAYER_PANEL.dropTargetZIndex%
    
    ' Only move if we have a valid target and it's different from current position
    IF targetZ% >= 1 AND targetZ% <= LAYER_COUNT% AND targetZ% <> draggedZ% THEN
        ' Shift other layers to make room
        IF targetZ% > draggedZ% THEN
            ' Moving up (towards higher zIndex / top of list)
            ' Shift layers between old and new position DOWN by 1
            FOR i% = 1 TO 64
                IF LAYERS(i%).imgHandle& <> 0 AND i% <> draggedIdx% THEN
                    IF LAYERS(i%).zIndex% > draggedZ% AND LAYERS(i%).zIndex% <= targetZ% THEN
                        LAYERS(i%).zIndex% = LAYERS(i%).zIndex% - 1
                    END IF
                END IF
            NEXT i%
            LAYERS(draggedIdx%).zIndex% = targetZ%
        ELSE
            ' Moving down (towards lower zIndex / bottom of list)
            ' Shift layers between new and old position UP by 1
            FOR i% = 1 TO 64
                IF LAYERS(i%).imgHandle& <> 0 AND i% <> draggedIdx% THEN
                    IF LAYERS(i%).zIndex% >= targetZ% AND LAYERS(i%).zIndex% < draggedZ% THEN
                        LAYERS(i%).zIndex% = LAYERS(i%).zIndex% + 1
                    END IF
                END IF
            NEXT i%
            LAYERS(draggedIdx%).zIndex% = targetZ%
        END IF
    END IF
    
    ' End drag operation
    BLEND_invalidate_cache
    GUI_NEEDS_REDRAW% = TRUE
    LAYER_PANEL_drag_cancel
END SUB


''
' Load layer panel icons from theme directory
' Falls back to text rendering if PNGs are missing
' Must be called after CONFIG_load so CFG.THEME$ is available
'
SUB LAYER_PANEL_load_icons ()
    DIM themeDir AS STRING
    themeDir$ = "ASSETS/THEMES/" + _TRIM$(CFG.THEME$) + "/"

    ' Free any previously loaded icons
    LAYER_PANEL_cleanup_icons

    ' Load row icons (visibility toggle)
    LAYER_PANEL.iconVisOn&    = _LOADIMAGE(themeDir$ + "layer-icon-visibility-on.png", 32)
    LAYER_PANEL.iconVisOff&   = _LOADIMAGE(themeDir$ + "layer-icon-visibility-off.png", 32)

    ' Load row icons (opacity lock)
    LAYER_PANEL.iconLockOn&   = _LOADIMAGE(themeDir$ + "layer-icon-lock-on.png", 32)
    LAYER_PANEL.iconLockOff&  = _LOADIMAGE(themeDir$ + "layer-icon-lock-off.png", 32)

    ' Load bottom button icons
    LAYER_PANEL.iconBtnUp&     = _LOADIMAGE(themeDir$ + "layer-btn-up.png", 32)
    LAYER_PANEL.iconBtnDown&   = _LOADIMAGE(themeDir$ + "layer-btn-down.png", 32)
    LAYER_PANEL.iconBtnMerge&  = _LOADIMAGE(themeDir$ + "layer-btn-merge.png", 32)
    LAYER_PANEL.iconBtnDelete& = _LOADIMAGE(themeDir$ + "layer-btn-delete.png", 32)
    LAYER_PANEL.iconBtnAdd&    = _LOADIMAGE(themeDir$ + "layer-btn-add.png", 32)
END SUB


''
' Free all loaded layer panel icon image handles
'
SUB LAYER_PANEL_cleanup_icons ()
    IF LAYER_PANEL.iconVisOn&    < -1 THEN _FREEIMAGE LAYER_PANEL.iconVisOn&
    IF LAYER_PANEL.iconVisOff&   < -1 THEN _FREEIMAGE LAYER_PANEL.iconVisOff&
    IF LAYER_PANEL.iconLockOn&   < -1 THEN _FREEIMAGE LAYER_PANEL.iconLockOn&
    IF LAYER_PANEL.iconLockOff&  < -1 THEN _FREEIMAGE LAYER_PANEL.iconLockOff&
    IF LAYER_PANEL.iconBtnUp&     < -1 THEN _FREEIMAGE LAYER_PANEL.iconBtnUp&
    IF LAYER_PANEL.iconBtnDown&   < -1 THEN _FREEIMAGE LAYER_PANEL.iconBtnDown&
    IF LAYER_PANEL.iconBtnMerge&  < -1 THEN _FREEIMAGE LAYER_PANEL.iconBtnMerge&
    IF LAYER_PANEL.iconBtnDelete& < -1 THEN _FREEIMAGE LAYER_PANEL.iconBtnDelete&
    IF LAYER_PANEL.iconBtnAdd&    < -1 THEN _FREEIMAGE LAYER_PANEL.iconBtnAdd&
    LAYER_PANEL.iconVisOn&    = 0
    LAYER_PANEL.iconVisOff&   = 0
    LAYER_PANEL.iconLockOn&   = 0
    LAYER_PANEL.iconLockOff&  = 0
    LAYER_PANEL.iconBtnUp&     = 0
    LAYER_PANEL.iconBtnDown&   = 0
    LAYER_PANEL.iconBtnMerge&  = 0
    LAYER_PANEL.iconBtnDelete& = 0
    LAYER_PANEL.iconBtnAdd&    = 0
END SUB


''
' Create a marquee selection from non-transparent pixels of a layer
' CTRL+Left-Click on a layer in the panel calls this.
' Replaces any existing selection.
'
' @param INTEGER layerIdx - Layer index to scan
'
SUB LAYER_select_non_transparent (layerIdx AS INTEGER)
    DIM old_dest AS LONG, old_source AS LONG
    DIM imgHandle AS LONG
    DIM w AS INTEGER, h AS INTEGER
    DIM px AS INTEGER, py AS INTEGER
    DIM minX AS INTEGER, minY AS INTEGER, maxX AS INTEGER, maxY AS INTEGER
    DIM mask_color AS _UNSIGNED LONG
    DIM pixel_color AS _UNSIGNED LONG
    DIM found_any AS INTEGER
    
    ' Validate layer
    IF layerIdx% < 1 OR layerIdx% > 64 THEN EXIT SUB
    imgHandle& = LAYERS(layerIdx%).imgHandle&
    IF imgHandle& = 0 THEN EXIT SUB
    
    old_dest& = _DEST
    old_source& = _SOURCE
    mask_color~& = _RGB32(255, 255, 255)
    
    w% = _WIDTH(imgHandle&)
    h% = _HEIGHT(imgHandle&)
    
    ' Clear any existing selection
    MARQUEE_reset
    MAGIC_WAND_reset
    IF MARQUEE.SELECTION_MASK < -1 THEN
        _FREEIMAGE MARQUEE.SELECTION_MASK
        MARQUEE.SELECTION_MASK = 0
    END IF
    
    ' Create new selection mask
    MARQUEE.SELECTION_MASK = _NEWIMAGE(w%, h%, 32)
    IF MARQUEE.SELECTION_MASK >= -1 THEN
        _DEST old_dest&
        _SOURCE old_source&
        EXIT SUB
    END IF
    
    ' Clear mask to transparent
    _DEST MARQUEE.SELECTION_MASK
    CLS , _RGBA32(0, 0, 0, 0)
    _DONTBLEND MARQUEE.SELECTION_MASK
    
    ' Scan layer image and mark non-transparent pixels
    _SOURCE imgHandle&
    minX% = w%: minY% = h%: maxX% = 0: maxY% = 0
    found_any% = FALSE
    
    FOR py% = 0 TO h% - 1
        FOR px% = 0 TO w% - 1
            pixel_color~& = POINT(px%, py%)
            IF _ALPHA32(pixel_color~&) > 0 THEN
                _DEST MARQUEE.SELECTION_MASK
                PSET (px%, py%), mask_color~&
                IF px% < minX% THEN minX% = px%
                IF px% > maxX% THEN maxX% = px%
                IF py% < minY% THEN minY% = py%
                IF py% > maxY% THEN maxY% = py%
                found_any% = TRUE
                _SOURCE imgHandle&
            END IF
        NEXT px%
    NEXT py%
    
    _BLEND MARQUEE.SELECTION_MASK
    
    IF found_any% THEN
        ' Set up marquee bounding box from mask bounds
        MARQUEE.WAND_MIN_X = minX%
        MARQUEE.WAND_MIN_Y = minY%
        MARQUEE.WAND_MAX_X = maxX%
        MARQUEE.WAND_MAX_Y = maxY%
        MARQUEE.BOX.x = minX%
        MARQUEE.BOX.y = minY%
        MARQUEE.BOX.w = maxX% - minX% + 1
        MARQUEE.BOX.h = maxY% - minY% + 1
        MARQUEE.ACTIVE% = TRUE
        MARQUEE.INITIALIZED% = TRUE
        MARQUEE.USER_CREATED = TRUE
        MARQUEE.WAND_HAS_SELECTION = TRUE
        
        ' Initialize BBX config for the selection
        MARQUEE.CFG.initX = minX%
        MARQUEE.CFG.initY = minY%
        MARQUEE.CFG.initW = maxX% - minX% + 1
        MARQUEE.CFG.initH = maxY% - minY% + 1
        GJ_BBX_InitWithConfig MARQUEE.CFG
        MARQUEE.BOX = GJ_BBX_box
        
        ' Switch to marquee tool so the selection is visible and usable
        PREVIOUS_TOOL% = CURRENT_TOOL%
        CURRENT_TOOL% = TOOL_MARQUEE
        MARQUEE.MAGIC_WAND_MODE = FALSE
    ELSE
        ' No non-transparent pixels found - clean up
        IF MARQUEE.SELECTION_MASK < -1 THEN
            _FREEIMAGE MARQUEE.SELECTION_MASK
            MARQUEE.SELECTION_MASK = 0
        END IF
    END IF
    
    GUI_NEEDS_REDRAW% = TRUE
    _DEST old_dest&
    _SOURCE old_source&
END SUB


''
' Return full name of a blend mode
'
FUNCTION BLEND_mode_name$ (mode AS INTEGER)
    SELECT CASE mode%
        CASE BLEND_NORMAL:       BLEND_mode_name$ = "Normal"
        CASE BLEND_MULTIPLY:     BLEND_mode_name$ = "Multiply"
        CASE BLEND_SCREEN:       BLEND_mode_name$ = "Screen"
        CASE BLEND_OVERLAY:      BLEND_mode_name$ = "Overlay"
        CASE BLEND_ADD:          BLEND_mode_name$ = "Add"
        CASE BLEND_SUBTRACT:     BLEND_mode_name$ = "Subtract"
        CASE BLEND_DIFFERENCE:   BLEND_mode_name$ = "Difference"
        CASE BLEND_DARKEN:       BLEND_mode_name$ = "Darken"
        CASE BLEND_LIGHTEN:      BLEND_mode_name$ = "Lighten"
        CASE BLEND_COLOR_DODGE:  BLEND_mode_name$ = "Color Dodge"
        CASE BLEND_COLOR_BURN:   BLEND_mode_name$ = "Color Burn"
        CASE BLEND_HARD_LIGHT:   BLEND_mode_name$ = "Hard Light"
        CASE BLEND_SOFT_LIGHT:   BLEND_mode_name$ = "Soft Light"
        CASE BLEND_EXCLUSION:    BLEND_mode_name$ = "Exclusion"
        CASE BLEND_VIVID_LIGHT:  BLEND_mode_name$ = "Vivid Light"
        CASE BLEND_LINEAR_LIGHT: BLEND_mode_name$ = "Linear Light"
        CASE BLEND_PIN_LIGHT:    BLEND_mode_name$ = "Pin Light"
        CASE BLEND_COLOR:        BLEND_mode_name$ = "Color"
        CASE BLEND_LUMINOSITY:   BLEND_mode_name$ = "Luminosity"
        CASE ELSE:               BLEND_mode_name$ = "Normal"
    END SELECT
END FUNCTION


''
' Return short 3-char abbreviation of a blend mode
'
FUNCTION BLEND_mode_short$ (mode AS INTEGER)
    SELECT CASE mode%
        CASE BLEND_NORMAL:       BLEND_mode_short$ = "Nrm"
        CASE BLEND_MULTIPLY:     BLEND_mode_short$ = "Mul"
        CASE BLEND_SCREEN:       BLEND_mode_short$ = "Scr"
        CASE BLEND_OVERLAY:      BLEND_mode_short$ = "Ovr"
        CASE BLEND_ADD:          BLEND_mode_short$ = "Add"
        CASE BLEND_SUBTRACT:     BLEND_mode_short$ = "Sub"
        CASE BLEND_DIFFERENCE:   BLEND_mode_short$ = "Dif"
        CASE BLEND_DARKEN:       BLEND_mode_short$ = "Drk"
        CASE BLEND_LIGHTEN:      BLEND_mode_short$ = "Ltn"
        CASE BLEND_COLOR_DODGE:  BLEND_mode_short$ = "CDg"
        CASE BLEND_COLOR_BURN:   BLEND_mode_short$ = "CBn"
        CASE BLEND_HARD_LIGHT:   BLEND_mode_short$ = "HdL"
        CASE BLEND_SOFT_LIGHT:   BLEND_mode_short$ = "SfL"
        CASE BLEND_EXCLUSION:    BLEND_mode_short$ = "Exc"
        CASE BLEND_VIVID_LIGHT:  BLEND_mode_short$ = "VvL"
        CASE BLEND_LINEAR_LIGHT: BLEND_mode_short$ = "LnL"
        CASE BLEND_PIN_LIGHT:    BLEND_mode_short$ = "PnL"
        CASE BLEND_COLOR:        BLEND_mode_short$ = "Clr"
        CASE BLEND_LUMINOSITY:   BLEND_mode_short$ = "Lum"
        CASE ELSE:               BLEND_mode_short$ = "Nrm"
    END SELECT
END FUNCTION


''
' Check if any visible layer uses non-Normal blend mode
' Returns TRUE if composite buffer approach is needed
'
FUNCTION BLEND_needs_composite% ()
    ' Return cached result if not dirty
    IF NOT BLEND_COMPOSITE_DIRTY% THEN
        BLEND_needs_composite% = BLEND_COMPOSITE_CACHED%
        EXIT FUNCTION
    END IF

    DIM i AS INTEGER
    FOR i% = 1 TO 64
        IF LAYERS(i%).imgHandle& <> 0 THEN
            IF LAYERS(i%).visible% THEN
                IF LAYERS(i%).blendMode% <> BLEND_NORMAL THEN
                    BLEND_COMPOSITE_CACHED% = TRUE
                    BLEND_COMPOSITE_DIRTY% = FALSE
                    BLEND_needs_composite% = TRUE
                    EXIT FUNCTION
                END IF
            END IF
        END IF
    NEXT i%
    BLEND_COMPOSITE_CACHED% = FALSE
    BLEND_COMPOSITE_DIRTY% = FALSE
    BLEND_needs_composite% = FALSE
END FUNCTION


''
' Invalidate the blend composite cache.
' Call whenever blend modes, visibility, or layer structure changes.
'
SUB BLEND_invalidate_cache ()
    DIM bic_i AS INTEGER
    BLEND_COMPOSITE_DIRTY% = TRUE
    RENDER_ORDER_DIRTY% = TRUE
    SCENE_DIRTY% = TRUE
    COMPOSITE_BELOW_VALID% = FALSE
    ' NOTE: We intentionally do NOT mark all layers contentDirty% here.
    ' contentDirty% controls the per-layer opacity cache, which only depends on
    ' the layer's own pixel data + opacity value. Visibility/structure changes
    ' don't affect individual layer pixel content. Only mark contentDirty% when
    ' actual pixel data changes (e.g. drawing, undo, file load).
END SUB


''
' Rebuild the pre-sorted render order lookup table.
' Called once per dirty frame instead of O(nÃ—64) scan per frame.
'
SUB RENDER_ORDER_rebuild ()
    DIM rz AS INTEGER, ri AS INTEGER, rc AS INTEGER
    rc% = 0
    FOR rz% = 1 TO LAYER_COUNT%
        FOR ri% = 1 TO 64
            IF LAYERS(ri%).imgHandle& <> 0 AND LAYERS(ri%).zIndex% = rz% THEN
                rc% = rc% + 1
                RENDER_ORDER%(rc%) = ri%
                EXIT FOR
            END IF
        NEXT ri%
    NEXT rz%
    RENDER_ORDER_COUNT% = rc%
    RENDER_ORDER_DIRTY% = FALSE
END SUB


''
' Composite src image onto dst image using specified blend mode and opacity.
' Both images must be the same dimensions (32-bit color).
' Uses _MEM for fast per-pixel operations.
'
SUB LAYER_blend_composite (dst AS LONG, src AS LONG, blendMode AS INTEGER, opacity AS INTEGER)
    DIM dstMem AS _MEM, srcMem AS _MEM
    DIM pixOff AS _OFFSET
    DIM dstPix AS _UNSIGNED LONG, srcPix AS _UNSIGNED LONG
    DIM sA AS LONG, sR AS LONG, sG AS LONG, sB AS LONG
    DIM dA AS LONG, dR AS LONG, dG AS LONG, dB AS LONG
    DIM bR AS LONG, bG AS LONG, bB AS LONG
    DIM rR AS LONG, rG AS LONG, rB AS LONG, rA AS LONG
    DIM effAlpha AS LONG
    
    IF dst& = 0 OR src& = 0 THEN EXIT SUB
    IF _WIDTH(dst&) <> _WIDTH(src&) OR _HEIGHT(dst&) <> _HEIGHT(src&) THEN EXIT SUB

    dstMem = _MEMIMAGE(dst&)
    srcMem = _MEMIMAGE(src&)

    FOR pixOff = 0 TO srcMem.SIZE - 4 STEP 4
        _MEMGET srcMem, srcMem.OFFSET + pixOff, srcPix~&
        sA& = _ALPHA32(srcPix~&)
        IF sA& = 0 THEN _CONTINUE ' Fully transparent - skip

        ' Apply layer opacity to source alpha (integer math)
        effAlpha& = (sA& * opacity%) \ 255
        IF effAlpha& <= 0 THEN _CONTINUE

        sR& = _RED32(srcPix~&)
        sG& = _GREEN32(srcPix~&)
        sB& = _BLUE32(srcPix~&)

        _MEMGET dstMem, dstMem.OFFSET + pixOff, dstPix~&
        dA& = _ALPHA32(dstPix~&)
        dR& = _RED32(dstPix~&)
        dG& = _GREEN32(dstPix~&)
        dB& = _BLUE32(dstPix~&)

        ' Apply blend formula to get blended RGB
        SELECT CASE blendMode%
            CASE BLEND_MULTIPLY
                bR& = (dR& * sR&) \ 255
                bG& = (dG& * sG&) \ 255
                bB& = (dB& * sB&) \ 255

            CASE BLEND_SCREEN
                bR& = 255 - ((255 - dR&) * (255 - sR&)) \ 255
                bG& = 255 - ((255 - dG&) * (255 - sG&)) \ 255
                bB& = 255 - ((255 - dB&) * (255 - sB&)) \ 255

            CASE BLEND_OVERLAY
                IF dR& < 128 THEN bR& = (2 * dR& * sR&) \ 255 ELSE bR& = 255 - (2 * (255 - dR&) * (255 - sR&)) \ 255
                IF dG& < 128 THEN bG& = (2 * dG& * sG&) \ 255 ELSE bG& = 255 - (2 * (255 - dG&) * (255 - sG&)) \ 255
                IF dB& < 128 THEN bB& = (2 * dB& * sB&) \ 255 ELSE bB& = 255 - (2 * (255 - dB&) * (255 - sB&)) \ 255

            CASE BLEND_ADD
                bR& = dR& + sR&: IF bR& > 255 THEN bR& = 255
                bG& = dG& + sG&: IF bG& > 255 THEN bG& = 255
                bB& = dB& + sB&: IF bB& > 255 THEN bB& = 255

            CASE BLEND_SUBTRACT
                bR& = dR& - sR&: IF bR& < 0 THEN bR& = 0
                bG& = dG& - sG&: IF bG& < 0 THEN bG& = 0
                bB& = dB& - sB&: IF bB& < 0 THEN bB& = 0

            CASE BLEND_DIFFERENCE
                bR& = ABS(dR& - sR&)
                bG& = ABS(dG& - sG&)
                bB& = ABS(dB& - sB&)

            CASE BLEND_DARKEN
                IF dR& < sR& THEN bR& = dR& ELSE bR& = sR&
                IF dG& < sG& THEN bG& = dG& ELSE bG& = sG&
                IF dB& < sB& THEN bB& = dB& ELSE bB& = sB&

            CASE BLEND_LIGHTEN
                IF dR& > sR& THEN bR& = dR& ELSE bR& = sR&
                IF dG& > sG& THEN bG& = dG& ELSE bG& = sG&
                IF dB& > sB& THEN bB& = dB& ELSE bB& = sB&

            CASE BLEND_COLOR_DODGE
                ' d / (1 - s) = d * 255 / (255 - s), clamped
                IF sR& >= 255 THEN bR& = 255 ELSE bR& = (dR& * 255) \ (255 - sR&): IF bR& > 255 THEN bR& = 255
                IF sG& >= 255 THEN bG& = 255 ELSE bG& = (dG& * 255) \ (255 - sG&): IF bG& > 255 THEN bG& = 255
                IF sB& >= 255 THEN bB& = 255 ELSE bB& = (dB& * 255) \ (255 - sB&): IF bB& > 255 THEN bB& = 255

            CASE BLEND_COLOR_BURN
                ' 1 - (1 - d) / s = 255 - (255 - d) * 255 / s, clamped
                IF sR& <= 0 THEN bR& = 0 ELSE bR& = 255 - ((255 - dR&) * 255) \ sR&: IF bR& < 0 THEN bR& = 0
                IF sG& <= 0 THEN bG& = 0 ELSE bG& = 255 - ((255 - dG&) * 255) \ sG&: IF bG& < 0 THEN bG& = 0
                IF sB& <= 0 THEN bB& = 0 ELSE bB& = 255 - ((255 - dB&) * 255) \ sB&: IF bB& < 0 THEN bB& = 0

            CASE BLEND_HARD_LIGHT
                ' Overlay with source and dest swapped
                IF sR& < 128 THEN bR& = (2 * sR& * dR&) \ 255 ELSE bR& = 255 - (2 * (255 - sR&) * (255 - dR&)) \ 255
                IF sG& < 128 THEN bG& = (2 * sG& * dG&) \ 255 ELSE bG& = 255 - (2 * (255 - sG&) * (255 - dG&)) \ 255
                IF sB& < 128 THEN bB& = (2 * sB& * dB&) \ 255 ELSE bB& = 255 - (2 * (255 - sB&) * (255 - dB&)) \ 255

            CASE BLEND_SOFT_LIGHT
                ' Pegtop formula: (1-2s)*d^2/255 + 2s*d, all in 0-255 integer range
                bR& = ((255 - 2 * sR&) * dR& * dR&) \ 65025 + (2 * sR& * dR&) \ 255
                bG& = ((255 - 2 * sG&) * dG& * dG&) \ 65025 + (2 * sG& * dG&) \ 255
                bB& = ((255 - 2 * sB&) * dB& * dB&) \ 65025 + (2 * sB& * dB&) \ 255
                IF bR& < 0 THEN bR& = 0 ELSE IF bR& > 255 THEN bR& = 255
                IF bG& < 0 THEN bG& = 0 ELSE IF bG& > 255 THEN bG& = 255
                IF bB& < 0 THEN bB& = 0 ELSE IF bB& > 255 THEN bB& = 255

            CASE BLEND_EXCLUSION
                ' d + s - 2*d*s/255
                bR& = dR& + sR& - (2 * dR& * sR&) \ 255
                bG& = dG& + sG& - (2 * dG& * sG&) \ 255
                bB& = dB& + sB& - (2 * dB& * sB&) \ 255

            CASE BLEND_VIVID_LIGHT
                ' Color Dodge if s > 128, Color Burn if s <= 128
                IF sR& > 128 THEN
                    DIM vr AS LONG: vr& = 2 * (sR& - 128): IF vr& >= 255 THEN bR& = 255 ELSE bR& = (dR& * 255) \ (255 - vr&): IF bR& > 255 THEN bR& = 255
                ELSE
                    DIM vr2 AS LONG: vr2& = 2 * sR&: IF vr2& <= 0 THEN bR& = 0 ELSE bR& = 255 - ((255 - dR&) * 255) \ vr2&: IF bR& < 0 THEN bR& = 0
                END IF
                IF sG& > 128 THEN
                    DIM vg AS LONG: vg& = 2 * (sG& - 128): IF vg& >= 255 THEN bG& = 255 ELSE bG& = (dG& * 255) \ (255 - vg&): IF bG& > 255 THEN bG& = 255
                ELSE
                    DIM vg2 AS LONG: vg2& = 2 * sG&: IF vg2& <= 0 THEN bG& = 0 ELSE bG& = 255 - ((255 - dG&) * 255) \ vg2&: IF bG& < 0 THEN bG& = 0
                END IF
                IF sB& > 128 THEN
                    DIM vb AS LONG: vb& = 2 * (sB& - 128): IF vb& >= 255 THEN bB& = 255 ELSE bB& = (dB& * 255) \ (255 - vb&): IF bB& > 255 THEN bB& = 255
                ELSE
                    DIM vb2 AS LONG: vb2& = 2 * sB&: IF vb2& <= 0 THEN bB& = 0 ELSE bB& = 255 - ((255 - dB&) * 255) \ vb2&: IF bB& < 0 THEN bB& = 0
                END IF

            CASE BLEND_LINEAR_LIGHT
                ' d + 2*s - 255, clamped
                bR& = dR& + 2 * sR& - 255: IF bR& < 0 THEN bR& = 0 ELSE IF bR& > 255 THEN bR& = 255
                bG& = dG& + 2 * sG& - 255: IF bG& < 0 THEN bG& = 0 ELSE IF bG& > 255 THEN bG& = 255
                bB& = dB& + 2 * sB& - 255: IF bB& < 0 THEN bB& = 0 ELSE IF bB& > 255 THEN bB& = 255

            CASE BLEND_PIN_LIGHT
                ' If s > 128: max(d, 2*s-255), else: min(d, 2*s)
                IF sR& > 128 THEN
                    DIM ps AS LONG: ps& = 2 * sR& - 255: IF dR& > ps& THEN bR& = dR& ELSE bR& = ps&
                ELSE
                    ps& = 2 * sR&: IF dR& < ps& THEN bR& = dR& ELSE bR& = ps&
                END IF
                IF sG& > 128 THEN
                    ps& = 2 * sG& - 255: IF dG& > ps& THEN bG& = dG& ELSE bG& = ps&
                ELSE
                    ps& = 2 * sG&: IF dG& < ps& THEN bG& = dG& ELSE bG& = ps&
                END IF
                IF sB& > 128 THEN
                    ps& = 2 * sB& - 255: IF dB& > ps& THEN bB& = dB& ELSE bB& = ps&
                ELSE
                    ps& = 2 * sB&: IF dB& < ps& THEN bB& = dB& ELSE bB& = ps&
                END IF

            CASE BLEND_COLOR
                ' Source hue+saturation, dest luminosity (Rec. 601)
                DIM srcLum AS LONG, dstLum AS LONG, deltaLum AS LONG
                srcLum& = (sR& * 77 + sG& * 150 + sB& * 29) \ 256
                dstLum& = (dR& * 77 + dG& * 150 + dB& * 29) \ 256
                deltaLum& = dstLum& - srcLum&
                bR& = sR& + deltaLum&: IF bR& < 0 THEN bR& = 0 ELSE IF bR& > 255 THEN bR& = 255
                bG& = sG& + deltaLum&: IF bG& < 0 THEN bG& = 0 ELSE IF bG& > 255 THEN bG& = 255
                bB& = sB& + deltaLum&: IF bB& < 0 THEN bB& = 0 ELSE IF bB& > 255 THEN bB& = 255

            CASE BLEND_LUMINOSITY
                ' Source luminosity, dest hue+saturation (Rec. 601)
                DIM srcLum2 AS LONG, dstLum2 AS LONG, deltaLum2 AS LONG
                srcLum2& = (sR& * 77 + sG& * 150 + sB& * 29) \ 256
                dstLum2& = (dR& * 77 + dG& * 150 + dB& * 29) \ 256
                deltaLum2& = srcLum2& - dstLum2&
                bR& = dR& + deltaLum2&: IF bR& < 0 THEN bR& = 0 ELSE IF bR& > 255 THEN bR& = 255
                bG& = dG& + deltaLum2&: IF bG& < 0 THEN bG& = 0 ELSE IF bG& > 255 THEN bG& = 255
                bB& = dB& + deltaLum2&: IF bB& < 0 THEN bB& = 0 ELSE IF bB& > 255 THEN bB& = 255

            CASE ELSE
                ' Normal fallback (shouldn't reach here)
                bR& = sR&: bG& = sG&: bB& = sB&
        END SELECT

        ' Mix blended result with base using effective alpha (Porter-Duff "over")
        IF dA& = 0 THEN
            ' No base - use blended color directly with blend alpha
            rR& = bR&: rG& = bG&: rB& = bB&
            rA& = effAlpha&
        ELSE
            ' Composite: result = blended * effAlpha + base * (1 - effAlpha/255)
            rR& = dR& + ((bR& - dR&) * effAlpha&) \ 255
            rG& = dG& + ((bG& - dG&) * effAlpha&) \ 255
            rB& = dB& + ((bB& - dB&) * effAlpha&) \ 255
            rA& = dA& + effAlpha& - (dA& * effAlpha&) \ 255
            IF rA& > 255 THEN rA& = 255
        END IF

        ' Write result pixel
        _MEMPUT dstMem, dstMem.OFFSET + pixOff, _RGBA32(rR&, rG&, rB&, rA&) AS _UNSIGNED LONG
    NEXT pixOff

    _MEMFREE srcMem
    _MEMFREE dstMem
END SUB